// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Model.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Model.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace CoreML {
namespace Specification {
class PipelineDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Pipeline> {
} _Pipeline_default_instance_;
class PipelineClassifierDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PipelineClassifier> {
} _PipelineClassifier_default_instance_;
class PipelineRegressorDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PipelineRegressor> {
} _PipelineRegressor_default_instance_;
class FeatureDescriptionDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<FeatureDescription> {
} _FeatureDescription_default_instance_;
class Metadata_UserDefinedEntryDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Metadata::Metadata_UserDefinedEntry> {
} _Metadata_UserDefinedEntry_default_instance_;
class MetadataDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Metadata> {
} _Metadata_default_instance_;
class ModelDescriptionDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ModelDescription> {
} _ModelDescription_default_instance_;
class ModelDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Model> {
  public:
  const ::CoreML::Specification::PipelineClassifier* pipelineclassifier_;
  const ::CoreML::Specification::PipelineRegressor* pipelineregressor_;
  const ::CoreML::Specification::Pipeline* pipeline_;
  const ::CoreML::Specification::GLMRegressor* glmregressor_;
  const ::CoreML::Specification::SupportVectorRegressor* supportvectorregressor_;
  const ::CoreML::Specification::TreeEnsembleRegressor* treeensembleregressor_;
  const ::CoreML::Specification::NeuralNetworkRegressor* neuralnetworkregressor_;
  const ::CoreML::Specification::BayesianProbitRegressor* bayesianprobitregressor_;
  const ::CoreML::Specification::GLMClassifier* glmclassifier_;
  const ::CoreML::Specification::SupportVectorClassifier* supportvectorclassifier_;
  const ::CoreML::Specification::TreeEnsembleClassifier* treeensembleclassifier_;
  const ::CoreML::Specification::NeuralNetworkClassifier* neuralnetworkclassifier_;
  const ::CoreML::Specification::NeuralNetwork* neuralnetwork_;
  const ::CoreML::Specification::CustomModel* custommodel_;
  const ::CoreML::Specification::OneHotEncoder* onehotencoder_;
  const ::CoreML::Specification::Imputer* imputer_;
  const ::CoreML::Specification::FeatureVectorizer* featurevectorizer_;
  const ::CoreML::Specification::DictVectorizer* dictvectorizer_;
  const ::CoreML::Specification::Scaler* scaler_;
  const ::CoreML::Specification::CategoricalMapping* categoricalmapping_;
  const ::CoreML::Specification::Normalizer* normalizer_;
  const ::CoreML::Specification::ArrayFeatureExtractor* arrayfeatureextractor_;
  const ::CoreML::Specification::NonMaximumSuppression* nonmaximumsuppression_;
  const ::CoreML::Specification::Identity* identity_;
  const ::CoreML::Specification::CoreMLModels::TextClassifier* textclassifier_;
  const ::CoreML::Specification::CoreMLModels::WordTagger* wordtagger_;
  const ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* visionfeatureprint_;
} _Model_default_instance_;

namespace protobuf_Model_2eproto {

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};


void TableStruct::Shutdown() {
  _Pipeline_default_instance_.Shutdown();
  _PipelineClassifier_default_instance_.Shutdown();
  _PipelineRegressor_default_instance_.Shutdown();
  _FeatureDescription_default_instance_.Shutdown();
  _Metadata_default_instance_.Shutdown();
  _ModelDescription_default_instance_.Shutdown();
  _Model_default_instance_.Shutdown();
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  ::CoreML::Specification::CoreMLModels::protobuf_VisionFeaturePrint_2eproto::InitDefaults();
  ::CoreML::Specification::CoreMLModels::protobuf_TextClassifier_2eproto::InitDefaults();
  ::CoreML::Specification::CoreMLModels::protobuf_WordTagger_2eproto::InitDefaults();
  ::CoreML::Specification::protobuf_ArrayFeatureExtractor_2eproto::InitDefaults();
  ::CoreML::Specification::protobuf_BayesianProbitRegressor_2eproto::InitDefaults();
  ::CoreML::Specification::protobuf_CategoricalMapping_2eproto::InitDefaults();
  ::CoreML::Specification::protobuf_CustomModel_2eproto::InitDefaults();
  ::CoreML::Specification::protobuf_DictVectorizer_2eproto::InitDefaults();
  ::CoreML::Specification::protobuf_FeatureTypes_2eproto::InitDefaults();
  ::CoreML::Specification::protobuf_FeatureVectorizer_2eproto::InitDefaults();
  ::CoreML::Specification::protobuf_GLMRegressor_2eproto::InitDefaults();
  ::CoreML::Specification::protobuf_GLMClassifier_2eproto::InitDefaults();
  ::CoreML::Specification::protobuf_Identity_2eproto::InitDefaults();
  ::CoreML::Specification::protobuf_Imputer_2eproto::InitDefaults();
  ::CoreML::Specification::protobuf_NeuralNetwork_2eproto::InitDefaults();
  ::CoreML::Specification::protobuf_Normalizer_2eproto::InitDefaults();
  ::CoreML::Specification::protobuf_OneHotEncoder_2eproto::InitDefaults();
  ::CoreML::Specification::protobuf_Scaler_2eproto::InitDefaults();
  ::CoreML::Specification::protobuf_NonMaximumSuppression_2eproto::InitDefaults();
  ::CoreML::Specification::protobuf_SVM_2eproto::InitDefaults();
  ::CoreML::Specification::protobuf_TreeEnsemble_2eproto::InitDefaults();
  _Pipeline_default_instance_.DefaultConstruct();
  _PipelineClassifier_default_instance_.DefaultConstruct();
  _PipelineRegressor_default_instance_.DefaultConstruct();
  _FeatureDescription_default_instance_.DefaultConstruct();
  _Metadata_UserDefinedEntry_default_instance_.DefaultConstruct();
  _Metadata_default_instance_.DefaultConstruct();
  _ModelDescription_default_instance_.DefaultConstruct();
  _Model_default_instance_.DefaultConstruct();
  _PipelineClassifier_default_instance_.get_mutable()->pipeline_ = const_cast< ::CoreML::Specification::Pipeline*>(
      ::CoreML::Specification::Pipeline::internal_default_instance());
  _PipelineRegressor_default_instance_.get_mutable()->pipeline_ = const_cast< ::CoreML::Specification::Pipeline*>(
      ::CoreML::Specification::Pipeline::internal_default_instance());
  _FeatureDescription_default_instance_.get_mutable()->type_ = const_cast< ::CoreML::Specification::FeatureType*>(
      ::CoreML::Specification::FeatureType::internal_default_instance());
  _Metadata_UserDefinedEntry_default_instance_.get_mutable()->set_default_instance(_Metadata_UserDefinedEntry_default_instance_.get_mutable());
  _Metadata_UserDefinedEntry_default_instance_.get_mutable()->InitAsDefaultInstance();
  _ModelDescription_default_instance_.get_mutable()->metadata_ = const_cast< ::CoreML::Specification::Metadata*>(
      ::CoreML::Specification::Metadata::internal_default_instance());
  _Model_default_instance_.get_mutable()->description_ = const_cast< ::CoreML::Specification::ModelDescription*>(
      ::CoreML::Specification::ModelDescription::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  ::CoreML::Specification::CoreMLModels::protobuf_VisionFeaturePrint_2eproto::AddDescriptors();
  ::CoreML::Specification::CoreMLModels::protobuf_TextClassifier_2eproto::AddDescriptors();
  ::CoreML::Specification::CoreMLModels::protobuf_WordTagger_2eproto::AddDescriptors();
  ::CoreML::Specification::protobuf_ArrayFeatureExtractor_2eproto::AddDescriptors();
  ::CoreML::Specification::protobuf_BayesianProbitRegressor_2eproto::AddDescriptors();
  ::CoreML::Specification::protobuf_CategoricalMapping_2eproto::AddDescriptors();
  ::CoreML::Specification::protobuf_CustomModel_2eproto::AddDescriptors();
  ::CoreML::Specification::protobuf_DictVectorizer_2eproto::AddDescriptors();
  ::CoreML::Specification::protobuf_FeatureTypes_2eproto::AddDescriptors();
  ::CoreML::Specification::protobuf_FeatureVectorizer_2eproto::AddDescriptors();
  ::CoreML::Specification::protobuf_GLMRegressor_2eproto::AddDescriptors();
  ::CoreML::Specification::protobuf_GLMClassifier_2eproto::AddDescriptors();
  ::CoreML::Specification::protobuf_Identity_2eproto::AddDescriptors();
  ::CoreML::Specification::protobuf_Imputer_2eproto::AddDescriptors();
  ::CoreML::Specification::protobuf_NeuralNetwork_2eproto::AddDescriptors();
  ::CoreML::Specification::protobuf_Normalizer_2eproto::AddDescriptors();
  ::CoreML::Specification::protobuf_OneHotEncoder_2eproto::AddDescriptors();
  ::CoreML::Specification::protobuf_Scaler_2eproto::AddDescriptors();
  ::CoreML::Specification::protobuf_NonMaximumSuppression_2eproto::AddDescriptors();
  ::CoreML::Specification::protobuf_SVM_2eproto::AddDescriptors();
  ::CoreML::Specification::protobuf_TreeEnsemble_2eproto::AddDescriptors();
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
#endif  // GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

}  // namespace protobuf_Model_2eproto


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Pipeline::kModelsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Pipeline::Pipeline()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_Model_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.Pipeline)
}
Pipeline::Pipeline(const Pipeline& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      models_(from.models_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Pipeline)
}

void Pipeline::SharedCtor() {
  _cached_size_ = 0;
}

Pipeline::~Pipeline() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Pipeline)
  SharedDtor();
}

void Pipeline::SharedDtor() {
}

void Pipeline::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Pipeline& Pipeline::default_instance() {
  protobuf_Model_2eproto::InitDefaults();
  return *internal_default_instance();
}

Pipeline* Pipeline::New(::google::protobuf::Arena* arena) const {
  Pipeline* n = new Pipeline;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Pipeline::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Pipeline)
  models_.Clear();
}

bool Pipeline::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.Pipeline)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CoreML.Specification.Model models = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_models()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.Pipeline)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.Pipeline)
  return false;
#undef DO_
}

void Pipeline::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.Pipeline)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.Model models = 1;
  for (unsigned int i = 0, n = this->models_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->models(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.Pipeline)
}

size_t Pipeline::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Pipeline)
  size_t total_size = 0;

  // repeated .CoreML.Specification.Model models = 1;
  {
    unsigned int count = this->models_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->models(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Pipeline::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Pipeline*>(&from));
}

void Pipeline::MergeFrom(const Pipeline& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Pipeline)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  models_.MergeFrom(from.models_);
}

void Pipeline::CopyFrom(const Pipeline& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Pipeline)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pipeline::IsInitialized() const {
  return true;
}

void Pipeline::Swap(Pipeline* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Pipeline::InternalSwap(Pipeline* other) {
  models_.InternalSwap(&other->models_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Pipeline::GetTypeName() const {
  return "CoreML.Specification.Pipeline";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Pipeline

// repeated .CoreML.Specification.Model models = 1;
int Pipeline::models_size() const {
  return models_.size();
}
void Pipeline::clear_models() {
  models_.Clear();
}
const ::CoreML::Specification::Model& Pipeline::models(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Pipeline.models)
  return models_.Get(index);
}
::CoreML::Specification::Model* Pipeline::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Pipeline.models)
  return models_.Mutable(index);
}
::CoreML::Specification::Model* Pipeline::add_models() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.Pipeline.models)
  return models_.Add();
}
::google::protobuf::RepeatedPtrField< ::CoreML::Specification::Model >*
Pipeline::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.Pipeline.models)
  return &models_;
}
const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::Model >&
Pipeline::models() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.Pipeline.models)
  return models_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PipelineClassifier::kPipelineFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PipelineClassifier::PipelineClassifier()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_Model_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.PipelineClassifier)
}
PipelineClassifier::PipelineClassifier(const PipelineClassifier& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_pipeline()) {
    pipeline_ = new ::CoreML::Specification::Pipeline(*from.pipeline_);
  } else {
    pipeline_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.PipelineClassifier)
}

void PipelineClassifier::SharedCtor() {
  pipeline_ = NULL;
  _cached_size_ = 0;
}

PipelineClassifier::~PipelineClassifier() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.PipelineClassifier)
  SharedDtor();
}

void PipelineClassifier::SharedDtor() {
  if (this != internal_default_instance()) {
    delete pipeline_;
  }
}

void PipelineClassifier::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PipelineClassifier& PipelineClassifier::default_instance() {
  protobuf_Model_2eproto::InitDefaults();
  return *internal_default_instance();
}

PipelineClassifier* PipelineClassifier::New(::google::protobuf::Arena* arena) const {
  PipelineClassifier* n = new PipelineClassifier;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PipelineClassifier::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.PipelineClassifier)
  if (GetArenaNoVirtual() == NULL && pipeline_ != NULL) {
    delete pipeline_;
  }
  pipeline_ = NULL;
}

bool PipelineClassifier::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.PipelineClassifier)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .CoreML.Specification.Pipeline pipeline = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pipeline()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.PipelineClassifier)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.PipelineClassifier)
  return false;
#undef DO_
}

void PipelineClassifier::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.PipelineClassifier)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.Pipeline pipeline = 1;
  if (this->has_pipeline()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->pipeline_, output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.PipelineClassifier)
}

size_t PipelineClassifier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.PipelineClassifier)
  size_t total_size = 0;

  // .CoreML.Specification.Pipeline pipeline = 1;
  if (this->has_pipeline()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pipeline_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PipelineClassifier::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PipelineClassifier*>(&from));
}

void PipelineClassifier::MergeFrom(const PipelineClassifier& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.PipelineClassifier)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_pipeline()) {
    mutable_pipeline()->::CoreML::Specification::Pipeline::MergeFrom(from.pipeline());
  }
}

void PipelineClassifier::CopyFrom(const PipelineClassifier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.PipelineClassifier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PipelineClassifier::IsInitialized() const {
  return true;
}

void PipelineClassifier::Swap(PipelineClassifier* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PipelineClassifier::InternalSwap(PipelineClassifier* other) {
  std::swap(pipeline_, other->pipeline_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string PipelineClassifier::GetTypeName() const {
  return "CoreML.Specification.PipelineClassifier";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PipelineClassifier

// .CoreML.Specification.Pipeline pipeline = 1;
bool PipelineClassifier::has_pipeline() const {
  return this != internal_default_instance() && pipeline_ != NULL;
}
void PipelineClassifier::clear_pipeline() {
  if (GetArenaNoVirtual() == NULL && pipeline_ != NULL) delete pipeline_;
  pipeline_ = NULL;
}
const ::CoreML::Specification::Pipeline& PipelineClassifier::pipeline() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PipelineClassifier.pipeline)
  return pipeline_ != NULL ? *pipeline_
                         : *::CoreML::Specification::Pipeline::internal_default_instance();
}
::CoreML::Specification::Pipeline* PipelineClassifier::mutable_pipeline() {
  
  if (pipeline_ == NULL) {
    pipeline_ = new ::CoreML::Specification::Pipeline;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.PipelineClassifier.pipeline)
  return pipeline_;
}
::CoreML::Specification::Pipeline* PipelineClassifier::release_pipeline() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.PipelineClassifier.pipeline)
  
  ::CoreML::Specification::Pipeline* temp = pipeline_;
  pipeline_ = NULL;
  return temp;
}
void PipelineClassifier::set_allocated_pipeline(::CoreML::Specification::Pipeline* pipeline) {
  delete pipeline_;
  pipeline_ = pipeline;
  if (pipeline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PipelineClassifier.pipeline)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PipelineRegressor::kPipelineFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PipelineRegressor::PipelineRegressor()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_Model_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.PipelineRegressor)
}
PipelineRegressor::PipelineRegressor(const PipelineRegressor& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_pipeline()) {
    pipeline_ = new ::CoreML::Specification::Pipeline(*from.pipeline_);
  } else {
    pipeline_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.PipelineRegressor)
}

void PipelineRegressor::SharedCtor() {
  pipeline_ = NULL;
  _cached_size_ = 0;
}

PipelineRegressor::~PipelineRegressor() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.PipelineRegressor)
  SharedDtor();
}

void PipelineRegressor::SharedDtor() {
  if (this != internal_default_instance()) {
    delete pipeline_;
  }
}

void PipelineRegressor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PipelineRegressor& PipelineRegressor::default_instance() {
  protobuf_Model_2eproto::InitDefaults();
  return *internal_default_instance();
}

PipelineRegressor* PipelineRegressor::New(::google::protobuf::Arena* arena) const {
  PipelineRegressor* n = new PipelineRegressor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PipelineRegressor::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.PipelineRegressor)
  if (GetArenaNoVirtual() == NULL && pipeline_ != NULL) {
    delete pipeline_;
  }
  pipeline_ = NULL;
}

bool PipelineRegressor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.PipelineRegressor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .CoreML.Specification.Pipeline pipeline = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pipeline()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.PipelineRegressor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.PipelineRegressor)
  return false;
#undef DO_
}

void PipelineRegressor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.PipelineRegressor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.Pipeline pipeline = 1;
  if (this->has_pipeline()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->pipeline_, output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.PipelineRegressor)
}

size_t PipelineRegressor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.PipelineRegressor)
  size_t total_size = 0;

  // .CoreML.Specification.Pipeline pipeline = 1;
  if (this->has_pipeline()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pipeline_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PipelineRegressor::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PipelineRegressor*>(&from));
}

void PipelineRegressor::MergeFrom(const PipelineRegressor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.PipelineRegressor)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_pipeline()) {
    mutable_pipeline()->::CoreML::Specification::Pipeline::MergeFrom(from.pipeline());
  }
}

void PipelineRegressor::CopyFrom(const PipelineRegressor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.PipelineRegressor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PipelineRegressor::IsInitialized() const {
  return true;
}

void PipelineRegressor::Swap(PipelineRegressor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PipelineRegressor::InternalSwap(PipelineRegressor* other) {
  std::swap(pipeline_, other->pipeline_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string PipelineRegressor::GetTypeName() const {
  return "CoreML.Specification.PipelineRegressor";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PipelineRegressor

// .CoreML.Specification.Pipeline pipeline = 1;
bool PipelineRegressor::has_pipeline() const {
  return this != internal_default_instance() && pipeline_ != NULL;
}
void PipelineRegressor::clear_pipeline() {
  if (GetArenaNoVirtual() == NULL && pipeline_ != NULL) delete pipeline_;
  pipeline_ = NULL;
}
const ::CoreML::Specification::Pipeline& PipelineRegressor::pipeline() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PipelineRegressor.pipeline)
  return pipeline_ != NULL ? *pipeline_
                         : *::CoreML::Specification::Pipeline::internal_default_instance();
}
::CoreML::Specification::Pipeline* PipelineRegressor::mutable_pipeline() {
  
  if (pipeline_ == NULL) {
    pipeline_ = new ::CoreML::Specification::Pipeline;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.PipelineRegressor.pipeline)
  return pipeline_;
}
::CoreML::Specification::Pipeline* PipelineRegressor::release_pipeline() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.PipelineRegressor.pipeline)
  
  ::CoreML::Specification::Pipeline* temp = pipeline_;
  pipeline_ = NULL;
  return temp;
}
void PipelineRegressor::set_allocated_pipeline(::CoreML::Specification::Pipeline* pipeline) {
  delete pipeline_;
  pipeline_ = pipeline;
  if (pipeline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PipelineRegressor.pipeline)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FeatureDescription::kNameFieldNumber;
const int FeatureDescription::kShortDescriptionFieldNumber;
const int FeatureDescription::kTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FeatureDescription::FeatureDescription()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_Model_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.FeatureDescription)
}
FeatureDescription::FeatureDescription(const FeatureDescription& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.name().size() > 0) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  shortdescription_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.shortdescription().size() > 0) {
    shortdescription_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.shortdescription_);
  }
  if (from.has_type()) {
    type_ = new ::CoreML::Specification::FeatureType(*from.type_);
  } else {
    type_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.FeatureDescription)
}

void FeatureDescription::SharedCtor() {
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  shortdescription_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = NULL;
  _cached_size_ = 0;
}

FeatureDescription::~FeatureDescription() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.FeatureDescription)
  SharedDtor();
}

void FeatureDescription::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  shortdescription_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete type_;
  }
}

void FeatureDescription::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FeatureDescription& FeatureDescription::default_instance() {
  protobuf_Model_2eproto::InitDefaults();
  return *internal_default_instance();
}

FeatureDescription* FeatureDescription::New(::google::protobuf::Arena* arena) const {
  FeatureDescription* n = new FeatureDescription;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FeatureDescription::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.FeatureDescription)
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  shortdescription_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && type_ != NULL) {
    delete type_;
  }
  type_ = NULL;
}

bool FeatureDescription::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.FeatureDescription)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.FeatureDescription.name"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string shortDescription = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_shortdescription()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->shortdescription().data(), this->shortdescription().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.FeatureDescription.shortDescription"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.FeatureType type = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_type()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.FeatureDescription)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.FeatureDescription)
  return false;
#undef DO_
}

void FeatureDescription::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.FeatureDescription)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.FeatureDescription.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // string shortDescription = 2;
  if (this->shortdescription().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->shortdescription().data(), this->shortdescription().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.FeatureDescription.shortDescription");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->shortdescription(), output);
  }

  // .CoreML.Specification.FeatureType type = 3;
  if (this->has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->type_, output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.FeatureDescription)
}

size_t FeatureDescription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.FeatureDescription)
  size_t total_size = 0;

  // string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  // string shortDescription = 2;
  if (this->shortdescription().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->shortdescription());
  }

  // .CoreML.Specification.FeatureType type = 3;
  if (this->has_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->type_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FeatureDescription::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FeatureDescription*>(&from));
}

void FeatureDescription::MergeFrom(const FeatureDescription& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.FeatureDescription)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.shortdescription().size() > 0) {

    shortdescription_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.shortdescription_);
  }
  if (from.has_type()) {
    mutable_type()->::CoreML::Specification::FeatureType::MergeFrom(from.type());
  }
}

void FeatureDescription::CopyFrom(const FeatureDescription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.FeatureDescription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeatureDescription::IsInitialized() const {
  return true;
}

void FeatureDescription::Swap(FeatureDescription* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FeatureDescription::InternalSwap(FeatureDescription* other) {
  name_.Swap(&other->name_);
  shortdescription_.Swap(&other->shortdescription_);
  std::swap(type_, other->type_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FeatureDescription::GetTypeName() const {
  return "CoreML.Specification.FeatureDescription";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FeatureDescription

// string name = 1;
void FeatureDescription::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& FeatureDescription::name() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureDescription.name)
  return name_.GetNoArena();
}
void FeatureDescription::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.FeatureDescription.name)
}
#if LANG_CXX11
void FeatureDescription::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.FeatureDescription.name)
}
#endif
void FeatureDescription::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.FeatureDescription.name)
}
void FeatureDescription::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.FeatureDescription.name)
}
::std::string* FeatureDescription::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureDescription.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* FeatureDescription::release_name() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureDescription.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void FeatureDescription::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureDescription.name)
}

// string shortDescription = 2;
void FeatureDescription::clear_shortdescription() {
  shortdescription_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& FeatureDescription::shortdescription() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureDescription.shortDescription)
  return shortdescription_.GetNoArena();
}
void FeatureDescription::set_shortdescription(const ::std::string& value) {
  
  shortdescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.FeatureDescription.shortDescription)
}
#if LANG_CXX11
void FeatureDescription::set_shortdescription(::std::string&& value) {
  
  shortdescription_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.FeatureDescription.shortDescription)
}
#endif
void FeatureDescription::set_shortdescription(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  shortdescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.FeatureDescription.shortDescription)
}
void FeatureDescription::set_shortdescription(const char* value, size_t size) {
  
  shortdescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.FeatureDescription.shortDescription)
}
::std::string* FeatureDescription::mutable_shortdescription() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureDescription.shortDescription)
  return shortdescription_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* FeatureDescription::release_shortdescription() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureDescription.shortDescription)
  
  return shortdescription_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void FeatureDescription::set_allocated_shortdescription(::std::string* shortdescription) {
  if (shortdescription != NULL) {
    
  } else {
    
  }
  shortdescription_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), shortdescription);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureDescription.shortDescription)
}

// .CoreML.Specification.FeatureType type = 3;
bool FeatureDescription::has_type() const {
  return this != internal_default_instance() && type_ != NULL;
}
void FeatureDescription::clear_type() {
  if (GetArenaNoVirtual() == NULL && type_ != NULL) delete type_;
  type_ = NULL;
}
const ::CoreML::Specification::FeatureType& FeatureDescription::type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureDescription.type)
  return type_ != NULL ? *type_
                         : *::CoreML::Specification::FeatureType::internal_default_instance();
}
::CoreML::Specification::FeatureType* FeatureDescription::mutable_type() {
  
  if (type_ == NULL) {
    type_ = new ::CoreML::Specification::FeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureDescription.type)
  return type_;
}
::CoreML::Specification::FeatureType* FeatureDescription::release_type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureDescription.type)
  
  ::CoreML::Specification::FeatureType* temp = type_;
  type_ = NULL;
  return temp;
}
void FeatureDescription::set_allocated_type(::CoreML::Specification::FeatureType* type) {
  delete type_;
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureDescription.type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if PROTOBUF_INLINE_NOT_IN_HEADERS
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Metadata::kShortDescriptionFieldNumber;
const int Metadata::kVersionStringFieldNumber;
const int Metadata::kAuthorFieldNumber;
const int Metadata::kLicenseFieldNumber;
const int Metadata::kUserDefinedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Metadata::Metadata()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_Model_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.Metadata)
}
Metadata::Metadata(const Metadata& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  userdefined_.MergeFrom(from.userdefined_);
  shortdescription_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.shortdescription().size() > 0) {
    shortdescription_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.shortdescription_);
  }
  versionstring_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.versionstring().size() > 0) {
    versionstring_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.versionstring_);
  }
  author_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.author().size() > 0) {
    author_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.author_);
  }
  license_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.license().size() > 0) {
    license_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.license_);
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Metadata)
}

void Metadata::SharedCtor() {
  shortdescription_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  versionstring_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  author_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  license_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _cached_size_ = 0;
}

Metadata::~Metadata() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Metadata)
  SharedDtor();
}

void Metadata::SharedDtor() {
  shortdescription_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  versionstring_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  author_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  license_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Metadata::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Metadata& Metadata::default_instance() {
  protobuf_Model_2eproto::InitDefaults();
  return *internal_default_instance();
}

Metadata* Metadata::New(::google::protobuf::Arena* arena) const {
  Metadata* n = new Metadata;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Metadata::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Metadata)
  userdefined_.Clear();
  shortdescription_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  versionstring_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  author_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  license_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Metadata::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.Metadata)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string shortDescription = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_shortdescription()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->shortdescription().data(), this->shortdescription().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.Metadata.shortDescription"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string versionString = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_versionstring()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->versionstring().data(), this->versionstring().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.Metadata.versionString"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string author = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_author()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->author().data(), this->author().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.Metadata.author"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string license = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_license()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->license().data(), this->license().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.Metadata.license"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // map<string, string> userDefined = 100;
      case 100: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(802u)) {
          Metadata_UserDefinedEntry::Parser< ::google::protobuf::internal::MapFieldLite<
              Metadata_UserDefinedEntry,
              ::std::string, ::std::string,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              0 >,
            ::google::protobuf::Map< ::std::string, ::std::string > > parser(&userdefined_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            parser.key().data(), parser.key().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.Metadata.UserDefinedEntry.key"));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            parser.value().data(), parser.value().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.Metadata.UserDefinedEntry.value"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.Metadata)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.Metadata)
  return false;
#undef DO_
}

void Metadata::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.Metadata)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string shortDescription = 1;
  if (this->shortdescription().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->shortdescription().data(), this->shortdescription().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.Metadata.shortDescription");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->shortdescription(), output);
  }

  // string versionString = 2;
  if (this->versionstring().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->versionstring().data(), this->versionstring().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.Metadata.versionString");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->versionstring(), output);
  }

  // string author = 3;
  if (this->author().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->author().data(), this->author().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.Metadata.author");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->author(), output);
  }

  // string license = 4;
  if (this->license().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->license().data(), this->license().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.Metadata.license");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->license(), output);
  }

  // map<string, string> userDefined = 100;
  if (!this->userdefined().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.Metadata.UserDefinedEntry.key");
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->second.data(), p->second.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.Metadata.UserDefinedEntry.value");
      }
    };

    if (output->IsSerializationDeterministic() &&
        this->userdefined().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->userdefined().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::std::string >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::std::string >::const_iterator
          it = this->userdefined().begin();
          it != this->userdefined().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<Metadata_UserDefinedEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(userdefined_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            100, *entry, output);
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<Metadata_UserDefinedEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::std::string >::const_iterator
          it = this->userdefined().begin();
          it != this->userdefined().end(); ++it) {
        entry.reset(userdefined_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            100, *entry, output);
        Utf8Check::Check(&*it);
      }
    }
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.Metadata)
}

size_t Metadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Metadata)
  size_t total_size = 0;

  // map<string, string> userDefined = 100;
  total_size += 2 *
      ::google::protobuf::internal::FromIntSize(this->userdefined_size());
  {
    ::google::protobuf::scoped_ptr<Metadata_UserDefinedEntry> entry;
    for (::google::protobuf::Map< ::std::string, ::std::string >::const_iterator
        it = this->userdefined().begin();
        it != this->userdefined().end(); ++it) {
      entry.reset(userdefined_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  // string shortDescription = 1;
  if (this->shortdescription().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->shortdescription());
  }

  // string versionString = 2;
  if (this->versionstring().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->versionstring());
  }

  // string author = 3;
  if (this->author().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->author());
  }

  // string license = 4;
  if (this->license().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->license());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Metadata::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Metadata*>(&from));
}

void Metadata::MergeFrom(const Metadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Metadata)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  userdefined_.MergeFrom(from.userdefined_);
  if (from.shortdescription().size() > 0) {

    shortdescription_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.shortdescription_);
  }
  if (from.versionstring().size() > 0) {

    versionstring_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.versionstring_);
  }
  if (from.author().size() > 0) {

    author_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.author_);
  }
  if (from.license().size() > 0) {

    license_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.license_);
  }
}

void Metadata::CopyFrom(const Metadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Metadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Metadata::IsInitialized() const {
  return true;
}

void Metadata::Swap(Metadata* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Metadata::InternalSwap(Metadata* other) {
  userdefined_.Swap(&other->userdefined_);
  shortdescription_.Swap(&other->shortdescription_);
  versionstring_.Swap(&other->versionstring_);
  author_.Swap(&other->author_);
  license_.Swap(&other->license_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Metadata::GetTypeName() const {
  return "CoreML.Specification.Metadata";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Metadata

// string shortDescription = 1;
void Metadata::clear_shortdescription() {
  shortdescription_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Metadata::shortdescription() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Metadata.shortDescription)
  return shortdescription_.GetNoArena();
}
void Metadata::set_shortdescription(const ::std::string& value) {
  
  shortdescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Metadata.shortDescription)
}
#if LANG_CXX11
void Metadata::set_shortdescription(::std::string&& value) {
  
  shortdescription_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.Metadata.shortDescription)
}
#endif
void Metadata::set_shortdescription(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  shortdescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.Metadata.shortDescription)
}
void Metadata::set_shortdescription(const char* value, size_t size) {
  
  shortdescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.Metadata.shortDescription)
}
::std::string* Metadata::mutable_shortdescription() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Metadata.shortDescription)
  return shortdescription_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Metadata::release_shortdescription() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Metadata.shortDescription)
  
  return shortdescription_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Metadata::set_allocated_shortdescription(::std::string* shortdescription) {
  if (shortdescription != NULL) {
    
  } else {
    
  }
  shortdescription_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), shortdescription);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Metadata.shortDescription)
}

// string versionString = 2;
void Metadata::clear_versionstring() {
  versionstring_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Metadata::versionstring() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Metadata.versionString)
  return versionstring_.GetNoArena();
}
void Metadata::set_versionstring(const ::std::string& value) {
  
  versionstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Metadata.versionString)
}
#if LANG_CXX11
void Metadata::set_versionstring(::std::string&& value) {
  
  versionstring_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.Metadata.versionString)
}
#endif
void Metadata::set_versionstring(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  versionstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.Metadata.versionString)
}
void Metadata::set_versionstring(const char* value, size_t size) {
  
  versionstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.Metadata.versionString)
}
::std::string* Metadata::mutable_versionstring() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Metadata.versionString)
  return versionstring_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Metadata::release_versionstring() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Metadata.versionString)
  
  return versionstring_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Metadata::set_allocated_versionstring(::std::string* versionstring) {
  if (versionstring != NULL) {
    
  } else {
    
  }
  versionstring_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), versionstring);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Metadata.versionString)
}

// string author = 3;
void Metadata::clear_author() {
  author_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Metadata::author() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Metadata.author)
  return author_.GetNoArena();
}
void Metadata::set_author(const ::std::string& value) {
  
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Metadata.author)
}
#if LANG_CXX11
void Metadata::set_author(::std::string&& value) {
  
  author_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.Metadata.author)
}
#endif
void Metadata::set_author(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.Metadata.author)
}
void Metadata::set_author(const char* value, size_t size) {
  
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.Metadata.author)
}
::std::string* Metadata::mutable_author() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Metadata.author)
  return author_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Metadata::release_author() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Metadata.author)
  
  return author_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Metadata::set_allocated_author(::std::string* author) {
  if (author != NULL) {
    
  } else {
    
  }
  author_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), author);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Metadata.author)
}

// string license = 4;
void Metadata::clear_license() {
  license_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Metadata::license() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Metadata.license)
  return license_.GetNoArena();
}
void Metadata::set_license(const ::std::string& value) {
  
  license_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Metadata.license)
}
#if LANG_CXX11
void Metadata::set_license(::std::string&& value) {
  
  license_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.Metadata.license)
}
#endif
void Metadata::set_license(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  license_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.Metadata.license)
}
void Metadata::set_license(const char* value, size_t size) {
  
  license_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.Metadata.license)
}
::std::string* Metadata::mutable_license() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Metadata.license)
  return license_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Metadata::release_license() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Metadata.license)
  
  return license_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Metadata::set_allocated_license(::std::string* license) {
  if (license != NULL) {
    
  } else {
    
  }
  license_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), license);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Metadata.license)
}

// map<string, string> userDefined = 100;
int Metadata::userdefined_size() const {
  return userdefined_.size();
}
void Metadata::clear_userdefined() {
  userdefined_.Clear();
}
 const ::google::protobuf::Map< ::std::string, ::std::string >&
Metadata::userdefined() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.Metadata.userDefined)
  return userdefined_.GetMap();
}
 ::google::protobuf::Map< ::std::string, ::std::string >*
Metadata::mutable_userdefined() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.Metadata.userDefined)
  return userdefined_.MutableMap();
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ModelDescription::kInputFieldNumber;
const int ModelDescription::kOutputFieldNumber;
const int ModelDescription::kPredictedFeatureNameFieldNumber;
const int ModelDescription::kPredictedProbabilitiesNameFieldNumber;
const int ModelDescription::kMetadataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ModelDescription::ModelDescription()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_Model_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.ModelDescription)
}
ModelDescription::ModelDescription(const ModelDescription& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      input_(from.input_),
      output_(from.output_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  predictedfeaturename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.predictedfeaturename().size() > 0) {
    predictedfeaturename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.predictedfeaturename_);
  }
  predictedprobabilitiesname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.predictedprobabilitiesname().size() > 0) {
    predictedprobabilitiesname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.predictedprobabilitiesname_);
  }
  if (from.has_metadata()) {
    metadata_ = new ::CoreML::Specification::Metadata(*from.metadata_);
  } else {
    metadata_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ModelDescription)
}

void ModelDescription::SharedCtor() {
  predictedfeaturename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  predictedprobabilitiesname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  metadata_ = NULL;
  _cached_size_ = 0;
}

ModelDescription::~ModelDescription() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ModelDescription)
  SharedDtor();
}

void ModelDescription::SharedDtor() {
  predictedfeaturename_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  predictedprobabilitiesname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete metadata_;
  }
}

void ModelDescription::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ModelDescription& ModelDescription::default_instance() {
  protobuf_Model_2eproto::InitDefaults();
  return *internal_default_instance();
}

ModelDescription* ModelDescription::New(::google::protobuf::Arena* arena) const {
  ModelDescription* n = new ModelDescription;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ModelDescription::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ModelDescription)
  input_.Clear();
  output_.Clear();
  predictedfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  predictedprobabilitiesname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) {
    delete metadata_;
  }
  metadata_ = NULL;
}

bool ModelDescription::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.ModelDescription)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CoreML.Specification.FeatureDescription input = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_input()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .CoreML.Specification.FeatureDescription output = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_output()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string predictedFeatureName = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(90u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_predictedfeaturename()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->predictedfeaturename().data(), this->predictedfeaturename().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.ModelDescription.predictedFeatureName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string predictedProbabilitiesName = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(98u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_predictedprobabilitiesname()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->predictedprobabilitiesname().data(), this->predictedprobabilitiesname().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.ModelDescription.predictedProbabilitiesName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.Metadata metadata = 100;
      case 100: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(802u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_metadata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.ModelDescription)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.ModelDescription)
  return false;
#undef DO_
}

void ModelDescription::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.ModelDescription)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.FeatureDescription input = 1;
  for (unsigned int i = 0, n = this->input_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->input(i), output);
  }

  // repeated .CoreML.Specification.FeatureDescription output = 10;
  for (unsigned int i = 0, n = this->output_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->output(i), output);
  }

  // string predictedFeatureName = 11;
  if (this->predictedfeaturename().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->predictedfeaturename().data(), this->predictedfeaturename().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.ModelDescription.predictedFeatureName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      11, this->predictedfeaturename(), output);
  }

  // string predictedProbabilitiesName = 12;
  if (this->predictedprobabilitiesname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->predictedprobabilitiesname().data(), this->predictedprobabilitiesname().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.ModelDescription.predictedProbabilitiesName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      12, this->predictedprobabilitiesname(), output);
  }

  // .CoreML.Specification.Metadata metadata = 100;
  if (this->has_metadata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      100, *this->metadata_, output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.ModelDescription)
}

size_t ModelDescription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ModelDescription)
  size_t total_size = 0;

  // repeated .CoreML.Specification.FeatureDescription input = 1;
  {
    unsigned int count = this->input_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->input(i));
    }
  }

  // repeated .CoreML.Specification.FeatureDescription output = 10;
  {
    unsigned int count = this->output_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->output(i));
    }
  }

  // string predictedFeatureName = 11;
  if (this->predictedfeaturename().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->predictedfeaturename());
  }

  // string predictedProbabilitiesName = 12;
  if (this->predictedprobabilitiesname().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->predictedprobabilitiesname());
  }

  // .CoreML.Specification.Metadata metadata = 100;
  if (this->has_metadata()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->metadata_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModelDescription::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ModelDescription*>(&from));
}

void ModelDescription::MergeFrom(const ModelDescription& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ModelDescription)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  input_.MergeFrom(from.input_);
  output_.MergeFrom(from.output_);
  if (from.predictedfeaturename().size() > 0) {

    predictedfeaturename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.predictedfeaturename_);
  }
  if (from.predictedprobabilitiesname().size() > 0) {

    predictedprobabilitiesname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.predictedprobabilitiesname_);
  }
  if (from.has_metadata()) {
    mutable_metadata()->::CoreML::Specification::Metadata::MergeFrom(from.metadata());
  }
}

void ModelDescription::CopyFrom(const ModelDescription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ModelDescription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelDescription::IsInitialized() const {
  return true;
}

void ModelDescription::Swap(ModelDescription* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ModelDescription::InternalSwap(ModelDescription* other) {
  input_.InternalSwap(&other->input_);
  output_.InternalSwap(&other->output_);
  predictedfeaturename_.Swap(&other->predictedfeaturename_);
  predictedprobabilitiesname_.Swap(&other->predictedprobabilitiesname_);
  std::swap(metadata_, other->metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ModelDescription::GetTypeName() const {
  return "CoreML.Specification.ModelDescription";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ModelDescription

// repeated .CoreML.Specification.FeatureDescription input = 1;
int ModelDescription::input_size() const {
  return input_.size();
}
void ModelDescription::clear_input() {
  input_.Clear();
}
const ::CoreML::Specification::FeatureDescription& ModelDescription::input(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.input)
  return input_.Get(index);
}
::CoreML::Specification::FeatureDescription* ModelDescription::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.input)
  return input_.Mutable(index);
}
::CoreML::Specification::FeatureDescription* ModelDescription::add_input() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.ModelDescription.input)
  return input_.Add();
}
::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
ModelDescription::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ModelDescription.input)
  return &input_;
}
const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
ModelDescription::input() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ModelDescription.input)
  return input_;
}

// repeated .CoreML.Specification.FeatureDescription output = 10;
int ModelDescription::output_size() const {
  return output_.size();
}
void ModelDescription::clear_output() {
  output_.Clear();
}
const ::CoreML::Specification::FeatureDescription& ModelDescription::output(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.output)
  return output_.Get(index);
}
::CoreML::Specification::FeatureDescription* ModelDescription::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.output)
  return output_.Mutable(index);
}
::CoreML::Specification::FeatureDescription* ModelDescription::add_output() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.ModelDescription.output)
  return output_.Add();
}
::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
ModelDescription::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ModelDescription.output)
  return &output_;
}
const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
ModelDescription::output() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ModelDescription.output)
  return output_;
}

// string predictedFeatureName = 11;
void ModelDescription::clear_predictedfeaturename() {
  predictedfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& ModelDescription::predictedfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.predictedFeatureName)
  return predictedfeaturename_.GetNoArena();
}
void ModelDescription::set_predictedfeaturename(const ::std::string& value) {
  
  predictedfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ModelDescription.predictedFeatureName)
}
#if LANG_CXX11
void ModelDescription::set_predictedfeaturename(::std::string&& value) {
  
  predictedfeaturename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.ModelDescription.predictedFeatureName)
}
#endif
void ModelDescription::set_predictedfeaturename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  predictedfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.ModelDescription.predictedFeatureName)
}
void ModelDescription::set_predictedfeaturename(const char* value, size_t size) {
  
  predictedfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.ModelDescription.predictedFeatureName)
}
::std::string* ModelDescription::mutable_predictedfeaturename() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.predictedFeatureName)
  return predictedfeaturename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ModelDescription::release_predictedfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ModelDescription.predictedFeatureName)
  
  return predictedfeaturename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ModelDescription::set_allocated_predictedfeaturename(::std::string* predictedfeaturename) {
  if (predictedfeaturename != NULL) {
    
  } else {
    
  }
  predictedfeaturename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), predictedfeaturename);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ModelDescription.predictedFeatureName)
}

// string predictedProbabilitiesName = 12;
void ModelDescription::clear_predictedprobabilitiesname() {
  predictedprobabilitiesname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& ModelDescription::predictedprobabilitiesname() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
  return predictedprobabilitiesname_.GetNoArena();
}
void ModelDescription::set_predictedprobabilitiesname(const ::std::string& value) {
  
  predictedprobabilitiesname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
}
#if LANG_CXX11
void ModelDescription::set_predictedprobabilitiesname(::std::string&& value) {
  
  predictedprobabilitiesname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
}
#endif
void ModelDescription::set_predictedprobabilitiesname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  predictedprobabilitiesname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
}
void ModelDescription::set_predictedprobabilitiesname(const char* value, size_t size) {
  
  predictedprobabilitiesname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
}
::std::string* ModelDescription::mutable_predictedprobabilitiesname() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
  return predictedprobabilitiesname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ModelDescription::release_predictedprobabilitiesname() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
  
  return predictedprobabilitiesname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ModelDescription::set_allocated_predictedprobabilitiesname(::std::string* predictedprobabilitiesname) {
  if (predictedprobabilitiesname != NULL) {
    
  } else {
    
  }
  predictedprobabilitiesname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), predictedprobabilitiesname);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
}

// .CoreML.Specification.Metadata metadata = 100;
bool ModelDescription::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
void ModelDescription::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) delete metadata_;
  metadata_ = NULL;
}
const ::CoreML::Specification::Metadata& ModelDescription::metadata() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.metadata)
  return metadata_ != NULL ? *metadata_
                         : *::CoreML::Specification::Metadata::internal_default_instance();
}
::CoreML::Specification::Metadata* ModelDescription::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::CoreML::Specification::Metadata;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.metadata)
  return metadata_;
}
::CoreML::Specification::Metadata* ModelDescription::release_metadata() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ModelDescription.metadata)
  
  ::CoreML::Specification::Metadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
void ModelDescription::set_allocated_metadata(::CoreML::Specification::Metadata* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ModelDescription.metadata)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Model::kSpecificationVersionFieldNumber;
const int Model::kDescriptionFieldNumber;
const int Model::kPipelineClassifierFieldNumber;
const int Model::kPipelineRegressorFieldNumber;
const int Model::kPipelineFieldNumber;
const int Model::kGlmRegressorFieldNumber;
const int Model::kSupportVectorRegressorFieldNumber;
const int Model::kTreeEnsembleRegressorFieldNumber;
const int Model::kNeuralNetworkRegressorFieldNumber;
const int Model::kBayesianProbitRegressorFieldNumber;
const int Model::kGlmClassifierFieldNumber;
const int Model::kSupportVectorClassifierFieldNumber;
const int Model::kTreeEnsembleClassifierFieldNumber;
const int Model::kNeuralNetworkClassifierFieldNumber;
const int Model::kNeuralNetworkFieldNumber;
const int Model::kCustomModelFieldNumber;
const int Model::kOneHotEncoderFieldNumber;
const int Model::kImputerFieldNumber;
const int Model::kFeatureVectorizerFieldNumber;
const int Model::kDictVectorizerFieldNumber;
const int Model::kScalerFieldNumber;
const int Model::kCategoricalMappingFieldNumber;
const int Model::kNormalizerFieldNumber;
const int Model::kArrayFeatureExtractorFieldNumber;
const int Model::kNonMaximumSuppressionFieldNumber;
const int Model::kIdentityFieldNumber;
const int Model::kTextClassifierFieldNumber;
const int Model::kWordTaggerFieldNumber;
const int Model::kVisionFeaturePrintFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Model::Model()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_Model_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.Model)
}
Model::Model(const Model& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_description()) {
    description_ = new ::CoreML::Specification::ModelDescription(*from.description_);
  } else {
    description_ = NULL;
  }
  specificationversion_ = from.specificationversion_;
  clear_has_Type();
  switch (from.Type_case()) {
    case kPipelineClassifier: {
      mutable_pipelineclassifier()->::CoreML::Specification::PipelineClassifier::MergeFrom(from.pipelineclassifier());
      break;
    }
    case kPipelineRegressor: {
      mutable_pipelineregressor()->::CoreML::Specification::PipelineRegressor::MergeFrom(from.pipelineregressor());
      break;
    }
    case kPipeline: {
      mutable_pipeline()->::CoreML::Specification::Pipeline::MergeFrom(from.pipeline());
      break;
    }
    case kGlmRegressor: {
      mutable_glmregressor()->::CoreML::Specification::GLMRegressor::MergeFrom(from.glmregressor());
      break;
    }
    case kSupportVectorRegressor: {
      mutable_supportvectorregressor()->::CoreML::Specification::SupportVectorRegressor::MergeFrom(from.supportvectorregressor());
      break;
    }
    case kTreeEnsembleRegressor: {
      mutable_treeensembleregressor()->::CoreML::Specification::TreeEnsembleRegressor::MergeFrom(from.treeensembleregressor());
      break;
    }
    case kNeuralNetworkRegressor: {
      mutable_neuralnetworkregressor()->::CoreML::Specification::NeuralNetworkRegressor::MergeFrom(from.neuralnetworkregressor());
      break;
    }
    case kBayesianProbitRegressor: {
      mutable_bayesianprobitregressor()->::CoreML::Specification::BayesianProbitRegressor::MergeFrom(from.bayesianprobitregressor());
      break;
    }
    case kGlmClassifier: {
      mutable_glmclassifier()->::CoreML::Specification::GLMClassifier::MergeFrom(from.glmclassifier());
      break;
    }
    case kSupportVectorClassifier: {
      mutable_supportvectorclassifier()->::CoreML::Specification::SupportVectorClassifier::MergeFrom(from.supportvectorclassifier());
      break;
    }
    case kTreeEnsembleClassifier: {
      mutable_treeensembleclassifier()->::CoreML::Specification::TreeEnsembleClassifier::MergeFrom(from.treeensembleclassifier());
      break;
    }
    case kNeuralNetworkClassifier: {
      mutable_neuralnetworkclassifier()->::CoreML::Specification::NeuralNetworkClassifier::MergeFrom(from.neuralnetworkclassifier());
      break;
    }
    case kNeuralNetwork: {
      mutable_neuralnetwork()->::CoreML::Specification::NeuralNetwork::MergeFrom(from.neuralnetwork());
      break;
    }
    case kCustomModel: {
      mutable_custommodel()->::CoreML::Specification::CustomModel::MergeFrom(from.custommodel());
      break;
    }
    case kOneHotEncoder: {
      mutable_onehotencoder()->::CoreML::Specification::OneHotEncoder::MergeFrom(from.onehotencoder());
      break;
    }
    case kImputer: {
      mutable_imputer()->::CoreML::Specification::Imputer::MergeFrom(from.imputer());
      break;
    }
    case kFeatureVectorizer: {
      mutable_featurevectorizer()->::CoreML::Specification::FeatureVectorizer::MergeFrom(from.featurevectorizer());
      break;
    }
    case kDictVectorizer: {
      mutable_dictvectorizer()->::CoreML::Specification::DictVectorizer::MergeFrom(from.dictvectorizer());
      break;
    }
    case kScaler: {
      mutable_scaler()->::CoreML::Specification::Scaler::MergeFrom(from.scaler());
      break;
    }
    case kCategoricalMapping: {
      mutable_categoricalmapping()->::CoreML::Specification::CategoricalMapping::MergeFrom(from.categoricalmapping());
      break;
    }
    case kNormalizer: {
      mutable_normalizer()->::CoreML::Specification::Normalizer::MergeFrom(from.normalizer());
      break;
    }
    case kArrayFeatureExtractor: {
      mutable_arrayfeatureextractor()->::CoreML::Specification::ArrayFeatureExtractor::MergeFrom(from.arrayfeatureextractor());
      break;
    }
    case kNonMaximumSuppression: {
      mutable_nonmaximumsuppression()->::CoreML::Specification::NonMaximumSuppression::MergeFrom(from.nonmaximumsuppression());
      break;
    }
    case kIdentity: {
      mutable_identity()->::CoreML::Specification::Identity::MergeFrom(from.identity());
      break;
    }
    case kTextClassifier: {
      mutable_textclassifier()->::CoreML::Specification::CoreMLModels::TextClassifier::MergeFrom(from.textclassifier());
      break;
    }
    case kWordTagger: {
      mutable_wordtagger()->::CoreML::Specification::CoreMLModels::WordTagger::MergeFrom(from.wordtagger());
      break;
    }
    case kVisionFeaturePrint: {
      mutable_visionfeatureprint()->::CoreML::Specification::CoreMLModels::VisionFeaturePrint::MergeFrom(from.visionfeatureprint());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Model)
}

void Model::SharedCtor() {
  ::memset(&description_, 0, reinterpret_cast<char*>(&specificationversion_) -
    reinterpret_cast<char*>(&description_) + sizeof(specificationversion_));
  clear_has_Type();
  _cached_size_ = 0;
}

Model::~Model() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Model)
  SharedDtor();
}

void Model::SharedDtor() {
  if (this != internal_default_instance()) {
    delete description_;
  }
  if (has_Type()) {
    clear_Type();
  }
}

void Model::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Model& Model::default_instance() {
  protobuf_Model_2eproto::InitDefaults();
  return *internal_default_instance();
}

Model* Model::New(::google::protobuf::Arena* arena) const {
  Model* n = new Model;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Model::clear_Type() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.Model)
  switch (Type_case()) {
    case kPipelineClassifier: {
      delete Type_.pipelineclassifier_;
      break;
    }
    case kPipelineRegressor: {
      delete Type_.pipelineregressor_;
      break;
    }
    case kPipeline: {
      delete Type_.pipeline_;
      break;
    }
    case kGlmRegressor: {
      delete Type_.glmregressor_;
      break;
    }
    case kSupportVectorRegressor: {
      delete Type_.supportvectorregressor_;
      break;
    }
    case kTreeEnsembleRegressor: {
      delete Type_.treeensembleregressor_;
      break;
    }
    case kNeuralNetworkRegressor: {
      delete Type_.neuralnetworkregressor_;
      break;
    }
    case kBayesianProbitRegressor: {
      delete Type_.bayesianprobitregressor_;
      break;
    }
    case kGlmClassifier: {
      delete Type_.glmclassifier_;
      break;
    }
    case kSupportVectorClassifier: {
      delete Type_.supportvectorclassifier_;
      break;
    }
    case kTreeEnsembleClassifier: {
      delete Type_.treeensembleclassifier_;
      break;
    }
    case kNeuralNetworkClassifier: {
      delete Type_.neuralnetworkclassifier_;
      break;
    }
    case kNeuralNetwork: {
      delete Type_.neuralnetwork_;
      break;
    }
    case kCustomModel: {
      delete Type_.custommodel_;
      break;
    }
    case kOneHotEncoder: {
      delete Type_.onehotencoder_;
      break;
    }
    case kImputer: {
      delete Type_.imputer_;
      break;
    }
    case kFeatureVectorizer: {
      delete Type_.featurevectorizer_;
      break;
    }
    case kDictVectorizer: {
      delete Type_.dictvectorizer_;
      break;
    }
    case kScaler: {
      delete Type_.scaler_;
      break;
    }
    case kCategoricalMapping: {
      delete Type_.categoricalmapping_;
      break;
    }
    case kNormalizer: {
      delete Type_.normalizer_;
      break;
    }
    case kArrayFeatureExtractor: {
      delete Type_.arrayfeatureextractor_;
      break;
    }
    case kNonMaximumSuppression: {
      delete Type_.nonmaximumsuppression_;
      break;
    }
    case kIdentity: {
      delete Type_.identity_;
      break;
    }
    case kTextClassifier: {
      delete Type_.textclassifier_;
      break;
    }
    case kWordTagger: {
      delete Type_.wordtagger_;
      break;
    }
    case kVisionFeaturePrint: {
      delete Type_.visionfeatureprint_;
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TYPE_NOT_SET;
}


void Model::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Model)
  if (GetArenaNoVirtual() == NULL && description_ != NULL) {
    delete description_;
  }
  description_ = NULL;
  specificationversion_ = 0;
  clear_Type();
}

bool Model::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.Model)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int32 specificationVersion = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &specificationversion_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.ModelDescription description = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_description()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.PipelineClassifier pipelineClassifier = 200;
      case 200: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(1602u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pipelineclassifier()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.PipelineRegressor pipelineRegressor = 201;
      case 201: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(1610u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pipelineregressor()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.Pipeline pipeline = 202;
      case 202: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(1618u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pipeline()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.GLMRegressor glmRegressor = 300;
      case 300: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(2402u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_glmregressor()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.SupportVectorRegressor supportVectorRegressor = 301;
      case 301: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(2410u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_supportvectorregressor()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.TreeEnsembleRegressor treeEnsembleRegressor = 302;
      case 302: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(2418u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_treeensembleregressor()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.NeuralNetworkRegressor neuralNetworkRegressor = 303;
      case 303: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(2426u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_neuralnetworkregressor()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.BayesianProbitRegressor bayesianProbitRegressor = 304;
      case 304: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(2434u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bayesianprobitregressor()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.GLMClassifier glmClassifier = 400;
      case 400: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(3202u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_glmclassifier()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.SupportVectorClassifier supportVectorClassifier = 401;
      case 401: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(3210u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_supportvectorclassifier()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.TreeEnsembleClassifier treeEnsembleClassifier = 402;
      case 402: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(3218u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_treeensembleclassifier()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.NeuralNetworkClassifier neuralNetworkClassifier = 403;
      case 403: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(3226u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_neuralnetworkclassifier()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.NeuralNetwork neuralNetwork = 500;
      case 500: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(4002u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_neuralnetwork()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.CustomModel customModel = 555;
      case 555: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(4442u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_custommodel()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.OneHotEncoder oneHotEncoder = 600;
      case 600: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(4802u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_onehotencoder()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.Imputer imputer = 601;
      case 601: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(4810u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_imputer()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.FeatureVectorizer featureVectorizer = 602;
      case 602: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(4818u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_featurevectorizer()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.DictVectorizer dictVectorizer = 603;
      case 603: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(4826u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dictvectorizer()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.Scaler scaler = 604;
      case 604: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(4834u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scaler()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.CategoricalMapping categoricalMapping = 606;
      case 606: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(4850u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_categoricalmapping()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.Normalizer normalizer = 607;
      case 607: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(4858u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_normalizer()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.ArrayFeatureExtractor arrayFeatureExtractor = 609;
      case 609: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(4874u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_arrayfeatureextractor()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.NonMaximumSuppression nonMaximumSuppression = 610;
      case 610: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(4882u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_nonmaximumsuppression()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.Identity identity = 900;
      case 900: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(7202u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_identity()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.CoreMLModels.TextClassifier textClassifier = 2000;
      case 2000: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16002u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_textclassifier()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.CoreMLModels.WordTagger wordTagger = 2001;
      case 2001: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16010u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_wordtagger()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.CoreMLModels.VisionFeaturePrint visionFeaturePrint = 2002;
      case 2002: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16018u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_visionfeatureprint()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.Model)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.Model)
  return false;
#undef DO_
}

void Model::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.Model)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 specificationVersion = 1;
  if (this->specificationversion() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->specificationversion(), output);
  }

  // .CoreML.Specification.ModelDescription description = 2;
  if (this->has_description()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->description_, output);
  }

  // .CoreML.Specification.PipelineClassifier pipelineClassifier = 200;
  if (has_pipelineclassifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      200, *Type_.pipelineclassifier_, output);
  }

  // .CoreML.Specification.PipelineRegressor pipelineRegressor = 201;
  if (has_pipelineregressor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      201, *Type_.pipelineregressor_, output);
  }

  // .CoreML.Specification.Pipeline pipeline = 202;
  if (has_pipeline()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      202, *Type_.pipeline_, output);
  }

  // .CoreML.Specification.GLMRegressor glmRegressor = 300;
  if (has_glmregressor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      300, *Type_.glmregressor_, output);
  }

  // .CoreML.Specification.SupportVectorRegressor supportVectorRegressor = 301;
  if (has_supportvectorregressor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      301, *Type_.supportvectorregressor_, output);
  }

  // .CoreML.Specification.TreeEnsembleRegressor treeEnsembleRegressor = 302;
  if (has_treeensembleregressor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      302, *Type_.treeensembleregressor_, output);
  }

  // .CoreML.Specification.NeuralNetworkRegressor neuralNetworkRegressor = 303;
  if (has_neuralnetworkregressor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      303, *Type_.neuralnetworkregressor_, output);
  }

  // .CoreML.Specification.BayesianProbitRegressor bayesianProbitRegressor = 304;
  if (has_bayesianprobitregressor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      304, *Type_.bayesianprobitregressor_, output);
  }

  // .CoreML.Specification.GLMClassifier glmClassifier = 400;
  if (has_glmclassifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      400, *Type_.glmclassifier_, output);
  }

  // .CoreML.Specification.SupportVectorClassifier supportVectorClassifier = 401;
  if (has_supportvectorclassifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      401, *Type_.supportvectorclassifier_, output);
  }

  // .CoreML.Specification.TreeEnsembleClassifier treeEnsembleClassifier = 402;
  if (has_treeensembleclassifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      402, *Type_.treeensembleclassifier_, output);
  }

  // .CoreML.Specification.NeuralNetworkClassifier neuralNetworkClassifier = 403;
  if (has_neuralnetworkclassifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      403, *Type_.neuralnetworkclassifier_, output);
  }

  // .CoreML.Specification.NeuralNetwork neuralNetwork = 500;
  if (has_neuralnetwork()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      500, *Type_.neuralnetwork_, output);
  }

  // .CoreML.Specification.CustomModel customModel = 555;
  if (has_custommodel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      555, *Type_.custommodel_, output);
  }

  // .CoreML.Specification.OneHotEncoder oneHotEncoder = 600;
  if (has_onehotencoder()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      600, *Type_.onehotencoder_, output);
  }

  // .CoreML.Specification.Imputer imputer = 601;
  if (has_imputer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      601, *Type_.imputer_, output);
  }

  // .CoreML.Specification.FeatureVectorizer featureVectorizer = 602;
  if (has_featurevectorizer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      602, *Type_.featurevectorizer_, output);
  }

  // .CoreML.Specification.DictVectorizer dictVectorizer = 603;
  if (has_dictvectorizer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      603, *Type_.dictvectorizer_, output);
  }

  // .CoreML.Specification.Scaler scaler = 604;
  if (has_scaler()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      604, *Type_.scaler_, output);
  }

  // .CoreML.Specification.CategoricalMapping categoricalMapping = 606;
  if (has_categoricalmapping()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      606, *Type_.categoricalmapping_, output);
  }

  // .CoreML.Specification.Normalizer normalizer = 607;
  if (has_normalizer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      607, *Type_.normalizer_, output);
  }

  // .CoreML.Specification.ArrayFeatureExtractor arrayFeatureExtractor = 609;
  if (has_arrayfeatureextractor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      609, *Type_.arrayfeatureextractor_, output);
  }

  // .CoreML.Specification.NonMaximumSuppression nonMaximumSuppression = 610;
  if (has_nonmaximumsuppression()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      610, *Type_.nonmaximumsuppression_, output);
  }

  // .CoreML.Specification.Identity identity = 900;
  if (has_identity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      900, *Type_.identity_, output);
  }

  // .CoreML.Specification.CoreMLModels.TextClassifier textClassifier = 2000;
  if (has_textclassifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2000, *Type_.textclassifier_, output);
  }

  // .CoreML.Specification.CoreMLModels.WordTagger wordTagger = 2001;
  if (has_wordtagger()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2001, *Type_.wordtagger_, output);
  }

  // .CoreML.Specification.CoreMLModels.VisionFeaturePrint visionFeaturePrint = 2002;
  if (has_visionfeatureprint()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2002, *Type_.visionfeatureprint_, output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.Model)
}

size_t Model::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Model)
  size_t total_size = 0;

  // .CoreML.Specification.ModelDescription description = 2;
  if (this->has_description()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->description_);
  }

  // int32 specificationVersion = 1;
  if (this->specificationversion() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->specificationversion());
  }

  switch (Type_case()) {
    // .CoreML.Specification.PipelineClassifier pipelineClassifier = 200;
    case kPipelineClassifier: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.pipelineclassifier_);
      break;
    }
    // .CoreML.Specification.PipelineRegressor pipelineRegressor = 201;
    case kPipelineRegressor: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.pipelineregressor_);
      break;
    }
    // .CoreML.Specification.Pipeline pipeline = 202;
    case kPipeline: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.pipeline_);
      break;
    }
    // .CoreML.Specification.GLMRegressor glmRegressor = 300;
    case kGlmRegressor: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.glmregressor_);
      break;
    }
    // .CoreML.Specification.SupportVectorRegressor supportVectorRegressor = 301;
    case kSupportVectorRegressor: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.supportvectorregressor_);
      break;
    }
    // .CoreML.Specification.TreeEnsembleRegressor treeEnsembleRegressor = 302;
    case kTreeEnsembleRegressor: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.treeensembleregressor_);
      break;
    }
    // .CoreML.Specification.NeuralNetworkRegressor neuralNetworkRegressor = 303;
    case kNeuralNetworkRegressor: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.neuralnetworkregressor_);
      break;
    }
    // .CoreML.Specification.BayesianProbitRegressor bayesianProbitRegressor = 304;
    case kBayesianProbitRegressor: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.bayesianprobitregressor_);
      break;
    }
    // .CoreML.Specification.GLMClassifier glmClassifier = 400;
    case kGlmClassifier: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.glmclassifier_);
      break;
    }
    // .CoreML.Specification.SupportVectorClassifier supportVectorClassifier = 401;
    case kSupportVectorClassifier: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.supportvectorclassifier_);
      break;
    }
    // .CoreML.Specification.TreeEnsembleClassifier treeEnsembleClassifier = 402;
    case kTreeEnsembleClassifier: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.treeensembleclassifier_);
      break;
    }
    // .CoreML.Specification.NeuralNetworkClassifier neuralNetworkClassifier = 403;
    case kNeuralNetworkClassifier: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.neuralnetworkclassifier_);
      break;
    }
    // .CoreML.Specification.NeuralNetwork neuralNetwork = 500;
    case kNeuralNetwork: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.neuralnetwork_);
      break;
    }
    // .CoreML.Specification.CustomModel customModel = 555;
    case kCustomModel: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.custommodel_);
      break;
    }
    // .CoreML.Specification.OneHotEncoder oneHotEncoder = 600;
    case kOneHotEncoder: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.onehotencoder_);
      break;
    }
    // .CoreML.Specification.Imputer imputer = 601;
    case kImputer: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.imputer_);
      break;
    }
    // .CoreML.Specification.FeatureVectorizer featureVectorizer = 602;
    case kFeatureVectorizer: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.featurevectorizer_);
      break;
    }
    // .CoreML.Specification.DictVectorizer dictVectorizer = 603;
    case kDictVectorizer: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.dictvectorizer_);
      break;
    }
    // .CoreML.Specification.Scaler scaler = 604;
    case kScaler: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.scaler_);
      break;
    }
    // .CoreML.Specification.CategoricalMapping categoricalMapping = 606;
    case kCategoricalMapping: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.categoricalmapping_);
      break;
    }
    // .CoreML.Specification.Normalizer normalizer = 607;
    case kNormalizer: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.normalizer_);
      break;
    }
    // .CoreML.Specification.ArrayFeatureExtractor arrayFeatureExtractor = 609;
    case kArrayFeatureExtractor: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.arrayfeatureextractor_);
      break;
    }
    // .CoreML.Specification.NonMaximumSuppression nonMaximumSuppression = 610;
    case kNonMaximumSuppression: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.nonmaximumsuppression_);
      break;
    }
    // .CoreML.Specification.Identity identity = 900;
    case kIdentity: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.identity_);
      break;
    }
    // .CoreML.Specification.CoreMLModels.TextClassifier textClassifier = 2000;
    case kTextClassifier: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.textclassifier_);
      break;
    }
    // .CoreML.Specification.CoreMLModels.WordTagger wordTagger = 2001;
    case kWordTagger: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.wordtagger_);
      break;
    }
    // .CoreML.Specification.CoreMLModels.VisionFeaturePrint visionFeaturePrint = 2002;
    case kVisionFeaturePrint: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.visionfeatureprint_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Model::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Model*>(&from));
}

void Model::MergeFrom(const Model& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Model)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_description()) {
    mutable_description()->::CoreML::Specification::ModelDescription::MergeFrom(from.description());
  }
  if (from.specificationversion() != 0) {
    set_specificationversion(from.specificationversion());
  }
  switch (from.Type_case()) {
    case kPipelineClassifier: {
      mutable_pipelineclassifier()->::CoreML::Specification::PipelineClassifier::MergeFrom(from.pipelineclassifier());
      break;
    }
    case kPipelineRegressor: {
      mutable_pipelineregressor()->::CoreML::Specification::PipelineRegressor::MergeFrom(from.pipelineregressor());
      break;
    }
    case kPipeline: {
      mutable_pipeline()->::CoreML::Specification::Pipeline::MergeFrom(from.pipeline());
      break;
    }
    case kGlmRegressor: {
      mutable_glmregressor()->::CoreML::Specification::GLMRegressor::MergeFrom(from.glmregressor());
      break;
    }
    case kSupportVectorRegressor: {
      mutable_supportvectorregressor()->::CoreML::Specification::SupportVectorRegressor::MergeFrom(from.supportvectorregressor());
      break;
    }
    case kTreeEnsembleRegressor: {
      mutable_treeensembleregressor()->::CoreML::Specification::TreeEnsembleRegressor::MergeFrom(from.treeensembleregressor());
      break;
    }
    case kNeuralNetworkRegressor: {
      mutable_neuralnetworkregressor()->::CoreML::Specification::NeuralNetworkRegressor::MergeFrom(from.neuralnetworkregressor());
      break;
    }
    case kBayesianProbitRegressor: {
      mutable_bayesianprobitregressor()->::CoreML::Specification::BayesianProbitRegressor::MergeFrom(from.bayesianprobitregressor());
      break;
    }
    case kGlmClassifier: {
      mutable_glmclassifier()->::CoreML::Specification::GLMClassifier::MergeFrom(from.glmclassifier());
      break;
    }
    case kSupportVectorClassifier: {
      mutable_supportvectorclassifier()->::CoreML::Specification::SupportVectorClassifier::MergeFrom(from.supportvectorclassifier());
      break;
    }
    case kTreeEnsembleClassifier: {
      mutable_treeensembleclassifier()->::CoreML::Specification::TreeEnsembleClassifier::MergeFrom(from.treeensembleclassifier());
      break;
    }
    case kNeuralNetworkClassifier: {
      mutable_neuralnetworkclassifier()->::CoreML::Specification::NeuralNetworkClassifier::MergeFrom(from.neuralnetworkclassifier());
      break;
    }
    case kNeuralNetwork: {
      mutable_neuralnetwork()->::CoreML::Specification::NeuralNetwork::MergeFrom(from.neuralnetwork());
      break;
    }
    case kCustomModel: {
      mutable_custommodel()->::CoreML::Specification::CustomModel::MergeFrom(from.custommodel());
      break;
    }
    case kOneHotEncoder: {
      mutable_onehotencoder()->::CoreML::Specification::OneHotEncoder::MergeFrom(from.onehotencoder());
      break;
    }
    case kImputer: {
      mutable_imputer()->::CoreML::Specification::Imputer::MergeFrom(from.imputer());
      break;
    }
    case kFeatureVectorizer: {
      mutable_featurevectorizer()->::CoreML::Specification::FeatureVectorizer::MergeFrom(from.featurevectorizer());
      break;
    }
    case kDictVectorizer: {
      mutable_dictvectorizer()->::CoreML::Specification::DictVectorizer::MergeFrom(from.dictvectorizer());
      break;
    }
    case kScaler: {
      mutable_scaler()->::CoreML::Specification::Scaler::MergeFrom(from.scaler());
      break;
    }
    case kCategoricalMapping: {
      mutable_categoricalmapping()->::CoreML::Specification::CategoricalMapping::MergeFrom(from.categoricalmapping());
      break;
    }
    case kNormalizer: {
      mutable_normalizer()->::CoreML::Specification::Normalizer::MergeFrom(from.normalizer());
      break;
    }
    case kArrayFeatureExtractor: {
      mutable_arrayfeatureextractor()->::CoreML::Specification::ArrayFeatureExtractor::MergeFrom(from.arrayfeatureextractor());
      break;
    }
    case kNonMaximumSuppression: {
      mutable_nonmaximumsuppression()->::CoreML::Specification::NonMaximumSuppression::MergeFrom(from.nonmaximumsuppression());
      break;
    }
    case kIdentity: {
      mutable_identity()->::CoreML::Specification::Identity::MergeFrom(from.identity());
      break;
    }
    case kTextClassifier: {
      mutable_textclassifier()->::CoreML::Specification::CoreMLModels::TextClassifier::MergeFrom(from.textclassifier());
      break;
    }
    case kWordTagger: {
      mutable_wordtagger()->::CoreML::Specification::CoreMLModels::WordTagger::MergeFrom(from.wordtagger());
      break;
    }
    case kVisionFeaturePrint: {
      mutable_visionfeatureprint()->::CoreML::Specification::CoreMLModels::VisionFeaturePrint::MergeFrom(from.visionfeatureprint());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
}

void Model::CopyFrom(const Model& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Model)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Model::IsInitialized() const {
  return true;
}

void Model::Swap(Model* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Model::InternalSwap(Model* other) {
  std::swap(description_, other->description_);
  std::swap(specificationversion_, other->specificationversion_);
  std::swap(Type_, other->Type_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Model::GetTypeName() const {
  return "CoreML.Specification.Model";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Model

// int32 specificationVersion = 1;
void Model::clear_specificationversion() {
  specificationversion_ = 0;
}
::google::protobuf::int32 Model::specificationversion() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.specificationVersion)
  return specificationversion_;
}
void Model::set_specificationversion(::google::protobuf::int32 value) {
  
  specificationversion_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.Model.specificationVersion)
}

// .CoreML.Specification.ModelDescription description = 2;
bool Model::has_description() const {
  return this != internal_default_instance() && description_ != NULL;
}
void Model::clear_description() {
  if (GetArenaNoVirtual() == NULL && description_ != NULL) delete description_;
  description_ = NULL;
}
const ::CoreML::Specification::ModelDescription& Model::description() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.description)
  return description_ != NULL ? *description_
                         : *::CoreML::Specification::ModelDescription::internal_default_instance();
}
::CoreML::Specification::ModelDescription* Model::mutable_description() {
  
  if (description_ == NULL) {
    description_ = new ::CoreML::Specification::ModelDescription;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.description)
  return description_;
}
::CoreML::Specification::ModelDescription* Model::release_description() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.description)
  
  ::CoreML::Specification::ModelDescription* temp = description_;
  description_ = NULL;
  return temp;
}
void Model::set_allocated_description(::CoreML::Specification::ModelDescription* description) {
  delete description_;
  description_ = description;
  if (description) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.description)
}

// .CoreML.Specification.PipelineClassifier pipelineClassifier = 200;
bool Model::has_pipelineclassifier() const {
  return Type_case() == kPipelineClassifier;
}
void Model::set_has_pipelineclassifier() {
  _oneof_case_[0] = kPipelineClassifier;
}
void Model::clear_pipelineclassifier() {
  if (has_pipelineclassifier()) {
    delete Type_.pipelineclassifier_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::PipelineClassifier& Model::pipelineclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.pipelineClassifier)
  return has_pipelineclassifier()
      ? *Type_.pipelineclassifier_
      : ::CoreML::Specification::PipelineClassifier::default_instance();
}
::CoreML::Specification::PipelineClassifier* Model::mutable_pipelineclassifier() {
  if (!has_pipelineclassifier()) {
    clear_Type();
    set_has_pipelineclassifier();
    Type_.pipelineclassifier_ = new ::CoreML::Specification::PipelineClassifier;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.pipelineClassifier)
  return Type_.pipelineclassifier_;
}
::CoreML::Specification::PipelineClassifier* Model::release_pipelineclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.pipelineClassifier)
  if (has_pipelineclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::PipelineClassifier* temp = Type_.pipelineclassifier_;
    Type_.pipelineclassifier_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_pipelineclassifier(::CoreML::Specification::PipelineClassifier* pipelineclassifier) {
  clear_Type();
  if (pipelineclassifier) {
    set_has_pipelineclassifier();
    Type_.pipelineclassifier_ = pipelineclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.pipelineClassifier)
}

// .CoreML.Specification.PipelineRegressor pipelineRegressor = 201;
bool Model::has_pipelineregressor() const {
  return Type_case() == kPipelineRegressor;
}
void Model::set_has_pipelineregressor() {
  _oneof_case_[0] = kPipelineRegressor;
}
void Model::clear_pipelineregressor() {
  if (has_pipelineregressor()) {
    delete Type_.pipelineregressor_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::PipelineRegressor& Model::pipelineregressor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.pipelineRegressor)
  return has_pipelineregressor()
      ? *Type_.pipelineregressor_
      : ::CoreML::Specification::PipelineRegressor::default_instance();
}
::CoreML::Specification::PipelineRegressor* Model::mutable_pipelineregressor() {
  if (!has_pipelineregressor()) {
    clear_Type();
    set_has_pipelineregressor();
    Type_.pipelineregressor_ = new ::CoreML::Specification::PipelineRegressor;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.pipelineRegressor)
  return Type_.pipelineregressor_;
}
::CoreML::Specification::PipelineRegressor* Model::release_pipelineregressor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.pipelineRegressor)
  if (has_pipelineregressor()) {
    clear_has_Type();
    ::CoreML::Specification::PipelineRegressor* temp = Type_.pipelineregressor_;
    Type_.pipelineregressor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_pipelineregressor(::CoreML::Specification::PipelineRegressor* pipelineregressor) {
  clear_Type();
  if (pipelineregressor) {
    set_has_pipelineregressor();
    Type_.pipelineregressor_ = pipelineregressor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.pipelineRegressor)
}

// .CoreML.Specification.Pipeline pipeline = 202;
bool Model::has_pipeline() const {
  return Type_case() == kPipeline;
}
void Model::set_has_pipeline() {
  _oneof_case_[0] = kPipeline;
}
void Model::clear_pipeline() {
  if (has_pipeline()) {
    delete Type_.pipeline_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::Pipeline& Model::pipeline() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.pipeline)
  return has_pipeline()
      ? *Type_.pipeline_
      : ::CoreML::Specification::Pipeline::default_instance();
}
::CoreML::Specification::Pipeline* Model::mutable_pipeline() {
  if (!has_pipeline()) {
    clear_Type();
    set_has_pipeline();
    Type_.pipeline_ = new ::CoreML::Specification::Pipeline;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.pipeline)
  return Type_.pipeline_;
}
::CoreML::Specification::Pipeline* Model::release_pipeline() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.pipeline)
  if (has_pipeline()) {
    clear_has_Type();
    ::CoreML::Specification::Pipeline* temp = Type_.pipeline_;
    Type_.pipeline_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_pipeline(::CoreML::Specification::Pipeline* pipeline) {
  clear_Type();
  if (pipeline) {
    set_has_pipeline();
    Type_.pipeline_ = pipeline;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.pipeline)
}

// .CoreML.Specification.GLMRegressor glmRegressor = 300;
bool Model::has_glmregressor() const {
  return Type_case() == kGlmRegressor;
}
void Model::set_has_glmregressor() {
  _oneof_case_[0] = kGlmRegressor;
}
void Model::clear_glmregressor() {
  if (has_glmregressor()) {
    delete Type_.glmregressor_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::GLMRegressor& Model::glmregressor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.glmRegressor)
  return has_glmregressor()
      ? *Type_.glmregressor_
      : ::CoreML::Specification::GLMRegressor::default_instance();
}
::CoreML::Specification::GLMRegressor* Model::mutable_glmregressor() {
  if (!has_glmregressor()) {
    clear_Type();
    set_has_glmregressor();
    Type_.glmregressor_ = new ::CoreML::Specification::GLMRegressor;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.glmRegressor)
  return Type_.glmregressor_;
}
::CoreML::Specification::GLMRegressor* Model::release_glmregressor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.glmRegressor)
  if (has_glmregressor()) {
    clear_has_Type();
    ::CoreML::Specification::GLMRegressor* temp = Type_.glmregressor_;
    Type_.glmregressor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_glmregressor(::CoreML::Specification::GLMRegressor* glmregressor) {
  clear_Type();
  if (glmregressor) {
    set_has_glmregressor();
    Type_.glmregressor_ = glmregressor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.glmRegressor)
}

// .CoreML.Specification.SupportVectorRegressor supportVectorRegressor = 301;
bool Model::has_supportvectorregressor() const {
  return Type_case() == kSupportVectorRegressor;
}
void Model::set_has_supportvectorregressor() {
  _oneof_case_[0] = kSupportVectorRegressor;
}
void Model::clear_supportvectorregressor() {
  if (has_supportvectorregressor()) {
    delete Type_.supportvectorregressor_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::SupportVectorRegressor& Model::supportvectorregressor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.supportVectorRegressor)
  return has_supportvectorregressor()
      ? *Type_.supportvectorregressor_
      : ::CoreML::Specification::SupportVectorRegressor::default_instance();
}
::CoreML::Specification::SupportVectorRegressor* Model::mutable_supportvectorregressor() {
  if (!has_supportvectorregressor()) {
    clear_Type();
    set_has_supportvectorregressor();
    Type_.supportvectorregressor_ = new ::CoreML::Specification::SupportVectorRegressor;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.supportVectorRegressor)
  return Type_.supportvectorregressor_;
}
::CoreML::Specification::SupportVectorRegressor* Model::release_supportvectorregressor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.supportVectorRegressor)
  if (has_supportvectorregressor()) {
    clear_has_Type();
    ::CoreML::Specification::SupportVectorRegressor* temp = Type_.supportvectorregressor_;
    Type_.supportvectorregressor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_supportvectorregressor(::CoreML::Specification::SupportVectorRegressor* supportvectorregressor) {
  clear_Type();
  if (supportvectorregressor) {
    set_has_supportvectorregressor();
    Type_.supportvectorregressor_ = supportvectorregressor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.supportVectorRegressor)
}

// .CoreML.Specification.TreeEnsembleRegressor treeEnsembleRegressor = 302;
bool Model::has_treeensembleregressor() const {
  return Type_case() == kTreeEnsembleRegressor;
}
void Model::set_has_treeensembleregressor() {
  _oneof_case_[0] = kTreeEnsembleRegressor;
}
void Model::clear_treeensembleregressor() {
  if (has_treeensembleregressor()) {
    delete Type_.treeensembleregressor_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::TreeEnsembleRegressor& Model::treeensembleregressor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.treeEnsembleRegressor)
  return has_treeensembleregressor()
      ? *Type_.treeensembleregressor_
      : ::CoreML::Specification::TreeEnsembleRegressor::default_instance();
}
::CoreML::Specification::TreeEnsembleRegressor* Model::mutable_treeensembleregressor() {
  if (!has_treeensembleregressor()) {
    clear_Type();
    set_has_treeensembleregressor();
    Type_.treeensembleregressor_ = new ::CoreML::Specification::TreeEnsembleRegressor;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.treeEnsembleRegressor)
  return Type_.treeensembleregressor_;
}
::CoreML::Specification::TreeEnsembleRegressor* Model::release_treeensembleregressor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.treeEnsembleRegressor)
  if (has_treeensembleregressor()) {
    clear_has_Type();
    ::CoreML::Specification::TreeEnsembleRegressor* temp = Type_.treeensembleregressor_;
    Type_.treeensembleregressor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_treeensembleregressor(::CoreML::Specification::TreeEnsembleRegressor* treeensembleregressor) {
  clear_Type();
  if (treeensembleregressor) {
    set_has_treeensembleregressor();
    Type_.treeensembleregressor_ = treeensembleregressor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.treeEnsembleRegressor)
}

// .CoreML.Specification.NeuralNetworkRegressor neuralNetworkRegressor = 303;
bool Model::has_neuralnetworkregressor() const {
  return Type_case() == kNeuralNetworkRegressor;
}
void Model::set_has_neuralnetworkregressor() {
  _oneof_case_[0] = kNeuralNetworkRegressor;
}
void Model::clear_neuralnetworkregressor() {
  if (has_neuralnetworkregressor()) {
    delete Type_.neuralnetworkregressor_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::NeuralNetworkRegressor& Model::neuralnetworkregressor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.neuralNetworkRegressor)
  return has_neuralnetworkregressor()
      ? *Type_.neuralnetworkregressor_
      : ::CoreML::Specification::NeuralNetworkRegressor::default_instance();
}
::CoreML::Specification::NeuralNetworkRegressor* Model::mutable_neuralnetworkregressor() {
  if (!has_neuralnetworkregressor()) {
    clear_Type();
    set_has_neuralnetworkregressor();
    Type_.neuralnetworkregressor_ = new ::CoreML::Specification::NeuralNetworkRegressor;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.neuralNetworkRegressor)
  return Type_.neuralnetworkregressor_;
}
::CoreML::Specification::NeuralNetworkRegressor* Model::release_neuralnetworkregressor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.neuralNetworkRegressor)
  if (has_neuralnetworkregressor()) {
    clear_has_Type();
    ::CoreML::Specification::NeuralNetworkRegressor* temp = Type_.neuralnetworkregressor_;
    Type_.neuralnetworkregressor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_neuralnetworkregressor(::CoreML::Specification::NeuralNetworkRegressor* neuralnetworkregressor) {
  clear_Type();
  if (neuralnetworkregressor) {
    set_has_neuralnetworkregressor();
    Type_.neuralnetworkregressor_ = neuralnetworkregressor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.neuralNetworkRegressor)
}

// .CoreML.Specification.BayesianProbitRegressor bayesianProbitRegressor = 304;
bool Model::has_bayesianprobitregressor() const {
  return Type_case() == kBayesianProbitRegressor;
}
void Model::set_has_bayesianprobitregressor() {
  _oneof_case_[0] = kBayesianProbitRegressor;
}
void Model::clear_bayesianprobitregressor() {
  if (has_bayesianprobitregressor()) {
    delete Type_.bayesianprobitregressor_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::BayesianProbitRegressor& Model::bayesianprobitregressor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.bayesianProbitRegressor)
  return has_bayesianprobitregressor()
      ? *Type_.bayesianprobitregressor_
      : ::CoreML::Specification::BayesianProbitRegressor::default_instance();
}
::CoreML::Specification::BayesianProbitRegressor* Model::mutable_bayesianprobitregressor() {
  if (!has_bayesianprobitregressor()) {
    clear_Type();
    set_has_bayesianprobitregressor();
    Type_.bayesianprobitregressor_ = new ::CoreML::Specification::BayesianProbitRegressor;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.bayesianProbitRegressor)
  return Type_.bayesianprobitregressor_;
}
::CoreML::Specification::BayesianProbitRegressor* Model::release_bayesianprobitregressor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.bayesianProbitRegressor)
  if (has_bayesianprobitregressor()) {
    clear_has_Type();
    ::CoreML::Specification::BayesianProbitRegressor* temp = Type_.bayesianprobitregressor_;
    Type_.bayesianprobitregressor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_bayesianprobitregressor(::CoreML::Specification::BayesianProbitRegressor* bayesianprobitregressor) {
  clear_Type();
  if (bayesianprobitregressor) {
    set_has_bayesianprobitregressor();
    Type_.bayesianprobitregressor_ = bayesianprobitregressor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.bayesianProbitRegressor)
}

// .CoreML.Specification.GLMClassifier glmClassifier = 400;
bool Model::has_glmclassifier() const {
  return Type_case() == kGlmClassifier;
}
void Model::set_has_glmclassifier() {
  _oneof_case_[0] = kGlmClassifier;
}
void Model::clear_glmclassifier() {
  if (has_glmclassifier()) {
    delete Type_.glmclassifier_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::GLMClassifier& Model::glmclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.glmClassifier)
  return has_glmclassifier()
      ? *Type_.glmclassifier_
      : ::CoreML::Specification::GLMClassifier::default_instance();
}
::CoreML::Specification::GLMClassifier* Model::mutable_glmclassifier() {
  if (!has_glmclassifier()) {
    clear_Type();
    set_has_glmclassifier();
    Type_.glmclassifier_ = new ::CoreML::Specification::GLMClassifier;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.glmClassifier)
  return Type_.glmclassifier_;
}
::CoreML::Specification::GLMClassifier* Model::release_glmclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.glmClassifier)
  if (has_glmclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::GLMClassifier* temp = Type_.glmclassifier_;
    Type_.glmclassifier_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_glmclassifier(::CoreML::Specification::GLMClassifier* glmclassifier) {
  clear_Type();
  if (glmclassifier) {
    set_has_glmclassifier();
    Type_.glmclassifier_ = glmclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.glmClassifier)
}

// .CoreML.Specification.SupportVectorClassifier supportVectorClassifier = 401;
bool Model::has_supportvectorclassifier() const {
  return Type_case() == kSupportVectorClassifier;
}
void Model::set_has_supportvectorclassifier() {
  _oneof_case_[0] = kSupportVectorClassifier;
}
void Model::clear_supportvectorclassifier() {
  if (has_supportvectorclassifier()) {
    delete Type_.supportvectorclassifier_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::SupportVectorClassifier& Model::supportvectorclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.supportVectorClassifier)
  return has_supportvectorclassifier()
      ? *Type_.supportvectorclassifier_
      : ::CoreML::Specification::SupportVectorClassifier::default_instance();
}
::CoreML::Specification::SupportVectorClassifier* Model::mutable_supportvectorclassifier() {
  if (!has_supportvectorclassifier()) {
    clear_Type();
    set_has_supportvectorclassifier();
    Type_.supportvectorclassifier_ = new ::CoreML::Specification::SupportVectorClassifier;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.supportVectorClassifier)
  return Type_.supportvectorclassifier_;
}
::CoreML::Specification::SupportVectorClassifier* Model::release_supportvectorclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.supportVectorClassifier)
  if (has_supportvectorclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::SupportVectorClassifier* temp = Type_.supportvectorclassifier_;
    Type_.supportvectorclassifier_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_supportvectorclassifier(::CoreML::Specification::SupportVectorClassifier* supportvectorclassifier) {
  clear_Type();
  if (supportvectorclassifier) {
    set_has_supportvectorclassifier();
    Type_.supportvectorclassifier_ = supportvectorclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.supportVectorClassifier)
}

// .CoreML.Specification.TreeEnsembleClassifier treeEnsembleClassifier = 402;
bool Model::has_treeensembleclassifier() const {
  return Type_case() == kTreeEnsembleClassifier;
}
void Model::set_has_treeensembleclassifier() {
  _oneof_case_[0] = kTreeEnsembleClassifier;
}
void Model::clear_treeensembleclassifier() {
  if (has_treeensembleclassifier()) {
    delete Type_.treeensembleclassifier_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::TreeEnsembleClassifier& Model::treeensembleclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.treeEnsembleClassifier)
  return has_treeensembleclassifier()
      ? *Type_.treeensembleclassifier_
      : ::CoreML::Specification::TreeEnsembleClassifier::default_instance();
}
::CoreML::Specification::TreeEnsembleClassifier* Model::mutable_treeensembleclassifier() {
  if (!has_treeensembleclassifier()) {
    clear_Type();
    set_has_treeensembleclassifier();
    Type_.treeensembleclassifier_ = new ::CoreML::Specification::TreeEnsembleClassifier;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.treeEnsembleClassifier)
  return Type_.treeensembleclassifier_;
}
::CoreML::Specification::TreeEnsembleClassifier* Model::release_treeensembleclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.treeEnsembleClassifier)
  if (has_treeensembleclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::TreeEnsembleClassifier* temp = Type_.treeensembleclassifier_;
    Type_.treeensembleclassifier_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_treeensembleclassifier(::CoreML::Specification::TreeEnsembleClassifier* treeensembleclassifier) {
  clear_Type();
  if (treeensembleclassifier) {
    set_has_treeensembleclassifier();
    Type_.treeensembleclassifier_ = treeensembleclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.treeEnsembleClassifier)
}

// .CoreML.Specification.NeuralNetworkClassifier neuralNetworkClassifier = 403;
bool Model::has_neuralnetworkclassifier() const {
  return Type_case() == kNeuralNetworkClassifier;
}
void Model::set_has_neuralnetworkclassifier() {
  _oneof_case_[0] = kNeuralNetworkClassifier;
}
void Model::clear_neuralnetworkclassifier() {
  if (has_neuralnetworkclassifier()) {
    delete Type_.neuralnetworkclassifier_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::NeuralNetworkClassifier& Model::neuralnetworkclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.neuralNetworkClassifier)
  return has_neuralnetworkclassifier()
      ? *Type_.neuralnetworkclassifier_
      : ::CoreML::Specification::NeuralNetworkClassifier::default_instance();
}
::CoreML::Specification::NeuralNetworkClassifier* Model::mutable_neuralnetworkclassifier() {
  if (!has_neuralnetworkclassifier()) {
    clear_Type();
    set_has_neuralnetworkclassifier();
    Type_.neuralnetworkclassifier_ = new ::CoreML::Specification::NeuralNetworkClassifier;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.neuralNetworkClassifier)
  return Type_.neuralnetworkclassifier_;
}
::CoreML::Specification::NeuralNetworkClassifier* Model::release_neuralnetworkclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.neuralNetworkClassifier)
  if (has_neuralnetworkclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::NeuralNetworkClassifier* temp = Type_.neuralnetworkclassifier_;
    Type_.neuralnetworkclassifier_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_neuralnetworkclassifier(::CoreML::Specification::NeuralNetworkClassifier* neuralnetworkclassifier) {
  clear_Type();
  if (neuralnetworkclassifier) {
    set_has_neuralnetworkclassifier();
    Type_.neuralnetworkclassifier_ = neuralnetworkclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.neuralNetworkClassifier)
}

// .CoreML.Specification.NeuralNetwork neuralNetwork = 500;
bool Model::has_neuralnetwork() const {
  return Type_case() == kNeuralNetwork;
}
void Model::set_has_neuralnetwork() {
  _oneof_case_[0] = kNeuralNetwork;
}
void Model::clear_neuralnetwork() {
  if (has_neuralnetwork()) {
    delete Type_.neuralnetwork_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::NeuralNetwork& Model::neuralnetwork() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.neuralNetwork)
  return has_neuralnetwork()
      ? *Type_.neuralnetwork_
      : ::CoreML::Specification::NeuralNetwork::default_instance();
}
::CoreML::Specification::NeuralNetwork* Model::mutable_neuralnetwork() {
  if (!has_neuralnetwork()) {
    clear_Type();
    set_has_neuralnetwork();
    Type_.neuralnetwork_ = new ::CoreML::Specification::NeuralNetwork;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.neuralNetwork)
  return Type_.neuralnetwork_;
}
::CoreML::Specification::NeuralNetwork* Model::release_neuralnetwork() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.neuralNetwork)
  if (has_neuralnetwork()) {
    clear_has_Type();
    ::CoreML::Specification::NeuralNetwork* temp = Type_.neuralnetwork_;
    Type_.neuralnetwork_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_neuralnetwork(::CoreML::Specification::NeuralNetwork* neuralnetwork) {
  clear_Type();
  if (neuralnetwork) {
    set_has_neuralnetwork();
    Type_.neuralnetwork_ = neuralnetwork;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.neuralNetwork)
}

// .CoreML.Specification.CustomModel customModel = 555;
bool Model::has_custommodel() const {
  return Type_case() == kCustomModel;
}
void Model::set_has_custommodel() {
  _oneof_case_[0] = kCustomModel;
}
void Model::clear_custommodel() {
  if (has_custommodel()) {
    delete Type_.custommodel_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::CustomModel& Model::custommodel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.customModel)
  return has_custommodel()
      ? *Type_.custommodel_
      : ::CoreML::Specification::CustomModel::default_instance();
}
::CoreML::Specification::CustomModel* Model::mutable_custommodel() {
  if (!has_custommodel()) {
    clear_Type();
    set_has_custommodel();
    Type_.custommodel_ = new ::CoreML::Specification::CustomModel;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.customModel)
  return Type_.custommodel_;
}
::CoreML::Specification::CustomModel* Model::release_custommodel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.customModel)
  if (has_custommodel()) {
    clear_has_Type();
    ::CoreML::Specification::CustomModel* temp = Type_.custommodel_;
    Type_.custommodel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_custommodel(::CoreML::Specification::CustomModel* custommodel) {
  clear_Type();
  if (custommodel) {
    set_has_custommodel();
    Type_.custommodel_ = custommodel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.customModel)
}

// .CoreML.Specification.OneHotEncoder oneHotEncoder = 600;
bool Model::has_onehotencoder() const {
  return Type_case() == kOneHotEncoder;
}
void Model::set_has_onehotencoder() {
  _oneof_case_[0] = kOneHotEncoder;
}
void Model::clear_onehotencoder() {
  if (has_onehotencoder()) {
    delete Type_.onehotencoder_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::OneHotEncoder& Model::onehotencoder() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.oneHotEncoder)
  return has_onehotencoder()
      ? *Type_.onehotencoder_
      : ::CoreML::Specification::OneHotEncoder::default_instance();
}
::CoreML::Specification::OneHotEncoder* Model::mutable_onehotencoder() {
  if (!has_onehotencoder()) {
    clear_Type();
    set_has_onehotencoder();
    Type_.onehotencoder_ = new ::CoreML::Specification::OneHotEncoder;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.oneHotEncoder)
  return Type_.onehotencoder_;
}
::CoreML::Specification::OneHotEncoder* Model::release_onehotencoder() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.oneHotEncoder)
  if (has_onehotencoder()) {
    clear_has_Type();
    ::CoreML::Specification::OneHotEncoder* temp = Type_.onehotencoder_;
    Type_.onehotencoder_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_onehotencoder(::CoreML::Specification::OneHotEncoder* onehotencoder) {
  clear_Type();
  if (onehotencoder) {
    set_has_onehotencoder();
    Type_.onehotencoder_ = onehotencoder;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.oneHotEncoder)
}

// .CoreML.Specification.Imputer imputer = 601;
bool Model::has_imputer() const {
  return Type_case() == kImputer;
}
void Model::set_has_imputer() {
  _oneof_case_[0] = kImputer;
}
void Model::clear_imputer() {
  if (has_imputer()) {
    delete Type_.imputer_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::Imputer& Model::imputer() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.imputer)
  return has_imputer()
      ? *Type_.imputer_
      : ::CoreML::Specification::Imputer::default_instance();
}
::CoreML::Specification::Imputer* Model::mutable_imputer() {
  if (!has_imputer()) {
    clear_Type();
    set_has_imputer();
    Type_.imputer_ = new ::CoreML::Specification::Imputer;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.imputer)
  return Type_.imputer_;
}
::CoreML::Specification::Imputer* Model::release_imputer() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.imputer)
  if (has_imputer()) {
    clear_has_Type();
    ::CoreML::Specification::Imputer* temp = Type_.imputer_;
    Type_.imputer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_imputer(::CoreML::Specification::Imputer* imputer) {
  clear_Type();
  if (imputer) {
    set_has_imputer();
    Type_.imputer_ = imputer;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.imputer)
}

// .CoreML.Specification.FeatureVectorizer featureVectorizer = 602;
bool Model::has_featurevectorizer() const {
  return Type_case() == kFeatureVectorizer;
}
void Model::set_has_featurevectorizer() {
  _oneof_case_[0] = kFeatureVectorizer;
}
void Model::clear_featurevectorizer() {
  if (has_featurevectorizer()) {
    delete Type_.featurevectorizer_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::FeatureVectorizer& Model::featurevectorizer() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.featureVectorizer)
  return has_featurevectorizer()
      ? *Type_.featurevectorizer_
      : ::CoreML::Specification::FeatureVectorizer::default_instance();
}
::CoreML::Specification::FeatureVectorizer* Model::mutable_featurevectorizer() {
  if (!has_featurevectorizer()) {
    clear_Type();
    set_has_featurevectorizer();
    Type_.featurevectorizer_ = new ::CoreML::Specification::FeatureVectorizer;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.featureVectorizer)
  return Type_.featurevectorizer_;
}
::CoreML::Specification::FeatureVectorizer* Model::release_featurevectorizer() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.featureVectorizer)
  if (has_featurevectorizer()) {
    clear_has_Type();
    ::CoreML::Specification::FeatureVectorizer* temp = Type_.featurevectorizer_;
    Type_.featurevectorizer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_featurevectorizer(::CoreML::Specification::FeatureVectorizer* featurevectorizer) {
  clear_Type();
  if (featurevectorizer) {
    set_has_featurevectorizer();
    Type_.featurevectorizer_ = featurevectorizer;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.featureVectorizer)
}

// .CoreML.Specification.DictVectorizer dictVectorizer = 603;
bool Model::has_dictvectorizer() const {
  return Type_case() == kDictVectorizer;
}
void Model::set_has_dictvectorizer() {
  _oneof_case_[0] = kDictVectorizer;
}
void Model::clear_dictvectorizer() {
  if (has_dictvectorizer()) {
    delete Type_.dictvectorizer_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::DictVectorizer& Model::dictvectorizer() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.dictVectorizer)
  return has_dictvectorizer()
      ? *Type_.dictvectorizer_
      : ::CoreML::Specification::DictVectorizer::default_instance();
}
::CoreML::Specification::DictVectorizer* Model::mutable_dictvectorizer() {
  if (!has_dictvectorizer()) {
    clear_Type();
    set_has_dictvectorizer();
    Type_.dictvectorizer_ = new ::CoreML::Specification::DictVectorizer;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.dictVectorizer)
  return Type_.dictvectorizer_;
}
::CoreML::Specification::DictVectorizer* Model::release_dictvectorizer() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.dictVectorizer)
  if (has_dictvectorizer()) {
    clear_has_Type();
    ::CoreML::Specification::DictVectorizer* temp = Type_.dictvectorizer_;
    Type_.dictvectorizer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_dictvectorizer(::CoreML::Specification::DictVectorizer* dictvectorizer) {
  clear_Type();
  if (dictvectorizer) {
    set_has_dictvectorizer();
    Type_.dictvectorizer_ = dictvectorizer;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.dictVectorizer)
}

// .CoreML.Specification.Scaler scaler = 604;
bool Model::has_scaler() const {
  return Type_case() == kScaler;
}
void Model::set_has_scaler() {
  _oneof_case_[0] = kScaler;
}
void Model::clear_scaler() {
  if (has_scaler()) {
    delete Type_.scaler_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::Scaler& Model::scaler() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.scaler)
  return has_scaler()
      ? *Type_.scaler_
      : ::CoreML::Specification::Scaler::default_instance();
}
::CoreML::Specification::Scaler* Model::mutable_scaler() {
  if (!has_scaler()) {
    clear_Type();
    set_has_scaler();
    Type_.scaler_ = new ::CoreML::Specification::Scaler;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.scaler)
  return Type_.scaler_;
}
::CoreML::Specification::Scaler* Model::release_scaler() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.scaler)
  if (has_scaler()) {
    clear_has_Type();
    ::CoreML::Specification::Scaler* temp = Type_.scaler_;
    Type_.scaler_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_scaler(::CoreML::Specification::Scaler* scaler) {
  clear_Type();
  if (scaler) {
    set_has_scaler();
    Type_.scaler_ = scaler;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.scaler)
}

// .CoreML.Specification.CategoricalMapping categoricalMapping = 606;
bool Model::has_categoricalmapping() const {
  return Type_case() == kCategoricalMapping;
}
void Model::set_has_categoricalmapping() {
  _oneof_case_[0] = kCategoricalMapping;
}
void Model::clear_categoricalmapping() {
  if (has_categoricalmapping()) {
    delete Type_.categoricalmapping_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::CategoricalMapping& Model::categoricalmapping() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.categoricalMapping)
  return has_categoricalmapping()
      ? *Type_.categoricalmapping_
      : ::CoreML::Specification::CategoricalMapping::default_instance();
}
::CoreML::Specification::CategoricalMapping* Model::mutable_categoricalmapping() {
  if (!has_categoricalmapping()) {
    clear_Type();
    set_has_categoricalmapping();
    Type_.categoricalmapping_ = new ::CoreML::Specification::CategoricalMapping;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.categoricalMapping)
  return Type_.categoricalmapping_;
}
::CoreML::Specification::CategoricalMapping* Model::release_categoricalmapping() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.categoricalMapping)
  if (has_categoricalmapping()) {
    clear_has_Type();
    ::CoreML::Specification::CategoricalMapping* temp = Type_.categoricalmapping_;
    Type_.categoricalmapping_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_categoricalmapping(::CoreML::Specification::CategoricalMapping* categoricalmapping) {
  clear_Type();
  if (categoricalmapping) {
    set_has_categoricalmapping();
    Type_.categoricalmapping_ = categoricalmapping;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.categoricalMapping)
}

// .CoreML.Specification.Normalizer normalizer = 607;
bool Model::has_normalizer() const {
  return Type_case() == kNormalizer;
}
void Model::set_has_normalizer() {
  _oneof_case_[0] = kNormalizer;
}
void Model::clear_normalizer() {
  if (has_normalizer()) {
    delete Type_.normalizer_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::Normalizer& Model::normalizer() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.normalizer)
  return has_normalizer()
      ? *Type_.normalizer_
      : ::CoreML::Specification::Normalizer::default_instance();
}
::CoreML::Specification::Normalizer* Model::mutable_normalizer() {
  if (!has_normalizer()) {
    clear_Type();
    set_has_normalizer();
    Type_.normalizer_ = new ::CoreML::Specification::Normalizer;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.normalizer)
  return Type_.normalizer_;
}
::CoreML::Specification::Normalizer* Model::release_normalizer() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.normalizer)
  if (has_normalizer()) {
    clear_has_Type();
    ::CoreML::Specification::Normalizer* temp = Type_.normalizer_;
    Type_.normalizer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_normalizer(::CoreML::Specification::Normalizer* normalizer) {
  clear_Type();
  if (normalizer) {
    set_has_normalizer();
    Type_.normalizer_ = normalizer;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.normalizer)
}

// .CoreML.Specification.ArrayFeatureExtractor arrayFeatureExtractor = 609;
bool Model::has_arrayfeatureextractor() const {
  return Type_case() == kArrayFeatureExtractor;
}
void Model::set_has_arrayfeatureextractor() {
  _oneof_case_[0] = kArrayFeatureExtractor;
}
void Model::clear_arrayfeatureextractor() {
  if (has_arrayfeatureextractor()) {
    delete Type_.arrayfeatureextractor_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::ArrayFeatureExtractor& Model::arrayfeatureextractor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.arrayFeatureExtractor)
  return has_arrayfeatureextractor()
      ? *Type_.arrayfeatureextractor_
      : ::CoreML::Specification::ArrayFeatureExtractor::default_instance();
}
::CoreML::Specification::ArrayFeatureExtractor* Model::mutable_arrayfeatureextractor() {
  if (!has_arrayfeatureextractor()) {
    clear_Type();
    set_has_arrayfeatureextractor();
    Type_.arrayfeatureextractor_ = new ::CoreML::Specification::ArrayFeatureExtractor;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.arrayFeatureExtractor)
  return Type_.arrayfeatureextractor_;
}
::CoreML::Specification::ArrayFeatureExtractor* Model::release_arrayfeatureextractor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.arrayFeatureExtractor)
  if (has_arrayfeatureextractor()) {
    clear_has_Type();
    ::CoreML::Specification::ArrayFeatureExtractor* temp = Type_.arrayfeatureextractor_;
    Type_.arrayfeatureextractor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_arrayfeatureextractor(::CoreML::Specification::ArrayFeatureExtractor* arrayfeatureextractor) {
  clear_Type();
  if (arrayfeatureextractor) {
    set_has_arrayfeatureextractor();
    Type_.arrayfeatureextractor_ = arrayfeatureextractor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.arrayFeatureExtractor)
}

// .CoreML.Specification.NonMaximumSuppression nonMaximumSuppression = 610;
bool Model::has_nonmaximumsuppression() const {
  return Type_case() == kNonMaximumSuppression;
}
void Model::set_has_nonmaximumsuppression() {
  _oneof_case_[0] = kNonMaximumSuppression;
}
void Model::clear_nonmaximumsuppression() {
  if (has_nonmaximumsuppression()) {
    delete Type_.nonmaximumsuppression_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::NonMaximumSuppression& Model::nonmaximumsuppression() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.nonMaximumSuppression)
  return has_nonmaximumsuppression()
      ? *Type_.nonmaximumsuppression_
      : ::CoreML::Specification::NonMaximumSuppression::default_instance();
}
::CoreML::Specification::NonMaximumSuppression* Model::mutable_nonmaximumsuppression() {
  if (!has_nonmaximumsuppression()) {
    clear_Type();
    set_has_nonmaximumsuppression();
    Type_.nonmaximumsuppression_ = new ::CoreML::Specification::NonMaximumSuppression;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.nonMaximumSuppression)
  return Type_.nonmaximumsuppression_;
}
::CoreML::Specification::NonMaximumSuppression* Model::release_nonmaximumsuppression() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.nonMaximumSuppression)
  if (has_nonmaximumsuppression()) {
    clear_has_Type();
    ::CoreML::Specification::NonMaximumSuppression* temp = Type_.nonmaximumsuppression_;
    Type_.nonmaximumsuppression_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_nonmaximumsuppression(::CoreML::Specification::NonMaximumSuppression* nonmaximumsuppression) {
  clear_Type();
  if (nonmaximumsuppression) {
    set_has_nonmaximumsuppression();
    Type_.nonmaximumsuppression_ = nonmaximumsuppression;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.nonMaximumSuppression)
}

// .CoreML.Specification.Identity identity = 900;
bool Model::has_identity() const {
  return Type_case() == kIdentity;
}
void Model::set_has_identity() {
  _oneof_case_[0] = kIdentity;
}
void Model::clear_identity() {
  if (has_identity()) {
    delete Type_.identity_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::Identity& Model::identity() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.identity)
  return has_identity()
      ? *Type_.identity_
      : ::CoreML::Specification::Identity::default_instance();
}
::CoreML::Specification::Identity* Model::mutable_identity() {
  if (!has_identity()) {
    clear_Type();
    set_has_identity();
    Type_.identity_ = new ::CoreML::Specification::Identity;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.identity)
  return Type_.identity_;
}
::CoreML::Specification::Identity* Model::release_identity() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.identity)
  if (has_identity()) {
    clear_has_Type();
    ::CoreML::Specification::Identity* temp = Type_.identity_;
    Type_.identity_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_identity(::CoreML::Specification::Identity* identity) {
  clear_Type();
  if (identity) {
    set_has_identity();
    Type_.identity_ = identity;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.identity)
}

// .CoreML.Specification.CoreMLModels.TextClassifier textClassifier = 2000;
bool Model::has_textclassifier() const {
  return Type_case() == kTextClassifier;
}
void Model::set_has_textclassifier() {
  _oneof_case_[0] = kTextClassifier;
}
void Model::clear_textclassifier() {
  if (has_textclassifier()) {
    delete Type_.textclassifier_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::CoreMLModels::TextClassifier& Model::textclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.textClassifier)
  return has_textclassifier()
      ? *Type_.textclassifier_
      : ::CoreML::Specification::CoreMLModels::TextClassifier::default_instance();
}
::CoreML::Specification::CoreMLModels::TextClassifier* Model::mutable_textclassifier() {
  if (!has_textclassifier()) {
    clear_Type();
    set_has_textclassifier();
    Type_.textclassifier_ = new ::CoreML::Specification::CoreMLModels::TextClassifier;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.textClassifier)
  return Type_.textclassifier_;
}
::CoreML::Specification::CoreMLModels::TextClassifier* Model::release_textclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.textClassifier)
  if (has_textclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::CoreMLModels::TextClassifier* temp = Type_.textclassifier_;
    Type_.textclassifier_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_textclassifier(::CoreML::Specification::CoreMLModels::TextClassifier* textclassifier) {
  clear_Type();
  if (textclassifier) {
    set_has_textclassifier();
    Type_.textclassifier_ = textclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.textClassifier)
}

// .CoreML.Specification.CoreMLModels.WordTagger wordTagger = 2001;
bool Model::has_wordtagger() const {
  return Type_case() == kWordTagger;
}
void Model::set_has_wordtagger() {
  _oneof_case_[0] = kWordTagger;
}
void Model::clear_wordtagger() {
  if (has_wordtagger()) {
    delete Type_.wordtagger_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::CoreMLModels::WordTagger& Model::wordtagger() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.wordTagger)
  return has_wordtagger()
      ? *Type_.wordtagger_
      : ::CoreML::Specification::CoreMLModels::WordTagger::default_instance();
}
::CoreML::Specification::CoreMLModels::WordTagger* Model::mutable_wordtagger() {
  if (!has_wordtagger()) {
    clear_Type();
    set_has_wordtagger();
    Type_.wordtagger_ = new ::CoreML::Specification::CoreMLModels::WordTagger;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.wordTagger)
  return Type_.wordtagger_;
}
::CoreML::Specification::CoreMLModels::WordTagger* Model::release_wordtagger() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.wordTagger)
  if (has_wordtagger()) {
    clear_has_Type();
    ::CoreML::Specification::CoreMLModels::WordTagger* temp = Type_.wordtagger_;
    Type_.wordtagger_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_wordtagger(::CoreML::Specification::CoreMLModels::WordTagger* wordtagger) {
  clear_Type();
  if (wordtagger) {
    set_has_wordtagger();
    Type_.wordtagger_ = wordtagger;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.wordTagger)
}

// .CoreML.Specification.CoreMLModels.VisionFeaturePrint visionFeaturePrint = 2002;
bool Model::has_visionfeatureprint() const {
  return Type_case() == kVisionFeaturePrint;
}
void Model::set_has_visionfeatureprint() {
  _oneof_case_[0] = kVisionFeaturePrint;
}
void Model::clear_visionfeatureprint() {
  if (has_visionfeatureprint()) {
    delete Type_.visionfeatureprint_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::CoreMLModels::VisionFeaturePrint& Model::visionfeatureprint() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.visionFeaturePrint)
  return has_visionfeatureprint()
      ? *Type_.visionfeatureprint_
      : ::CoreML::Specification::CoreMLModels::VisionFeaturePrint::default_instance();
}
::CoreML::Specification::CoreMLModels::VisionFeaturePrint* Model::mutable_visionfeatureprint() {
  if (!has_visionfeatureprint()) {
    clear_Type();
    set_has_visionfeatureprint();
    Type_.visionfeatureprint_ = new ::CoreML::Specification::CoreMLModels::VisionFeaturePrint;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.visionFeaturePrint)
  return Type_.visionfeatureprint_;
}
::CoreML::Specification::CoreMLModels::VisionFeaturePrint* Model::release_visionfeatureprint() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.visionFeaturePrint)
  if (has_visionfeatureprint()) {
    clear_has_Type();
    ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* temp = Type_.visionfeatureprint_;
    Type_.visionfeatureprint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Model::set_allocated_visionfeatureprint(::CoreML::Specification::CoreMLModels::VisionFeaturePrint* visionfeatureprint) {
  clear_Type();
  if (visionfeatureprint) {
    set_has_visionfeatureprint();
    Type_.visionfeatureprint_ = visionfeatureprint;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.visionFeaturePrint)
}

bool Model::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
void Model::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
Model::TypeCase Model::Type_case() const {
  return Model::TypeCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace Specification
}  // namespace CoreML

// @@protoc_insertion_point(global_scope)
