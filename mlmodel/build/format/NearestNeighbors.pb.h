// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NearestNeighbors.proto

#ifndef PROTOBUF_NearestNeighbors_2eproto__INCLUDED
#define PROTOBUF_NearestNeighbors_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "DataStructures.pb.h"  // IWYU pragma: export
#include "Parameters.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)
namespace CoreML {
namespace Specification {
class ArrayFeatureType;
class ArrayFeatureTypeDefaultTypeInternal;
extern ArrayFeatureTypeDefaultTypeInternal _ArrayFeatureType_default_instance_;
class ArrayFeatureType_EnumeratedShapes;
class ArrayFeatureType_EnumeratedShapesDefaultTypeInternal;
extern ArrayFeatureType_EnumeratedShapesDefaultTypeInternal _ArrayFeatureType_EnumeratedShapes_default_instance_;
class ArrayFeatureType_Shape;
class ArrayFeatureType_ShapeDefaultTypeInternal;
extern ArrayFeatureType_ShapeDefaultTypeInternal _ArrayFeatureType_Shape_default_instance_;
class ArrayFeatureType_ShapeRange;
class ArrayFeatureType_ShapeRangeDefaultTypeInternal;
extern ArrayFeatureType_ShapeRangeDefaultTypeInternal _ArrayFeatureType_ShapeRange_default_instance_;
class BoolParameter;
class BoolParameterDefaultTypeInternal;
extern BoolParameterDefaultTypeInternal _BoolParameter_default_instance_;
class DictionaryFeatureType;
class DictionaryFeatureTypeDefaultTypeInternal;
extern DictionaryFeatureTypeDefaultTypeInternal _DictionaryFeatureType_default_instance_;
class DoubleFeatureType;
class DoubleFeatureTypeDefaultTypeInternal;
extern DoubleFeatureTypeDefaultTypeInternal _DoubleFeatureType_default_instance_;
class DoubleParameter;
class DoubleParameterDefaultTypeInternal;
extern DoubleParameterDefaultTypeInternal _DoubleParameter_default_instance_;
class DoubleRange;
class DoubleRangeDefaultTypeInternal;
extern DoubleRangeDefaultTypeInternal _DoubleRange_default_instance_;
class DoubleVector;
class DoubleVectorDefaultTypeInternal;
extern DoubleVectorDefaultTypeInternal _DoubleVector_default_instance_;
class FeatureType;
class FeatureTypeDefaultTypeInternal;
extern FeatureTypeDefaultTypeInternal _FeatureType_default_instance_;
class FloatVector;
class FloatVectorDefaultTypeInternal;
extern FloatVectorDefaultTypeInternal _FloatVector_default_instance_;
class ImageFeatureType;
class ImageFeatureTypeDefaultTypeInternal;
extern ImageFeatureTypeDefaultTypeInternal _ImageFeatureType_default_instance_;
class ImageFeatureType_EnumeratedImageSizes;
class ImageFeatureType_EnumeratedImageSizesDefaultTypeInternal;
extern ImageFeatureType_EnumeratedImageSizesDefaultTypeInternal _ImageFeatureType_EnumeratedImageSizes_default_instance_;
class ImageFeatureType_ImageSize;
class ImageFeatureType_ImageSizeDefaultTypeInternal;
extern ImageFeatureType_ImageSizeDefaultTypeInternal _ImageFeatureType_ImageSize_default_instance_;
class ImageFeatureType_ImageSizeRange;
class ImageFeatureType_ImageSizeRangeDefaultTypeInternal;
extern ImageFeatureType_ImageSizeRangeDefaultTypeInternal _ImageFeatureType_ImageSizeRange_default_instance_;
class Int64FeatureType;
class Int64FeatureTypeDefaultTypeInternal;
extern Int64FeatureTypeDefaultTypeInternal _Int64FeatureType_default_instance_;
class Int64Parameter;
class Int64ParameterDefaultTypeInternal;
extern Int64ParameterDefaultTypeInternal _Int64Parameter_default_instance_;
class Int64Range;
class Int64RangeDefaultTypeInternal;
extern Int64RangeDefaultTypeInternal _Int64Range_default_instance_;
class Int64Set;
class Int64SetDefaultTypeInternal;
extern Int64SetDefaultTypeInternal _Int64Set_default_instance_;
class Int64ToDoubleMap;
class Int64ToDoubleMapDefaultTypeInternal;
extern Int64ToDoubleMapDefaultTypeInternal _Int64ToDoubleMap_default_instance_;
class Int64ToDoubleMap_MapEntry;
class Int64ToDoubleMap_MapEntryDefaultTypeInternal;
extern Int64ToDoubleMap_MapEntryDefaultTypeInternal _Int64ToDoubleMap_MapEntry_default_instance_;
class Int64ToStringMap;
class Int64ToStringMapDefaultTypeInternal;
extern Int64ToStringMapDefaultTypeInternal _Int64ToStringMap_default_instance_;
class Int64ToStringMap_MapEntry;
class Int64ToStringMap_MapEntryDefaultTypeInternal;
extern Int64ToStringMap_MapEntryDefaultTypeInternal _Int64ToStringMap_MapEntry_default_instance_;
class Int64Vector;
class Int64VectorDefaultTypeInternal;
extern Int64VectorDefaultTypeInternal _Int64Vector_default_instance_;
class InverseDistanceWeighting;
class InverseDistanceWeightingDefaultTypeInternal;
extern InverseDistanceWeightingDefaultTypeInternal _InverseDistanceWeighting_default_instance_;
class KNearestNeighborsClassifier;
class KNearestNeighborsClassifierDefaultTypeInternal;
extern KNearestNeighborsClassifierDefaultTypeInternal _KNearestNeighborsClassifier_default_instance_;
class LinearIndex;
class LinearIndexDefaultTypeInternal;
extern LinearIndexDefaultTypeInternal _LinearIndex_default_instance_;
class NearestNeighborsIndex;
class NearestNeighborsIndexDefaultTypeInternal;
extern NearestNeighborsIndexDefaultTypeInternal _NearestNeighborsIndex_default_instance_;
class SequenceFeatureType;
class SequenceFeatureTypeDefaultTypeInternal;
extern SequenceFeatureTypeDefaultTypeInternal _SequenceFeatureType_default_instance_;
class SingleKdTreeIndex;
class SingleKdTreeIndexDefaultTypeInternal;
extern SingleKdTreeIndexDefaultTypeInternal _SingleKdTreeIndex_default_instance_;
class SizeRange;
class SizeRangeDefaultTypeInternal;
extern SizeRangeDefaultTypeInternal _SizeRange_default_instance_;
class SquaredEuclideanDistance;
class SquaredEuclideanDistanceDefaultTypeInternal;
extern SquaredEuclideanDistanceDefaultTypeInternal _SquaredEuclideanDistance_default_instance_;
class StringFeatureType;
class StringFeatureTypeDefaultTypeInternal;
extern StringFeatureTypeDefaultTypeInternal _StringFeatureType_default_instance_;
class StringParameter;
class StringParameterDefaultTypeInternal;
extern StringParameterDefaultTypeInternal _StringParameter_default_instance_;
class StringToDoubleMap;
class StringToDoubleMapDefaultTypeInternal;
extern StringToDoubleMapDefaultTypeInternal _StringToDoubleMap_default_instance_;
class StringToDoubleMap_MapEntry;
class StringToDoubleMap_MapEntryDefaultTypeInternal;
extern StringToDoubleMap_MapEntryDefaultTypeInternal _StringToDoubleMap_MapEntry_default_instance_;
class StringToInt64Map;
class StringToInt64MapDefaultTypeInternal;
extern StringToInt64MapDefaultTypeInternal _StringToInt64Map_default_instance_;
class StringToInt64Map_MapEntry;
class StringToInt64Map_MapEntryDefaultTypeInternal;
extern StringToInt64Map_MapEntryDefaultTypeInternal _StringToInt64Map_MapEntry_default_instance_;
class StringVector;
class StringVectorDefaultTypeInternal;
extern StringVectorDefaultTypeInternal _StringVector_default_instance_;
class UniformWeighting;
class UniformWeightingDefaultTypeInternal;
extern UniformWeightingDefaultTypeInternal _UniformWeighting_default_instance_;
}  // namespace Specification
}  // namespace CoreML

namespace CoreML {
namespace Specification {

namespace protobuf_NearestNeighbors_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_NearestNeighbors_2eproto

// ===================================================================

class KNearestNeighborsClassifier : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.KNearestNeighborsClassifier) */ {
 public:
  KNearestNeighborsClassifier();
  virtual ~KNearestNeighborsClassifier();

  KNearestNeighborsClassifier(const KNearestNeighborsClassifier& from);

  inline KNearestNeighborsClassifier& operator=(const KNearestNeighborsClassifier& from) {
    CopyFrom(from);
    return *this;
  }

  static const KNearestNeighborsClassifier& default_instance();

  enum ClassLabelsCase {
    kStringClassLabels = 100,
    kInt64ClassLabels = 101,
    CLASSLABELS_NOT_SET = 0,
  };

  enum DefaultClassLabelCase {
    kDefaultStringLabel = 110,
    kDefaultInt64Label = 111,
    DEFAULTCLASSLABEL_NOT_SET = 0,
  };

  enum WeightingSchemeCase {
    kUniformWeighting = 200,
    kInverseDistanceWeighting = 210,
    WEIGHTINGSCHEME_NOT_SET = 0,
  };

  static inline const KNearestNeighborsClassifier* internal_default_instance() {
    return reinterpret_cast<const KNearestNeighborsClassifier*>(
               &_KNearestNeighborsClassifier_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(KNearestNeighborsClassifier* other);

  // implements Message ----------------------------------------------

  inline KNearestNeighborsClassifier* New() const PROTOBUF_FINAL { return New(NULL); }

  KNearestNeighborsClassifier* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const KNearestNeighborsClassifier& from);
  void MergeFrom(const KNearestNeighborsClassifier& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KNearestNeighborsClassifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.NearestNeighborsIndex nearestNeighborsIndex = 1;
  bool has_nearestneighborsindex() const;
  void clear_nearestneighborsindex();
  static const int kNearestNeighborsIndexFieldNumber = 1;
  const ::CoreML::Specification::NearestNeighborsIndex& nearestneighborsindex() const;
  ::CoreML::Specification::NearestNeighborsIndex* mutable_nearestneighborsindex();
  ::CoreML::Specification::NearestNeighborsIndex* release_nearestneighborsindex();
  void set_allocated_nearestneighborsindex(::CoreML::Specification::NearestNeighborsIndex* nearestneighborsindex);

  // .CoreML.Specification.Int64Parameter numberOfNeighbors = 3;
  bool has_numberofneighbors() const;
  void clear_numberofneighbors();
  static const int kNumberOfNeighborsFieldNumber = 3;
  const ::CoreML::Specification::Int64Parameter& numberofneighbors() const;
  ::CoreML::Specification::Int64Parameter* mutable_numberofneighbors();
  ::CoreML::Specification::Int64Parameter* release_numberofneighbors();
  void set_allocated_numberofneighbors(::CoreML::Specification::Int64Parameter* numberofneighbors);

  // .CoreML.Specification.StringVector stringClassLabels = 100;
  bool has_stringclasslabels() const;
  void clear_stringclasslabels();
  static const int kStringClassLabelsFieldNumber = 100;
  const ::CoreML::Specification::StringVector& stringclasslabels() const;
  ::CoreML::Specification::StringVector* mutable_stringclasslabels();
  ::CoreML::Specification::StringVector* release_stringclasslabels();
  void set_allocated_stringclasslabels(::CoreML::Specification::StringVector* stringclasslabels);

  // .CoreML.Specification.Int64Vector int64ClassLabels = 101;
  bool has_int64classlabels() const;
  void clear_int64classlabels();
  static const int kInt64ClassLabelsFieldNumber = 101;
  const ::CoreML::Specification::Int64Vector& int64classlabels() const;
  ::CoreML::Specification::Int64Vector* mutable_int64classlabels();
  ::CoreML::Specification::Int64Vector* release_int64classlabels();
  void set_allocated_int64classlabels(::CoreML::Specification::Int64Vector* int64classlabels);

  // string defaultStringLabel = 110;
  private:
  bool has_defaultstringlabel() const;
  public:
  void clear_defaultstringlabel();
  static const int kDefaultStringLabelFieldNumber = 110;
  const ::std::string& defaultstringlabel() const;
  void set_defaultstringlabel(const ::std::string& value);
  #if LANG_CXX11
  void set_defaultstringlabel(::std::string&& value);
  #endif
  void set_defaultstringlabel(const char* value);
  void set_defaultstringlabel(const char* value, size_t size);
  ::std::string* mutable_defaultstringlabel();
  ::std::string* release_defaultstringlabel();
  void set_allocated_defaultstringlabel(::std::string* defaultstringlabel);

  // int64 defaultInt64Label = 111;
  private:
  bool has_defaultint64label() const;
  public:
  void clear_defaultint64label();
  static const int kDefaultInt64LabelFieldNumber = 111;
  ::google::protobuf::int64 defaultint64label() const;
  void set_defaultint64label(::google::protobuf::int64 value);

  // .CoreML.Specification.UniformWeighting uniformWeighting = 200;
  bool has_uniformweighting() const;
  void clear_uniformweighting();
  static const int kUniformWeightingFieldNumber = 200;
  const ::CoreML::Specification::UniformWeighting& uniformweighting() const;
  ::CoreML::Specification::UniformWeighting* mutable_uniformweighting();
  ::CoreML::Specification::UniformWeighting* release_uniformweighting();
  void set_allocated_uniformweighting(::CoreML::Specification::UniformWeighting* uniformweighting);

  // .CoreML.Specification.InverseDistanceWeighting inverseDistanceWeighting = 210;
  bool has_inversedistanceweighting() const;
  void clear_inversedistanceweighting();
  static const int kInverseDistanceWeightingFieldNumber = 210;
  const ::CoreML::Specification::InverseDistanceWeighting& inversedistanceweighting() const;
  ::CoreML::Specification::InverseDistanceWeighting* mutable_inversedistanceweighting();
  ::CoreML::Specification::InverseDistanceWeighting* release_inversedistanceweighting();
  void set_allocated_inversedistanceweighting(::CoreML::Specification::InverseDistanceWeighting* inversedistanceweighting);

  ClassLabelsCase ClassLabels_case() const;
  DefaultClassLabelCase DefaultClassLabel_case() const;
  WeightingSchemeCase WeightingScheme_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.KNearestNeighborsClassifier)
 private:
  void set_has_stringclasslabels();
  void set_has_int64classlabels();
  void set_has_defaultstringlabel();
  void set_has_defaultint64label();
  void set_has_uniformweighting();
  void set_has_inversedistanceweighting();

  inline bool has_ClassLabels() const;
  void clear_ClassLabels();
  inline void clear_has_ClassLabels();

  inline bool has_DefaultClassLabel() const;
  void clear_DefaultClassLabel();
  inline void clear_has_DefaultClassLabel();

  inline bool has_WeightingScheme() const;
  void clear_WeightingScheme();
  inline void clear_has_WeightingScheme();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::CoreML::Specification::NearestNeighborsIndex* nearestneighborsindex_;
  ::CoreML::Specification::Int64Parameter* numberofneighbors_;
  union ClassLabelsUnion {
    ClassLabelsUnion() {}
    ::CoreML::Specification::StringVector* stringclasslabels_;
    ::CoreML::Specification::Int64Vector* int64classlabels_;
  } ClassLabels_;
  union DefaultClassLabelUnion {
    DefaultClassLabelUnion() {}
    ::google::protobuf::internal::ArenaStringPtr defaultstringlabel_;
    ::google::protobuf::int64 defaultint64label_;
  } DefaultClassLabel_;
  union WeightingSchemeUnion {
    WeightingSchemeUnion() {}
    ::CoreML::Specification::UniformWeighting* uniformweighting_;
    ::CoreML::Specification::InverseDistanceWeighting* inversedistanceweighting_;
  } WeightingScheme_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[3];

  friend struct protobuf_NearestNeighbors_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NearestNeighborsIndex : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.NearestNeighborsIndex) */ {
 public:
  NearestNeighborsIndex();
  virtual ~NearestNeighborsIndex();

  NearestNeighborsIndex(const NearestNeighborsIndex& from);

  inline NearestNeighborsIndex& operator=(const NearestNeighborsIndex& from) {
    CopyFrom(from);
    return *this;
  }

  static const NearestNeighborsIndex& default_instance();

  enum IndexTypeCase {
    kLinearIndex = 100,
    kSingleKdTreeIndex = 110,
    INDEXTYPE_NOT_SET = 0,
  };

  enum DistanceFunctionCase {
    kSquaredEuclideanDistance = 200,
    DISTANCEFUNCTION_NOT_SET = 0,
  };

  static inline const NearestNeighborsIndex* internal_default_instance() {
    return reinterpret_cast<const NearestNeighborsIndex*>(
               &_NearestNeighborsIndex_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(NearestNeighborsIndex* other);

  // implements Message ----------------------------------------------

  inline NearestNeighborsIndex* New() const PROTOBUF_FINAL { return New(NULL); }

  NearestNeighborsIndex* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NearestNeighborsIndex& from);
  void MergeFrom(const NearestNeighborsIndex& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NearestNeighborsIndex* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.FloatVector floatSamples = 2;
  int floatsamples_size() const;
  void clear_floatsamples();
  static const int kFloatSamplesFieldNumber = 2;
  const ::CoreML::Specification::FloatVector& floatsamples(int index) const;
  ::CoreML::Specification::FloatVector* mutable_floatsamples(int index);
  ::CoreML::Specification::FloatVector* add_floatsamples();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FloatVector >*
      mutable_floatsamples();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FloatVector >&
      floatsamples() const;

  // int32 numberOfDimensions = 1;
  void clear_numberofdimensions();
  static const int kNumberOfDimensionsFieldNumber = 1;
  ::google::protobuf::int32 numberofdimensions() const;
  void set_numberofdimensions(::google::protobuf::int32 value);

  // .CoreML.Specification.LinearIndex linearIndex = 100;
  bool has_linearindex() const;
  void clear_linearindex();
  static const int kLinearIndexFieldNumber = 100;
  const ::CoreML::Specification::LinearIndex& linearindex() const;
  ::CoreML::Specification::LinearIndex* mutable_linearindex();
  ::CoreML::Specification::LinearIndex* release_linearindex();
  void set_allocated_linearindex(::CoreML::Specification::LinearIndex* linearindex);

  // .CoreML.Specification.SingleKdTreeIndex singleKdTreeIndex = 110;
  bool has_singlekdtreeindex() const;
  void clear_singlekdtreeindex();
  static const int kSingleKdTreeIndexFieldNumber = 110;
  const ::CoreML::Specification::SingleKdTreeIndex& singlekdtreeindex() const;
  ::CoreML::Specification::SingleKdTreeIndex* mutable_singlekdtreeindex();
  ::CoreML::Specification::SingleKdTreeIndex* release_singlekdtreeindex();
  void set_allocated_singlekdtreeindex(::CoreML::Specification::SingleKdTreeIndex* singlekdtreeindex);

  // .CoreML.Specification.SquaredEuclideanDistance squaredEuclideanDistance = 200;
  bool has_squaredeuclideandistance() const;
  void clear_squaredeuclideandistance();
  static const int kSquaredEuclideanDistanceFieldNumber = 200;
  const ::CoreML::Specification::SquaredEuclideanDistance& squaredeuclideandistance() const;
  ::CoreML::Specification::SquaredEuclideanDistance* mutable_squaredeuclideandistance();
  ::CoreML::Specification::SquaredEuclideanDistance* release_squaredeuclideandistance();
  void set_allocated_squaredeuclideandistance(::CoreML::Specification::SquaredEuclideanDistance* squaredeuclideandistance);

  IndexTypeCase IndexType_case() const;
  DistanceFunctionCase DistanceFunction_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.NearestNeighborsIndex)
 private:
  void set_has_linearindex();
  void set_has_singlekdtreeindex();
  void set_has_squaredeuclideandistance();

  inline bool has_IndexType() const;
  void clear_IndexType();
  inline void clear_has_IndexType();

  inline bool has_DistanceFunction() const;
  void clear_DistanceFunction();
  inline void clear_has_DistanceFunction();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FloatVector > floatsamples_;
  ::google::protobuf::int32 numberofdimensions_;
  union IndexTypeUnion {
    IndexTypeUnion() {}
    ::CoreML::Specification::LinearIndex* linearindex_;
    ::CoreML::Specification::SingleKdTreeIndex* singlekdtreeindex_;
  } IndexType_;
  union DistanceFunctionUnion {
    DistanceFunctionUnion() {}
    ::CoreML::Specification::SquaredEuclideanDistance* squaredeuclideandistance_;
  } DistanceFunction_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  friend struct protobuf_NearestNeighbors_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UniformWeighting : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.UniformWeighting) */ {
 public:
  UniformWeighting();
  virtual ~UniformWeighting();

  UniformWeighting(const UniformWeighting& from);

  inline UniformWeighting& operator=(const UniformWeighting& from) {
    CopyFrom(from);
    return *this;
  }

  static const UniformWeighting& default_instance();

  static inline const UniformWeighting* internal_default_instance() {
    return reinterpret_cast<const UniformWeighting*>(
               &_UniformWeighting_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(UniformWeighting* other);

  // implements Message ----------------------------------------------

  inline UniformWeighting* New() const PROTOBUF_FINAL { return New(NULL); }

  UniformWeighting* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const UniformWeighting& from);
  void MergeFrom(const UniformWeighting& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UniformWeighting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.UniformWeighting)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_NearestNeighbors_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InverseDistanceWeighting : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.InverseDistanceWeighting) */ {
 public:
  InverseDistanceWeighting();
  virtual ~InverseDistanceWeighting();

  InverseDistanceWeighting(const InverseDistanceWeighting& from);

  inline InverseDistanceWeighting& operator=(const InverseDistanceWeighting& from) {
    CopyFrom(from);
    return *this;
  }

  static const InverseDistanceWeighting& default_instance();

  static inline const InverseDistanceWeighting* internal_default_instance() {
    return reinterpret_cast<const InverseDistanceWeighting*>(
               &_InverseDistanceWeighting_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(InverseDistanceWeighting* other);

  // implements Message ----------------------------------------------

  inline InverseDistanceWeighting* New() const PROTOBUF_FINAL { return New(NULL); }

  InverseDistanceWeighting* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const InverseDistanceWeighting& from);
  void MergeFrom(const InverseDistanceWeighting& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InverseDistanceWeighting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.InverseDistanceWeighting)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_NearestNeighbors_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LinearIndex : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.LinearIndex) */ {
 public:
  LinearIndex();
  virtual ~LinearIndex();

  LinearIndex(const LinearIndex& from);

  inline LinearIndex& operator=(const LinearIndex& from) {
    CopyFrom(from);
    return *this;
  }

  static const LinearIndex& default_instance();

  static inline const LinearIndex* internal_default_instance() {
    return reinterpret_cast<const LinearIndex*>(
               &_LinearIndex_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(LinearIndex* other);

  // implements Message ----------------------------------------------

  inline LinearIndex* New() const PROTOBUF_FINAL { return New(NULL); }

  LinearIndex* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const LinearIndex& from);
  void MergeFrom(const LinearIndex& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LinearIndex* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.LinearIndex)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_NearestNeighbors_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SingleKdTreeIndex : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.SingleKdTreeIndex) */ {
 public:
  SingleKdTreeIndex();
  virtual ~SingleKdTreeIndex();

  SingleKdTreeIndex(const SingleKdTreeIndex& from);

  inline SingleKdTreeIndex& operator=(const SingleKdTreeIndex& from) {
    CopyFrom(from);
    return *this;
  }

  static const SingleKdTreeIndex& default_instance();

  static inline const SingleKdTreeIndex* internal_default_instance() {
    return reinterpret_cast<const SingleKdTreeIndex*>(
               &_SingleKdTreeIndex_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(SingleKdTreeIndex* other);

  // implements Message ----------------------------------------------

  inline SingleKdTreeIndex* New() const PROTOBUF_FINAL { return New(NULL); }

  SingleKdTreeIndex* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SingleKdTreeIndex& from);
  void MergeFrom(const SingleKdTreeIndex& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SingleKdTreeIndex* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 leafSize = 1;
  void clear_leafsize();
  static const int kLeafSizeFieldNumber = 1;
  ::google::protobuf::int32 leafsize() const;
  void set_leafsize(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.SingleKdTreeIndex)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int32 leafsize_;
  mutable int _cached_size_;
  friend struct protobuf_NearestNeighbors_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SquaredEuclideanDistance : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.SquaredEuclideanDistance) */ {
 public:
  SquaredEuclideanDistance();
  virtual ~SquaredEuclideanDistance();

  SquaredEuclideanDistance(const SquaredEuclideanDistance& from);

  inline SquaredEuclideanDistance& operator=(const SquaredEuclideanDistance& from) {
    CopyFrom(from);
    return *this;
  }

  static const SquaredEuclideanDistance& default_instance();

  static inline const SquaredEuclideanDistance* internal_default_instance() {
    return reinterpret_cast<const SquaredEuclideanDistance*>(
               &_SquaredEuclideanDistance_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(SquaredEuclideanDistance* other);

  // implements Message ----------------------------------------------

  inline SquaredEuclideanDistance* New() const PROTOBUF_FINAL { return New(NULL); }

  SquaredEuclideanDistance* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SquaredEuclideanDistance& from);
  void MergeFrom(const SquaredEuclideanDistance& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SquaredEuclideanDistance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.SquaredEuclideanDistance)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_NearestNeighbors_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// KNearestNeighborsClassifier

// .CoreML.Specification.NearestNeighborsIndex nearestNeighborsIndex = 1;
inline bool KNearestNeighborsClassifier::has_nearestneighborsindex() const {
  return this != internal_default_instance() && nearestneighborsindex_ != NULL;
}
inline void KNearestNeighborsClassifier::clear_nearestneighborsindex() {
  if (GetArenaNoVirtual() == NULL && nearestneighborsindex_ != NULL) delete nearestneighborsindex_;
  nearestneighborsindex_ = NULL;
}
inline const ::CoreML::Specification::NearestNeighborsIndex& KNearestNeighborsClassifier::nearestneighborsindex() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.KNearestNeighborsClassifier.nearestNeighborsIndex)
  return nearestneighborsindex_ != NULL ? *nearestneighborsindex_
                         : *::CoreML::Specification::NearestNeighborsIndex::internal_default_instance();
}
inline ::CoreML::Specification::NearestNeighborsIndex* KNearestNeighborsClassifier::mutable_nearestneighborsindex() {
  
  if (nearestneighborsindex_ == NULL) {
    nearestneighborsindex_ = new ::CoreML::Specification::NearestNeighborsIndex;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.KNearestNeighborsClassifier.nearestNeighborsIndex)
  return nearestneighborsindex_;
}
inline ::CoreML::Specification::NearestNeighborsIndex* KNearestNeighborsClassifier::release_nearestneighborsindex() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.KNearestNeighborsClassifier.nearestNeighborsIndex)
  
  ::CoreML::Specification::NearestNeighborsIndex* temp = nearestneighborsindex_;
  nearestneighborsindex_ = NULL;
  return temp;
}
inline void KNearestNeighborsClassifier::set_allocated_nearestneighborsindex(::CoreML::Specification::NearestNeighborsIndex* nearestneighborsindex) {
  delete nearestneighborsindex_;
  nearestneighborsindex_ = nearestneighborsindex;
  if (nearestneighborsindex) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.KNearestNeighborsClassifier.nearestNeighborsIndex)
}

// .CoreML.Specification.Int64Parameter numberOfNeighbors = 3;
inline bool KNearestNeighborsClassifier::has_numberofneighbors() const {
  return this != internal_default_instance() && numberofneighbors_ != NULL;
}
inline void KNearestNeighborsClassifier::clear_numberofneighbors() {
  if (GetArenaNoVirtual() == NULL && numberofneighbors_ != NULL) delete numberofneighbors_;
  numberofneighbors_ = NULL;
}
inline const ::CoreML::Specification::Int64Parameter& KNearestNeighborsClassifier::numberofneighbors() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.KNearestNeighborsClassifier.numberOfNeighbors)
  return numberofneighbors_ != NULL ? *numberofneighbors_
                         : *::CoreML::Specification::Int64Parameter::internal_default_instance();
}
inline ::CoreML::Specification::Int64Parameter* KNearestNeighborsClassifier::mutable_numberofneighbors() {
  
  if (numberofneighbors_ == NULL) {
    numberofneighbors_ = new ::CoreML::Specification::Int64Parameter;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.KNearestNeighborsClassifier.numberOfNeighbors)
  return numberofneighbors_;
}
inline ::CoreML::Specification::Int64Parameter* KNearestNeighborsClassifier::release_numberofneighbors() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.KNearestNeighborsClassifier.numberOfNeighbors)
  
  ::CoreML::Specification::Int64Parameter* temp = numberofneighbors_;
  numberofneighbors_ = NULL;
  return temp;
}
inline void KNearestNeighborsClassifier::set_allocated_numberofneighbors(::CoreML::Specification::Int64Parameter* numberofneighbors) {
  delete numberofneighbors_;
  numberofneighbors_ = numberofneighbors;
  if (numberofneighbors) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.KNearestNeighborsClassifier.numberOfNeighbors)
}

// .CoreML.Specification.StringVector stringClassLabels = 100;
inline bool KNearestNeighborsClassifier::has_stringclasslabels() const {
  return ClassLabels_case() == kStringClassLabels;
}
inline void KNearestNeighborsClassifier::set_has_stringclasslabels() {
  _oneof_case_[0] = kStringClassLabels;
}
inline void KNearestNeighborsClassifier::clear_stringclasslabels() {
  if (has_stringclasslabels()) {
    delete ClassLabels_.stringclasslabels_;
    clear_has_ClassLabels();
  }
}
inline  const ::CoreML::Specification::StringVector& KNearestNeighborsClassifier::stringclasslabels() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.KNearestNeighborsClassifier.stringClassLabels)
  return has_stringclasslabels()
      ? *ClassLabels_.stringclasslabels_
      : ::CoreML::Specification::StringVector::default_instance();
}
inline ::CoreML::Specification::StringVector* KNearestNeighborsClassifier::mutable_stringclasslabels() {
  if (!has_stringclasslabels()) {
    clear_ClassLabels();
    set_has_stringclasslabels();
    ClassLabels_.stringclasslabels_ = new ::CoreML::Specification::StringVector;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.KNearestNeighborsClassifier.stringClassLabels)
  return ClassLabels_.stringclasslabels_;
}
inline ::CoreML::Specification::StringVector* KNearestNeighborsClassifier::release_stringclasslabels() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.KNearestNeighborsClassifier.stringClassLabels)
  if (has_stringclasslabels()) {
    clear_has_ClassLabels();
    ::CoreML::Specification::StringVector* temp = ClassLabels_.stringclasslabels_;
    ClassLabels_.stringclasslabels_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void KNearestNeighborsClassifier::set_allocated_stringclasslabels(::CoreML::Specification::StringVector* stringclasslabels) {
  clear_ClassLabels();
  if (stringclasslabels) {
    set_has_stringclasslabels();
    ClassLabels_.stringclasslabels_ = stringclasslabels;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.KNearestNeighborsClassifier.stringClassLabels)
}

// .CoreML.Specification.Int64Vector int64ClassLabels = 101;
inline bool KNearestNeighborsClassifier::has_int64classlabels() const {
  return ClassLabels_case() == kInt64ClassLabels;
}
inline void KNearestNeighborsClassifier::set_has_int64classlabels() {
  _oneof_case_[0] = kInt64ClassLabels;
}
inline void KNearestNeighborsClassifier::clear_int64classlabels() {
  if (has_int64classlabels()) {
    delete ClassLabels_.int64classlabels_;
    clear_has_ClassLabels();
  }
}
inline  const ::CoreML::Specification::Int64Vector& KNearestNeighborsClassifier::int64classlabels() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.KNearestNeighborsClassifier.int64ClassLabels)
  return has_int64classlabels()
      ? *ClassLabels_.int64classlabels_
      : ::CoreML::Specification::Int64Vector::default_instance();
}
inline ::CoreML::Specification::Int64Vector* KNearestNeighborsClassifier::mutable_int64classlabels() {
  if (!has_int64classlabels()) {
    clear_ClassLabels();
    set_has_int64classlabels();
    ClassLabels_.int64classlabels_ = new ::CoreML::Specification::Int64Vector;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.KNearestNeighborsClassifier.int64ClassLabels)
  return ClassLabels_.int64classlabels_;
}
inline ::CoreML::Specification::Int64Vector* KNearestNeighborsClassifier::release_int64classlabels() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.KNearestNeighborsClassifier.int64ClassLabels)
  if (has_int64classlabels()) {
    clear_has_ClassLabels();
    ::CoreML::Specification::Int64Vector* temp = ClassLabels_.int64classlabels_;
    ClassLabels_.int64classlabels_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void KNearestNeighborsClassifier::set_allocated_int64classlabels(::CoreML::Specification::Int64Vector* int64classlabels) {
  clear_ClassLabels();
  if (int64classlabels) {
    set_has_int64classlabels();
    ClassLabels_.int64classlabels_ = int64classlabels;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.KNearestNeighborsClassifier.int64ClassLabels)
}

// string defaultStringLabel = 110;
inline bool KNearestNeighborsClassifier::has_defaultstringlabel() const {
  return DefaultClassLabel_case() == kDefaultStringLabel;
}
inline void KNearestNeighborsClassifier::set_has_defaultstringlabel() {
  _oneof_case_[1] = kDefaultStringLabel;
}
inline void KNearestNeighborsClassifier::clear_defaultstringlabel() {
  if (has_defaultstringlabel()) {
    DefaultClassLabel_.defaultstringlabel_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_DefaultClassLabel();
  }
}
inline const ::std::string& KNearestNeighborsClassifier::defaultstringlabel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.KNearestNeighborsClassifier.defaultStringLabel)
  if (has_defaultstringlabel()) {
    return DefaultClassLabel_.defaultstringlabel_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void KNearestNeighborsClassifier::set_defaultstringlabel(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:CoreML.Specification.KNearestNeighborsClassifier.defaultStringLabel)
  if (!has_defaultstringlabel()) {
    clear_DefaultClassLabel();
    set_has_defaultstringlabel();
    DefaultClassLabel_.defaultstringlabel_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  DefaultClassLabel_.defaultstringlabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.KNearestNeighborsClassifier.defaultStringLabel)
}
#if LANG_CXX11
inline void KNearestNeighborsClassifier::set_defaultstringlabel(::std::string&& value) {
  // @@protoc_insertion_point(field_set:CoreML.Specification.KNearestNeighborsClassifier.defaultStringLabel)
  if (!has_defaultstringlabel()) {
    clear_DefaultClassLabel();
    set_has_defaultstringlabel();
    DefaultClassLabel_.defaultstringlabel_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  DefaultClassLabel_.defaultstringlabel_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.KNearestNeighborsClassifier.defaultStringLabel)
}
#endif
inline void KNearestNeighborsClassifier::set_defaultstringlabel(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_defaultstringlabel()) {
    clear_DefaultClassLabel();
    set_has_defaultstringlabel();
    DefaultClassLabel_.defaultstringlabel_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  DefaultClassLabel_.defaultstringlabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.KNearestNeighborsClassifier.defaultStringLabel)
}
inline void KNearestNeighborsClassifier::set_defaultstringlabel(const char* value, size_t size) {
  if (!has_defaultstringlabel()) {
    clear_DefaultClassLabel();
    set_has_defaultstringlabel();
    DefaultClassLabel_.defaultstringlabel_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  DefaultClassLabel_.defaultstringlabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.KNearestNeighborsClassifier.defaultStringLabel)
}
inline ::std::string* KNearestNeighborsClassifier::mutable_defaultstringlabel() {
  if (!has_defaultstringlabel()) {
    clear_DefaultClassLabel();
    set_has_defaultstringlabel();
    DefaultClassLabel_.defaultstringlabel_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.KNearestNeighborsClassifier.defaultStringLabel)
  return DefaultClassLabel_.defaultstringlabel_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KNearestNeighborsClassifier::release_defaultstringlabel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.KNearestNeighborsClassifier.defaultStringLabel)
  if (has_defaultstringlabel()) {
    clear_has_DefaultClassLabel();
    return DefaultClassLabel_.defaultstringlabel_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void KNearestNeighborsClassifier::set_allocated_defaultstringlabel(::std::string* defaultstringlabel) {
  if (!has_defaultstringlabel()) {
    DefaultClassLabel_.defaultstringlabel_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_DefaultClassLabel();
  if (defaultstringlabel != NULL) {
    set_has_defaultstringlabel();
    DefaultClassLabel_.defaultstringlabel_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        defaultstringlabel);
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.KNearestNeighborsClassifier.defaultStringLabel)
}

// int64 defaultInt64Label = 111;
inline bool KNearestNeighborsClassifier::has_defaultint64label() const {
  return DefaultClassLabel_case() == kDefaultInt64Label;
}
inline void KNearestNeighborsClassifier::set_has_defaultint64label() {
  _oneof_case_[1] = kDefaultInt64Label;
}
inline void KNearestNeighborsClassifier::clear_defaultint64label() {
  if (has_defaultint64label()) {
    DefaultClassLabel_.defaultint64label_ = GOOGLE_LONGLONG(0);
    clear_has_DefaultClassLabel();
  }
}
inline ::google::protobuf::int64 KNearestNeighborsClassifier::defaultint64label() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.KNearestNeighborsClassifier.defaultInt64Label)
  if (has_defaultint64label()) {
    return DefaultClassLabel_.defaultint64label_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void KNearestNeighborsClassifier::set_defaultint64label(::google::protobuf::int64 value) {
  if (!has_defaultint64label()) {
    clear_DefaultClassLabel();
    set_has_defaultint64label();
  }
  DefaultClassLabel_.defaultint64label_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.KNearestNeighborsClassifier.defaultInt64Label)
}

// .CoreML.Specification.UniformWeighting uniformWeighting = 200;
inline bool KNearestNeighborsClassifier::has_uniformweighting() const {
  return WeightingScheme_case() == kUniformWeighting;
}
inline void KNearestNeighborsClassifier::set_has_uniformweighting() {
  _oneof_case_[2] = kUniformWeighting;
}
inline void KNearestNeighborsClassifier::clear_uniformweighting() {
  if (has_uniformweighting()) {
    delete WeightingScheme_.uniformweighting_;
    clear_has_WeightingScheme();
  }
}
inline  const ::CoreML::Specification::UniformWeighting& KNearestNeighborsClassifier::uniformweighting() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.KNearestNeighborsClassifier.uniformWeighting)
  return has_uniformweighting()
      ? *WeightingScheme_.uniformweighting_
      : ::CoreML::Specification::UniformWeighting::default_instance();
}
inline ::CoreML::Specification::UniformWeighting* KNearestNeighborsClassifier::mutable_uniformweighting() {
  if (!has_uniformweighting()) {
    clear_WeightingScheme();
    set_has_uniformweighting();
    WeightingScheme_.uniformweighting_ = new ::CoreML::Specification::UniformWeighting;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.KNearestNeighborsClassifier.uniformWeighting)
  return WeightingScheme_.uniformweighting_;
}
inline ::CoreML::Specification::UniformWeighting* KNearestNeighborsClassifier::release_uniformweighting() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.KNearestNeighborsClassifier.uniformWeighting)
  if (has_uniformweighting()) {
    clear_has_WeightingScheme();
    ::CoreML::Specification::UniformWeighting* temp = WeightingScheme_.uniformweighting_;
    WeightingScheme_.uniformweighting_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void KNearestNeighborsClassifier::set_allocated_uniformweighting(::CoreML::Specification::UniformWeighting* uniformweighting) {
  clear_WeightingScheme();
  if (uniformweighting) {
    set_has_uniformweighting();
    WeightingScheme_.uniformweighting_ = uniformweighting;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.KNearestNeighborsClassifier.uniformWeighting)
}

// .CoreML.Specification.InverseDistanceWeighting inverseDistanceWeighting = 210;
inline bool KNearestNeighborsClassifier::has_inversedistanceweighting() const {
  return WeightingScheme_case() == kInverseDistanceWeighting;
}
inline void KNearestNeighborsClassifier::set_has_inversedistanceweighting() {
  _oneof_case_[2] = kInverseDistanceWeighting;
}
inline void KNearestNeighborsClassifier::clear_inversedistanceweighting() {
  if (has_inversedistanceweighting()) {
    delete WeightingScheme_.inversedistanceweighting_;
    clear_has_WeightingScheme();
  }
}
inline  const ::CoreML::Specification::InverseDistanceWeighting& KNearestNeighborsClassifier::inversedistanceweighting() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.KNearestNeighborsClassifier.inverseDistanceWeighting)
  return has_inversedistanceweighting()
      ? *WeightingScheme_.inversedistanceweighting_
      : ::CoreML::Specification::InverseDistanceWeighting::default_instance();
}
inline ::CoreML::Specification::InverseDistanceWeighting* KNearestNeighborsClassifier::mutable_inversedistanceweighting() {
  if (!has_inversedistanceweighting()) {
    clear_WeightingScheme();
    set_has_inversedistanceweighting();
    WeightingScheme_.inversedistanceweighting_ = new ::CoreML::Specification::InverseDistanceWeighting;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.KNearestNeighborsClassifier.inverseDistanceWeighting)
  return WeightingScheme_.inversedistanceweighting_;
}
inline ::CoreML::Specification::InverseDistanceWeighting* KNearestNeighborsClassifier::release_inversedistanceweighting() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.KNearestNeighborsClassifier.inverseDistanceWeighting)
  if (has_inversedistanceweighting()) {
    clear_has_WeightingScheme();
    ::CoreML::Specification::InverseDistanceWeighting* temp = WeightingScheme_.inversedistanceweighting_;
    WeightingScheme_.inversedistanceweighting_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void KNearestNeighborsClassifier::set_allocated_inversedistanceweighting(::CoreML::Specification::InverseDistanceWeighting* inversedistanceweighting) {
  clear_WeightingScheme();
  if (inversedistanceweighting) {
    set_has_inversedistanceweighting();
    WeightingScheme_.inversedistanceweighting_ = inversedistanceweighting;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.KNearestNeighborsClassifier.inverseDistanceWeighting)
}

inline bool KNearestNeighborsClassifier::has_ClassLabels() const {
  return ClassLabels_case() != CLASSLABELS_NOT_SET;
}
inline void KNearestNeighborsClassifier::clear_has_ClassLabels() {
  _oneof_case_[0] = CLASSLABELS_NOT_SET;
}
inline bool KNearestNeighborsClassifier::has_DefaultClassLabel() const {
  return DefaultClassLabel_case() != DEFAULTCLASSLABEL_NOT_SET;
}
inline void KNearestNeighborsClassifier::clear_has_DefaultClassLabel() {
  _oneof_case_[1] = DEFAULTCLASSLABEL_NOT_SET;
}
inline bool KNearestNeighborsClassifier::has_WeightingScheme() const {
  return WeightingScheme_case() != WEIGHTINGSCHEME_NOT_SET;
}
inline void KNearestNeighborsClassifier::clear_has_WeightingScheme() {
  _oneof_case_[2] = WEIGHTINGSCHEME_NOT_SET;
}
inline KNearestNeighborsClassifier::ClassLabelsCase KNearestNeighborsClassifier::ClassLabels_case() const {
  return KNearestNeighborsClassifier::ClassLabelsCase(_oneof_case_[0]);
}
inline KNearestNeighborsClassifier::DefaultClassLabelCase KNearestNeighborsClassifier::DefaultClassLabel_case() const {
  return KNearestNeighborsClassifier::DefaultClassLabelCase(_oneof_case_[1]);
}
inline KNearestNeighborsClassifier::WeightingSchemeCase KNearestNeighborsClassifier::WeightingScheme_case() const {
  return KNearestNeighborsClassifier::WeightingSchemeCase(_oneof_case_[2]);
}
// -------------------------------------------------------------------

// NearestNeighborsIndex

// int32 numberOfDimensions = 1;
inline void NearestNeighborsIndex::clear_numberofdimensions() {
  numberofdimensions_ = 0;
}
inline ::google::protobuf::int32 NearestNeighborsIndex::numberofdimensions() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NearestNeighborsIndex.numberOfDimensions)
  return numberofdimensions_;
}
inline void NearestNeighborsIndex::set_numberofdimensions(::google::protobuf::int32 value) {
  
  numberofdimensions_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.NearestNeighborsIndex.numberOfDimensions)
}

// repeated .CoreML.Specification.FloatVector floatSamples = 2;
inline int NearestNeighborsIndex::floatsamples_size() const {
  return floatsamples_.size();
}
inline void NearestNeighborsIndex::clear_floatsamples() {
  floatsamples_.Clear();
}
inline const ::CoreML::Specification::FloatVector& NearestNeighborsIndex::floatsamples(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NearestNeighborsIndex.floatSamples)
  return floatsamples_.Get(index);
}
inline ::CoreML::Specification::FloatVector* NearestNeighborsIndex::mutable_floatsamples(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NearestNeighborsIndex.floatSamples)
  return floatsamples_.Mutable(index);
}
inline ::CoreML::Specification::FloatVector* NearestNeighborsIndex::add_floatsamples() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.NearestNeighborsIndex.floatSamples)
  return floatsamples_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FloatVector >*
NearestNeighborsIndex::mutable_floatsamples() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.NearestNeighborsIndex.floatSamples)
  return &floatsamples_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FloatVector >&
NearestNeighborsIndex::floatsamples() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.NearestNeighborsIndex.floatSamples)
  return floatsamples_;
}

// .CoreML.Specification.LinearIndex linearIndex = 100;
inline bool NearestNeighborsIndex::has_linearindex() const {
  return IndexType_case() == kLinearIndex;
}
inline void NearestNeighborsIndex::set_has_linearindex() {
  _oneof_case_[0] = kLinearIndex;
}
inline void NearestNeighborsIndex::clear_linearindex() {
  if (has_linearindex()) {
    delete IndexType_.linearindex_;
    clear_has_IndexType();
  }
}
inline  const ::CoreML::Specification::LinearIndex& NearestNeighborsIndex::linearindex() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NearestNeighborsIndex.linearIndex)
  return has_linearindex()
      ? *IndexType_.linearindex_
      : ::CoreML::Specification::LinearIndex::default_instance();
}
inline ::CoreML::Specification::LinearIndex* NearestNeighborsIndex::mutable_linearindex() {
  if (!has_linearindex()) {
    clear_IndexType();
    set_has_linearindex();
    IndexType_.linearindex_ = new ::CoreML::Specification::LinearIndex;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NearestNeighborsIndex.linearIndex)
  return IndexType_.linearindex_;
}
inline ::CoreML::Specification::LinearIndex* NearestNeighborsIndex::release_linearindex() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NearestNeighborsIndex.linearIndex)
  if (has_linearindex()) {
    clear_has_IndexType();
    ::CoreML::Specification::LinearIndex* temp = IndexType_.linearindex_;
    IndexType_.linearindex_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NearestNeighborsIndex::set_allocated_linearindex(::CoreML::Specification::LinearIndex* linearindex) {
  clear_IndexType();
  if (linearindex) {
    set_has_linearindex();
    IndexType_.linearindex_ = linearindex;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NearestNeighborsIndex.linearIndex)
}

// .CoreML.Specification.SingleKdTreeIndex singleKdTreeIndex = 110;
inline bool NearestNeighborsIndex::has_singlekdtreeindex() const {
  return IndexType_case() == kSingleKdTreeIndex;
}
inline void NearestNeighborsIndex::set_has_singlekdtreeindex() {
  _oneof_case_[0] = kSingleKdTreeIndex;
}
inline void NearestNeighborsIndex::clear_singlekdtreeindex() {
  if (has_singlekdtreeindex()) {
    delete IndexType_.singlekdtreeindex_;
    clear_has_IndexType();
  }
}
inline  const ::CoreML::Specification::SingleKdTreeIndex& NearestNeighborsIndex::singlekdtreeindex() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NearestNeighborsIndex.singleKdTreeIndex)
  return has_singlekdtreeindex()
      ? *IndexType_.singlekdtreeindex_
      : ::CoreML::Specification::SingleKdTreeIndex::default_instance();
}
inline ::CoreML::Specification::SingleKdTreeIndex* NearestNeighborsIndex::mutable_singlekdtreeindex() {
  if (!has_singlekdtreeindex()) {
    clear_IndexType();
    set_has_singlekdtreeindex();
    IndexType_.singlekdtreeindex_ = new ::CoreML::Specification::SingleKdTreeIndex;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NearestNeighborsIndex.singleKdTreeIndex)
  return IndexType_.singlekdtreeindex_;
}
inline ::CoreML::Specification::SingleKdTreeIndex* NearestNeighborsIndex::release_singlekdtreeindex() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NearestNeighborsIndex.singleKdTreeIndex)
  if (has_singlekdtreeindex()) {
    clear_has_IndexType();
    ::CoreML::Specification::SingleKdTreeIndex* temp = IndexType_.singlekdtreeindex_;
    IndexType_.singlekdtreeindex_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NearestNeighborsIndex::set_allocated_singlekdtreeindex(::CoreML::Specification::SingleKdTreeIndex* singlekdtreeindex) {
  clear_IndexType();
  if (singlekdtreeindex) {
    set_has_singlekdtreeindex();
    IndexType_.singlekdtreeindex_ = singlekdtreeindex;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NearestNeighborsIndex.singleKdTreeIndex)
}

// .CoreML.Specification.SquaredEuclideanDistance squaredEuclideanDistance = 200;
inline bool NearestNeighborsIndex::has_squaredeuclideandistance() const {
  return DistanceFunction_case() == kSquaredEuclideanDistance;
}
inline void NearestNeighborsIndex::set_has_squaredeuclideandistance() {
  _oneof_case_[1] = kSquaredEuclideanDistance;
}
inline void NearestNeighborsIndex::clear_squaredeuclideandistance() {
  if (has_squaredeuclideandistance()) {
    delete DistanceFunction_.squaredeuclideandistance_;
    clear_has_DistanceFunction();
  }
}
inline  const ::CoreML::Specification::SquaredEuclideanDistance& NearestNeighborsIndex::squaredeuclideandistance() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NearestNeighborsIndex.squaredEuclideanDistance)
  return has_squaredeuclideandistance()
      ? *DistanceFunction_.squaredeuclideandistance_
      : ::CoreML::Specification::SquaredEuclideanDistance::default_instance();
}
inline ::CoreML::Specification::SquaredEuclideanDistance* NearestNeighborsIndex::mutable_squaredeuclideandistance() {
  if (!has_squaredeuclideandistance()) {
    clear_DistanceFunction();
    set_has_squaredeuclideandistance();
    DistanceFunction_.squaredeuclideandistance_ = new ::CoreML::Specification::SquaredEuclideanDistance;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NearestNeighborsIndex.squaredEuclideanDistance)
  return DistanceFunction_.squaredeuclideandistance_;
}
inline ::CoreML::Specification::SquaredEuclideanDistance* NearestNeighborsIndex::release_squaredeuclideandistance() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NearestNeighborsIndex.squaredEuclideanDistance)
  if (has_squaredeuclideandistance()) {
    clear_has_DistanceFunction();
    ::CoreML::Specification::SquaredEuclideanDistance* temp = DistanceFunction_.squaredeuclideandistance_;
    DistanceFunction_.squaredeuclideandistance_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NearestNeighborsIndex::set_allocated_squaredeuclideandistance(::CoreML::Specification::SquaredEuclideanDistance* squaredeuclideandistance) {
  clear_DistanceFunction();
  if (squaredeuclideandistance) {
    set_has_squaredeuclideandistance();
    DistanceFunction_.squaredeuclideandistance_ = squaredeuclideandistance;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NearestNeighborsIndex.squaredEuclideanDistance)
}

inline bool NearestNeighborsIndex::has_IndexType() const {
  return IndexType_case() != INDEXTYPE_NOT_SET;
}
inline void NearestNeighborsIndex::clear_has_IndexType() {
  _oneof_case_[0] = INDEXTYPE_NOT_SET;
}
inline bool NearestNeighborsIndex::has_DistanceFunction() const {
  return DistanceFunction_case() != DISTANCEFUNCTION_NOT_SET;
}
inline void NearestNeighborsIndex::clear_has_DistanceFunction() {
  _oneof_case_[1] = DISTANCEFUNCTION_NOT_SET;
}
inline NearestNeighborsIndex::IndexTypeCase NearestNeighborsIndex::IndexType_case() const {
  return NearestNeighborsIndex::IndexTypeCase(_oneof_case_[0]);
}
inline NearestNeighborsIndex::DistanceFunctionCase NearestNeighborsIndex::DistanceFunction_case() const {
  return NearestNeighborsIndex::DistanceFunctionCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// UniformWeighting

// -------------------------------------------------------------------

// InverseDistanceWeighting

// -------------------------------------------------------------------

// LinearIndex

// -------------------------------------------------------------------

// SingleKdTreeIndex

// int32 leafSize = 1;
inline void SingleKdTreeIndex::clear_leafsize() {
  leafsize_ = 0;
}
inline ::google::protobuf::int32 SingleKdTreeIndex::leafsize() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SingleKdTreeIndex.leafSize)
  return leafsize_;
}
inline void SingleKdTreeIndex::set_leafsize(::google::protobuf::int32 value) {
  
  leafsize_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SingleKdTreeIndex.leafSize)
}

// -------------------------------------------------------------------

// SquaredEuclideanDistance

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace Specification
}  // namespace CoreML

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_NearestNeighbors_2eproto__INCLUDED
