// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Imputer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Imputer_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Imputer_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "DataStructures.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Imputer_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Imputer_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace CoreML {
namespace Specification {
class Imputer;
struct ImputerDefaultTypeInternal;
extern ImputerDefaultTypeInternal _Imputer_default_instance_;
}  // namespace Specification
}  // namespace CoreML
PROTOBUF_NAMESPACE_OPEN
template<> ::CoreML::Specification::Imputer* Arena::CreateMaybeMessage<::CoreML::Specification::Imputer>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace CoreML {
namespace Specification {

// ===================================================================

class Imputer final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.Imputer) */ {
 public:
  inline Imputer() : Imputer(nullptr) {}
  ~Imputer() override;
  explicit constexpr Imputer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Imputer(const Imputer& from);
  Imputer(Imputer&& from) noexcept
    : Imputer() {
    *this = ::std::move(from);
  }

  inline Imputer& operator=(const Imputer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Imputer& operator=(Imputer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Imputer& default_instance() {
    return *internal_default_instance();
  }
  enum ImputedValueCase {
    kImputedDoubleValue = 1,
    kImputedInt64Value = 2,
    kImputedStringValue = 3,
    kImputedDoubleArray = 4,
    kImputedInt64Array = 5,
    kImputedStringDictionary = 6,
    kImputedInt64Dictionary = 7,
    IMPUTEDVALUE_NOT_SET = 0,
  };

  enum ReplaceValueCase {
    kReplaceDoubleValue = 11,
    kReplaceInt64Value = 12,
    kReplaceStringValue = 13,
    REPLACEVALUE_NOT_SET = 0,
  };

  static inline const Imputer* internal_default_instance() {
    return reinterpret_cast<const Imputer*>(
               &_Imputer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Imputer& a, Imputer& b) {
    a.Swap(&b);
  }
  inline void Swap(Imputer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Imputer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Imputer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Imputer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Imputer& from);
  void MergeFrom(const Imputer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Imputer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.Imputer";
  }
  protected:
  explicit Imputer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImputedDoubleValueFieldNumber = 1,
    kImputedInt64ValueFieldNumber = 2,
    kImputedStringValueFieldNumber = 3,
    kImputedDoubleArrayFieldNumber = 4,
    kImputedInt64ArrayFieldNumber = 5,
    kImputedStringDictionaryFieldNumber = 6,
    kImputedInt64DictionaryFieldNumber = 7,
    kReplaceDoubleValueFieldNumber = 11,
    kReplaceInt64ValueFieldNumber = 12,
    kReplaceStringValueFieldNumber = 13,
  };
  // double imputedDoubleValue = 1;
  bool has_imputeddoublevalue() const;
  private:
  bool _internal_has_imputeddoublevalue() const;
  public:
  void clear_imputeddoublevalue();
  double imputeddoublevalue() const;
  void set_imputeddoublevalue(double value);
  private:
  double _internal_imputeddoublevalue() const;
  void _internal_set_imputeddoublevalue(double value);
  public:

  // int64 imputedInt64Value = 2;
  bool has_imputedint64value() const;
  private:
  bool _internal_has_imputedint64value() const;
  public:
  void clear_imputedint64value();
  int64_t imputedint64value() const;
  void set_imputedint64value(int64_t value);
  private:
  int64_t _internal_imputedint64value() const;
  void _internal_set_imputedint64value(int64_t value);
  public:

  // string imputedStringValue = 3;
  bool has_imputedstringvalue() const;
  private:
  bool _internal_has_imputedstringvalue() const;
  public:
  void clear_imputedstringvalue();
  const std::string& imputedstringvalue() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_imputedstringvalue(ArgT0&& arg0, ArgT... args);
  std::string* mutable_imputedstringvalue();
  PROTOBUF_NODISCARD std::string* release_imputedstringvalue();
  void set_allocated_imputedstringvalue(std::string* imputedstringvalue);
  private:
  const std::string& _internal_imputedstringvalue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_imputedstringvalue(const std::string& value);
  std::string* _internal_mutable_imputedstringvalue();
  public:

  // .CoreML.Specification.DoubleVector imputedDoubleArray = 4;
  bool has_imputeddoublearray() const;
  private:
  bool _internal_has_imputeddoublearray() const;
  public:
  void clear_imputeddoublearray();
  const ::CoreML::Specification::DoubleVector& imputeddoublearray() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::DoubleVector* release_imputeddoublearray();
  ::CoreML::Specification::DoubleVector* mutable_imputeddoublearray();
  void set_allocated_imputeddoublearray(::CoreML::Specification::DoubleVector* imputeddoublearray);
  private:
  const ::CoreML::Specification::DoubleVector& _internal_imputeddoublearray() const;
  ::CoreML::Specification::DoubleVector* _internal_mutable_imputeddoublearray();
  public:
  void unsafe_arena_set_allocated_imputeddoublearray(
      ::CoreML::Specification::DoubleVector* imputeddoublearray);
  ::CoreML::Specification::DoubleVector* unsafe_arena_release_imputeddoublearray();

  // .CoreML.Specification.Int64Vector imputedInt64Array = 5;
  bool has_imputedint64array() const;
  private:
  bool _internal_has_imputedint64array() const;
  public:
  void clear_imputedint64array();
  const ::CoreML::Specification::Int64Vector& imputedint64array() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::Int64Vector* release_imputedint64array();
  ::CoreML::Specification::Int64Vector* mutable_imputedint64array();
  void set_allocated_imputedint64array(::CoreML::Specification::Int64Vector* imputedint64array);
  private:
  const ::CoreML::Specification::Int64Vector& _internal_imputedint64array() const;
  ::CoreML::Specification::Int64Vector* _internal_mutable_imputedint64array();
  public:
  void unsafe_arena_set_allocated_imputedint64array(
      ::CoreML::Specification::Int64Vector* imputedint64array);
  ::CoreML::Specification::Int64Vector* unsafe_arena_release_imputedint64array();

  // .CoreML.Specification.StringToDoubleMap imputedStringDictionary = 6;
  bool has_imputedstringdictionary() const;
  private:
  bool _internal_has_imputedstringdictionary() const;
  public:
  void clear_imputedstringdictionary();
  const ::CoreML::Specification::StringToDoubleMap& imputedstringdictionary() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::StringToDoubleMap* release_imputedstringdictionary();
  ::CoreML::Specification::StringToDoubleMap* mutable_imputedstringdictionary();
  void set_allocated_imputedstringdictionary(::CoreML::Specification::StringToDoubleMap* imputedstringdictionary);
  private:
  const ::CoreML::Specification::StringToDoubleMap& _internal_imputedstringdictionary() const;
  ::CoreML::Specification::StringToDoubleMap* _internal_mutable_imputedstringdictionary();
  public:
  void unsafe_arena_set_allocated_imputedstringdictionary(
      ::CoreML::Specification::StringToDoubleMap* imputedstringdictionary);
  ::CoreML::Specification::StringToDoubleMap* unsafe_arena_release_imputedstringdictionary();

  // .CoreML.Specification.Int64ToDoubleMap imputedInt64Dictionary = 7;
  bool has_imputedint64dictionary() const;
  private:
  bool _internal_has_imputedint64dictionary() const;
  public:
  void clear_imputedint64dictionary();
  const ::CoreML::Specification::Int64ToDoubleMap& imputedint64dictionary() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::Int64ToDoubleMap* release_imputedint64dictionary();
  ::CoreML::Specification::Int64ToDoubleMap* mutable_imputedint64dictionary();
  void set_allocated_imputedint64dictionary(::CoreML::Specification::Int64ToDoubleMap* imputedint64dictionary);
  private:
  const ::CoreML::Specification::Int64ToDoubleMap& _internal_imputedint64dictionary() const;
  ::CoreML::Specification::Int64ToDoubleMap* _internal_mutable_imputedint64dictionary();
  public:
  void unsafe_arena_set_allocated_imputedint64dictionary(
      ::CoreML::Specification::Int64ToDoubleMap* imputedint64dictionary);
  ::CoreML::Specification::Int64ToDoubleMap* unsafe_arena_release_imputedint64dictionary();

  // double replaceDoubleValue = 11;
  bool has_replacedoublevalue() const;
  private:
  bool _internal_has_replacedoublevalue() const;
  public:
  void clear_replacedoublevalue();
  double replacedoublevalue() const;
  void set_replacedoublevalue(double value);
  private:
  double _internal_replacedoublevalue() const;
  void _internal_set_replacedoublevalue(double value);
  public:

  // int64 replaceInt64Value = 12;
  bool has_replaceint64value() const;
  private:
  bool _internal_has_replaceint64value() const;
  public:
  void clear_replaceint64value();
  int64_t replaceint64value() const;
  void set_replaceint64value(int64_t value);
  private:
  int64_t _internal_replaceint64value() const;
  void _internal_set_replaceint64value(int64_t value);
  public:

  // string replaceStringValue = 13;
  bool has_replacestringvalue() const;
  private:
  bool _internal_has_replacestringvalue() const;
  public:
  void clear_replacestringvalue();
  const std::string& replacestringvalue() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_replacestringvalue(ArgT0&& arg0, ArgT... args);
  std::string* mutable_replacestringvalue();
  PROTOBUF_NODISCARD std::string* release_replacestringvalue();
  void set_allocated_replacestringvalue(std::string* replacestringvalue);
  private:
  const std::string& _internal_replacestringvalue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_replacestringvalue(const std::string& value);
  std::string* _internal_mutable_replacestringvalue();
  public:

  void clear_ImputedValue();
  ImputedValueCase ImputedValue_case() const;
  void clear_ReplaceValue();
  ReplaceValueCase ReplaceValue_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.Imputer)
 private:
  class _Internal;
  void set_has_imputeddoublevalue();
  void set_has_imputedint64value();
  void set_has_imputedstringvalue();
  void set_has_imputeddoublearray();
  void set_has_imputedint64array();
  void set_has_imputedstringdictionary();
  void set_has_imputedint64dictionary();
  void set_has_replacedoublevalue();
  void set_has_replaceint64value();
  void set_has_replacestringvalue();

  inline bool has_ImputedValue() const;
  inline void clear_has_ImputedValue();

  inline bool has_ReplaceValue() const;
  inline void clear_has_ReplaceValue();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ImputedValueUnion {
    constexpr ImputedValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    double imputeddoublevalue_;
    int64_t imputedint64value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imputedstringvalue_;
    ::CoreML::Specification::DoubleVector* imputeddoublearray_;
    ::CoreML::Specification::Int64Vector* imputedint64array_;
    ::CoreML::Specification::StringToDoubleMap* imputedstringdictionary_;
    ::CoreML::Specification::Int64ToDoubleMap* imputedint64dictionary_;
  } ImputedValue_;
  union ReplaceValueUnion {
    constexpr ReplaceValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    double replacedoublevalue_;
    int64_t replaceint64value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr replacestringvalue_;
  } ReplaceValue_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[2];

  friend struct ::TableStruct_Imputer_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Imputer

// double imputedDoubleValue = 1;
inline bool Imputer::_internal_has_imputeddoublevalue() const {
  return ImputedValue_case() == kImputedDoubleValue;
}
inline bool Imputer::has_imputeddoublevalue() const {
  return _internal_has_imputeddoublevalue();
}
inline void Imputer::set_has_imputeddoublevalue() {
  _oneof_case_[0] = kImputedDoubleValue;
}
inline void Imputer::clear_imputeddoublevalue() {
  if (_internal_has_imputeddoublevalue()) {
    ImputedValue_.imputeddoublevalue_ = 0;
    clear_has_ImputedValue();
  }
}
inline double Imputer::_internal_imputeddoublevalue() const {
  if (_internal_has_imputeddoublevalue()) {
    return ImputedValue_.imputeddoublevalue_;
  }
  return 0;
}
inline void Imputer::_internal_set_imputeddoublevalue(double value) {
  if (!_internal_has_imputeddoublevalue()) {
    clear_ImputedValue();
    set_has_imputeddoublevalue();
  }
  ImputedValue_.imputeddoublevalue_ = value;
}
inline double Imputer::imputeddoublevalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Imputer.imputedDoubleValue)
  return _internal_imputeddoublevalue();
}
inline void Imputer::set_imputeddoublevalue(double value) {
  _internal_set_imputeddoublevalue(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Imputer.imputedDoubleValue)
}

// int64 imputedInt64Value = 2;
inline bool Imputer::_internal_has_imputedint64value() const {
  return ImputedValue_case() == kImputedInt64Value;
}
inline bool Imputer::has_imputedint64value() const {
  return _internal_has_imputedint64value();
}
inline void Imputer::set_has_imputedint64value() {
  _oneof_case_[0] = kImputedInt64Value;
}
inline void Imputer::clear_imputedint64value() {
  if (_internal_has_imputedint64value()) {
    ImputedValue_.imputedint64value_ = int64_t{0};
    clear_has_ImputedValue();
  }
}
inline int64_t Imputer::_internal_imputedint64value() const {
  if (_internal_has_imputedint64value()) {
    return ImputedValue_.imputedint64value_;
  }
  return int64_t{0};
}
inline void Imputer::_internal_set_imputedint64value(int64_t value) {
  if (!_internal_has_imputedint64value()) {
    clear_ImputedValue();
    set_has_imputedint64value();
  }
  ImputedValue_.imputedint64value_ = value;
}
inline int64_t Imputer::imputedint64value() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Imputer.imputedInt64Value)
  return _internal_imputedint64value();
}
inline void Imputer::set_imputedint64value(int64_t value) {
  _internal_set_imputedint64value(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Imputer.imputedInt64Value)
}

// string imputedStringValue = 3;
inline bool Imputer::_internal_has_imputedstringvalue() const {
  return ImputedValue_case() == kImputedStringValue;
}
inline bool Imputer::has_imputedstringvalue() const {
  return _internal_has_imputedstringvalue();
}
inline void Imputer::set_has_imputedstringvalue() {
  _oneof_case_[0] = kImputedStringValue;
}
inline void Imputer::clear_imputedstringvalue() {
  if (_internal_has_imputedstringvalue()) {
    ImputedValue_.imputedstringvalue_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_ImputedValue();
  }
}
inline const std::string& Imputer::imputedstringvalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Imputer.imputedStringValue)
  return _internal_imputedstringvalue();
}
template <typename ArgT0, typename... ArgT>
inline void Imputer::set_imputedstringvalue(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_imputedstringvalue()) {
    clear_ImputedValue();
    set_has_imputedstringvalue();
    ImputedValue_.imputedstringvalue_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  ImputedValue_.imputedstringvalue_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.Imputer.imputedStringValue)
}
inline std::string* Imputer::mutable_imputedstringvalue() {
  std::string* _s = _internal_mutable_imputedstringvalue();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Imputer.imputedStringValue)
  return _s;
}
inline const std::string& Imputer::_internal_imputedstringvalue() const {
  if (_internal_has_imputedstringvalue()) {
    return ImputedValue_.imputedstringvalue_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Imputer::_internal_set_imputedstringvalue(const std::string& value) {
  if (!_internal_has_imputedstringvalue()) {
    clear_ImputedValue();
    set_has_imputedstringvalue();
    ImputedValue_.imputedstringvalue_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  ImputedValue_.imputedstringvalue_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Imputer::_internal_mutable_imputedstringvalue() {
  if (!_internal_has_imputedstringvalue()) {
    clear_ImputedValue();
    set_has_imputedstringvalue();
    ImputedValue_.imputedstringvalue_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return ImputedValue_.imputedstringvalue_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Imputer::release_imputedstringvalue() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Imputer.imputedStringValue)
  if (_internal_has_imputedstringvalue()) {
    clear_has_ImputedValue();
    return ImputedValue_.imputedstringvalue_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Imputer::set_allocated_imputedstringvalue(std::string* imputedstringvalue) {
  if (has_ImputedValue()) {
    clear_ImputedValue();
  }
  if (imputedstringvalue != nullptr) {
    set_has_imputedstringvalue();
    ImputedValue_.imputedstringvalue_.UnsafeSetDefault(imputedstringvalue);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(imputedstringvalue);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Imputer.imputedStringValue)
}

// .CoreML.Specification.DoubleVector imputedDoubleArray = 4;
inline bool Imputer::_internal_has_imputeddoublearray() const {
  return ImputedValue_case() == kImputedDoubleArray;
}
inline bool Imputer::has_imputeddoublearray() const {
  return _internal_has_imputeddoublearray();
}
inline void Imputer::set_has_imputeddoublearray() {
  _oneof_case_[0] = kImputedDoubleArray;
}
inline ::CoreML::Specification::DoubleVector* Imputer::release_imputeddoublearray() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Imputer.imputedDoubleArray)
  if (_internal_has_imputeddoublearray()) {
    clear_has_ImputedValue();
      ::CoreML::Specification::DoubleVector* temp = ImputedValue_.imputeddoublearray_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ImputedValue_.imputeddoublearray_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::DoubleVector& Imputer::_internal_imputeddoublearray() const {
  return _internal_has_imputeddoublearray()
      ? *ImputedValue_.imputeddoublearray_
      : reinterpret_cast< ::CoreML::Specification::DoubleVector&>(::CoreML::Specification::_DoubleVector_default_instance_);
}
inline const ::CoreML::Specification::DoubleVector& Imputer::imputeddoublearray() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Imputer.imputedDoubleArray)
  return _internal_imputeddoublearray();
}
inline ::CoreML::Specification::DoubleVector* Imputer::unsafe_arena_release_imputeddoublearray() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Imputer.imputedDoubleArray)
  if (_internal_has_imputeddoublearray()) {
    clear_has_ImputedValue();
    ::CoreML::Specification::DoubleVector* temp = ImputedValue_.imputeddoublearray_;
    ImputedValue_.imputeddoublearray_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Imputer::unsafe_arena_set_allocated_imputeddoublearray(::CoreML::Specification::DoubleVector* imputeddoublearray) {
  clear_ImputedValue();
  if (imputeddoublearray) {
    set_has_imputeddoublearray();
    ImputedValue_.imputeddoublearray_ = imputeddoublearray;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Imputer.imputedDoubleArray)
}
inline ::CoreML::Specification::DoubleVector* Imputer::_internal_mutable_imputeddoublearray() {
  if (!_internal_has_imputeddoublearray()) {
    clear_ImputedValue();
    set_has_imputeddoublearray();
    ImputedValue_.imputeddoublearray_ = CreateMaybeMessage< ::CoreML::Specification::DoubleVector >(GetArenaForAllocation());
  }
  return ImputedValue_.imputeddoublearray_;
}
inline ::CoreML::Specification::DoubleVector* Imputer::mutable_imputeddoublearray() {
  ::CoreML::Specification::DoubleVector* _msg = _internal_mutable_imputeddoublearray();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Imputer.imputedDoubleArray)
  return _msg;
}

// .CoreML.Specification.Int64Vector imputedInt64Array = 5;
inline bool Imputer::_internal_has_imputedint64array() const {
  return ImputedValue_case() == kImputedInt64Array;
}
inline bool Imputer::has_imputedint64array() const {
  return _internal_has_imputedint64array();
}
inline void Imputer::set_has_imputedint64array() {
  _oneof_case_[0] = kImputedInt64Array;
}
inline ::CoreML::Specification::Int64Vector* Imputer::release_imputedint64array() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Imputer.imputedInt64Array)
  if (_internal_has_imputedint64array()) {
    clear_has_ImputedValue();
      ::CoreML::Specification::Int64Vector* temp = ImputedValue_.imputedint64array_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ImputedValue_.imputedint64array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::Int64Vector& Imputer::_internal_imputedint64array() const {
  return _internal_has_imputedint64array()
      ? *ImputedValue_.imputedint64array_
      : reinterpret_cast< ::CoreML::Specification::Int64Vector&>(::CoreML::Specification::_Int64Vector_default_instance_);
}
inline const ::CoreML::Specification::Int64Vector& Imputer::imputedint64array() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Imputer.imputedInt64Array)
  return _internal_imputedint64array();
}
inline ::CoreML::Specification::Int64Vector* Imputer::unsafe_arena_release_imputedint64array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Imputer.imputedInt64Array)
  if (_internal_has_imputedint64array()) {
    clear_has_ImputedValue();
    ::CoreML::Specification::Int64Vector* temp = ImputedValue_.imputedint64array_;
    ImputedValue_.imputedint64array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Imputer::unsafe_arena_set_allocated_imputedint64array(::CoreML::Specification::Int64Vector* imputedint64array) {
  clear_ImputedValue();
  if (imputedint64array) {
    set_has_imputedint64array();
    ImputedValue_.imputedint64array_ = imputedint64array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Imputer.imputedInt64Array)
}
inline ::CoreML::Specification::Int64Vector* Imputer::_internal_mutable_imputedint64array() {
  if (!_internal_has_imputedint64array()) {
    clear_ImputedValue();
    set_has_imputedint64array();
    ImputedValue_.imputedint64array_ = CreateMaybeMessage< ::CoreML::Specification::Int64Vector >(GetArenaForAllocation());
  }
  return ImputedValue_.imputedint64array_;
}
inline ::CoreML::Specification::Int64Vector* Imputer::mutable_imputedint64array() {
  ::CoreML::Specification::Int64Vector* _msg = _internal_mutable_imputedint64array();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Imputer.imputedInt64Array)
  return _msg;
}

// .CoreML.Specification.StringToDoubleMap imputedStringDictionary = 6;
inline bool Imputer::_internal_has_imputedstringdictionary() const {
  return ImputedValue_case() == kImputedStringDictionary;
}
inline bool Imputer::has_imputedstringdictionary() const {
  return _internal_has_imputedstringdictionary();
}
inline void Imputer::set_has_imputedstringdictionary() {
  _oneof_case_[0] = kImputedStringDictionary;
}
inline ::CoreML::Specification::StringToDoubleMap* Imputer::release_imputedstringdictionary() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Imputer.imputedStringDictionary)
  if (_internal_has_imputedstringdictionary()) {
    clear_has_ImputedValue();
      ::CoreML::Specification::StringToDoubleMap* temp = ImputedValue_.imputedstringdictionary_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ImputedValue_.imputedstringdictionary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::StringToDoubleMap& Imputer::_internal_imputedstringdictionary() const {
  return _internal_has_imputedstringdictionary()
      ? *ImputedValue_.imputedstringdictionary_
      : reinterpret_cast< ::CoreML::Specification::StringToDoubleMap&>(::CoreML::Specification::_StringToDoubleMap_default_instance_);
}
inline const ::CoreML::Specification::StringToDoubleMap& Imputer::imputedstringdictionary() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Imputer.imputedStringDictionary)
  return _internal_imputedstringdictionary();
}
inline ::CoreML::Specification::StringToDoubleMap* Imputer::unsafe_arena_release_imputedstringdictionary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Imputer.imputedStringDictionary)
  if (_internal_has_imputedstringdictionary()) {
    clear_has_ImputedValue();
    ::CoreML::Specification::StringToDoubleMap* temp = ImputedValue_.imputedstringdictionary_;
    ImputedValue_.imputedstringdictionary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Imputer::unsafe_arena_set_allocated_imputedstringdictionary(::CoreML::Specification::StringToDoubleMap* imputedstringdictionary) {
  clear_ImputedValue();
  if (imputedstringdictionary) {
    set_has_imputedstringdictionary();
    ImputedValue_.imputedstringdictionary_ = imputedstringdictionary;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Imputer.imputedStringDictionary)
}
inline ::CoreML::Specification::StringToDoubleMap* Imputer::_internal_mutable_imputedstringdictionary() {
  if (!_internal_has_imputedstringdictionary()) {
    clear_ImputedValue();
    set_has_imputedstringdictionary();
    ImputedValue_.imputedstringdictionary_ = CreateMaybeMessage< ::CoreML::Specification::StringToDoubleMap >(GetArenaForAllocation());
  }
  return ImputedValue_.imputedstringdictionary_;
}
inline ::CoreML::Specification::StringToDoubleMap* Imputer::mutable_imputedstringdictionary() {
  ::CoreML::Specification::StringToDoubleMap* _msg = _internal_mutable_imputedstringdictionary();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Imputer.imputedStringDictionary)
  return _msg;
}

// .CoreML.Specification.Int64ToDoubleMap imputedInt64Dictionary = 7;
inline bool Imputer::_internal_has_imputedint64dictionary() const {
  return ImputedValue_case() == kImputedInt64Dictionary;
}
inline bool Imputer::has_imputedint64dictionary() const {
  return _internal_has_imputedint64dictionary();
}
inline void Imputer::set_has_imputedint64dictionary() {
  _oneof_case_[0] = kImputedInt64Dictionary;
}
inline ::CoreML::Specification::Int64ToDoubleMap* Imputer::release_imputedint64dictionary() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Imputer.imputedInt64Dictionary)
  if (_internal_has_imputedint64dictionary()) {
    clear_has_ImputedValue();
      ::CoreML::Specification::Int64ToDoubleMap* temp = ImputedValue_.imputedint64dictionary_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ImputedValue_.imputedint64dictionary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::Int64ToDoubleMap& Imputer::_internal_imputedint64dictionary() const {
  return _internal_has_imputedint64dictionary()
      ? *ImputedValue_.imputedint64dictionary_
      : reinterpret_cast< ::CoreML::Specification::Int64ToDoubleMap&>(::CoreML::Specification::_Int64ToDoubleMap_default_instance_);
}
inline const ::CoreML::Specification::Int64ToDoubleMap& Imputer::imputedint64dictionary() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Imputer.imputedInt64Dictionary)
  return _internal_imputedint64dictionary();
}
inline ::CoreML::Specification::Int64ToDoubleMap* Imputer::unsafe_arena_release_imputedint64dictionary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Imputer.imputedInt64Dictionary)
  if (_internal_has_imputedint64dictionary()) {
    clear_has_ImputedValue();
    ::CoreML::Specification::Int64ToDoubleMap* temp = ImputedValue_.imputedint64dictionary_;
    ImputedValue_.imputedint64dictionary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Imputer::unsafe_arena_set_allocated_imputedint64dictionary(::CoreML::Specification::Int64ToDoubleMap* imputedint64dictionary) {
  clear_ImputedValue();
  if (imputedint64dictionary) {
    set_has_imputedint64dictionary();
    ImputedValue_.imputedint64dictionary_ = imputedint64dictionary;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Imputer.imputedInt64Dictionary)
}
inline ::CoreML::Specification::Int64ToDoubleMap* Imputer::_internal_mutable_imputedint64dictionary() {
  if (!_internal_has_imputedint64dictionary()) {
    clear_ImputedValue();
    set_has_imputedint64dictionary();
    ImputedValue_.imputedint64dictionary_ = CreateMaybeMessage< ::CoreML::Specification::Int64ToDoubleMap >(GetArenaForAllocation());
  }
  return ImputedValue_.imputedint64dictionary_;
}
inline ::CoreML::Specification::Int64ToDoubleMap* Imputer::mutable_imputedint64dictionary() {
  ::CoreML::Specification::Int64ToDoubleMap* _msg = _internal_mutable_imputedint64dictionary();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Imputer.imputedInt64Dictionary)
  return _msg;
}

// double replaceDoubleValue = 11;
inline bool Imputer::_internal_has_replacedoublevalue() const {
  return ReplaceValue_case() == kReplaceDoubleValue;
}
inline bool Imputer::has_replacedoublevalue() const {
  return _internal_has_replacedoublevalue();
}
inline void Imputer::set_has_replacedoublevalue() {
  _oneof_case_[1] = kReplaceDoubleValue;
}
inline void Imputer::clear_replacedoublevalue() {
  if (_internal_has_replacedoublevalue()) {
    ReplaceValue_.replacedoublevalue_ = 0;
    clear_has_ReplaceValue();
  }
}
inline double Imputer::_internal_replacedoublevalue() const {
  if (_internal_has_replacedoublevalue()) {
    return ReplaceValue_.replacedoublevalue_;
  }
  return 0;
}
inline void Imputer::_internal_set_replacedoublevalue(double value) {
  if (!_internal_has_replacedoublevalue()) {
    clear_ReplaceValue();
    set_has_replacedoublevalue();
  }
  ReplaceValue_.replacedoublevalue_ = value;
}
inline double Imputer::replacedoublevalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Imputer.replaceDoubleValue)
  return _internal_replacedoublevalue();
}
inline void Imputer::set_replacedoublevalue(double value) {
  _internal_set_replacedoublevalue(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Imputer.replaceDoubleValue)
}

// int64 replaceInt64Value = 12;
inline bool Imputer::_internal_has_replaceint64value() const {
  return ReplaceValue_case() == kReplaceInt64Value;
}
inline bool Imputer::has_replaceint64value() const {
  return _internal_has_replaceint64value();
}
inline void Imputer::set_has_replaceint64value() {
  _oneof_case_[1] = kReplaceInt64Value;
}
inline void Imputer::clear_replaceint64value() {
  if (_internal_has_replaceint64value()) {
    ReplaceValue_.replaceint64value_ = int64_t{0};
    clear_has_ReplaceValue();
  }
}
inline int64_t Imputer::_internal_replaceint64value() const {
  if (_internal_has_replaceint64value()) {
    return ReplaceValue_.replaceint64value_;
  }
  return int64_t{0};
}
inline void Imputer::_internal_set_replaceint64value(int64_t value) {
  if (!_internal_has_replaceint64value()) {
    clear_ReplaceValue();
    set_has_replaceint64value();
  }
  ReplaceValue_.replaceint64value_ = value;
}
inline int64_t Imputer::replaceint64value() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Imputer.replaceInt64Value)
  return _internal_replaceint64value();
}
inline void Imputer::set_replaceint64value(int64_t value) {
  _internal_set_replaceint64value(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Imputer.replaceInt64Value)
}

// string replaceStringValue = 13;
inline bool Imputer::_internal_has_replacestringvalue() const {
  return ReplaceValue_case() == kReplaceStringValue;
}
inline bool Imputer::has_replacestringvalue() const {
  return _internal_has_replacestringvalue();
}
inline void Imputer::set_has_replacestringvalue() {
  _oneof_case_[1] = kReplaceStringValue;
}
inline void Imputer::clear_replacestringvalue() {
  if (_internal_has_replacestringvalue()) {
    ReplaceValue_.replacestringvalue_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_ReplaceValue();
  }
}
inline const std::string& Imputer::replacestringvalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Imputer.replaceStringValue)
  return _internal_replacestringvalue();
}
template <typename ArgT0, typename... ArgT>
inline void Imputer::set_replacestringvalue(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_replacestringvalue()) {
    clear_ReplaceValue();
    set_has_replacestringvalue();
    ReplaceValue_.replacestringvalue_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  ReplaceValue_.replacestringvalue_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.Imputer.replaceStringValue)
}
inline std::string* Imputer::mutable_replacestringvalue() {
  std::string* _s = _internal_mutable_replacestringvalue();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Imputer.replaceStringValue)
  return _s;
}
inline const std::string& Imputer::_internal_replacestringvalue() const {
  if (_internal_has_replacestringvalue()) {
    return ReplaceValue_.replacestringvalue_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Imputer::_internal_set_replacestringvalue(const std::string& value) {
  if (!_internal_has_replacestringvalue()) {
    clear_ReplaceValue();
    set_has_replacestringvalue();
    ReplaceValue_.replacestringvalue_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  ReplaceValue_.replacestringvalue_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Imputer::_internal_mutable_replacestringvalue() {
  if (!_internal_has_replacestringvalue()) {
    clear_ReplaceValue();
    set_has_replacestringvalue();
    ReplaceValue_.replacestringvalue_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return ReplaceValue_.replacestringvalue_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Imputer::release_replacestringvalue() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Imputer.replaceStringValue)
  if (_internal_has_replacestringvalue()) {
    clear_has_ReplaceValue();
    return ReplaceValue_.replacestringvalue_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Imputer::set_allocated_replacestringvalue(std::string* replacestringvalue) {
  if (has_ReplaceValue()) {
    clear_ReplaceValue();
  }
  if (replacestringvalue != nullptr) {
    set_has_replacestringvalue();
    ReplaceValue_.replacestringvalue_.UnsafeSetDefault(replacestringvalue);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(replacestringvalue);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Imputer.replaceStringValue)
}

inline bool Imputer::has_ImputedValue() const {
  return ImputedValue_case() != IMPUTEDVALUE_NOT_SET;
}
inline void Imputer::clear_has_ImputedValue() {
  _oneof_case_[0] = IMPUTEDVALUE_NOT_SET;
}
inline bool Imputer::has_ReplaceValue() const {
  return ReplaceValue_case() != REPLACEVALUE_NOT_SET;
}
inline void Imputer::clear_has_ReplaceValue() {
  _oneof_case_[1] = REPLACEVALUE_NOT_SET;
}
inline Imputer::ImputedValueCase Imputer::ImputedValue_case() const {
  return Imputer::ImputedValueCase(_oneof_case_[0]);
}
inline Imputer::ReplaceValueCase Imputer::ReplaceValue_case() const {
  return Imputer::ReplaceValueCase(_oneof_case_[1]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace Specification
}  // namespace CoreML

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Imputer_2eproto
