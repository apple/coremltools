// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Model.proto

#include "Model.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace CoreML {
namespace Specification {
constexpr Pipeline::Pipeline(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : models_()
  , names_(){}
struct PipelineDefaultTypeInternal {
  constexpr PipelineDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PipelineDefaultTypeInternal() {}
  union {
    Pipeline _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PipelineDefaultTypeInternal _Pipeline_default_instance_;
constexpr PipelineClassifier::PipelineClassifier(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : pipeline_(nullptr){}
struct PipelineClassifierDefaultTypeInternal {
  constexpr PipelineClassifierDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PipelineClassifierDefaultTypeInternal() {}
  union {
    PipelineClassifier _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PipelineClassifierDefaultTypeInternal _PipelineClassifier_default_instance_;
constexpr PipelineRegressor::PipelineRegressor(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : pipeline_(nullptr){}
struct PipelineRegressorDefaultTypeInternal {
  constexpr PipelineRegressorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PipelineRegressorDefaultTypeInternal() {}
  union {
    PipelineRegressor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PipelineRegressorDefaultTypeInternal _PipelineRegressor_default_instance_;
constexpr FeatureDescription::FeatureDescription(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , shortdescription_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , type_(nullptr){}
struct FeatureDescriptionDefaultTypeInternal {
  constexpr FeatureDescriptionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FeatureDescriptionDefaultTypeInternal() {}
  union {
    FeatureDescription _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FeatureDescriptionDefaultTypeInternal _FeatureDescription_default_instance_;
constexpr Metadata_UserDefinedEntry_DoNotUse::Metadata_UserDefinedEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct Metadata_UserDefinedEntry_DoNotUseDefaultTypeInternal {
  constexpr Metadata_UserDefinedEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Metadata_UserDefinedEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Metadata_UserDefinedEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Metadata_UserDefinedEntry_DoNotUseDefaultTypeInternal _Metadata_UserDefinedEntry_DoNotUse_default_instance_;
constexpr Metadata::Metadata(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : userdefined_()
  , shortdescription_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , versionstring_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , author_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , license_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct MetadataDefaultTypeInternal {
  constexpr MetadataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MetadataDefaultTypeInternal() {}
  union {
    Metadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MetadataDefaultTypeInternal _Metadata_default_instance_;
constexpr FunctionDescription::FunctionDescription(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : input_()
  , output_()
  , state_()
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , predictedfeaturename_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , predictedprobabilitiesname_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct FunctionDescriptionDefaultTypeInternal {
  constexpr FunctionDescriptionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FunctionDescriptionDefaultTypeInternal() {}
  union {
    FunctionDescription _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FunctionDescriptionDefaultTypeInternal _FunctionDescription_default_instance_;
constexpr ModelDescription::ModelDescription(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : input_()
  , output_()
  , state_()
  , functions_()
  , traininginput_()
  , predictedfeaturename_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , predictedprobabilitiesname_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , defaultfunctionname_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , metadata_(nullptr){}
struct ModelDescriptionDefaultTypeInternal {
  constexpr ModelDescriptionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelDescriptionDefaultTypeInternal() {}
  union {
    ModelDescription _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelDescriptionDefaultTypeInternal _ModelDescription_default_instance_;
constexpr SerializedModel::SerializedModel(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : identifier_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , model_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct SerializedModelDefaultTypeInternal {
  constexpr SerializedModelDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SerializedModelDefaultTypeInternal() {}
  union {
    SerializedModel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SerializedModelDefaultTypeInternal _SerializedModel_default_instance_;
constexpr Model::Model(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : description_(nullptr)
  , specificationversion_(0)
  , isupdatable_(false)
  , _oneof_case_{}{}
struct ModelDefaultTypeInternal {
  constexpr ModelDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelDefaultTypeInternal() {}
  union {
    Model _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelDefaultTypeInternal _Model_default_instance_;
}  // namespace Specification
}  // namespace CoreML
namespace CoreML {
namespace Specification {

// ===================================================================

class Pipeline::_Internal {
 public:
};

Pipeline::Pipeline(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  models_(arena),
  names_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.Pipeline)
}
Pipeline::Pipeline(const Pipeline& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      models_(from.models_),
      names_(from.names_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Pipeline)
}

inline void Pipeline::SharedCtor() {
}

Pipeline::~Pipeline() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Pipeline)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Pipeline::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Pipeline::ArenaDtor(void* object) {
  Pipeline* _this = reinterpret_cast< Pipeline* >(object);
  (void)_this;
}
void Pipeline::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Pipeline::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Pipeline::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Pipeline)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  models_.Clear();
  names_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Pipeline::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.Model models = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_models(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string names = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_names();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Pipeline::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.Pipeline)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.Model models = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_models_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_models(i), target, stream);
  }

  // repeated string names = 2;
  for (int i = 0, n = this->_internal_names_size(); i < n; i++) {
    const auto& s = this->_internal_names(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.Pipeline.names");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.Pipeline)
  return target;
}

size_t Pipeline::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Pipeline)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.Model models = 1;
  total_size += 1UL * this->_internal_models_size();
  for (const auto& msg : this->models_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string names = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(names_.size());
  for (int i = 0, n = names_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      names_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Pipeline::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Pipeline*>(
      &from));
}

void Pipeline::MergeFrom(const Pipeline& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Pipeline)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  models_.MergeFrom(from.models_);
  names_.MergeFrom(from.names_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Pipeline::CopyFrom(const Pipeline& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Pipeline)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pipeline::IsInitialized() const {
  return true;
}

void Pipeline::InternalSwap(Pipeline* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  models_.InternalSwap(&other->models_);
  names_.InternalSwap(&other->names_);
}

std::string Pipeline::GetTypeName() const {
  return "CoreML.Specification.Pipeline";
}


// ===================================================================

class PipelineClassifier::_Internal {
 public:
  static const ::CoreML::Specification::Pipeline& pipeline(const PipelineClassifier* msg);
};

const ::CoreML::Specification::Pipeline&
PipelineClassifier::_Internal::pipeline(const PipelineClassifier* msg) {
  return *msg->pipeline_;
}
PipelineClassifier::PipelineClassifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.PipelineClassifier)
}
PipelineClassifier::PipelineClassifier(const PipelineClassifier& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_pipeline()) {
    pipeline_ = new ::CoreML::Specification::Pipeline(*from.pipeline_);
  } else {
    pipeline_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.PipelineClassifier)
}

inline void PipelineClassifier::SharedCtor() {
pipeline_ = nullptr;
}

PipelineClassifier::~PipelineClassifier() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.PipelineClassifier)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PipelineClassifier::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete pipeline_;
}

void PipelineClassifier::ArenaDtor(void* object) {
  PipelineClassifier* _this = reinterpret_cast< PipelineClassifier* >(object);
  (void)_this;
}
void PipelineClassifier::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PipelineClassifier::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PipelineClassifier::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.PipelineClassifier)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && pipeline_ != nullptr) {
    delete pipeline_;
  }
  pipeline_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* PipelineClassifier::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.Pipeline pipeline = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pipeline(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PipelineClassifier::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.PipelineClassifier)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.Pipeline pipeline = 1;
  if (this->_internal_has_pipeline()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::pipeline(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.PipelineClassifier)
  return target;
}

size_t PipelineClassifier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.PipelineClassifier)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.Pipeline pipeline = 1;
  if (this->_internal_has_pipeline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pipeline_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PipelineClassifier::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PipelineClassifier*>(
      &from));
}

void PipelineClassifier::MergeFrom(const PipelineClassifier& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.PipelineClassifier)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pipeline()) {
    _internal_mutable_pipeline()->::CoreML::Specification::Pipeline::MergeFrom(from._internal_pipeline());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PipelineClassifier::CopyFrom(const PipelineClassifier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.PipelineClassifier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PipelineClassifier::IsInitialized() const {
  return true;
}

void PipelineClassifier::InternalSwap(PipelineClassifier* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(pipeline_, other->pipeline_);
}

std::string PipelineClassifier::GetTypeName() const {
  return "CoreML.Specification.PipelineClassifier";
}


// ===================================================================

class PipelineRegressor::_Internal {
 public:
  static const ::CoreML::Specification::Pipeline& pipeline(const PipelineRegressor* msg);
};

const ::CoreML::Specification::Pipeline&
PipelineRegressor::_Internal::pipeline(const PipelineRegressor* msg) {
  return *msg->pipeline_;
}
PipelineRegressor::PipelineRegressor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.PipelineRegressor)
}
PipelineRegressor::PipelineRegressor(const PipelineRegressor& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_pipeline()) {
    pipeline_ = new ::CoreML::Specification::Pipeline(*from.pipeline_);
  } else {
    pipeline_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.PipelineRegressor)
}

inline void PipelineRegressor::SharedCtor() {
pipeline_ = nullptr;
}

PipelineRegressor::~PipelineRegressor() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.PipelineRegressor)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PipelineRegressor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete pipeline_;
}

void PipelineRegressor::ArenaDtor(void* object) {
  PipelineRegressor* _this = reinterpret_cast< PipelineRegressor* >(object);
  (void)_this;
}
void PipelineRegressor::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PipelineRegressor::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PipelineRegressor::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.PipelineRegressor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && pipeline_ != nullptr) {
    delete pipeline_;
  }
  pipeline_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* PipelineRegressor::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.Pipeline pipeline = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pipeline(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PipelineRegressor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.PipelineRegressor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.Pipeline pipeline = 1;
  if (this->_internal_has_pipeline()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::pipeline(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.PipelineRegressor)
  return target;
}

size_t PipelineRegressor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.PipelineRegressor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.Pipeline pipeline = 1;
  if (this->_internal_has_pipeline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pipeline_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PipelineRegressor::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PipelineRegressor*>(
      &from));
}

void PipelineRegressor::MergeFrom(const PipelineRegressor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.PipelineRegressor)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pipeline()) {
    _internal_mutable_pipeline()->::CoreML::Specification::Pipeline::MergeFrom(from._internal_pipeline());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PipelineRegressor::CopyFrom(const PipelineRegressor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.PipelineRegressor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PipelineRegressor::IsInitialized() const {
  return true;
}

void PipelineRegressor::InternalSwap(PipelineRegressor* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(pipeline_, other->pipeline_);
}

std::string PipelineRegressor::GetTypeName() const {
  return "CoreML.Specification.PipelineRegressor";
}


// ===================================================================

class FeatureDescription::_Internal {
 public:
  static const ::CoreML::Specification::FeatureType& type(const FeatureDescription* msg);
};

const ::CoreML::Specification::FeatureType&
FeatureDescription::_Internal::type(const FeatureDescription* msg) {
  return *msg->type_;
}
void FeatureDescription::clear_type() {
  if (GetArenaForAllocation() == nullptr && type_ != nullptr) {
    delete type_;
  }
  type_ = nullptr;
}
FeatureDescription::FeatureDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.FeatureDescription)
}
FeatureDescription::FeatureDescription(const FeatureDescription& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  shortdescription_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    shortdescription_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_shortdescription().empty()) {
    shortdescription_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_shortdescription(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_type()) {
    type_ = new ::CoreML::Specification::FeatureType(*from.type_);
  } else {
    type_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.FeatureDescription)
}

inline void FeatureDescription::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
shortdescription_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  shortdescription_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
type_ = nullptr;
}

FeatureDescription::~FeatureDescription() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.FeatureDescription)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FeatureDescription::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  shortdescription_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete type_;
}

void FeatureDescription::ArenaDtor(void* object) {
  FeatureDescription* _this = reinterpret_cast< FeatureDescription* >(object);
  (void)_this;
}
void FeatureDescription::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FeatureDescription::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FeatureDescription::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.FeatureDescription)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  shortdescription_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && type_ != nullptr) {
    delete type_;
  }
  type_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* FeatureDescription::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string shortDescription = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_shortdescription();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.FeatureType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FeatureDescription::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.FeatureDescription)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.FeatureDescription.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string shortDescription = 2;
  if (!this->_internal_shortdescription().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_shortdescription().data(), static_cast<int>(this->_internal_shortdescription().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.FeatureDescription.shortDescription");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_shortdescription(), target);
  }

  // .CoreML.Specification.FeatureType type = 3;
  if (this->_internal_has_type()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::type(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.FeatureDescription)
  return target;
}

size_t FeatureDescription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.FeatureDescription)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string shortDescription = 2;
  if (!this->_internal_shortdescription().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_shortdescription());
  }

  // .CoreML.Specification.FeatureType type = 3;
  if (this->_internal_has_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *type_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FeatureDescription::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FeatureDescription*>(
      &from));
}

void FeatureDescription::MergeFrom(const FeatureDescription& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.FeatureDescription)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (!from._internal_shortdescription().empty()) {
    _internal_set_shortdescription(from._internal_shortdescription());
  }
  if (from._internal_has_type()) {
    _internal_mutable_type()->::CoreML::Specification::FeatureType::MergeFrom(from._internal_type());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FeatureDescription::CopyFrom(const FeatureDescription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.FeatureDescription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeatureDescription::IsInitialized() const {
  return true;
}

void FeatureDescription::InternalSwap(FeatureDescription* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &shortdescription_, lhs_arena,
      &other->shortdescription_, rhs_arena
  );
  swap(type_, other->type_);
}

std::string FeatureDescription::GetTypeName() const {
  return "CoreML.Specification.FeatureDescription";
}


// ===================================================================

Metadata_UserDefinedEntry_DoNotUse::Metadata_UserDefinedEntry_DoNotUse() {}
Metadata_UserDefinedEntry_DoNotUse::Metadata_UserDefinedEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Metadata_UserDefinedEntry_DoNotUse::MergeFrom(const Metadata_UserDefinedEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class Metadata::_Internal {
 public:
};

Metadata::Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  userdefined_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.Metadata)
}
Metadata::Metadata(const Metadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  userdefined_.MergeFrom(from.userdefined_);
  shortdescription_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    shortdescription_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_shortdescription().empty()) {
    shortdescription_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_shortdescription(), 
      GetArenaForAllocation());
  }
  versionstring_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    versionstring_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_versionstring().empty()) {
    versionstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_versionstring(), 
      GetArenaForAllocation());
  }
  author_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    author_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_author().empty()) {
    author_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_author(), 
      GetArenaForAllocation());
  }
  license_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    license_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_license().empty()) {
    license_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_license(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Metadata)
}

inline void Metadata::SharedCtor() {
shortdescription_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  shortdescription_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
versionstring_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  versionstring_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
author_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  author_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
license_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  license_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Metadata::~Metadata() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Metadata)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Metadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  shortdescription_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  versionstring_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  author_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  license_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Metadata::ArenaDtor(void* object) {
  Metadata* _this = reinterpret_cast< Metadata* >(object);
  (void)_this;
}
void Metadata::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Metadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Metadata::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Metadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  userdefined_.Clear();
  shortdescription_.ClearToEmpty();
  versionstring_.ClearToEmpty();
  author_.ClearToEmpty();
  license_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* Metadata::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string shortDescription = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_shortdescription();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string versionString = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_versionstring();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string author = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_author();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string license = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_license();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> userDefined = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(&userdefined_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<802>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Metadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.Metadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string shortDescription = 1;
  if (!this->_internal_shortdescription().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_shortdescription().data(), static_cast<int>(this->_internal_shortdescription().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.Metadata.shortDescription");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_shortdescription(), target);
  }

  // string versionString = 2;
  if (!this->_internal_versionstring().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_versionstring().data(), static_cast<int>(this->_internal_versionstring().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.Metadata.versionString");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_versionstring(), target);
  }

  // string author = 3;
  if (!this->_internal_author().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_author().data(), static_cast<int>(this->_internal_author().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.Metadata.author");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_author(), target);
  }

  // string license = 4;
  if (!this->_internal_license().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_license().data(), static_cast<int>(this->_internal_license().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.Metadata.license");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_license(), target);
  }

  // map<string, string> userDefined = 100;
  if (!this->_internal_userdefined().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.Metadata.UserDefinedEntry.key");
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->second.data(), static_cast<int>(p->second.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.Metadata.UserDefinedEntry.value");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_userdefined().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_userdefined().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_userdefined().begin();
          it != this->_internal_userdefined().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = Metadata_UserDefinedEntry_DoNotUse::Funcs::InternalSerialize(100, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_userdefined().begin();
          it != this->_internal_userdefined().end(); ++it) {
        target = Metadata_UserDefinedEntry_DoNotUse::Funcs::InternalSerialize(100, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.Metadata)
  return target;
}

size_t Metadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Metadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> userDefined = 100;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_userdefined_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_userdefined().begin();
      it != this->_internal_userdefined().end(); ++it) {
    total_size += Metadata_UserDefinedEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string shortDescription = 1;
  if (!this->_internal_shortdescription().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_shortdescription());
  }

  // string versionString = 2;
  if (!this->_internal_versionstring().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_versionstring());
  }

  // string author = 3;
  if (!this->_internal_author().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_author());
  }

  // string license = 4;
  if (!this->_internal_license().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_license());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Metadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Metadata*>(
      &from));
}

void Metadata::MergeFrom(const Metadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Metadata)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  userdefined_.MergeFrom(from.userdefined_);
  if (!from._internal_shortdescription().empty()) {
    _internal_set_shortdescription(from._internal_shortdescription());
  }
  if (!from._internal_versionstring().empty()) {
    _internal_set_versionstring(from._internal_versionstring());
  }
  if (!from._internal_author().empty()) {
    _internal_set_author(from._internal_author());
  }
  if (!from._internal_license().empty()) {
    _internal_set_license(from._internal_license());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Metadata::CopyFrom(const Metadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Metadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Metadata::IsInitialized() const {
  return true;
}

void Metadata::InternalSwap(Metadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  userdefined_.InternalSwap(&other->userdefined_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &shortdescription_, lhs_arena,
      &other->shortdescription_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &versionstring_, lhs_arena,
      &other->versionstring_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &author_, lhs_arena,
      &other->author_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &license_, lhs_arena,
      &other->license_, rhs_arena
  );
}

std::string Metadata::GetTypeName() const {
  return "CoreML.Specification.Metadata";
}


// ===================================================================

class FunctionDescription::_Internal {
 public:
};

FunctionDescription::FunctionDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  input_(arena),
  output_(arena),
  state_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.FunctionDescription)
}
FunctionDescription::FunctionDescription(const FunctionDescription& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      input_(from.input_),
      output_(from.output_),
      state_(from.state_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  predictedfeaturename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    predictedfeaturename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_predictedfeaturename().empty()) {
    predictedfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_predictedfeaturename(), 
      GetArenaForAllocation());
  }
  predictedprobabilitiesname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    predictedprobabilitiesname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_predictedprobabilitiesname().empty()) {
    predictedprobabilitiesname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_predictedprobabilitiesname(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.FunctionDescription)
}

inline void FunctionDescription::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
predictedfeaturename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  predictedfeaturename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
predictedprobabilitiesname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  predictedprobabilitiesname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FunctionDescription::~FunctionDescription() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.FunctionDescription)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FunctionDescription::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  predictedfeaturename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  predictedprobabilitiesname_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void FunctionDescription::ArenaDtor(void* object) {
  FunctionDescription* _this = reinterpret_cast< FunctionDescription* >(object);
  (void)_this;
}
void FunctionDescription::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FunctionDescription::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FunctionDescription::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.FunctionDescription)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  input_.Clear();
  output_.Clear();
  state_.Clear();
  name_.ClearToEmpty();
  predictedfeaturename_.ClearToEmpty();
  predictedprobabilitiesname_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* FunctionDescription::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.FeatureDescription input = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_input(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.FeatureDescription output = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_output(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string predictedFeatureName = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_predictedfeaturename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string predictedProbabilitiesName = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_predictedprobabilitiesname();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.FeatureDescription state = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_state(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FunctionDescription::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.FunctionDescription)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.FunctionDescription.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated .CoreML.Specification.FeatureDescription input = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_input_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_input(i), target, stream);
  }

  // repeated .CoreML.Specification.FeatureDescription output = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_output_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_output(i), target, stream);
  }

  // string predictedFeatureName = 4;
  if (!this->_internal_predictedfeaturename().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_predictedfeaturename().data(), static_cast<int>(this->_internal_predictedfeaturename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.FunctionDescription.predictedFeatureName");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_predictedfeaturename(), target);
  }

  // string predictedProbabilitiesName = 5;
  if (!this->_internal_predictedprobabilitiesname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_predictedprobabilitiesname().data(), static_cast<int>(this->_internal_predictedprobabilitiesname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.FunctionDescription.predictedProbabilitiesName");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_predictedprobabilitiesname(), target);
  }

  // repeated .CoreML.Specification.FeatureDescription state = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_state_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_state(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.FunctionDescription)
  return target;
}

size_t FunctionDescription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.FunctionDescription)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.FeatureDescription input = 2;
  total_size += 1UL * this->_internal_input_size();
  for (const auto& msg : this->input_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CoreML.Specification.FeatureDescription output = 3;
  total_size += 1UL * this->_internal_output_size();
  for (const auto& msg : this->output_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CoreML.Specification.FeatureDescription state = 6;
  total_size += 1UL * this->_internal_state_size();
  for (const auto& msg : this->state_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string predictedFeatureName = 4;
  if (!this->_internal_predictedfeaturename().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_predictedfeaturename());
  }

  // string predictedProbabilitiesName = 5;
  if (!this->_internal_predictedprobabilitiesname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_predictedprobabilitiesname());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FunctionDescription::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FunctionDescription*>(
      &from));
}

void FunctionDescription::MergeFrom(const FunctionDescription& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.FunctionDescription)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  input_.MergeFrom(from.input_);
  output_.MergeFrom(from.output_);
  state_.MergeFrom(from.state_);
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (!from._internal_predictedfeaturename().empty()) {
    _internal_set_predictedfeaturename(from._internal_predictedfeaturename());
  }
  if (!from._internal_predictedprobabilitiesname().empty()) {
    _internal_set_predictedprobabilitiesname(from._internal_predictedprobabilitiesname());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FunctionDescription::CopyFrom(const FunctionDescription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.FunctionDescription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FunctionDescription::IsInitialized() const {
  return true;
}

void FunctionDescription::InternalSwap(FunctionDescription* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  input_.InternalSwap(&other->input_);
  output_.InternalSwap(&other->output_);
  state_.InternalSwap(&other->state_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &predictedfeaturename_, lhs_arena,
      &other->predictedfeaturename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &predictedprobabilitiesname_, lhs_arena,
      &other->predictedprobabilitiesname_, rhs_arena
  );
}

std::string FunctionDescription::GetTypeName() const {
  return "CoreML.Specification.FunctionDescription";
}


// ===================================================================

class ModelDescription::_Internal {
 public:
  static const ::CoreML::Specification::Metadata& metadata(const ModelDescription* msg);
};

const ::CoreML::Specification::Metadata&
ModelDescription::_Internal::metadata(const ModelDescription* msg) {
  return *msg->metadata_;
}
ModelDescription::ModelDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  input_(arena),
  output_(arena),
  state_(arena),
  functions_(arena),
  traininginput_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ModelDescription)
}
ModelDescription::ModelDescription(const ModelDescription& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      input_(from.input_),
      output_(from.output_),
      state_(from.state_),
      functions_(from.functions_),
      traininginput_(from.traininginput_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  predictedfeaturename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    predictedfeaturename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_predictedfeaturename().empty()) {
    predictedfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_predictedfeaturename(), 
      GetArenaForAllocation());
  }
  predictedprobabilitiesname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    predictedprobabilitiesname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_predictedprobabilitiesname().empty()) {
    predictedprobabilitiesname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_predictedprobabilitiesname(), 
      GetArenaForAllocation());
  }
  defaultfunctionname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    defaultfunctionname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_defaultfunctionname().empty()) {
    defaultfunctionname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_defaultfunctionname(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_metadata()) {
    metadata_ = new ::CoreML::Specification::Metadata(*from.metadata_);
  } else {
    metadata_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ModelDescription)
}

inline void ModelDescription::SharedCtor() {
predictedfeaturename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  predictedfeaturename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
predictedprobabilitiesname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  predictedprobabilitiesname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
defaultfunctionname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  defaultfunctionname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
metadata_ = nullptr;
}

ModelDescription::~ModelDescription() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ModelDescription)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ModelDescription::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  predictedfeaturename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  predictedprobabilitiesname_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  defaultfunctionname_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete metadata_;
}

void ModelDescription::ArenaDtor(void* object) {
  ModelDescription* _this = reinterpret_cast< ModelDescription* >(object);
  (void)_this;
}
void ModelDescription::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelDescription::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelDescription::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ModelDescription)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  input_.Clear();
  output_.Clear();
  state_.Clear();
  functions_.Clear();
  traininginput_.Clear();
  predictedfeaturename_.ClearToEmpty();
  predictedprobabilitiesname_.ClearToEmpty();
  defaultfunctionname_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* ModelDescription::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.FeatureDescription input = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_input(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.FeatureDescription output = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_output(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string predictedFeatureName = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_predictedfeaturename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string predictedProbabilitiesName = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_predictedprobabilitiesname();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.FeatureDescription state = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_state(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.FunctionDescription functions = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_functions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string defaultFunctionName = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_defaultfunctionname();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.FeatureDescription trainingInput = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_traininginput(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<402>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Metadata metadata = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelDescription::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ModelDescription)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.FeatureDescription input = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_input_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_input(i), target, stream);
  }

  // repeated .CoreML.Specification.FeatureDescription output = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_output_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_output(i), target, stream);
  }

  // string predictedFeatureName = 11;
  if (!this->_internal_predictedfeaturename().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_predictedfeaturename().data(), static_cast<int>(this->_internal_predictedfeaturename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.ModelDescription.predictedFeatureName");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_predictedfeaturename(), target);
  }

  // string predictedProbabilitiesName = 12;
  if (!this->_internal_predictedprobabilitiesname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_predictedprobabilitiesname().data(), static_cast<int>(this->_internal_predictedprobabilitiesname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.ModelDescription.predictedProbabilitiesName");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_predictedprobabilitiesname(), target);
  }

  // repeated .CoreML.Specification.FeatureDescription state = 13;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_state_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, this->_internal_state(i), target, stream);
  }

  // repeated .CoreML.Specification.FunctionDescription functions = 20;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_functions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, this->_internal_functions(i), target, stream);
  }

  // string defaultFunctionName = 21;
  if (!this->_internal_defaultfunctionname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_defaultfunctionname().data(), static_cast<int>(this->_internal_defaultfunctionname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.ModelDescription.defaultFunctionName");
    target = stream->WriteStringMaybeAliased(
        21, this->_internal_defaultfunctionname(), target);
  }

  // repeated .CoreML.Specification.FeatureDescription trainingInput = 50;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_traininginput_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(50, this->_internal_traininginput(i), target, stream);
  }

  // .CoreML.Specification.Metadata metadata = 100;
  if (this->_internal_has_metadata()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        100, _Internal::metadata(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ModelDescription)
  return target;
}

size_t ModelDescription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ModelDescription)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.FeatureDescription input = 1;
  total_size += 1UL * this->_internal_input_size();
  for (const auto& msg : this->input_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CoreML.Specification.FeatureDescription output = 10;
  total_size += 1UL * this->_internal_output_size();
  for (const auto& msg : this->output_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CoreML.Specification.FeatureDescription state = 13;
  total_size += 1UL * this->_internal_state_size();
  for (const auto& msg : this->state_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CoreML.Specification.FunctionDescription functions = 20;
  total_size += 2UL * this->_internal_functions_size();
  for (const auto& msg : this->functions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CoreML.Specification.FeatureDescription trainingInput = 50;
  total_size += 2UL * this->_internal_traininginput_size();
  for (const auto& msg : this->traininginput_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string predictedFeatureName = 11;
  if (!this->_internal_predictedfeaturename().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_predictedfeaturename());
  }

  // string predictedProbabilitiesName = 12;
  if (!this->_internal_predictedprobabilitiesname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_predictedprobabilitiesname());
  }

  // string defaultFunctionName = 21;
  if (!this->_internal_defaultfunctionname().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_defaultfunctionname());
  }

  // .CoreML.Specification.Metadata metadata = 100;
  if (this->_internal_has_metadata()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *metadata_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ModelDescription::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ModelDescription*>(
      &from));
}

void ModelDescription::MergeFrom(const ModelDescription& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ModelDescription)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  input_.MergeFrom(from.input_);
  output_.MergeFrom(from.output_);
  state_.MergeFrom(from.state_);
  functions_.MergeFrom(from.functions_);
  traininginput_.MergeFrom(from.traininginput_);
  if (!from._internal_predictedfeaturename().empty()) {
    _internal_set_predictedfeaturename(from._internal_predictedfeaturename());
  }
  if (!from._internal_predictedprobabilitiesname().empty()) {
    _internal_set_predictedprobabilitiesname(from._internal_predictedprobabilitiesname());
  }
  if (!from._internal_defaultfunctionname().empty()) {
    _internal_set_defaultfunctionname(from._internal_defaultfunctionname());
  }
  if (from._internal_has_metadata()) {
    _internal_mutable_metadata()->::CoreML::Specification::Metadata::MergeFrom(from._internal_metadata());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ModelDescription::CopyFrom(const ModelDescription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ModelDescription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelDescription::IsInitialized() const {
  return true;
}

void ModelDescription::InternalSwap(ModelDescription* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  input_.InternalSwap(&other->input_);
  output_.InternalSwap(&other->output_);
  state_.InternalSwap(&other->state_);
  functions_.InternalSwap(&other->functions_);
  traininginput_.InternalSwap(&other->traininginput_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &predictedfeaturename_, lhs_arena,
      &other->predictedfeaturename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &predictedprobabilitiesname_, lhs_arena,
      &other->predictedprobabilitiesname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &defaultfunctionname_, lhs_arena,
      &other->defaultfunctionname_, rhs_arena
  );
  swap(metadata_, other->metadata_);
}

std::string ModelDescription::GetTypeName() const {
  return "CoreML.Specification.ModelDescription";
}


// ===================================================================

class SerializedModel::_Internal {
 public:
};

SerializedModel::SerializedModel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SerializedModel)
}
SerializedModel::SerializedModel(const SerializedModel& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  identifier_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_identifier().empty()) {
    identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_identifier(), 
      GetArenaForAllocation());
  }
  model_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_model().empty()) {
    model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_model(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SerializedModel)
}

inline void SerializedModel::SharedCtor() {
identifier_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SerializedModel::~SerializedModel() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SerializedModel)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SerializedModel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  identifier_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  model_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SerializedModel::ArenaDtor(void* object) {
  SerializedModel* _this = reinterpret_cast< SerializedModel* >(object);
  (void)_this;
}
void SerializedModel::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SerializedModel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SerializedModel::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SerializedModel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  identifier_.ClearToEmpty();
  model_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* SerializedModel::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_identifier();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes model = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_model();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SerializedModel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SerializedModel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string identifier = 1;
  if (!this->_internal_identifier().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_identifier().data(), static_cast<int>(this->_internal_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.SerializedModel.identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_identifier(), target);
  }

  // bytes model = 2;
  if (!this->_internal_model().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_model(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SerializedModel)
  return target;
}

size_t SerializedModel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SerializedModel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string identifier = 1;
  if (!this->_internal_identifier().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_identifier());
  }

  // bytes model = 2;
  if (!this->_internal_model().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_model());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SerializedModel::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SerializedModel*>(
      &from));
}

void SerializedModel::MergeFrom(const SerializedModel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SerializedModel)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_identifier().empty()) {
    _internal_set_identifier(from._internal_identifier());
  }
  if (!from._internal_model().empty()) {
    _internal_set_model(from._internal_model());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SerializedModel::CopyFrom(const SerializedModel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SerializedModel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SerializedModel::IsInitialized() const {
  return true;
}

void SerializedModel::InternalSwap(SerializedModel* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &identifier_, lhs_arena,
      &other->identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &model_, lhs_arena,
      &other->model_, rhs_arena
  );
}

std::string SerializedModel::GetTypeName() const {
  return "CoreML.Specification.SerializedModel";
}


// ===================================================================

class Model::_Internal {
 public:
  static const ::CoreML::Specification::ModelDescription& description(const Model* msg);
  static const ::CoreML::Specification::PipelineClassifier& pipelineclassifier(const Model* msg);
  static const ::CoreML::Specification::PipelineRegressor& pipelineregressor(const Model* msg);
  static const ::CoreML::Specification::Pipeline& pipeline(const Model* msg);
  static const ::CoreML::Specification::GLMRegressor& glmregressor(const Model* msg);
  static const ::CoreML::Specification::SupportVectorRegressor& supportvectorregressor(const Model* msg);
  static const ::CoreML::Specification::TreeEnsembleRegressor& treeensembleregressor(const Model* msg);
  static const ::CoreML::Specification::NeuralNetworkRegressor& neuralnetworkregressor(const Model* msg);
  static const ::CoreML::Specification::BayesianProbitRegressor& bayesianprobitregressor(const Model* msg);
  static const ::CoreML::Specification::GLMClassifier& glmclassifier(const Model* msg);
  static const ::CoreML::Specification::SupportVectorClassifier& supportvectorclassifier(const Model* msg);
  static const ::CoreML::Specification::TreeEnsembleClassifier& treeensembleclassifier(const Model* msg);
  static const ::CoreML::Specification::NeuralNetworkClassifier& neuralnetworkclassifier(const Model* msg);
  static const ::CoreML::Specification::KNearestNeighborsClassifier& knearestneighborsclassifier(const Model* msg);
  static const ::CoreML::Specification::NeuralNetwork& neuralnetwork(const Model* msg);
  static const ::CoreML::Specification::ItemSimilarityRecommender& itemsimilarityrecommender(const Model* msg);
  static const ::CoreML::Specification::MILSpec::Program& mlprogram(const Model* msg);
  static const ::CoreML::Specification::CustomModel& custommodel(const Model* msg);
  static const ::CoreML::Specification::LinkedModel& linkedmodel(const Model* msg);
  static const ::CoreML::Specification::ClassConfidenceThresholding& classconfidencethresholding(const Model* msg);
  static const ::CoreML::Specification::OneHotEncoder& onehotencoder(const Model* msg);
  static const ::CoreML::Specification::Imputer& imputer(const Model* msg);
  static const ::CoreML::Specification::FeatureVectorizer& featurevectorizer(const Model* msg);
  static const ::CoreML::Specification::DictVectorizer& dictvectorizer(const Model* msg);
  static const ::CoreML::Specification::Scaler& scaler(const Model* msg);
  static const ::CoreML::Specification::CategoricalMapping& categoricalmapping(const Model* msg);
  static const ::CoreML::Specification::Normalizer& normalizer(const Model* msg);
  static const ::CoreML::Specification::ArrayFeatureExtractor& arrayfeatureextractor(const Model* msg);
  static const ::CoreML::Specification::NonMaximumSuppression& nonmaximumsuppression(const Model* msg);
  static const ::CoreML::Specification::Identity& identity(const Model* msg);
  static const ::CoreML::Specification::CoreMLModels::TextClassifier& textclassifier(const Model* msg);
  static const ::CoreML::Specification::CoreMLModels::WordTagger& wordtagger(const Model* msg);
  static const ::CoreML::Specification::CoreMLModels::VisionFeaturePrint& visionfeatureprint(const Model* msg);
  static const ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing& soundanalysispreprocessing(const Model* msg);
  static const ::CoreML::Specification::CoreMLModels::Gazetteer& gazetteer(const Model* msg);
  static const ::CoreML::Specification::CoreMLModels::WordEmbedding& wordembedding(const Model* msg);
  static const ::CoreML::Specification::CoreMLModels::AudioFeaturePrint& audiofeatureprint(const Model* msg);
  static const ::CoreML::Specification::SerializedModel& serializedmodel(const Model* msg);
};

const ::CoreML::Specification::ModelDescription&
Model::_Internal::description(const Model* msg) {
  return *msg->description_;
}
const ::CoreML::Specification::PipelineClassifier&
Model::_Internal::pipelineclassifier(const Model* msg) {
  return *msg->Type_.pipelineclassifier_;
}
const ::CoreML::Specification::PipelineRegressor&
Model::_Internal::pipelineregressor(const Model* msg) {
  return *msg->Type_.pipelineregressor_;
}
const ::CoreML::Specification::Pipeline&
Model::_Internal::pipeline(const Model* msg) {
  return *msg->Type_.pipeline_;
}
const ::CoreML::Specification::GLMRegressor&
Model::_Internal::glmregressor(const Model* msg) {
  return *msg->Type_.glmregressor_;
}
const ::CoreML::Specification::SupportVectorRegressor&
Model::_Internal::supportvectorregressor(const Model* msg) {
  return *msg->Type_.supportvectorregressor_;
}
const ::CoreML::Specification::TreeEnsembleRegressor&
Model::_Internal::treeensembleregressor(const Model* msg) {
  return *msg->Type_.treeensembleregressor_;
}
const ::CoreML::Specification::NeuralNetworkRegressor&
Model::_Internal::neuralnetworkregressor(const Model* msg) {
  return *msg->Type_.neuralnetworkregressor_;
}
const ::CoreML::Specification::BayesianProbitRegressor&
Model::_Internal::bayesianprobitregressor(const Model* msg) {
  return *msg->Type_.bayesianprobitregressor_;
}
const ::CoreML::Specification::GLMClassifier&
Model::_Internal::glmclassifier(const Model* msg) {
  return *msg->Type_.glmclassifier_;
}
const ::CoreML::Specification::SupportVectorClassifier&
Model::_Internal::supportvectorclassifier(const Model* msg) {
  return *msg->Type_.supportvectorclassifier_;
}
const ::CoreML::Specification::TreeEnsembleClassifier&
Model::_Internal::treeensembleclassifier(const Model* msg) {
  return *msg->Type_.treeensembleclassifier_;
}
const ::CoreML::Specification::NeuralNetworkClassifier&
Model::_Internal::neuralnetworkclassifier(const Model* msg) {
  return *msg->Type_.neuralnetworkclassifier_;
}
const ::CoreML::Specification::KNearestNeighborsClassifier&
Model::_Internal::knearestneighborsclassifier(const Model* msg) {
  return *msg->Type_.knearestneighborsclassifier_;
}
const ::CoreML::Specification::NeuralNetwork&
Model::_Internal::neuralnetwork(const Model* msg) {
  return *msg->Type_.neuralnetwork_;
}
const ::CoreML::Specification::ItemSimilarityRecommender&
Model::_Internal::itemsimilarityrecommender(const Model* msg) {
  return *msg->Type_.itemsimilarityrecommender_;
}
const ::CoreML::Specification::MILSpec::Program&
Model::_Internal::mlprogram(const Model* msg) {
  return *msg->Type_.mlprogram_;
}
const ::CoreML::Specification::CustomModel&
Model::_Internal::custommodel(const Model* msg) {
  return *msg->Type_.custommodel_;
}
const ::CoreML::Specification::LinkedModel&
Model::_Internal::linkedmodel(const Model* msg) {
  return *msg->Type_.linkedmodel_;
}
const ::CoreML::Specification::ClassConfidenceThresholding&
Model::_Internal::classconfidencethresholding(const Model* msg) {
  return *msg->Type_.classconfidencethresholding_;
}
const ::CoreML::Specification::OneHotEncoder&
Model::_Internal::onehotencoder(const Model* msg) {
  return *msg->Type_.onehotencoder_;
}
const ::CoreML::Specification::Imputer&
Model::_Internal::imputer(const Model* msg) {
  return *msg->Type_.imputer_;
}
const ::CoreML::Specification::FeatureVectorizer&
Model::_Internal::featurevectorizer(const Model* msg) {
  return *msg->Type_.featurevectorizer_;
}
const ::CoreML::Specification::DictVectorizer&
Model::_Internal::dictvectorizer(const Model* msg) {
  return *msg->Type_.dictvectorizer_;
}
const ::CoreML::Specification::Scaler&
Model::_Internal::scaler(const Model* msg) {
  return *msg->Type_.scaler_;
}
const ::CoreML::Specification::CategoricalMapping&
Model::_Internal::categoricalmapping(const Model* msg) {
  return *msg->Type_.categoricalmapping_;
}
const ::CoreML::Specification::Normalizer&
Model::_Internal::normalizer(const Model* msg) {
  return *msg->Type_.normalizer_;
}
const ::CoreML::Specification::ArrayFeatureExtractor&
Model::_Internal::arrayfeatureextractor(const Model* msg) {
  return *msg->Type_.arrayfeatureextractor_;
}
const ::CoreML::Specification::NonMaximumSuppression&
Model::_Internal::nonmaximumsuppression(const Model* msg) {
  return *msg->Type_.nonmaximumsuppression_;
}
const ::CoreML::Specification::Identity&
Model::_Internal::identity(const Model* msg) {
  return *msg->Type_.identity_;
}
const ::CoreML::Specification::CoreMLModels::TextClassifier&
Model::_Internal::textclassifier(const Model* msg) {
  return *msg->Type_.textclassifier_;
}
const ::CoreML::Specification::CoreMLModels::WordTagger&
Model::_Internal::wordtagger(const Model* msg) {
  return *msg->Type_.wordtagger_;
}
const ::CoreML::Specification::CoreMLModels::VisionFeaturePrint&
Model::_Internal::visionfeatureprint(const Model* msg) {
  return *msg->Type_.visionfeatureprint_;
}
const ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing&
Model::_Internal::soundanalysispreprocessing(const Model* msg) {
  return *msg->Type_.soundanalysispreprocessing_;
}
const ::CoreML::Specification::CoreMLModels::Gazetteer&
Model::_Internal::gazetteer(const Model* msg) {
  return *msg->Type_.gazetteer_;
}
const ::CoreML::Specification::CoreMLModels::WordEmbedding&
Model::_Internal::wordembedding(const Model* msg) {
  return *msg->Type_.wordembedding_;
}
const ::CoreML::Specification::CoreMLModels::AudioFeaturePrint&
Model::_Internal::audiofeatureprint(const Model* msg) {
  return *msg->Type_.audiofeatureprint_;
}
const ::CoreML::Specification::SerializedModel&
Model::_Internal::serializedmodel(const Model* msg) {
  return *msg->Type_.serializedmodel_;
}
void Model::set_allocated_pipelineclassifier(::CoreML::Specification::PipelineClassifier* pipelineclassifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (pipelineclassifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::PipelineClassifier>::GetOwningArena(pipelineclassifier);
    if (message_arena != submessage_arena) {
      pipelineclassifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pipelineclassifier, submessage_arena);
    }
    set_has_pipelineclassifier();
    Type_.pipelineclassifier_ = pipelineclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.pipelineClassifier)
}
void Model::set_allocated_pipelineregressor(::CoreML::Specification::PipelineRegressor* pipelineregressor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (pipelineregressor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::PipelineRegressor>::GetOwningArena(pipelineregressor);
    if (message_arena != submessage_arena) {
      pipelineregressor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pipelineregressor, submessage_arena);
    }
    set_has_pipelineregressor();
    Type_.pipelineregressor_ = pipelineregressor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.pipelineRegressor)
}
void Model::set_allocated_pipeline(::CoreML::Specification::Pipeline* pipeline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (pipeline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::Pipeline>::GetOwningArena(pipeline);
    if (message_arena != submessage_arena) {
      pipeline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pipeline, submessage_arena);
    }
    set_has_pipeline();
    Type_.pipeline_ = pipeline;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.pipeline)
}
void Model::set_allocated_glmregressor(::CoreML::Specification::GLMRegressor* glmregressor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (glmregressor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(glmregressor));
    if (message_arena != submessage_arena) {
      glmregressor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, glmregressor, submessage_arena);
    }
    set_has_glmregressor();
    Type_.glmregressor_ = glmregressor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.glmRegressor)
}
void Model::clear_glmregressor() {
  if (_internal_has_glmregressor()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.glmregressor_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_supportvectorregressor(::CoreML::Specification::SupportVectorRegressor* supportvectorregressor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (supportvectorregressor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(supportvectorregressor));
    if (message_arena != submessage_arena) {
      supportvectorregressor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, supportvectorregressor, submessage_arena);
    }
    set_has_supportvectorregressor();
    Type_.supportvectorregressor_ = supportvectorregressor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.supportVectorRegressor)
}
void Model::clear_supportvectorregressor() {
  if (_internal_has_supportvectorregressor()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.supportvectorregressor_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_treeensembleregressor(::CoreML::Specification::TreeEnsembleRegressor* treeensembleregressor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (treeensembleregressor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(treeensembleregressor));
    if (message_arena != submessage_arena) {
      treeensembleregressor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, treeensembleregressor, submessage_arena);
    }
    set_has_treeensembleregressor();
    Type_.treeensembleregressor_ = treeensembleregressor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.treeEnsembleRegressor)
}
void Model::clear_treeensembleregressor() {
  if (_internal_has_treeensembleregressor()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.treeensembleregressor_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_neuralnetworkregressor(::CoreML::Specification::NeuralNetworkRegressor* neuralnetworkregressor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (neuralnetworkregressor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(neuralnetworkregressor));
    if (message_arena != submessage_arena) {
      neuralnetworkregressor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neuralnetworkregressor, submessage_arena);
    }
    set_has_neuralnetworkregressor();
    Type_.neuralnetworkregressor_ = neuralnetworkregressor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.neuralNetworkRegressor)
}
void Model::clear_neuralnetworkregressor() {
  if (_internal_has_neuralnetworkregressor()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.neuralnetworkregressor_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_bayesianprobitregressor(::CoreML::Specification::BayesianProbitRegressor* bayesianprobitregressor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (bayesianprobitregressor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bayesianprobitregressor));
    if (message_arena != submessage_arena) {
      bayesianprobitregressor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bayesianprobitregressor, submessage_arena);
    }
    set_has_bayesianprobitregressor();
    Type_.bayesianprobitregressor_ = bayesianprobitregressor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.bayesianProbitRegressor)
}
void Model::clear_bayesianprobitregressor() {
  if (_internal_has_bayesianprobitregressor()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.bayesianprobitregressor_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_glmclassifier(::CoreML::Specification::GLMClassifier* glmclassifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (glmclassifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(glmclassifier));
    if (message_arena != submessage_arena) {
      glmclassifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, glmclassifier, submessage_arena);
    }
    set_has_glmclassifier();
    Type_.glmclassifier_ = glmclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.glmClassifier)
}
void Model::clear_glmclassifier() {
  if (_internal_has_glmclassifier()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.glmclassifier_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_supportvectorclassifier(::CoreML::Specification::SupportVectorClassifier* supportvectorclassifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (supportvectorclassifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(supportvectorclassifier));
    if (message_arena != submessage_arena) {
      supportvectorclassifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, supportvectorclassifier, submessage_arena);
    }
    set_has_supportvectorclassifier();
    Type_.supportvectorclassifier_ = supportvectorclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.supportVectorClassifier)
}
void Model::clear_supportvectorclassifier() {
  if (_internal_has_supportvectorclassifier()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.supportvectorclassifier_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_treeensembleclassifier(::CoreML::Specification::TreeEnsembleClassifier* treeensembleclassifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (treeensembleclassifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(treeensembleclassifier));
    if (message_arena != submessage_arena) {
      treeensembleclassifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, treeensembleclassifier, submessage_arena);
    }
    set_has_treeensembleclassifier();
    Type_.treeensembleclassifier_ = treeensembleclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.treeEnsembleClassifier)
}
void Model::clear_treeensembleclassifier() {
  if (_internal_has_treeensembleclassifier()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.treeensembleclassifier_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_neuralnetworkclassifier(::CoreML::Specification::NeuralNetworkClassifier* neuralnetworkclassifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (neuralnetworkclassifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(neuralnetworkclassifier));
    if (message_arena != submessage_arena) {
      neuralnetworkclassifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neuralnetworkclassifier, submessage_arena);
    }
    set_has_neuralnetworkclassifier();
    Type_.neuralnetworkclassifier_ = neuralnetworkclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.neuralNetworkClassifier)
}
void Model::clear_neuralnetworkclassifier() {
  if (_internal_has_neuralnetworkclassifier()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.neuralnetworkclassifier_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_knearestneighborsclassifier(::CoreML::Specification::KNearestNeighborsClassifier* knearestneighborsclassifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (knearestneighborsclassifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(knearestneighborsclassifier));
    if (message_arena != submessage_arena) {
      knearestneighborsclassifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, knearestneighborsclassifier, submessage_arena);
    }
    set_has_knearestneighborsclassifier();
    Type_.knearestneighborsclassifier_ = knearestneighborsclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.kNearestNeighborsClassifier)
}
void Model::clear_knearestneighborsclassifier() {
  if (_internal_has_knearestneighborsclassifier()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.knearestneighborsclassifier_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_neuralnetwork(::CoreML::Specification::NeuralNetwork* neuralnetwork) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (neuralnetwork) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(neuralnetwork));
    if (message_arena != submessage_arena) {
      neuralnetwork = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neuralnetwork, submessage_arena);
    }
    set_has_neuralnetwork();
    Type_.neuralnetwork_ = neuralnetwork;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.neuralNetwork)
}
void Model::clear_neuralnetwork() {
  if (_internal_has_neuralnetwork()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.neuralnetwork_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_itemsimilarityrecommender(::CoreML::Specification::ItemSimilarityRecommender* itemsimilarityrecommender) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (itemsimilarityrecommender) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(itemsimilarityrecommender));
    if (message_arena != submessage_arena) {
      itemsimilarityrecommender = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, itemsimilarityrecommender, submessage_arena);
    }
    set_has_itemsimilarityrecommender();
    Type_.itemsimilarityrecommender_ = itemsimilarityrecommender;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.itemSimilarityRecommender)
}
void Model::clear_itemsimilarityrecommender() {
  if (_internal_has_itemsimilarityrecommender()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.itemsimilarityrecommender_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_mlprogram(::CoreML::Specification::MILSpec::Program* mlprogram) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (mlprogram) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mlprogram));
    if (message_arena != submessage_arena) {
      mlprogram = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mlprogram, submessage_arena);
    }
    set_has_mlprogram();
    Type_.mlprogram_ = mlprogram;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.mlProgram)
}
void Model::clear_mlprogram() {
  if (_internal_has_mlprogram()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.mlprogram_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_custommodel(::CoreML::Specification::CustomModel* custommodel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (custommodel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(custommodel));
    if (message_arena != submessage_arena) {
      custommodel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, custommodel, submessage_arena);
    }
    set_has_custommodel();
    Type_.custommodel_ = custommodel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.customModel)
}
void Model::clear_custommodel() {
  if (_internal_has_custommodel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.custommodel_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_linkedmodel(::CoreML::Specification::LinkedModel* linkedmodel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (linkedmodel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(linkedmodel));
    if (message_arena != submessage_arena) {
      linkedmodel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linkedmodel, submessage_arena);
    }
    set_has_linkedmodel();
    Type_.linkedmodel_ = linkedmodel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.linkedModel)
}
void Model::clear_linkedmodel() {
  if (_internal_has_linkedmodel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.linkedmodel_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_classconfidencethresholding(::CoreML::Specification::ClassConfidenceThresholding* classconfidencethresholding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (classconfidencethresholding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(classconfidencethresholding));
    if (message_arena != submessage_arena) {
      classconfidencethresholding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, classconfidencethresholding, submessage_arena);
    }
    set_has_classconfidencethresholding();
    Type_.classconfidencethresholding_ = classconfidencethresholding;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.classConfidenceThresholding)
}
void Model::clear_classconfidencethresholding() {
  if (_internal_has_classconfidencethresholding()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.classconfidencethresholding_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_onehotencoder(::CoreML::Specification::OneHotEncoder* onehotencoder) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (onehotencoder) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(onehotencoder));
    if (message_arena != submessage_arena) {
      onehotencoder = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, onehotencoder, submessage_arena);
    }
    set_has_onehotencoder();
    Type_.onehotencoder_ = onehotencoder;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.oneHotEncoder)
}
void Model::clear_onehotencoder() {
  if (_internal_has_onehotencoder()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.onehotencoder_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_imputer(::CoreML::Specification::Imputer* imputer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (imputer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(imputer));
    if (message_arena != submessage_arena) {
      imputer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imputer, submessage_arena);
    }
    set_has_imputer();
    Type_.imputer_ = imputer;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.imputer)
}
void Model::clear_imputer() {
  if (_internal_has_imputer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.imputer_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_featurevectorizer(::CoreML::Specification::FeatureVectorizer* featurevectorizer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (featurevectorizer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(featurevectorizer));
    if (message_arena != submessage_arena) {
      featurevectorizer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, featurevectorizer, submessage_arena);
    }
    set_has_featurevectorizer();
    Type_.featurevectorizer_ = featurevectorizer;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.featureVectorizer)
}
void Model::clear_featurevectorizer() {
  if (_internal_has_featurevectorizer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.featurevectorizer_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_dictvectorizer(::CoreML::Specification::DictVectorizer* dictvectorizer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (dictvectorizer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dictvectorizer));
    if (message_arena != submessage_arena) {
      dictvectorizer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dictvectorizer, submessage_arena);
    }
    set_has_dictvectorizer();
    Type_.dictvectorizer_ = dictvectorizer;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.dictVectorizer)
}
void Model::clear_dictvectorizer() {
  if (_internal_has_dictvectorizer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.dictvectorizer_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_scaler(::CoreML::Specification::Scaler* scaler) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (scaler) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scaler));
    if (message_arena != submessage_arena) {
      scaler = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scaler, submessage_arena);
    }
    set_has_scaler();
    Type_.scaler_ = scaler;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.scaler)
}
void Model::clear_scaler() {
  if (_internal_has_scaler()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.scaler_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_categoricalmapping(::CoreML::Specification::CategoricalMapping* categoricalmapping) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (categoricalmapping) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(categoricalmapping));
    if (message_arena != submessage_arena) {
      categoricalmapping = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, categoricalmapping, submessage_arena);
    }
    set_has_categoricalmapping();
    Type_.categoricalmapping_ = categoricalmapping;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.categoricalMapping)
}
void Model::clear_categoricalmapping() {
  if (_internal_has_categoricalmapping()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.categoricalmapping_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_normalizer(::CoreML::Specification::Normalizer* normalizer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (normalizer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(normalizer));
    if (message_arena != submessage_arena) {
      normalizer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, normalizer, submessage_arena);
    }
    set_has_normalizer();
    Type_.normalizer_ = normalizer;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.normalizer)
}
void Model::clear_normalizer() {
  if (_internal_has_normalizer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.normalizer_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_arrayfeatureextractor(::CoreML::Specification::ArrayFeatureExtractor* arrayfeatureextractor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (arrayfeatureextractor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(arrayfeatureextractor));
    if (message_arena != submessage_arena) {
      arrayfeatureextractor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arrayfeatureextractor, submessage_arena);
    }
    set_has_arrayfeatureextractor();
    Type_.arrayfeatureextractor_ = arrayfeatureextractor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.arrayFeatureExtractor)
}
void Model::clear_arrayfeatureextractor() {
  if (_internal_has_arrayfeatureextractor()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.arrayfeatureextractor_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_nonmaximumsuppression(::CoreML::Specification::NonMaximumSuppression* nonmaximumsuppression) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (nonmaximumsuppression) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nonmaximumsuppression));
    if (message_arena != submessage_arena) {
      nonmaximumsuppression = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nonmaximumsuppression, submessage_arena);
    }
    set_has_nonmaximumsuppression();
    Type_.nonmaximumsuppression_ = nonmaximumsuppression;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.nonMaximumSuppression)
}
void Model::clear_nonmaximumsuppression() {
  if (_internal_has_nonmaximumsuppression()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.nonmaximumsuppression_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_identity(::CoreML::Specification::Identity* identity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (identity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(identity));
    if (message_arena != submessage_arena) {
      identity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identity, submessage_arena);
    }
    set_has_identity();
    Type_.identity_ = identity;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.identity)
}
void Model::clear_identity() {
  if (_internal_has_identity()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.identity_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_textclassifier(::CoreML::Specification::CoreMLModels::TextClassifier* textclassifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (textclassifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(textclassifier));
    if (message_arena != submessage_arena) {
      textclassifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, textclassifier, submessage_arena);
    }
    set_has_textclassifier();
    Type_.textclassifier_ = textclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.textClassifier)
}
void Model::clear_textclassifier() {
  if (_internal_has_textclassifier()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.textclassifier_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_wordtagger(::CoreML::Specification::CoreMLModels::WordTagger* wordtagger) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (wordtagger) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wordtagger));
    if (message_arena != submessage_arena) {
      wordtagger = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wordtagger, submessage_arena);
    }
    set_has_wordtagger();
    Type_.wordtagger_ = wordtagger;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.wordTagger)
}
void Model::clear_wordtagger() {
  if (_internal_has_wordtagger()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.wordtagger_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_visionfeatureprint(::CoreML::Specification::CoreMLModels::VisionFeaturePrint* visionfeatureprint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (visionfeatureprint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(visionfeatureprint));
    if (message_arena != submessage_arena) {
      visionfeatureprint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visionfeatureprint, submessage_arena);
    }
    set_has_visionfeatureprint();
    Type_.visionfeatureprint_ = visionfeatureprint;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.visionFeaturePrint)
}
void Model::clear_visionfeatureprint() {
  if (_internal_has_visionfeatureprint()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.visionfeatureprint_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_soundanalysispreprocessing(::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing* soundanalysispreprocessing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (soundanalysispreprocessing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(soundanalysispreprocessing));
    if (message_arena != submessage_arena) {
      soundanalysispreprocessing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, soundanalysispreprocessing, submessage_arena);
    }
    set_has_soundanalysispreprocessing();
    Type_.soundanalysispreprocessing_ = soundanalysispreprocessing;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.soundAnalysisPreprocessing)
}
void Model::clear_soundanalysispreprocessing() {
  if (_internal_has_soundanalysispreprocessing()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.soundanalysispreprocessing_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_gazetteer(::CoreML::Specification::CoreMLModels::Gazetteer* gazetteer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (gazetteer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gazetteer));
    if (message_arena != submessage_arena) {
      gazetteer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gazetteer, submessage_arena);
    }
    set_has_gazetteer();
    Type_.gazetteer_ = gazetteer;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.gazetteer)
}
void Model::clear_gazetteer() {
  if (_internal_has_gazetteer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.gazetteer_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_wordembedding(::CoreML::Specification::CoreMLModels::WordEmbedding* wordembedding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (wordembedding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wordembedding));
    if (message_arena != submessage_arena) {
      wordembedding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wordembedding, submessage_arena);
    }
    set_has_wordembedding();
    Type_.wordembedding_ = wordembedding;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.wordEmbedding)
}
void Model::clear_wordembedding() {
  if (_internal_has_wordembedding()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.wordembedding_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_audiofeatureprint(::CoreML::Specification::CoreMLModels::AudioFeaturePrint* audiofeatureprint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (audiofeatureprint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audiofeatureprint));
    if (message_arena != submessage_arena) {
      audiofeatureprint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audiofeatureprint, submessage_arena);
    }
    set_has_audiofeatureprint();
    Type_.audiofeatureprint_ = audiofeatureprint;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.audioFeaturePrint)
}
void Model::clear_audiofeatureprint() {
  if (_internal_has_audiofeatureprint()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.audiofeatureprint_;
    }
    clear_has_Type();
  }
}
void Model::set_allocated_serializedmodel(::CoreML::Specification::SerializedModel* serializedmodel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (serializedmodel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SerializedModel>::GetOwningArena(serializedmodel);
    if (message_arena != submessage_arena) {
      serializedmodel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, serializedmodel, submessage_arena);
    }
    set_has_serializedmodel();
    Type_.serializedmodel_ = serializedmodel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.serializedModel)
}
Model::Model(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.Model)
}
Model::Model(const Model& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_description()) {
    description_ = new ::CoreML::Specification::ModelDescription(*from.description_);
  } else {
    description_ = nullptr;
  }
  ::memcpy(&specificationversion_, &from.specificationversion_,
    static_cast<size_t>(reinterpret_cast<char*>(&isupdatable_) -
    reinterpret_cast<char*>(&specificationversion_)) + sizeof(isupdatable_));
  clear_has_Type();
  switch (from.Type_case()) {
    case kPipelineClassifier: {
      _internal_mutable_pipelineclassifier()->::CoreML::Specification::PipelineClassifier::MergeFrom(from._internal_pipelineclassifier());
      break;
    }
    case kPipelineRegressor: {
      _internal_mutable_pipelineregressor()->::CoreML::Specification::PipelineRegressor::MergeFrom(from._internal_pipelineregressor());
      break;
    }
    case kPipeline: {
      _internal_mutable_pipeline()->::CoreML::Specification::Pipeline::MergeFrom(from._internal_pipeline());
      break;
    }
    case kGlmRegressor: {
      _internal_mutable_glmregressor()->::CoreML::Specification::GLMRegressor::MergeFrom(from._internal_glmregressor());
      break;
    }
    case kSupportVectorRegressor: {
      _internal_mutable_supportvectorregressor()->::CoreML::Specification::SupportVectorRegressor::MergeFrom(from._internal_supportvectorregressor());
      break;
    }
    case kTreeEnsembleRegressor: {
      _internal_mutable_treeensembleregressor()->::CoreML::Specification::TreeEnsembleRegressor::MergeFrom(from._internal_treeensembleregressor());
      break;
    }
    case kNeuralNetworkRegressor: {
      _internal_mutable_neuralnetworkregressor()->::CoreML::Specification::NeuralNetworkRegressor::MergeFrom(from._internal_neuralnetworkregressor());
      break;
    }
    case kBayesianProbitRegressor: {
      _internal_mutable_bayesianprobitregressor()->::CoreML::Specification::BayesianProbitRegressor::MergeFrom(from._internal_bayesianprobitregressor());
      break;
    }
    case kGlmClassifier: {
      _internal_mutable_glmclassifier()->::CoreML::Specification::GLMClassifier::MergeFrom(from._internal_glmclassifier());
      break;
    }
    case kSupportVectorClassifier: {
      _internal_mutable_supportvectorclassifier()->::CoreML::Specification::SupportVectorClassifier::MergeFrom(from._internal_supportvectorclassifier());
      break;
    }
    case kTreeEnsembleClassifier: {
      _internal_mutable_treeensembleclassifier()->::CoreML::Specification::TreeEnsembleClassifier::MergeFrom(from._internal_treeensembleclassifier());
      break;
    }
    case kNeuralNetworkClassifier: {
      _internal_mutable_neuralnetworkclassifier()->::CoreML::Specification::NeuralNetworkClassifier::MergeFrom(from._internal_neuralnetworkclassifier());
      break;
    }
    case kKNearestNeighborsClassifier: {
      _internal_mutable_knearestneighborsclassifier()->::CoreML::Specification::KNearestNeighborsClassifier::MergeFrom(from._internal_knearestneighborsclassifier());
      break;
    }
    case kNeuralNetwork: {
      _internal_mutable_neuralnetwork()->::CoreML::Specification::NeuralNetwork::MergeFrom(from._internal_neuralnetwork());
      break;
    }
    case kItemSimilarityRecommender: {
      _internal_mutable_itemsimilarityrecommender()->::CoreML::Specification::ItemSimilarityRecommender::MergeFrom(from._internal_itemsimilarityrecommender());
      break;
    }
    case kMlProgram: {
      _internal_mutable_mlprogram()->::CoreML::Specification::MILSpec::Program::MergeFrom(from._internal_mlprogram());
      break;
    }
    case kCustomModel: {
      _internal_mutable_custommodel()->::CoreML::Specification::CustomModel::MergeFrom(from._internal_custommodel());
      break;
    }
    case kLinkedModel: {
      _internal_mutable_linkedmodel()->::CoreML::Specification::LinkedModel::MergeFrom(from._internal_linkedmodel());
      break;
    }
    case kClassConfidenceThresholding: {
      _internal_mutable_classconfidencethresholding()->::CoreML::Specification::ClassConfidenceThresholding::MergeFrom(from._internal_classconfidencethresholding());
      break;
    }
    case kOneHotEncoder: {
      _internal_mutable_onehotencoder()->::CoreML::Specification::OneHotEncoder::MergeFrom(from._internal_onehotencoder());
      break;
    }
    case kImputer: {
      _internal_mutable_imputer()->::CoreML::Specification::Imputer::MergeFrom(from._internal_imputer());
      break;
    }
    case kFeatureVectorizer: {
      _internal_mutable_featurevectorizer()->::CoreML::Specification::FeatureVectorizer::MergeFrom(from._internal_featurevectorizer());
      break;
    }
    case kDictVectorizer: {
      _internal_mutable_dictvectorizer()->::CoreML::Specification::DictVectorizer::MergeFrom(from._internal_dictvectorizer());
      break;
    }
    case kScaler: {
      _internal_mutable_scaler()->::CoreML::Specification::Scaler::MergeFrom(from._internal_scaler());
      break;
    }
    case kCategoricalMapping: {
      _internal_mutable_categoricalmapping()->::CoreML::Specification::CategoricalMapping::MergeFrom(from._internal_categoricalmapping());
      break;
    }
    case kNormalizer: {
      _internal_mutable_normalizer()->::CoreML::Specification::Normalizer::MergeFrom(from._internal_normalizer());
      break;
    }
    case kArrayFeatureExtractor: {
      _internal_mutable_arrayfeatureextractor()->::CoreML::Specification::ArrayFeatureExtractor::MergeFrom(from._internal_arrayfeatureextractor());
      break;
    }
    case kNonMaximumSuppression: {
      _internal_mutable_nonmaximumsuppression()->::CoreML::Specification::NonMaximumSuppression::MergeFrom(from._internal_nonmaximumsuppression());
      break;
    }
    case kIdentity: {
      _internal_mutable_identity()->::CoreML::Specification::Identity::MergeFrom(from._internal_identity());
      break;
    }
    case kTextClassifier: {
      _internal_mutable_textclassifier()->::CoreML::Specification::CoreMLModels::TextClassifier::MergeFrom(from._internal_textclassifier());
      break;
    }
    case kWordTagger: {
      _internal_mutable_wordtagger()->::CoreML::Specification::CoreMLModels::WordTagger::MergeFrom(from._internal_wordtagger());
      break;
    }
    case kVisionFeaturePrint: {
      _internal_mutable_visionfeatureprint()->::CoreML::Specification::CoreMLModels::VisionFeaturePrint::MergeFrom(from._internal_visionfeatureprint());
      break;
    }
    case kSoundAnalysisPreprocessing: {
      _internal_mutable_soundanalysispreprocessing()->::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing::MergeFrom(from._internal_soundanalysispreprocessing());
      break;
    }
    case kGazetteer: {
      _internal_mutable_gazetteer()->::CoreML::Specification::CoreMLModels::Gazetteer::MergeFrom(from._internal_gazetteer());
      break;
    }
    case kWordEmbedding: {
      _internal_mutable_wordembedding()->::CoreML::Specification::CoreMLModels::WordEmbedding::MergeFrom(from._internal_wordembedding());
      break;
    }
    case kAudioFeaturePrint: {
      _internal_mutable_audiofeatureprint()->::CoreML::Specification::CoreMLModels::AudioFeaturePrint::MergeFrom(from._internal_audiofeatureprint());
      break;
    }
    case kSerializedModel: {
      _internal_mutable_serializedmodel()->::CoreML::Specification::SerializedModel::MergeFrom(from._internal_serializedmodel());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Model)
}

inline void Model::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&description_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&isupdatable_) -
    reinterpret_cast<char*>(&description_)) + sizeof(isupdatable_));
clear_has_Type();
}

Model::~Model() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Model)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Model::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete description_;
  if (has_Type()) {
    clear_Type();
  }
}

void Model::ArenaDtor(void* object) {
  Model* _this = reinterpret_cast< Model* >(object);
  (void)_this;
}
void Model::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Model::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Model::clear_Type() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.Model)
  switch (Type_case()) {
    case kPipelineClassifier: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.pipelineclassifier_;
      }
      break;
    }
    case kPipelineRegressor: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.pipelineregressor_;
      }
      break;
    }
    case kPipeline: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.pipeline_;
      }
      break;
    }
    case kGlmRegressor: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.glmregressor_;
      }
      break;
    }
    case kSupportVectorRegressor: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.supportvectorregressor_;
      }
      break;
    }
    case kTreeEnsembleRegressor: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.treeensembleregressor_;
      }
      break;
    }
    case kNeuralNetworkRegressor: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.neuralnetworkregressor_;
      }
      break;
    }
    case kBayesianProbitRegressor: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.bayesianprobitregressor_;
      }
      break;
    }
    case kGlmClassifier: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.glmclassifier_;
      }
      break;
    }
    case kSupportVectorClassifier: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.supportvectorclassifier_;
      }
      break;
    }
    case kTreeEnsembleClassifier: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.treeensembleclassifier_;
      }
      break;
    }
    case kNeuralNetworkClassifier: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.neuralnetworkclassifier_;
      }
      break;
    }
    case kKNearestNeighborsClassifier: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.knearestneighborsclassifier_;
      }
      break;
    }
    case kNeuralNetwork: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.neuralnetwork_;
      }
      break;
    }
    case kItemSimilarityRecommender: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.itemsimilarityrecommender_;
      }
      break;
    }
    case kMlProgram: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.mlprogram_;
      }
      break;
    }
    case kCustomModel: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.custommodel_;
      }
      break;
    }
    case kLinkedModel: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.linkedmodel_;
      }
      break;
    }
    case kClassConfidenceThresholding: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.classconfidencethresholding_;
      }
      break;
    }
    case kOneHotEncoder: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.onehotencoder_;
      }
      break;
    }
    case kImputer: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.imputer_;
      }
      break;
    }
    case kFeatureVectorizer: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.featurevectorizer_;
      }
      break;
    }
    case kDictVectorizer: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.dictvectorizer_;
      }
      break;
    }
    case kScaler: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.scaler_;
      }
      break;
    }
    case kCategoricalMapping: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.categoricalmapping_;
      }
      break;
    }
    case kNormalizer: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.normalizer_;
      }
      break;
    }
    case kArrayFeatureExtractor: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.arrayfeatureextractor_;
      }
      break;
    }
    case kNonMaximumSuppression: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.nonmaximumsuppression_;
      }
      break;
    }
    case kIdentity: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.identity_;
      }
      break;
    }
    case kTextClassifier: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.textclassifier_;
      }
      break;
    }
    case kWordTagger: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.wordtagger_;
      }
      break;
    }
    case kVisionFeaturePrint: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.visionfeatureprint_;
      }
      break;
    }
    case kSoundAnalysisPreprocessing: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.soundanalysispreprocessing_;
      }
      break;
    }
    case kGazetteer: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.gazetteer_;
      }
      break;
    }
    case kWordEmbedding: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.wordembedding_;
      }
      break;
    }
    case kAudioFeaturePrint: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.audiofeatureprint_;
      }
      break;
    }
    case kSerializedModel: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.serializedmodel_;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TYPE_NOT_SET;
}


void Model::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Model)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && description_ != nullptr) {
    delete description_;
  }
  description_ = nullptr;
  ::memset(&specificationversion_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isupdatable_) -
      reinterpret_cast<char*>(&specificationversion_)) + sizeof(isupdatable_));
  clear_Type();
  _internal_metadata_.Clear<std::string>();
}

const char* Model::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 specificationVersion = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          specificationversion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ModelDescription description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_description(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isUpdatable = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          isupdatable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.PipelineClassifier pipelineClassifier = 200;
      case 200:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_pipelineclassifier(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.PipelineRegressor pipelineRegressor = 201;
      case 201:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_pipelineregressor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Pipeline pipeline = 202;
      case 202:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_pipeline(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.GLMRegressor glmRegressor = 300;
      case 300:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_glmregressor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SupportVectorRegressor supportVectorRegressor = 301;
      case 301:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_supportvectorregressor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.TreeEnsembleRegressor treeEnsembleRegressor = 302;
      case 302:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_treeensembleregressor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NeuralNetworkRegressor neuralNetworkRegressor = 303;
      case 303:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_neuralnetworkregressor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.BayesianProbitRegressor bayesianProbitRegressor = 304;
      case 304:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_bayesianprobitregressor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.GLMClassifier glmClassifier = 400;
      case 400:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_glmclassifier(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SupportVectorClassifier supportVectorClassifier = 401;
      case 401:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_supportvectorclassifier(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.TreeEnsembleClassifier treeEnsembleClassifier = 402;
      case 402:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_treeensembleclassifier(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NeuralNetworkClassifier neuralNetworkClassifier = 403;
      case 403:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_neuralnetworkclassifier(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.KNearestNeighborsClassifier kNearestNeighborsClassifier = 404;
      case 404:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_knearestneighborsclassifier(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NeuralNetwork neuralNetwork = 500;
      case 500:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_neuralnetwork(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ItemSimilarityRecommender itemSimilarityRecommender = 501;
      case 501:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_itemsimilarityrecommender(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.Program mlProgram = 502;
      case 502:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_mlprogram(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CustomModel customModel = 555;
      case 555:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_custommodel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LinkedModel linkedModel = 556;
      case 556:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_linkedmodel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ClassConfidenceThresholding classConfidenceThresholding = 560;
      case 560:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_classconfidencethresholding(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.OneHotEncoder oneHotEncoder = 600;
      case 600:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_onehotencoder(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Imputer imputer = 601;
      case 601:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_imputer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.FeatureVectorizer featureVectorizer = 602;
      case 602:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_featurevectorizer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.DictVectorizer dictVectorizer = 603;
      case 603:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_dictvectorizer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Scaler scaler = 604;
      case 604:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_scaler(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CategoricalMapping categoricalMapping = 606;
      case 606:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_categoricalmapping(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Normalizer normalizer = 607;
      case 607:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_normalizer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ArrayFeatureExtractor arrayFeatureExtractor = 609;
      case 609:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_arrayfeatureextractor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NonMaximumSuppression nonMaximumSuppression = 610;
      case 610:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_nonmaximumsuppression(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Identity identity = 900;
      case 900:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_identity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CoreMLModels.TextClassifier textClassifier = 2000;
      case 2000:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_textclassifier(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CoreMLModels.WordTagger wordTagger = 2001;
      case 2001:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_wordtagger(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CoreMLModels.VisionFeaturePrint visionFeaturePrint = 2002;
      case 2002:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_visionfeatureprint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CoreMLModels.SoundAnalysisPreprocessing soundAnalysisPreprocessing = 2003;
      case 2003:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_soundanalysispreprocessing(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CoreMLModels.Gazetteer gazetteer = 2004;
      case 2004:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_gazetteer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CoreMLModels.WordEmbedding wordEmbedding = 2005;
      case 2005:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_wordembedding(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CoreMLModels.AudioFeaturePrint audioFeaturePrint = 2006;
      case 2006:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_audiofeatureprint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SerializedModel serializedModel = 3000;
      case 3000:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_serializedmodel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Model::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.Model)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 specificationVersion = 1;
  if (this->_internal_specificationversion() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_specificationversion(), target);
  }

  // .CoreML.Specification.ModelDescription description = 2;
  if (this->_internal_has_description()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::description(this), target, stream);
  }

  // bool isUpdatable = 10;
  if (this->_internal_isupdatable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_isupdatable(), target);
  }

  // .CoreML.Specification.PipelineClassifier pipelineClassifier = 200;
  if (_internal_has_pipelineclassifier()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        200, _Internal::pipelineclassifier(this), target, stream);
  }

  // .CoreML.Specification.PipelineRegressor pipelineRegressor = 201;
  if (_internal_has_pipelineregressor()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        201, _Internal::pipelineregressor(this), target, stream);
  }

  // .CoreML.Specification.Pipeline pipeline = 202;
  if (_internal_has_pipeline()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        202, _Internal::pipeline(this), target, stream);
  }

  // .CoreML.Specification.GLMRegressor glmRegressor = 300;
  if (_internal_has_glmregressor()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        300, _Internal::glmregressor(this), target, stream);
  }

  // .CoreML.Specification.SupportVectorRegressor supportVectorRegressor = 301;
  if (_internal_has_supportvectorregressor()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        301, _Internal::supportvectorregressor(this), target, stream);
  }

  // .CoreML.Specification.TreeEnsembleRegressor treeEnsembleRegressor = 302;
  if (_internal_has_treeensembleregressor()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        302, _Internal::treeensembleregressor(this), target, stream);
  }

  // .CoreML.Specification.NeuralNetworkRegressor neuralNetworkRegressor = 303;
  if (_internal_has_neuralnetworkregressor()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        303, _Internal::neuralnetworkregressor(this), target, stream);
  }

  // .CoreML.Specification.BayesianProbitRegressor bayesianProbitRegressor = 304;
  if (_internal_has_bayesianprobitregressor()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        304, _Internal::bayesianprobitregressor(this), target, stream);
  }

  // .CoreML.Specification.GLMClassifier glmClassifier = 400;
  if (_internal_has_glmclassifier()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        400, _Internal::glmclassifier(this), target, stream);
  }

  // .CoreML.Specification.SupportVectorClassifier supportVectorClassifier = 401;
  if (_internal_has_supportvectorclassifier()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        401, _Internal::supportvectorclassifier(this), target, stream);
  }

  // .CoreML.Specification.TreeEnsembleClassifier treeEnsembleClassifier = 402;
  if (_internal_has_treeensembleclassifier()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        402, _Internal::treeensembleclassifier(this), target, stream);
  }

  // .CoreML.Specification.NeuralNetworkClassifier neuralNetworkClassifier = 403;
  if (_internal_has_neuralnetworkclassifier()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        403, _Internal::neuralnetworkclassifier(this), target, stream);
  }

  // .CoreML.Specification.KNearestNeighborsClassifier kNearestNeighborsClassifier = 404;
  if (_internal_has_knearestneighborsclassifier()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        404, _Internal::knearestneighborsclassifier(this), target, stream);
  }

  // .CoreML.Specification.NeuralNetwork neuralNetwork = 500;
  if (_internal_has_neuralnetwork()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        500, _Internal::neuralnetwork(this), target, stream);
  }

  // .CoreML.Specification.ItemSimilarityRecommender itemSimilarityRecommender = 501;
  if (_internal_has_itemsimilarityrecommender()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        501, _Internal::itemsimilarityrecommender(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.Program mlProgram = 502;
  if (_internal_has_mlprogram()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        502, _Internal::mlprogram(this), target, stream);
  }

  // .CoreML.Specification.CustomModel customModel = 555;
  if (_internal_has_custommodel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        555, _Internal::custommodel(this), target, stream);
  }

  // .CoreML.Specification.LinkedModel linkedModel = 556;
  if (_internal_has_linkedmodel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        556, _Internal::linkedmodel(this), target, stream);
  }

  // .CoreML.Specification.ClassConfidenceThresholding classConfidenceThresholding = 560;
  if (_internal_has_classconfidencethresholding()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        560, _Internal::classconfidencethresholding(this), target, stream);
  }

  // .CoreML.Specification.OneHotEncoder oneHotEncoder = 600;
  if (_internal_has_onehotencoder()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        600, _Internal::onehotencoder(this), target, stream);
  }

  // .CoreML.Specification.Imputer imputer = 601;
  if (_internal_has_imputer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        601, _Internal::imputer(this), target, stream);
  }

  // .CoreML.Specification.FeatureVectorizer featureVectorizer = 602;
  if (_internal_has_featurevectorizer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        602, _Internal::featurevectorizer(this), target, stream);
  }

  // .CoreML.Specification.DictVectorizer dictVectorizer = 603;
  if (_internal_has_dictvectorizer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        603, _Internal::dictvectorizer(this), target, stream);
  }

  // .CoreML.Specification.Scaler scaler = 604;
  if (_internal_has_scaler()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        604, _Internal::scaler(this), target, stream);
  }

  // .CoreML.Specification.CategoricalMapping categoricalMapping = 606;
  if (_internal_has_categoricalmapping()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        606, _Internal::categoricalmapping(this), target, stream);
  }

  // .CoreML.Specification.Normalizer normalizer = 607;
  if (_internal_has_normalizer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        607, _Internal::normalizer(this), target, stream);
  }

  // .CoreML.Specification.ArrayFeatureExtractor arrayFeatureExtractor = 609;
  if (_internal_has_arrayfeatureextractor()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        609, _Internal::arrayfeatureextractor(this), target, stream);
  }

  // .CoreML.Specification.NonMaximumSuppression nonMaximumSuppression = 610;
  if (_internal_has_nonmaximumsuppression()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        610, _Internal::nonmaximumsuppression(this), target, stream);
  }

  // .CoreML.Specification.Identity identity = 900;
  if (_internal_has_identity()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        900, _Internal::identity(this), target, stream);
  }

  // .CoreML.Specification.CoreMLModels.TextClassifier textClassifier = 2000;
  if (_internal_has_textclassifier()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2000, _Internal::textclassifier(this), target, stream);
  }

  // .CoreML.Specification.CoreMLModels.WordTagger wordTagger = 2001;
  if (_internal_has_wordtagger()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2001, _Internal::wordtagger(this), target, stream);
  }

  // .CoreML.Specification.CoreMLModels.VisionFeaturePrint visionFeaturePrint = 2002;
  if (_internal_has_visionfeatureprint()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2002, _Internal::visionfeatureprint(this), target, stream);
  }

  // .CoreML.Specification.CoreMLModels.SoundAnalysisPreprocessing soundAnalysisPreprocessing = 2003;
  if (_internal_has_soundanalysispreprocessing()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2003, _Internal::soundanalysispreprocessing(this), target, stream);
  }

  // .CoreML.Specification.CoreMLModels.Gazetteer gazetteer = 2004;
  if (_internal_has_gazetteer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2004, _Internal::gazetteer(this), target, stream);
  }

  // .CoreML.Specification.CoreMLModels.WordEmbedding wordEmbedding = 2005;
  if (_internal_has_wordembedding()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2005, _Internal::wordembedding(this), target, stream);
  }

  // .CoreML.Specification.CoreMLModels.AudioFeaturePrint audioFeaturePrint = 2006;
  if (_internal_has_audiofeatureprint()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2006, _Internal::audiofeatureprint(this), target, stream);
  }

  // .CoreML.Specification.SerializedModel serializedModel = 3000;
  if (_internal_has_serializedmodel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3000, _Internal::serializedmodel(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.Model)
  return target;
}

size_t Model::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Model)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.ModelDescription description = 2;
  if (this->_internal_has_description()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *description_);
  }

  // int32 specificationVersion = 1;
  if (this->_internal_specificationversion() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_specificationversion());
  }

  // bool isUpdatable = 10;
  if (this->_internal_isupdatable() != 0) {
    total_size += 1 + 1;
  }

  switch (Type_case()) {
    // .CoreML.Specification.PipelineClassifier pipelineClassifier = 200;
    case kPipelineClassifier: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.pipelineclassifier_);
      break;
    }
    // .CoreML.Specification.PipelineRegressor pipelineRegressor = 201;
    case kPipelineRegressor: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.pipelineregressor_);
      break;
    }
    // .CoreML.Specification.Pipeline pipeline = 202;
    case kPipeline: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.pipeline_);
      break;
    }
    // .CoreML.Specification.GLMRegressor glmRegressor = 300;
    case kGlmRegressor: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.glmregressor_);
      break;
    }
    // .CoreML.Specification.SupportVectorRegressor supportVectorRegressor = 301;
    case kSupportVectorRegressor: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.supportvectorregressor_);
      break;
    }
    // .CoreML.Specification.TreeEnsembleRegressor treeEnsembleRegressor = 302;
    case kTreeEnsembleRegressor: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.treeensembleregressor_);
      break;
    }
    // .CoreML.Specification.NeuralNetworkRegressor neuralNetworkRegressor = 303;
    case kNeuralNetworkRegressor: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.neuralnetworkregressor_);
      break;
    }
    // .CoreML.Specification.BayesianProbitRegressor bayesianProbitRegressor = 304;
    case kBayesianProbitRegressor: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.bayesianprobitregressor_);
      break;
    }
    // .CoreML.Specification.GLMClassifier glmClassifier = 400;
    case kGlmClassifier: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.glmclassifier_);
      break;
    }
    // .CoreML.Specification.SupportVectorClassifier supportVectorClassifier = 401;
    case kSupportVectorClassifier: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.supportvectorclassifier_);
      break;
    }
    // .CoreML.Specification.TreeEnsembleClassifier treeEnsembleClassifier = 402;
    case kTreeEnsembleClassifier: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.treeensembleclassifier_);
      break;
    }
    // .CoreML.Specification.NeuralNetworkClassifier neuralNetworkClassifier = 403;
    case kNeuralNetworkClassifier: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.neuralnetworkclassifier_);
      break;
    }
    // .CoreML.Specification.KNearestNeighborsClassifier kNearestNeighborsClassifier = 404;
    case kKNearestNeighborsClassifier: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.knearestneighborsclassifier_);
      break;
    }
    // .CoreML.Specification.NeuralNetwork neuralNetwork = 500;
    case kNeuralNetwork: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.neuralnetwork_);
      break;
    }
    // .CoreML.Specification.ItemSimilarityRecommender itemSimilarityRecommender = 501;
    case kItemSimilarityRecommender: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.itemsimilarityrecommender_);
      break;
    }
    // .CoreML.Specification.MILSpec.Program mlProgram = 502;
    case kMlProgram: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.mlprogram_);
      break;
    }
    // .CoreML.Specification.CustomModel customModel = 555;
    case kCustomModel: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.custommodel_);
      break;
    }
    // .CoreML.Specification.LinkedModel linkedModel = 556;
    case kLinkedModel: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.linkedmodel_);
      break;
    }
    // .CoreML.Specification.ClassConfidenceThresholding classConfidenceThresholding = 560;
    case kClassConfidenceThresholding: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.classconfidencethresholding_);
      break;
    }
    // .CoreML.Specification.OneHotEncoder oneHotEncoder = 600;
    case kOneHotEncoder: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.onehotencoder_);
      break;
    }
    // .CoreML.Specification.Imputer imputer = 601;
    case kImputer: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.imputer_);
      break;
    }
    // .CoreML.Specification.FeatureVectorizer featureVectorizer = 602;
    case kFeatureVectorizer: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.featurevectorizer_);
      break;
    }
    // .CoreML.Specification.DictVectorizer dictVectorizer = 603;
    case kDictVectorizer: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.dictvectorizer_);
      break;
    }
    // .CoreML.Specification.Scaler scaler = 604;
    case kScaler: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.scaler_);
      break;
    }
    // .CoreML.Specification.CategoricalMapping categoricalMapping = 606;
    case kCategoricalMapping: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.categoricalmapping_);
      break;
    }
    // .CoreML.Specification.Normalizer normalizer = 607;
    case kNormalizer: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.normalizer_);
      break;
    }
    // .CoreML.Specification.ArrayFeatureExtractor arrayFeatureExtractor = 609;
    case kArrayFeatureExtractor: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.arrayfeatureextractor_);
      break;
    }
    // .CoreML.Specification.NonMaximumSuppression nonMaximumSuppression = 610;
    case kNonMaximumSuppression: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.nonmaximumsuppression_);
      break;
    }
    // .CoreML.Specification.Identity identity = 900;
    case kIdentity: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.identity_);
      break;
    }
    // .CoreML.Specification.CoreMLModels.TextClassifier textClassifier = 2000;
    case kTextClassifier: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.textclassifier_);
      break;
    }
    // .CoreML.Specification.CoreMLModels.WordTagger wordTagger = 2001;
    case kWordTagger: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.wordtagger_);
      break;
    }
    // .CoreML.Specification.CoreMLModels.VisionFeaturePrint visionFeaturePrint = 2002;
    case kVisionFeaturePrint: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.visionfeatureprint_);
      break;
    }
    // .CoreML.Specification.CoreMLModels.SoundAnalysisPreprocessing soundAnalysisPreprocessing = 2003;
    case kSoundAnalysisPreprocessing: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.soundanalysispreprocessing_);
      break;
    }
    // .CoreML.Specification.CoreMLModels.Gazetteer gazetteer = 2004;
    case kGazetteer: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.gazetteer_);
      break;
    }
    // .CoreML.Specification.CoreMLModels.WordEmbedding wordEmbedding = 2005;
    case kWordEmbedding: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.wordembedding_);
      break;
    }
    // .CoreML.Specification.CoreMLModels.AudioFeaturePrint audioFeaturePrint = 2006;
    case kAudioFeaturePrint: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.audiofeatureprint_);
      break;
    }
    // .CoreML.Specification.SerializedModel serializedModel = 3000;
    case kSerializedModel: {
      total_size += 3 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.serializedmodel_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Model::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Model*>(
      &from));
}

void Model::MergeFrom(const Model& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Model)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_description()) {
    _internal_mutable_description()->::CoreML::Specification::ModelDescription::MergeFrom(from._internal_description());
  }
  if (from._internal_specificationversion() != 0) {
    _internal_set_specificationversion(from._internal_specificationversion());
  }
  if (from._internal_isupdatable() != 0) {
    _internal_set_isupdatable(from._internal_isupdatable());
  }
  switch (from.Type_case()) {
    case kPipelineClassifier: {
      _internal_mutable_pipelineclassifier()->::CoreML::Specification::PipelineClassifier::MergeFrom(from._internal_pipelineclassifier());
      break;
    }
    case kPipelineRegressor: {
      _internal_mutable_pipelineregressor()->::CoreML::Specification::PipelineRegressor::MergeFrom(from._internal_pipelineregressor());
      break;
    }
    case kPipeline: {
      _internal_mutable_pipeline()->::CoreML::Specification::Pipeline::MergeFrom(from._internal_pipeline());
      break;
    }
    case kGlmRegressor: {
      _internal_mutable_glmregressor()->::CoreML::Specification::GLMRegressor::MergeFrom(from._internal_glmregressor());
      break;
    }
    case kSupportVectorRegressor: {
      _internal_mutable_supportvectorregressor()->::CoreML::Specification::SupportVectorRegressor::MergeFrom(from._internal_supportvectorregressor());
      break;
    }
    case kTreeEnsembleRegressor: {
      _internal_mutable_treeensembleregressor()->::CoreML::Specification::TreeEnsembleRegressor::MergeFrom(from._internal_treeensembleregressor());
      break;
    }
    case kNeuralNetworkRegressor: {
      _internal_mutable_neuralnetworkregressor()->::CoreML::Specification::NeuralNetworkRegressor::MergeFrom(from._internal_neuralnetworkregressor());
      break;
    }
    case kBayesianProbitRegressor: {
      _internal_mutable_bayesianprobitregressor()->::CoreML::Specification::BayesianProbitRegressor::MergeFrom(from._internal_bayesianprobitregressor());
      break;
    }
    case kGlmClassifier: {
      _internal_mutable_glmclassifier()->::CoreML::Specification::GLMClassifier::MergeFrom(from._internal_glmclassifier());
      break;
    }
    case kSupportVectorClassifier: {
      _internal_mutable_supportvectorclassifier()->::CoreML::Specification::SupportVectorClassifier::MergeFrom(from._internal_supportvectorclassifier());
      break;
    }
    case kTreeEnsembleClassifier: {
      _internal_mutable_treeensembleclassifier()->::CoreML::Specification::TreeEnsembleClassifier::MergeFrom(from._internal_treeensembleclassifier());
      break;
    }
    case kNeuralNetworkClassifier: {
      _internal_mutable_neuralnetworkclassifier()->::CoreML::Specification::NeuralNetworkClassifier::MergeFrom(from._internal_neuralnetworkclassifier());
      break;
    }
    case kKNearestNeighborsClassifier: {
      _internal_mutable_knearestneighborsclassifier()->::CoreML::Specification::KNearestNeighborsClassifier::MergeFrom(from._internal_knearestneighborsclassifier());
      break;
    }
    case kNeuralNetwork: {
      _internal_mutable_neuralnetwork()->::CoreML::Specification::NeuralNetwork::MergeFrom(from._internal_neuralnetwork());
      break;
    }
    case kItemSimilarityRecommender: {
      _internal_mutable_itemsimilarityrecommender()->::CoreML::Specification::ItemSimilarityRecommender::MergeFrom(from._internal_itemsimilarityrecommender());
      break;
    }
    case kMlProgram: {
      _internal_mutable_mlprogram()->::CoreML::Specification::MILSpec::Program::MergeFrom(from._internal_mlprogram());
      break;
    }
    case kCustomModel: {
      _internal_mutable_custommodel()->::CoreML::Specification::CustomModel::MergeFrom(from._internal_custommodel());
      break;
    }
    case kLinkedModel: {
      _internal_mutable_linkedmodel()->::CoreML::Specification::LinkedModel::MergeFrom(from._internal_linkedmodel());
      break;
    }
    case kClassConfidenceThresholding: {
      _internal_mutable_classconfidencethresholding()->::CoreML::Specification::ClassConfidenceThresholding::MergeFrom(from._internal_classconfidencethresholding());
      break;
    }
    case kOneHotEncoder: {
      _internal_mutable_onehotencoder()->::CoreML::Specification::OneHotEncoder::MergeFrom(from._internal_onehotencoder());
      break;
    }
    case kImputer: {
      _internal_mutable_imputer()->::CoreML::Specification::Imputer::MergeFrom(from._internal_imputer());
      break;
    }
    case kFeatureVectorizer: {
      _internal_mutable_featurevectorizer()->::CoreML::Specification::FeatureVectorizer::MergeFrom(from._internal_featurevectorizer());
      break;
    }
    case kDictVectorizer: {
      _internal_mutable_dictvectorizer()->::CoreML::Specification::DictVectorizer::MergeFrom(from._internal_dictvectorizer());
      break;
    }
    case kScaler: {
      _internal_mutable_scaler()->::CoreML::Specification::Scaler::MergeFrom(from._internal_scaler());
      break;
    }
    case kCategoricalMapping: {
      _internal_mutable_categoricalmapping()->::CoreML::Specification::CategoricalMapping::MergeFrom(from._internal_categoricalmapping());
      break;
    }
    case kNormalizer: {
      _internal_mutable_normalizer()->::CoreML::Specification::Normalizer::MergeFrom(from._internal_normalizer());
      break;
    }
    case kArrayFeatureExtractor: {
      _internal_mutable_arrayfeatureextractor()->::CoreML::Specification::ArrayFeatureExtractor::MergeFrom(from._internal_arrayfeatureextractor());
      break;
    }
    case kNonMaximumSuppression: {
      _internal_mutable_nonmaximumsuppression()->::CoreML::Specification::NonMaximumSuppression::MergeFrom(from._internal_nonmaximumsuppression());
      break;
    }
    case kIdentity: {
      _internal_mutable_identity()->::CoreML::Specification::Identity::MergeFrom(from._internal_identity());
      break;
    }
    case kTextClassifier: {
      _internal_mutable_textclassifier()->::CoreML::Specification::CoreMLModels::TextClassifier::MergeFrom(from._internal_textclassifier());
      break;
    }
    case kWordTagger: {
      _internal_mutable_wordtagger()->::CoreML::Specification::CoreMLModels::WordTagger::MergeFrom(from._internal_wordtagger());
      break;
    }
    case kVisionFeaturePrint: {
      _internal_mutable_visionfeatureprint()->::CoreML::Specification::CoreMLModels::VisionFeaturePrint::MergeFrom(from._internal_visionfeatureprint());
      break;
    }
    case kSoundAnalysisPreprocessing: {
      _internal_mutable_soundanalysispreprocessing()->::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing::MergeFrom(from._internal_soundanalysispreprocessing());
      break;
    }
    case kGazetteer: {
      _internal_mutable_gazetteer()->::CoreML::Specification::CoreMLModels::Gazetteer::MergeFrom(from._internal_gazetteer());
      break;
    }
    case kWordEmbedding: {
      _internal_mutable_wordembedding()->::CoreML::Specification::CoreMLModels::WordEmbedding::MergeFrom(from._internal_wordembedding());
      break;
    }
    case kAudioFeaturePrint: {
      _internal_mutable_audiofeatureprint()->::CoreML::Specification::CoreMLModels::AudioFeaturePrint::MergeFrom(from._internal_audiofeatureprint());
      break;
    }
    case kSerializedModel: {
      _internal_mutable_serializedmodel()->::CoreML::Specification::SerializedModel::MergeFrom(from._internal_serializedmodel());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Model::CopyFrom(const Model& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Model)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Model::IsInitialized() const {
  return true;
}

void Model::InternalSwap(Model* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Model, isupdatable_)
      + sizeof(Model::isupdatable_)
      - PROTOBUF_FIELD_OFFSET(Model, description_)>(
          reinterpret_cast<char*>(&description_),
          reinterpret_cast<char*>(&other->description_));
  swap(Type_, other->Type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string Model::GetTypeName() const {
  return "CoreML.Specification.Model";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace Specification
}  // namespace CoreML
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Pipeline* Arena::CreateMaybeMessage< ::CoreML::Specification::Pipeline >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Pipeline >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::PipelineClassifier* Arena::CreateMaybeMessage< ::CoreML::Specification::PipelineClassifier >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::PipelineClassifier >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::PipelineRegressor* Arena::CreateMaybeMessage< ::CoreML::Specification::PipelineRegressor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::PipelineRegressor >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::FeatureDescription* Arena::CreateMaybeMessage< ::CoreML::Specification::FeatureDescription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::FeatureDescription >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Metadata_UserDefinedEntry_DoNotUse* Arena::CreateMaybeMessage< ::CoreML::Specification::Metadata_UserDefinedEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Metadata_UserDefinedEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Metadata* Arena::CreateMaybeMessage< ::CoreML::Specification::Metadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Metadata >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::FunctionDescription* Arena::CreateMaybeMessage< ::CoreML::Specification::FunctionDescription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::FunctionDescription >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ModelDescription* Arena::CreateMaybeMessage< ::CoreML::Specification::ModelDescription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ModelDescription >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SerializedModel* Arena::CreateMaybeMessage< ::CoreML::Specification::SerializedModel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SerializedModel >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Model* Arena::CreateMaybeMessage< ::CoreML::Specification::Model >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Model >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
