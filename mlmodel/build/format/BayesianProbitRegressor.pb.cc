// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BayesianProbitRegressor.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "BayesianProbitRegressor.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace CoreML {
namespace Specification {
class BayesianProbitRegressor_GaussianDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<BayesianProbitRegressor_Gaussian> {
} _BayesianProbitRegressor_Gaussian_default_instance_;
class BayesianProbitRegressor_FeatureValueWeightDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<BayesianProbitRegressor_FeatureValueWeight> {
} _BayesianProbitRegressor_FeatureValueWeight_default_instance_;
class BayesianProbitRegressor_FeatureWeightDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<BayesianProbitRegressor_FeatureWeight> {
} _BayesianProbitRegressor_FeatureWeight_default_instance_;
class BayesianProbitRegressorDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<BayesianProbitRegressor> {
} _BayesianProbitRegressor_default_instance_;

namespace protobuf_BayesianProbitRegressor_2eproto {

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};


void TableStruct::Shutdown() {
  _BayesianProbitRegressor_Gaussian_default_instance_.Shutdown();
  _BayesianProbitRegressor_FeatureValueWeight_default_instance_.Shutdown();
  _BayesianProbitRegressor_FeatureWeight_default_instance_.Shutdown();
  _BayesianProbitRegressor_default_instance_.Shutdown();
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  _BayesianProbitRegressor_Gaussian_default_instance_.DefaultConstruct();
  _BayesianProbitRegressor_FeatureValueWeight_default_instance_.DefaultConstruct();
  _BayesianProbitRegressor_FeatureWeight_default_instance_.DefaultConstruct();
  _BayesianProbitRegressor_default_instance_.DefaultConstruct();
  _BayesianProbitRegressor_FeatureValueWeight_default_instance_.get_mutable()->featureweight_ = const_cast< ::CoreML::Specification::BayesianProbitRegressor_Gaussian*>(
      ::CoreML::Specification::BayesianProbitRegressor_Gaussian::internal_default_instance());
  _BayesianProbitRegressor_default_instance_.get_mutable()->bias_ = const_cast< ::CoreML::Specification::BayesianProbitRegressor_Gaussian*>(
      ::CoreML::Specification::BayesianProbitRegressor_Gaussian::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
#endif  // GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

}  // namespace protobuf_BayesianProbitRegressor_2eproto


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BayesianProbitRegressor_Gaussian::kMeanFieldNumber;
const int BayesianProbitRegressor_Gaussian::kPrecisionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BayesianProbitRegressor_Gaussian::BayesianProbitRegressor_Gaussian()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_BayesianProbitRegressor_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.BayesianProbitRegressor.Gaussian)
}
BayesianProbitRegressor_Gaussian::BayesianProbitRegressor_Gaussian(const BayesianProbitRegressor_Gaussian& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&mean_, &from.mean_,
    reinterpret_cast<char*>(&precision_) -
    reinterpret_cast<char*>(&mean_) + sizeof(precision_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.BayesianProbitRegressor.Gaussian)
}

void BayesianProbitRegressor_Gaussian::SharedCtor() {
  ::memset(&mean_, 0, reinterpret_cast<char*>(&precision_) -
    reinterpret_cast<char*>(&mean_) + sizeof(precision_));
  _cached_size_ = 0;
}

BayesianProbitRegressor_Gaussian::~BayesianProbitRegressor_Gaussian() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.BayesianProbitRegressor.Gaussian)
  SharedDtor();
}

void BayesianProbitRegressor_Gaussian::SharedDtor() {
}

void BayesianProbitRegressor_Gaussian::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BayesianProbitRegressor_Gaussian& BayesianProbitRegressor_Gaussian::default_instance() {
  protobuf_BayesianProbitRegressor_2eproto::InitDefaults();
  return *internal_default_instance();
}

BayesianProbitRegressor_Gaussian* BayesianProbitRegressor_Gaussian::New(::google::protobuf::Arena* arena) const {
  BayesianProbitRegressor_Gaussian* n = new BayesianProbitRegressor_Gaussian;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BayesianProbitRegressor_Gaussian::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.BayesianProbitRegressor.Gaussian)
  ::memset(&mean_, 0, reinterpret_cast<char*>(&precision_) -
    reinterpret_cast<char*>(&mean_) + sizeof(precision_));
}

bool BayesianProbitRegressor_Gaussian::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.BayesianProbitRegressor.Gaussian)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // double mean = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &mean_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double precision = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &precision_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.BayesianProbitRegressor.Gaussian)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.BayesianProbitRegressor.Gaussian)
  return false;
#undef DO_
}

void BayesianProbitRegressor_Gaussian::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.BayesianProbitRegressor.Gaussian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double mean = 1;
  if (this->mean() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->mean(), output);
  }

  // double precision = 2;
  if (this->precision() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->precision(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.BayesianProbitRegressor.Gaussian)
}

size_t BayesianProbitRegressor_Gaussian::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.BayesianProbitRegressor.Gaussian)
  size_t total_size = 0;

  // double mean = 1;
  if (this->mean() != 0) {
    total_size += 1 + 8;
  }

  // double precision = 2;
  if (this->precision() != 0) {
    total_size += 1 + 8;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BayesianProbitRegressor_Gaussian::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BayesianProbitRegressor_Gaussian*>(&from));
}

void BayesianProbitRegressor_Gaussian::MergeFrom(const BayesianProbitRegressor_Gaussian& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.BayesianProbitRegressor.Gaussian)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.mean() != 0) {
    set_mean(from.mean());
  }
  if (from.precision() != 0) {
    set_precision(from.precision());
  }
}

void BayesianProbitRegressor_Gaussian::CopyFrom(const BayesianProbitRegressor_Gaussian& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.BayesianProbitRegressor.Gaussian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BayesianProbitRegressor_Gaussian::IsInitialized() const {
  return true;
}

void BayesianProbitRegressor_Gaussian::Swap(BayesianProbitRegressor_Gaussian* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BayesianProbitRegressor_Gaussian::InternalSwap(BayesianProbitRegressor_Gaussian* other) {
  std::swap(mean_, other->mean_);
  std::swap(precision_, other->precision_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string BayesianProbitRegressor_Gaussian::GetTypeName() const {
  return "CoreML.Specification.BayesianProbitRegressor.Gaussian";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BayesianProbitRegressor_Gaussian

// double mean = 1;
void BayesianProbitRegressor_Gaussian::clear_mean() {
  mean_ = 0;
}
double BayesianProbitRegressor_Gaussian::mean() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.Gaussian.mean)
  return mean_;
}
void BayesianProbitRegressor_Gaussian::set_mean(double value) {
  
  mean_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.Gaussian.mean)
}

// double precision = 2;
void BayesianProbitRegressor_Gaussian::clear_precision() {
  precision_ = 0;
}
double BayesianProbitRegressor_Gaussian::precision() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.Gaussian.precision)
  return precision_;
}
void BayesianProbitRegressor_Gaussian::set_precision(double value) {
  
  precision_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.Gaussian.precision)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BayesianProbitRegressor_FeatureValueWeight::kFeatureValueFieldNumber;
const int BayesianProbitRegressor_FeatureValueWeight::kFeatureWeightFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BayesianProbitRegressor_FeatureValueWeight::BayesianProbitRegressor_FeatureValueWeight()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_BayesianProbitRegressor_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight)
}
BayesianProbitRegressor_FeatureValueWeight::BayesianProbitRegressor_FeatureValueWeight(const BayesianProbitRegressor_FeatureValueWeight& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_featureweight()) {
    featureweight_ = new ::CoreML::Specification::BayesianProbitRegressor_Gaussian(*from.featureweight_);
  } else {
    featureweight_ = NULL;
  }
  featurevalue_ = from.featurevalue_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight)
}

void BayesianProbitRegressor_FeatureValueWeight::SharedCtor() {
  ::memset(&featureweight_, 0, reinterpret_cast<char*>(&featurevalue_) -
    reinterpret_cast<char*>(&featureweight_) + sizeof(featurevalue_));
  _cached_size_ = 0;
}

BayesianProbitRegressor_FeatureValueWeight::~BayesianProbitRegressor_FeatureValueWeight() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight)
  SharedDtor();
}

void BayesianProbitRegressor_FeatureValueWeight::SharedDtor() {
  if (this != internal_default_instance()) {
    delete featureweight_;
  }
}

void BayesianProbitRegressor_FeatureValueWeight::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BayesianProbitRegressor_FeatureValueWeight& BayesianProbitRegressor_FeatureValueWeight::default_instance() {
  protobuf_BayesianProbitRegressor_2eproto::InitDefaults();
  return *internal_default_instance();
}

BayesianProbitRegressor_FeatureValueWeight* BayesianProbitRegressor_FeatureValueWeight::New(::google::protobuf::Arena* arena) const {
  BayesianProbitRegressor_FeatureValueWeight* n = new BayesianProbitRegressor_FeatureValueWeight;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BayesianProbitRegressor_FeatureValueWeight::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight)
  if (GetArenaNoVirtual() == NULL && featureweight_ != NULL) {
    delete featureweight_;
  }
  featureweight_ = NULL;
  featurevalue_ = 0u;
}

bool BayesianProbitRegressor_FeatureValueWeight::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint32 featureValue = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &featurevalue_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.BayesianProbitRegressor.Gaussian featureWeight = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_featureweight()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight)
  return false;
#undef DO_
}

void BayesianProbitRegressor_FeatureValueWeight::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 featureValue = 1;
  if (this->featurevalue() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->featurevalue(), output);
  }

  // .CoreML.Specification.BayesianProbitRegressor.Gaussian featureWeight = 2;
  if (this->has_featureweight()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->featureweight_, output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight)
}

size_t BayesianProbitRegressor_FeatureValueWeight::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight)
  size_t total_size = 0;

  // .CoreML.Specification.BayesianProbitRegressor.Gaussian featureWeight = 2;
  if (this->has_featureweight()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->featureweight_);
  }

  // uint32 featureValue = 1;
  if (this->featurevalue() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->featurevalue());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BayesianProbitRegressor_FeatureValueWeight::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BayesianProbitRegressor_FeatureValueWeight*>(&from));
}

void BayesianProbitRegressor_FeatureValueWeight::MergeFrom(const BayesianProbitRegressor_FeatureValueWeight& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_featureweight()) {
    mutable_featureweight()->::CoreML::Specification::BayesianProbitRegressor_Gaussian::MergeFrom(from.featureweight());
  }
  if (from.featurevalue() != 0) {
    set_featurevalue(from.featurevalue());
  }
}

void BayesianProbitRegressor_FeatureValueWeight::CopyFrom(const BayesianProbitRegressor_FeatureValueWeight& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BayesianProbitRegressor_FeatureValueWeight::IsInitialized() const {
  return true;
}

void BayesianProbitRegressor_FeatureValueWeight::Swap(BayesianProbitRegressor_FeatureValueWeight* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BayesianProbitRegressor_FeatureValueWeight::InternalSwap(BayesianProbitRegressor_FeatureValueWeight* other) {
  std::swap(featureweight_, other->featureweight_);
  std::swap(featurevalue_, other->featurevalue_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string BayesianProbitRegressor_FeatureValueWeight::GetTypeName() const {
  return "CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BayesianProbitRegressor_FeatureValueWeight

// uint32 featureValue = 1;
void BayesianProbitRegressor_FeatureValueWeight::clear_featurevalue() {
  featurevalue_ = 0u;
}
::google::protobuf::uint32 BayesianProbitRegressor_FeatureValueWeight::featurevalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight.featureValue)
  return featurevalue_;
}
void BayesianProbitRegressor_FeatureValueWeight::set_featurevalue(::google::protobuf::uint32 value) {
  
  featurevalue_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight.featureValue)
}

// .CoreML.Specification.BayesianProbitRegressor.Gaussian featureWeight = 2;
bool BayesianProbitRegressor_FeatureValueWeight::has_featureweight() const {
  return this != internal_default_instance() && featureweight_ != NULL;
}
void BayesianProbitRegressor_FeatureValueWeight::clear_featureweight() {
  if (GetArenaNoVirtual() == NULL && featureweight_ != NULL) delete featureweight_;
  featureweight_ = NULL;
}
const ::CoreML::Specification::BayesianProbitRegressor_Gaussian& BayesianProbitRegressor_FeatureValueWeight::featureweight() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight.featureWeight)
  return featureweight_ != NULL ? *featureweight_
                         : *::CoreML::Specification::BayesianProbitRegressor_Gaussian::internal_default_instance();
}
::CoreML::Specification::BayesianProbitRegressor_Gaussian* BayesianProbitRegressor_FeatureValueWeight::mutable_featureweight() {
  
  if (featureweight_ == NULL) {
    featureweight_ = new ::CoreML::Specification::BayesianProbitRegressor_Gaussian;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight.featureWeight)
  return featureweight_;
}
::CoreML::Specification::BayesianProbitRegressor_Gaussian* BayesianProbitRegressor_FeatureValueWeight::release_featureweight() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight.featureWeight)
  
  ::CoreML::Specification::BayesianProbitRegressor_Gaussian* temp = featureweight_;
  featureweight_ = NULL;
  return temp;
}
void BayesianProbitRegressor_FeatureValueWeight::set_allocated_featureweight(::CoreML::Specification::BayesianProbitRegressor_Gaussian* featureweight) {
  delete featureweight_;
  featureweight_ = featureweight;
  if (featureweight) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight.featureWeight)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BayesianProbitRegressor_FeatureWeight::kFeatureIdFieldNumber;
const int BayesianProbitRegressor_FeatureWeight::kWeightsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BayesianProbitRegressor_FeatureWeight::BayesianProbitRegressor_FeatureWeight()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_BayesianProbitRegressor_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.BayesianProbitRegressor.FeatureWeight)
}
BayesianProbitRegressor_FeatureWeight::BayesianProbitRegressor_FeatureWeight(const BayesianProbitRegressor_FeatureWeight& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      weights_(from.weights_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  featureid_ = from.featureid_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.BayesianProbitRegressor.FeatureWeight)
}

void BayesianProbitRegressor_FeatureWeight::SharedCtor() {
  featureid_ = 0u;
  _cached_size_ = 0;
}

BayesianProbitRegressor_FeatureWeight::~BayesianProbitRegressor_FeatureWeight() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.BayesianProbitRegressor.FeatureWeight)
  SharedDtor();
}

void BayesianProbitRegressor_FeatureWeight::SharedDtor() {
}

void BayesianProbitRegressor_FeatureWeight::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BayesianProbitRegressor_FeatureWeight& BayesianProbitRegressor_FeatureWeight::default_instance() {
  protobuf_BayesianProbitRegressor_2eproto::InitDefaults();
  return *internal_default_instance();
}

BayesianProbitRegressor_FeatureWeight* BayesianProbitRegressor_FeatureWeight::New(::google::protobuf::Arena* arena) const {
  BayesianProbitRegressor_FeatureWeight* n = new BayesianProbitRegressor_FeatureWeight;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BayesianProbitRegressor_FeatureWeight::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.BayesianProbitRegressor.FeatureWeight)
  weights_.Clear();
  featureid_ = 0u;
}

bool BayesianProbitRegressor_FeatureWeight::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.BayesianProbitRegressor.FeatureWeight)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint32 featureId = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &featureid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight weights = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_weights()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.BayesianProbitRegressor.FeatureWeight)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.BayesianProbitRegressor.FeatureWeight)
  return false;
#undef DO_
}

void BayesianProbitRegressor_FeatureWeight::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.BayesianProbitRegressor.FeatureWeight)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 featureId = 1;
  if (this->featureid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->featureid(), output);
  }

  // repeated .CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight weights = 2;
  for (unsigned int i = 0, n = this->weights_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->weights(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.BayesianProbitRegressor.FeatureWeight)
}

size_t BayesianProbitRegressor_FeatureWeight::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.BayesianProbitRegressor.FeatureWeight)
  size_t total_size = 0;

  // repeated .CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight weights = 2;
  {
    unsigned int count = this->weights_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->weights(i));
    }
  }

  // uint32 featureId = 1;
  if (this->featureid() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->featureid());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BayesianProbitRegressor_FeatureWeight::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BayesianProbitRegressor_FeatureWeight*>(&from));
}

void BayesianProbitRegressor_FeatureWeight::MergeFrom(const BayesianProbitRegressor_FeatureWeight& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.BayesianProbitRegressor.FeatureWeight)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  weights_.MergeFrom(from.weights_);
  if (from.featureid() != 0) {
    set_featureid(from.featureid());
  }
}

void BayesianProbitRegressor_FeatureWeight::CopyFrom(const BayesianProbitRegressor_FeatureWeight& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.BayesianProbitRegressor.FeatureWeight)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BayesianProbitRegressor_FeatureWeight::IsInitialized() const {
  return true;
}

void BayesianProbitRegressor_FeatureWeight::Swap(BayesianProbitRegressor_FeatureWeight* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BayesianProbitRegressor_FeatureWeight::InternalSwap(BayesianProbitRegressor_FeatureWeight* other) {
  weights_.InternalSwap(&other->weights_);
  std::swap(featureid_, other->featureid_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string BayesianProbitRegressor_FeatureWeight::GetTypeName() const {
  return "CoreML.Specification.BayesianProbitRegressor.FeatureWeight";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BayesianProbitRegressor_FeatureWeight

// uint32 featureId = 1;
void BayesianProbitRegressor_FeatureWeight::clear_featureid() {
  featureid_ = 0u;
}
::google::protobuf::uint32 BayesianProbitRegressor_FeatureWeight::featureid() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.FeatureWeight.featureId)
  return featureid_;
}
void BayesianProbitRegressor_FeatureWeight::set_featureid(::google::protobuf::uint32 value) {
  
  featureid_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.FeatureWeight.featureId)
}

// repeated .CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight weights = 2;
int BayesianProbitRegressor_FeatureWeight::weights_size() const {
  return weights_.size();
}
void BayesianProbitRegressor_FeatureWeight::clear_weights() {
  weights_.Clear();
}
const ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight& BayesianProbitRegressor_FeatureWeight::weights(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.FeatureWeight.weights)
  return weights_.Get(index);
}
::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight* BayesianProbitRegressor_FeatureWeight::mutable_weights(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.FeatureWeight.weights)
  return weights_.Mutable(index);
}
::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight* BayesianProbitRegressor_FeatureWeight::add_weights() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.BayesianProbitRegressor.FeatureWeight.weights)
  return weights_.Add();
}
::google::protobuf::RepeatedPtrField< ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight >*
BayesianProbitRegressor_FeatureWeight::mutable_weights() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.BayesianProbitRegressor.FeatureWeight.weights)
  return &weights_;
}
const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight >&
BayesianProbitRegressor_FeatureWeight::weights() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.BayesianProbitRegressor.FeatureWeight.weights)
  return weights_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BayesianProbitRegressor::kNumberOfFeaturesFieldNumber;
const int BayesianProbitRegressor::kBiasFieldNumber;
const int BayesianProbitRegressor::kFeaturesFieldNumber;
const int BayesianProbitRegressor::kRegressionInputFeatureNameFieldNumber;
const int BayesianProbitRegressor::kOptimismInputFeatureNameFieldNumber;
const int BayesianProbitRegressor::kSamplingScaleInputFeatureNameFieldNumber;
const int BayesianProbitRegressor::kSamplingTruncationInputFeatureNameFieldNumber;
const int BayesianProbitRegressor::kMeanOutputFeatureNameFieldNumber;
const int BayesianProbitRegressor::kVarianceOutputFeatureNameFieldNumber;
const int BayesianProbitRegressor::kPessimisticProbabilityOutputFeatureNameFieldNumber;
const int BayesianProbitRegressor::kSampledProbabilityOutputFeatureNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BayesianProbitRegressor::BayesianProbitRegressor()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_BayesianProbitRegressor_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.BayesianProbitRegressor)
}
BayesianProbitRegressor::BayesianProbitRegressor(const BayesianProbitRegressor& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      features_(from.features_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  regressioninputfeaturename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.regressioninputfeaturename().size() > 0) {
    regressioninputfeaturename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.regressioninputfeaturename_);
  }
  optimisminputfeaturename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.optimisminputfeaturename().size() > 0) {
    optimisminputfeaturename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.optimisminputfeaturename_);
  }
  samplingscaleinputfeaturename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.samplingscaleinputfeaturename().size() > 0) {
    samplingscaleinputfeaturename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.samplingscaleinputfeaturename_);
  }
  samplingtruncationinputfeaturename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.samplingtruncationinputfeaturename().size() > 0) {
    samplingtruncationinputfeaturename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.samplingtruncationinputfeaturename_);
  }
  meanoutputfeaturename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.meanoutputfeaturename().size() > 0) {
    meanoutputfeaturename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.meanoutputfeaturename_);
  }
  varianceoutputfeaturename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.varianceoutputfeaturename().size() > 0) {
    varianceoutputfeaturename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.varianceoutputfeaturename_);
  }
  pessimisticprobabilityoutputfeaturename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.pessimisticprobabilityoutputfeaturename().size() > 0) {
    pessimisticprobabilityoutputfeaturename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pessimisticprobabilityoutputfeaturename_);
  }
  sampledprobabilityoutputfeaturename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.sampledprobabilityoutputfeaturename().size() > 0) {
    sampledprobabilityoutputfeaturename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sampledprobabilityoutputfeaturename_);
  }
  if (from.has_bias()) {
    bias_ = new ::CoreML::Specification::BayesianProbitRegressor_Gaussian(*from.bias_);
  } else {
    bias_ = NULL;
  }
  numberoffeatures_ = from.numberoffeatures_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.BayesianProbitRegressor)
}

void BayesianProbitRegressor::SharedCtor() {
  regressioninputfeaturename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  optimisminputfeaturename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  samplingscaleinputfeaturename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  samplingtruncationinputfeaturename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  meanoutputfeaturename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  varianceoutputfeaturename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pessimisticprobabilityoutputfeaturename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sampledprobabilityoutputfeaturename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&bias_, 0, reinterpret_cast<char*>(&numberoffeatures_) -
    reinterpret_cast<char*>(&bias_) + sizeof(numberoffeatures_));
  _cached_size_ = 0;
}

BayesianProbitRegressor::~BayesianProbitRegressor() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.BayesianProbitRegressor)
  SharedDtor();
}

void BayesianProbitRegressor::SharedDtor() {
  regressioninputfeaturename_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  optimisminputfeaturename_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  samplingscaleinputfeaturename_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  samplingtruncationinputfeaturename_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  meanoutputfeaturename_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  varianceoutputfeaturename_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pessimisticprobabilityoutputfeaturename_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sampledprobabilityoutputfeaturename_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete bias_;
  }
}

void BayesianProbitRegressor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BayesianProbitRegressor& BayesianProbitRegressor::default_instance() {
  protobuf_BayesianProbitRegressor_2eproto::InitDefaults();
  return *internal_default_instance();
}

BayesianProbitRegressor* BayesianProbitRegressor::New(::google::protobuf::Arena* arena) const {
  BayesianProbitRegressor* n = new BayesianProbitRegressor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BayesianProbitRegressor::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.BayesianProbitRegressor)
  features_.Clear();
  regressioninputfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  optimisminputfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  samplingscaleinputfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  samplingtruncationinputfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  meanoutputfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  varianceoutputfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pessimisticprobabilityoutputfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sampledprobabilityoutputfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && bias_ != NULL) {
    delete bias_;
  }
  bias_ = NULL;
  numberoffeatures_ = 0u;
}

bool BayesianProbitRegressor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.BayesianProbitRegressor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint32 numberOfFeatures = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &numberoffeatures_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.BayesianProbitRegressor.Gaussian bias = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bias()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .CoreML.Specification.BayesianProbitRegressor.FeatureWeight features = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_features()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string regressionInputFeatureName = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_regressioninputfeaturename()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->regressioninputfeaturename().data(), this->regressioninputfeaturename().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.BayesianProbitRegressor.regressionInputFeatureName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string optimismInputFeatureName = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(90u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_optimisminputfeaturename()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->optimisminputfeaturename().data(), this->optimisminputfeaturename().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.BayesianProbitRegressor.optimismInputFeatureName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string samplingScaleInputFeatureName = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(98u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_samplingscaleinputfeaturename()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->samplingscaleinputfeaturename().data(), this->samplingscaleinputfeaturename().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.BayesianProbitRegressor.samplingScaleInputFeatureName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string samplingTruncationInputFeatureName = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(106u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_samplingtruncationinputfeaturename()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->samplingtruncationinputfeaturename().data(), this->samplingtruncationinputfeaturename().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.BayesianProbitRegressor.samplingTruncationInputFeatureName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string meanOutputFeatureName = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(162u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_meanoutputfeaturename()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->meanoutputfeaturename().data(), this->meanoutputfeaturename().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.BayesianProbitRegressor.meanOutputFeatureName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string varianceOutputFeatureName = 21;
      case 21: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(170u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_varianceoutputfeaturename()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->varianceoutputfeaturename().data(), this->varianceoutputfeaturename().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.BayesianProbitRegressor.varianceOutputFeatureName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string pessimisticProbabilityOutputFeatureName = 22;
      case 22: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(178u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pessimisticprobabilityoutputfeaturename()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->pessimisticprobabilityoutputfeaturename().data(), this->pessimisticprobabilityoutputfeaturename().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.BayesianProbitRegressor.pessimisticProbabilityOutputFeatureName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string sampledProbabilityOutputFeatureName = 23;
      case 23: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(186u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sampledprobabilityoutputfeaturename()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->sampledprobabilityoutputfeaturename().data(), this->sampledprobabilityoutputfeaturename().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.BayesianProbitRegressor.sampledProbabilityOutputFeatureName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.BayesianProbitRegressor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.BayesianProbitRegressor)
  return false;
#undef DO_
}

void BayesianProbitRegressor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.BayesianProbitRegressor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 numberOfFeatures = 1;
  if (this->numberoffeatures() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->numberoffeatures(), output);
  }

  // .CoreML.Specification.BayesianProbitRegressor.Gaussian bias = 2;
  if (this->has_bias()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->bias_, output);
  }

  // repeated .CoreML.Specification.BayesianProbitRegressor.FeatureWeight features = 3;
  for (unsigned int i = 0, n = this->features_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->features(i), output);
  }

  // string regressionInputFeatureName = 10;
  if (this->regressioninputfeaturename().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->regressioninputfeaturename().data(), this->regressioninputfeaturename().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.BayesianProbitRegressor.regressionInputFeatureName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->regressioninputfeaturename(), output);
  }

  // string optimismInputFeatureName = 11;
  if (this->optimisminputfeaturename().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->optimisminputfeaturename().data(), this->optimisminputfeaturename().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.BayesianProbitRegressor.optimismInputFeatureName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      11, this->optimisminputfeaturename(), output);
  }

  // string samplingScaleInputFeatureName = 12;
  if (this->samplingscaleinputfeaturename().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->samplingscaleinputfeaturename().data(), this->samplingscaleinputfeaturename().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.BayesianProbitRegressor.samplingScaleInputFeatureName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      12, this->samplingscaleinputfeaturename(), output);
  }

  // string samplingTruncationInputFeatureName = 13;
  if (this->samplingtruncationinputfeaturename().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->samplingtruncationinputfeaturename().data(), this->samplingtruncationinputfeaturename().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.BayesianProbitRegressor.samplingTruncationInputFeatureName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      13, this->samplingtruncationinputfeaturename(), output);
  }

  // string meanOutputFeatureName = 20;
  if (this->meanoutputfeaturename().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->meanoutputfeaturename().data(), this->meanoutputfeaturename().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.BayesianProbitRegressor.meanOutputFeatureName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      20, this->meanoutputfeaturename(), output);
  }

  // string varianceOutputFeatureName = 21;
  if (this->varianceoutputfeaturename().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->varianceoutputfeaturename().data(), this->varianceoutputfeaturename().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.BayesianProbitRegressor.varianceOutputFeatureName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      21, this->varianceoutputfeaturename(), output);
  }

  // string pessimisticProbabilityOutputFeatureName = 22;
  if (this->pessimisticprobabilityoutputfeaturename().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->pessimisticprobabilityoutputfeaturename().data(), this->pessimisticprobabilityoutputfeaturename().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.BayesianProbitRegressor.pessimisticProbabilityOutputFeatureName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      22, this->pessimisticprobabilityoutputfeaturename(), output);
  }

  // string sampledProbabilityOutputFeatureName = 23;
  if (this->sampledprobabilityoutputfeaturename().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->sampledprobabilityoutputfeaturename().data(), this->sampledprobabilityoutputfeaturename().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.BayesianProbitRegressor.sampledProbabilityOutputFeatureName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      23, this->sampledprobabilityoutputfeaturename(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.BayesianProbitRegressor)
}

size_t BayesianProbitRegressor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.BayesianProbitRegressor)
  size_t total_size = 0;

  // repeated .CoreML.Specification.BayesianProbitRegressor.FeatureWeight features = 3;
  {
    unsigned int count = this->features_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->features(i));
    }
  }

  // string regressionInputFeatureName = 10;
  if (this->regressioninputfeaturename().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->regressioninputfeaturename());
  }

  // string optimismInputFeatureName = 11;
  if (this->optimisminputfeaturename().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->optimisminputfeaturename());
  }

  // string samplingScaleInputFeatureName = 12;
  if (this->samplingscaleinputfeaturename().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->samplingscaleinputfeaturename());
  }

  // string samplingTruncationInputFeatureName = 13;
  if (this->samplingtruncationinputfeaturename().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->samplingtruncationinputfeaturename());
  }

  // string meanOutputFeatureName = 20;
  if (this->meanoutputfeaturename().size() > 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->meanoutputfeaturename());
  }

  // string varianceOutputFeatureName = 21;
  if (this->varianceoutputfeaturename().size() > 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->varianceoutputfeaturename());
  }

  // string pessimisticProbabilityOutputFeatureName = 22;
  if (this->pessimisticprobabilityoutputfeaturename().size() > 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->pessimisticprobabilityoutputfeaturename());
  }

  // string sampledProbabilityOutputFeatureName = 23;
  if (this->sampledprobabilityoutputfeaturename().size() > 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->sampledprobabilityoutputfeaturename());
  }

  // .CoreML.Specification.BayesianProbitRegressor.Gaussian bias = 2;
  if (this->has_bias()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->bias_);
  }

  // uint32 numberOfFeatures = 1;
  if (this->numberoffeatures() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->numberoffeatures());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BayesianProbitRegressor::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BayesianProbitRegressor*>(&from));
}

void BayesianProbitRegressor::MergeFrom(const BayesianProbitRegressor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.BayesianProbitRegressor)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  features_.MergeFrom(from.features_);
  if (from.regressioninputfeaturename().size() > 0) {

    regressioninputfeaturename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.regressioninputfeaturename_);
  }
  if (from.optimisminputfeaturename().size() > 0) {

    optimisminputfeaturename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.optimisminputfeaturename_);
  }
  if (from.samplingscaleinputfeaturename().size() > 0) {

    samplingscaleinputfeaturename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.samplingscaleinputfeaturename_);
  }
  if (from.samplingtruncationinputfeaturename().size() > 0) {

    samplingtruncationinputfeaturename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.samplingtruncationinputfeaturename_);
  }
  if (from.meanoutputfeaturename().size() > 0) {

    meanoutputfeaturename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.meanoutputfeaturename_);
  }
  if (from.varianceoutputfeaturename().size() > 0) {

    varianceoutputfeaturename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.varianceoutputfeaturename_);
  }
  if (from.pessimisticprobabilityoutputfeaturename().size() > 0) {

    pessimisticprobabilityoutputfeaturename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pessimisticprobabilityoutputfeaturename_);
  }
  if (from.sampledprobabilityoutputfeaturename().size() > 0) {

    sampledprobabilityoutputfeaturename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sampledprobabilityoutputfeaturename_);
  }
  if (from.has_bias()) {
    mutable_bias()->::CoreML::Specification::BayesianProbitRegressor_Gaussian::MergeFrom(from.bias());
  }
  if (from.numberoffeatures() != 0) {
    set_numberoffeatures(from.numberoffeatures());
  }
}

void BayesianProbitRegressor::CopyFrom(const BayesianProbitRegressor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.BayesianProbitRegressor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BayesianProbitRegressor::IsInitialized() const {
  return true;
}

void BayesianProbitRegressor::Swap(BayesianProbitRegressor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BayesianProbitRegressor::InternalSwap(BayesianProbitRegressor* other) {
  features_.InternalSwap(&other->features_);
  regressioninputfeaturename_.Swap(&other->regressioninputfeaturename_);
  optimisminputfeaturename_.Swap(&other->optimisminputfeaturename_);
  samplingscaleinputfeaturename_.Swap(&other->samplingscaleinputfeaturename_);
  samplingtruncationinputfeaturename_.Swap(&other->samplingtruncationinputfeaturename_);
  meanoutputfeaturename_.Swap(&other->meanoutputfeaturename_);
  varianceoutputfeaturename_.Swap(&other->varianceoutputfeaturename_);
  pessimisticprobabilityoutputfeaturename_.Swap(&other->pessimisticprobabilityoutputfeaturename_);
  sampledprobabilityoutputfeaturename_.Swap(&other->sampledprobabilityoutputfeaturename_);
  std::swap(bias_, other->bias_);
  std::swap(numberoffeatures_, other->numberoffeatures_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string BayesianProbitRegressor::GetTypeName() const {
  return "CoreML.Specification.BayesianProbitRegressor";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BayesianProbitRegressor

// uint32 numberOfFeatures = 1;
void BayesianProbitRegressor::clear_numberoffeatures() {
  numberoffeatures_ = 0u;
}
::google::protobuf::uint32 BayesianProbitRegressor::numberoffeatures() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.numberOfFeatures)
  return numberoffeatures_;
}
void BayesianProbitRegressor::set_numberoffeatures(::google::protobuf::uint32 value) {
  
  numberoffeatures_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.numberOfFeatures)
}

// .CoreML.Specification.BayesianProbitRegressor.Gaussian bias = 2;
bool BayesianProbitRegressor::has_bias() const {
  return this != internal_default_instance() && bias_ != NULL;
}
void BayesianProbitRegressor::clear_bias() {
  if (GetArenaNoVirtual() == NULL && bias_ != NULL) delete bias_;
  bias_ = NULL;
}
const ::CoreML::Specification::BayesianProbitRegressor_Gaussian& BayesianProbitRegressor::bias() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.bias)
  return bias_ != NULL ? *bias_
                         : *::CoreML::Specification::BayesianProbitRegressor_Gaussian::internal_default_instance();
}
::CoreML::Specification::BayesianProbitRegressor_Gaussian* BayesianProbitRegressor::mutable_bias() {
  
  if (bias_ == NULL) {
    bias_ = new ::CoreML::Specification::BayesianProbitRegressor_Gaussian;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.bias)
  return bias_;
}
::CoreML::Specification::BayesianProbitRegressor_Gaussian* BayesianProbitRegressor::release_bias() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.bias)
  
  ::CoreML::Specification::BayesianProbitRegressor_Gaussian* temp = bias_;
  bias_ = NULL;
  return temp;
}
void BayesianProbitRegressor::set_allocated_bias(::CoreML::Specification::BayesianProbitRegressor_Gaussian* bias) {
  delete bias_;
  bias_ = bias;
  if (bias) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.bias)
}

// repeated .CoreML.Specification.BayesianProbitRegressor.FeatureWeight features = 3;
int BayesianProbitRegressor::features_size() const {
  return features_.size();
}
void BayesianProbitRegressor::clear_features() {
  features_.Clear();
}
const ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight& BayesianProbitRegressor::features(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.features)
  return features_.Get(index);
}
::CoreML::Specification::BayesianProbitRegressor_FeatureWeight* BayesianProbitRegressor::mutable_features(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.features)
  return features_.Mutable(index);
}
::CoreML::Specification::BayesianProbitRegressor_FeatureWeight* BayesianProbitRegressor::add_features() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.BayesianProbitRegressor.features)
  return features_.Add();
}
::google::protobuf::RepeatedPtrField< ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight >*
BayesianProbitRegressor::mutable_features() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.BayesianProbitRegressor.features)
  return &features_;
}
const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight >&
BayesianProbitRegressor::features() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.BayesianProbitRegressor.features)
  return features_;
}

// string regressionInputFeatureName = 10;
void BayesianProbitRegressor::clear_regressioninputfeaturename() {
  regressioninputfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& BayesianProbitRegressor::regressioninputfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.regressionInputFeatureName)
  return regressioninputfeaturename_.GetNoArena();
}
void BayesianProbitRegressor::set_regressioninputfeaturename(const ::std::string& value) {
  
  regressioninputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.regressionInputFeatureName)
}
#if LANG_CXX11
void BayesianProbitRegressor::set_regressioninputfeaturename(::std::string&& value) {
  
  regressioninputfeaturename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.BayesianProbitRegressor.regressionInputFeatureName)
}
#endif
void BayesianProbitRegressor::set_regressioninputfeaturename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  regressioninputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.BayesianProbitRegressor.regressionInputFeatureName)
}
void BayesianProbitRegressor::set_regressioninputfeaturename(const char* value, size_t size) {
  
  regressioninputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.BayesianProbitRegressor.regressionInputFeatureName)
}
::std::string* BayesianProbitRegressor::mutable_regressioninputfeaturename() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.regressionInputFeatureName)
  return regressioninputfeaturename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* BayesianProbitRegressor::release_regressioninputfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.regressionInputFeatureName)
  
  return regressioninputfeaturename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void BayesianProbitRegressor::set_allocated_regressioninputfeaturename(::std::string* regressioninputfeaturename) {
  if (regressioninputfeaturename != NULL) {
    
  } else {
    
  }
  regressioninputfeaturename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), regressioninputfeaturename);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.regressionInputFeatureName)
}

// string optimismInputFeatureName = 11;
void BayesianProbitRegressor::clear_optimisminputfeaturename() {
  optimisminputfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& BayesianProbitRegressor::optimisminputfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.optimismInputFeatureName)
  return optimisminputfeaturename_.GetNoArena();
}
void BayesianProbitRegressor::set_optimisminputfeaturename(const ::std::string& value) {
  
  optimisminputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.optimismInputFeatureName)
}
#if LANG_CXX11
void BayesianProbitRegressor::set_optimisminputfeaturename(::std::string&& value) {
  
  optimisminputfeaturename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.BayesianProbitRegressor.optimismInputFeatureName)
}
#endif
void BayesianProbitRegressor::set_optimisminputfeaturename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  optimisminputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.BayesianProbitRegressor.optimismInputFeatureName)
}
void BayesianProbitRegressor::set_optimisminputfeaturename(const char* value, size_t size) {
  
  optimisminputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.BayesianProbitRegressor.optimismInputFeatureName)
}
::std::string* BayesianProbitRegressor::mutable_optimisminputfeaturename() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.optimismInputFeatureName)
  return optimisminputfeaturename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* BayesianProbitRegressor::release_optimisminputfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.optimismInputFeatureName)
  
  return optimisminputfeaturename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void BayesianProbitRegressor::set_allocated_optimisminputfeaturename(::std::string* optimisminputfeaturename) {
  if (optimisminputfeaturename != NULL) {
    
  } else {
    
  }
  optimisminputfeaturename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), optimisminputfeaturename);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.optimismInputFeatureName)
}

// string samplingScaleInputFeatureName = 12;
void BayesianProbitRegressor::clear_samplingscaleinputfeaturename() {
  samplingscaleinputfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& BayesianProbitRegressor::samplingscaleinputfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.samplingScaleInputFeatureName)
  return samplingscaleinputfeaturename_.GetNoArena();
}
void BayesianProbitRegressor::set_samplingscaleinputfeaturename(const ::std::string& value) {
  
  samplingscaleinputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.samplingScaleInputFeatureName)
}
#if LANG_CXX11
void BayesianProbitRegressor::set_samplingscaleinputfeaturename(::std::string&& value) {
  
  samplingscaleinputfeaturename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.BayesianProbitRegressor.samplingScaleInputFeatureName)
}
#endif
void BayesianProbitRegressor::set_samplingscaleinputfeaturename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  samplingscaleinputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.BayesianProbitRegressor.samplingScaleInputFeatureName)
}
void BayesianProbitRegressor::set_samplingscaleinputfeaturename(const char* value, size_t size) {
  
  samplingscaleinputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.BayesianProbitRegressor.samplingScaleInputFeatureName)
}
::std::string* BayesianProbitRegressor::mutable_samplingscaleinputfeaturename() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.samplingScaleInputFeatureName)
  return samplingscaleinputfeaturename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* BayesianProbitRegressor::release_samplingscaleinputfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.samplingScaleInputFeatureName)
  
  return samplingscaleinputfeaturename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void BayesianProbitRegressor::set_allocated_samplingscaleinputfeaturename(::std::string* samplingscaleinputfeaturename) {
  if (samplingscaleinputfeaturename != NULL) {
    
  } else {
    
  }
  samplingscaleinputfeaturename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), samplingscaleinputfeaturename);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.samplingScaleInputFeatureName)
}

// string samplingTruncationInputFeatureName = 13;
void BayesianProbitRegressor::clear_samplingtruncationinputfeaturename() {
  samplingtruncationinputfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& BayesianProbitRegressor::samplingtruncationinputfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.samplingTruncationInputFeatureName)
  return samplingtruncationinputfeaturename_.GetNoArena();
}
void BayesianProbitRegressor::set_samplingtruncationinputfeaturename(const ::std::string& value) {
  
  samplingtruncationinputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.samplingTruncationInputFeatureName)
}
#if LANG_CXX11
void BayesianProbitRegressor::set_samplingtruncationinputfeaturename(::std::string&& value) {
  
  samplingtruncationinputfeaturename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.BayesianProbitRegressor.samplingTruncationInputFeatureName)
}
#endif
void BayesianProbitRegressor::set_samplingtruncationinputfeaturename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  samplingtruncationinputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.BayesianProbitRegressor.samplingTruncationInputFeatureName)
}
void BayesianProbitRegressor::set_samplingtruncationinputfeaturename(const char* value, size_t size) {
  
  samplingtruncationinputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.BayesianProbitRegressor.samplingTruncationInputFeatureName)
}
::std::string* BayesianProbitRegressor::mutable_samplingtruncationinputfeaturename() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.samplingTruncationInputFeatureName)
  return samplingtruncationinputfeaturename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* BayesianProbitRegressor::release_samplingtruncationinputfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.samplingTruncationInputFeatureName)
  
  return samplingtruncationinputfeaturename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void BayesianProbitRegressor::set_allocated_samplingtruncationinputfeaturename(::std::string* samplingtruncationinputfeaturename) {
  if (samplingtruncationinputfeaturename != NULL) {
    
  } else {
    
  }
  samplingtruncationinputfeaturename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), samplingtruncationinputfeaturename);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.samplingTruncationInputFeatureName)
}

// string meanOutputFeatureName = 20;
void BayesianProbitRegressor::clear_meanoutputfeaturename() {
  meanoutputfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& BayesianProbitRegressor::meanoutputfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.meanOutputFeatureName)
  return meanoutputfeaturename_.GetNoArena();
}
void BayesianProbitRegressor::set_meanoutputfeaturename(const ::std::string& value) {
  
  meanoutputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.meanOutputFeatureName)
}
#if LANG_CXX11
void BayesianProbitRegressor::set_meanoutputfeaturename(::std::string&& value) {
  
  meanoutputfeaturename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.BayesianProbitRegressor.meanOutputFeatureName)
}
#endif
void BayesianProbitRegressor::set_meanoutputfeaturename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  meanoutputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.BayesianProbitRegressor.meanOutputFeatureName)
}
void BayesianProbitRegressor::set_meanoutputfeaturename(const char* value, size_t size) {
  
  meanoutputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.BayesianProbitRegressor.meanOutputFeatureName)
}
::std::string* BayesianProbitRegressor::mutable_meanoutputfeaturename() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.meanOutputFeatureName)
  return meanoutputfeaturename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* BayesianProbitRegressor::release_meanoutputfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.meanOutputFeatureName)
  
  return meanoutputfeaturename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void BayesianProbitRegressor::set_allocated_meanoutputfeaturename(::std::string* meanoutputfeaturename) {
  if (meanoutputfeaturename != NULL) {
    
  } else {
    
  }
  meanoutputfeaturename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), meanoutputfeaturename);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.meanOutputFeatureName)
}

// string varianceOutputFeatureName = 21;
void BayesianProbitRegressor::clear_varianceoutputfeaturename() {
  varianceoutputfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& BayesianProbitRegressor::varianceoutputfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.varianceOutputFeatureName)
  return varianceoutputfeaturename_.GetNoArena();
}
void BayesianProbitRegressor::set_varianceoutputfeaturename(const ::std::string& value) {
  
  varianceoutputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.varianceOutputFeatureName)
}
#if LANG_CXX11
void BayesianProbitRegressor::set_varianceoutputfeaturename(::std::string&& value) {
  
  varianceoutputfeaturename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.BayesianProbitRegressor.varianceOutputFeatureName)
}
#endif
void BayesianProbitRegressor::set_varianceoutputfeaturename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  varianceoutputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.BayesianProbitRegressor.varianceOutputFeatureName)
}
void BayesianProbitRegressor::set_varianceoutputfeaturename(const char* value, size_t size) {
  
  varianceoutputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.BayesianProbitRegressor.varianceOutputFeatureName)
}
::std::string* BayesianProbitRegressor::mutable_varianceoutputfeaturename() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.varianceOutputFeatureName)
  return varianceoutputfeaturename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* BayesianProbitRegressor::release_varianceoutputfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.varianceOutputFeatureName)
  
  return varianceoutputfeaturename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void BayesianProbitRegressor::set_allocated_varianceoutputfeaturename(::std::string* varianceoutputfeaturename) {
  if (varianceoutputfeaturename != NULL) {
    
  } else {
    
  }
  varianceoutputfeaturename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), varianceoutputfeaturename);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.varianceOutputFeatureName)
}

// string pessimisticProbabilityOutputFeatureName = 22;
void BayesianProbitRegressor::clear_pessimisticprobabilityoutputfeaturename() {
  pessimisticprobabilityoutputfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& BayesianProbitRegressor::pessimisticprobabilityoutputfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.pessimisticProbabilityOutputFeatureName)
  return pessimisticprobabilityoutputfeaturename_.GetNoArena();
}
void BayesianProbitRegressor::set_pessimisticprobabilityoutputfeaturename(const ::std::string& value) {
  
  pessimisticprobabilityoutputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.pessimisticProbabilityOutputFeatureName)
}
#if LANG_CXX11
void BayesianProbitRegressor::set_pessimisticprobabilityoutputfeaturename(::std::string&& value) {
  
  pessimisticprobabilityoutputfeaturename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.BayesianProbitRegressor.pessimisticProbabilityOutputFeatureName)
}
#endif
void BayesianProbitRegressor::set_pessimisticprobabilityoutputfeaturename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pessimisticprobabilityoutputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.BayesianProbitRegressor.pessimisticProbabilityOutputFeatureName)
}
void BayesianProbitRegressor::set_pessimisticprobabilityoutputfeaturename(const char* value, size_t size) {
  
  pessimisticprobabilityoutputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.BayesianProbitRegressor.pessimisticProbabilityOutputFeatureName)
}
::std::string* BayesianProbitRegressor::mutable_pessimisticprobabilityoutputfeaturename() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.pessimisticProbabilityOutputFeatureName)
  return pessimisticprobabilityoutputfeaturename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* BayesianProbitRegressor::release_pessimisticprobabilityoutputfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.pessimisticProbabilityOutputFeatureName)
  
  return pessimisticprobabilityoutputfeaturename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void BayesianProbitRegressor::set_allocated_pessimisticprobabilityoutputfeaturename(::std::string* pessimisticprobabilityoutputfeaturename) {
  if (pessimisticprobabilityoutputfeaturename != NULL) {
    
  } else {
    
  }
  pessimisticprobabilityoutputfeaturename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pessimisticprobabilityoutputfeaturename);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.pessimisticProbabilityOutputFeatureName)
}

// string sampledProbabilityOutputFeatureName = 23;
void BayesianProbitRegressor::clear_sampledprobabilityoutputfeaturename() {
  sampledprobabilityoutputfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& BayesianProbitRegressor::sampledprobabilityoutputfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.sampledProbabilityOutputFeatureName)
  return sampledprobabilityoutputfeaturename_.GetNoArena();
}
void BayesianProbitRegressor::set_sampledprobabilityoutputfeaturename(const ::std::string& value) {
  
  sampledprobabilityoutputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.sampledProbabilityOutputFeatureName)
}
#if LANG_CXX11
void BayesianProbitRegressor::set_sampledprobabilityoutputfeaturename(::std::string&& value) {
  
  sampledprobabilityoutputfeaturename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.BayesianProbitRegressor.sampledProbabilityOutputFeatureName)
}
#endif
void BayesianProbitRegressor::set_sampledprobabilityoutputfeaturename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sampledprobabilityoutputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.BayesianProbitRegressor.sampledProbabilityOutputFeatureName)
}
void BayesianProbitRegressor::set_sampledprobabilityoutputfeaturename(const char* value, size_t size) {
  
  sampledprobabilityoutputfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.BayesianProbitRegressor.sampledProbabilityOutputFeatureName)
}
::std::string* BayesianProbitRegressor::mutable_sampledprobabilityoutputfeaturename() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.sampledProbabilityOutputFeatureName)
  return sampledprobabilityoutputfeaturename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* BayesianProbitRegressor::release_sampledprobabilityoutputfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.sampledProbabilityOutputFeatureName)
  
  return sampledprobabilityoutputfeaturename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void BayesianProbitRegressor::set_allocated_sampledprobabilityoutputfeaturename(::std::string* sampledprobabilityoutputfeaturename) {
  if (sampledprobabilityoutputfeaturename != NULL) {
    
  } else {
    
  }
  sampledprobabilityoutputfeaturename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sampledprobabilityoutputfeaturename);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.sampledProbabilityOutputFeatureName)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace Specification
}  // namespace CoreML

// @@protoc_insertion_point(global_scope)
