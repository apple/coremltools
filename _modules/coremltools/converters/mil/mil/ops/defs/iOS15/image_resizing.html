<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>coremltools.converters.mil.mil.ops.defs.iOS15.image_resizing &mdash; coremltools API Reference 7.1 documentation</title>
      <link rel="stylesheet" href="../../../../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../../../../_static/sg_gallery-rendered-html.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../../../../_static/css/norightmargin.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../../../../../" id="documentation_options" src="../../../../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../../../../_static/jquery.js"></script>
        <script src="../../../../../../../../_static/underscore.js"></script>
        <script src="../../../../../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../../../../../_static/doctools.js"></script>
        <script src="../../../../../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../../index.html" class="icon icon-home">
            coremltools API Reference
          </a>
              <div class="version">
                7.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">API Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../source/coremltools.converters.html">Converters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../source/coremltools.models.html">Model APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../source/coremltools.converters.mil.html">MIL Builder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../source/coremltools.converters.mil.input_types.html">MIL Input Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../source/coremltools.converters.mil.mil.ops.defs.html">MIL Ops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../source/coremltools.converters.mil.mil.passes.defs.html">MIL Graph Passes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../source/coremltools.optimize.html">Optimizers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Resources</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://apple.github.io/coremltools/docs-guides/index.html">Guide and Examples</a></li>
<li class="toctree-l1"><a class="reference external" href="https://apple.github.io/coremltools/mlmodel/index.html">Core ML Format Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../source/api-versions.html">Previous Versions</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/apple/coremltools">GitHub</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../../index.html">coremltools API Reference</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">coremltools.converters.mil.mil.ops.defs.iOS15.image_resizing</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for coremltools.converters.mil.mil.ops.defs.iOS15.image_resizing</h1><div class="highlight"><pre>
<span></span><span class="c1">#  Copyright (c) 2022, Apple Inc. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1">#  Use of this source code is governed by a BSD-3-clause license that can be</span>
<span class="c1">#  found in the LICENSE.txt file or at https://opensource.org/licenses/BSD-3-Clause</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">coremltools.converters.mil.mil</span> <span class="kn">import</span> <span class="p">(</span><span class="n">DefaultInputs</span><span class="p">,</span> <span class="n">InputSpec</span><span class="p">,</span>
                                            <span class="n">Operation</span><span class="p">,</span> <span class="n">TensorInputType</span><span class="p">,</span>
                                            <span class="n">get_new_symbol</span><span class="p">,</span> <span class="n">types</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">coremltools.converters.mil.mil.ops.defs._op_reqs</span> <span class="kn">import</span> <span class="n">register_op</span>
<span class="kn">from</span> <span class="nn">coremltools.converters.mil.mil.ops.defs.iOS15</span> <span class="kn">import</span> <span class="n">_IOS15_TARGET</span>
<span class="kn">from</span> <span class="nn">coremltools.converters.mil.mil.types.symbolic</span> <span class="kn">import</span> <span class="n">is_symbolic</span>


<div class="viewcode-block" id="upsample_nearest_neighbor"><a class="viewcode-back" href="../../../../../../../../source/coremltools.converters.mil.mil.ops.defs.html#coremltools.converters.mil.mil.ops.defs.iOS15.image_resizing.upsample_nearest_neighbor">[docs]</a><span class="nd">@register_op</span>
<span class="k">class</span> <span class="nc">upsample_nearest_neighbor</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Upsample the spatial dimensions (last two dimensions) of the input</span>
<span class="sd">    by integer scale factors using nearest-neighbor interpolation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: tensor&lt;[\*D, H1, W1],T&gt;  (Required)</span>
<span class="sd">        * Must be at least rank ``3``.</span>
<span class="sd">    scale_factor_height: const&lt;i32&gt; or const&lt;fp32&gt; (Optional, default=1)</span>
<span class="sd">        * Scale factor for the height dimension (``axis=-2``).</span>
<span class="sd">        * Can be either an integer or fractional.</span>
<span class="sd">    scale_factor_width: const&lt;i32&gt; or const&lt;fp32&gt; (Optional, default=1)</span>
<span class="sd">        * Scale factor for the width dimension (``axis=-1``).</span>
<span class="sd">        * Can be either an integer or fractional.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor&lt;[\*D, H2, W2],T&gt;</span>
<span class="sd">        * Tensor with same type as the input.</span>
<span class="sd">        * ``H2`` = floor(``H1`` * ``scale_factor_height``).</span>
<span class="sd">        * ``W2`` = floor(``W1`` * ``scale_factor_width``).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    T: fp16, fp32</span>
<span class="sd">    U: fp32, i32</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">input_spec</span> <span class="o">=</span> <span class="n">InputSpec</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">type_domain</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">),</span>
        <span class="n">scale_factor_height</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span>
            <span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">optional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">type_domain</span><span class="o">=</span><span class="s2">&quot;U&quot;</span>
        <span class="p">),</span>
        <span class="n">scale_factor_width</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span>
            <span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">optional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">type_domain</span><span class="o">=</span><span class="s2">&quot;U&quot;</span>
        <span class="p">),</span>
    <span class="p">)</span>

    <span class="n">type_domains</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">fp16</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">fp32</span><span class="p">),</span>
        <span class="s2">&quot;U&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">fp32</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">default_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">DefaultInputs</span><span class="p">(</span>
            <span class="n">scale_factor_height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">scale_factor_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">type_inference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">rank</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;input to the &quot;upsample_nearest_neighbor&quot; op must have rank at least 3&#39;</span>
            <span class="p">)</span>

        <span class="n">ret_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">ret_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_factor_width</span><span class="o">.</span><span class="n">val</span> <span class="o">*</span> <span class="n">ret_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symbolic</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">else</span> <span class="n">get_new_symbol</span><span class="p">()</span>
        <span class="n">ret_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_factor_height</span><span class="o">.</span><span class="n">val</span> <span class="o">*</span> <span class="n">ret_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symbolic</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="k">else</span> <span class="n">get_new_symbol</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ret_shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="resize_nearest_neighbor"><a class="viewcode-back" href="../../../../../../../../source/coremltools.converters.mil.mil.ops.defs.html#coremltools.converters.mil.mil.ops.defs.iOS15.image_resizing.resize_nearest_neighbor">[docs]</a><span class="nd">@register_op</span>
<span class="k">class</span> <span class="nc">resize_nearest_neighbor</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resize the spatial (last two) dimensions to the specified target size</span>
<span class="sd">    using nearest neighbor interpolation. Although this op is similar to</span>
<span class="sd">    ``upsample_nearest_neighbor``, ``resize_nearest_neighbor`` works with</span>
<span class="sd">    a target size rather than with scale factors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: tensor&lt;[\*D, H1, W1], T&gt; (Required)</span>
<span class="sd">        * Must be at least rank ``3``.</span>
<span class="sd">    target_size_height: const&lt;int32&gt; (Required)</span>
<span class="sd">        * Target spatial size for the height dimension (``axis=-2``).</span>
<span class="sd">    target_size_width: const&lt;int32&gt; (Required)</span>
<span class="sd">        * Target spatial size for the width dimension (``axis=-1``).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See ``resize_bilinear`` for examples.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    resize_bilinear</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor&lt;[\*D, H2, W2], T&gt;</span>
<span class="sd">        * Tensor with same type as the input.</span>
<span class="sd">        * ``H2`` = ``target_size_height``.</span>
<span class="sd">        * ``W2`` = ``target_size_width``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    T: fp16, fp32</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">input_spec</span> <span class="o">=</span> <span class="n">InputSpec</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">type_domain</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">),</span>
        <span class="n">target_size_height</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
        <span class="n">target_size_width</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="n">type_domains</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">fp16</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">fp32</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">type_inference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">rank</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;input to the &quot;resize_nearest_neighbor&quot; op must have rank at least 3&#39;</span>
            <span class="p">)</span>

        <span class="n">ret_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">ret_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_size_width</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">ret_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_size_height</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ret_shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="upsample_bilinear"><a class="viewcode-back" href="../../../../../../../../source/coremltools.converters.mil.mil.ops.defs.html#coremltools.converters.mil.mil.ops.defs.iOS15.image_resizing.upsample_bilinear">[docs]</a><span class="nd">@register_op</span>
<span class="k">class</span> <span class="nc">upsample_bilinear</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Upsample the spatial dimensions (last two dimensions) of the input</span>
<span class="sd">    by scale factors using bilinear interpolation.</span>
<span class="sd">    The upsample_bilinear operation in MIL corresponds to the ``recompute_scale_factor=True``</span>
<span class="sd">    mode in the pyorch bilinear interpolation op. That is,</span>
<span class="sd">    the scale factor is recomputed by the output size.</span>
<span class="sd">    Note that when the ``scale_factor_height`` and ``scale_factor_width`` are floating point, this</span>
<span class="sd">    could result in a different scale factor due to rounding.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: tensor&lt;[\*D, H1, W1], T&gt;  (Required)</span>
<span class="sd">        * Must be at least rank ``3``.</span>
<span class="sd">    scale_factor_height: const&lt;U&gt; (Optional, default=1)</span>
<span class="sd">        * Scale factor for the height dimension (``axis=-2``).</span>
<span class="sd">    scale_factor_width: const&lt;U&gt; (Optional, default=1)</span>
<span class="sd">        * Scale factor for the width dimension (``axis=-1``).</span>
<span class="sd">    align_corners: const&lt;bool&gt; (Optional, default=True)</span>
<span class="sd">        * This parameter determines how samples are chosen for bilinear</span>
<span class="sd">          interpolation. For details, see the Notes section.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    To understand the ``align_corners`` parameter, consider the 1-D case.</span>
<span class="sd">    You need to sample a grid of pixels whose values are computed using linear</span>
<span class="sd">    interpolation. This parameter controls how the grid is sampled. If the</span>
<span class="sd">    input grid is ``[0, Xin-1]`` (corresponding to an input size of ``Xin``),</span>
<span class="sd">    and if the output size is ``Xout``, then the grid points are sampled in</span>
<span class="sd">    the following manner:</span>

<span class="sd">    .. sourcecode:: python</span>

<span class="sd">        # If align_corners == True:</span>
<span class="sd">        spacing = (Xin - 1) / (Xout - 1)</span>
<span class="sd">        grid_point[i] = min(Xin - 1, max(0, i*spacing)), for i=0,1,...,Xout-1</span>

<span class="sd">        # If align_corners == False:</span>
<span class="sd">        spacing = Xin / Xout</span>
<span class="sd">        grid_point[i] = min(Xin - 1, max(0, i*spacing + 0.5*spacing - 0.5)),</span>
<span class="sd">        ...   for i=0,1,...,Xout-1</span>

<span class="sd">    For example:</span>

<span class="sd">    .. sourcecode:: python</span>

<span class="sd">        Xin = 2</span>
<span class="sd">        input_interval = [0,1]</span>

<span class="sd">    Grid points:</span>

<span class="sd">    .. sourcecode:: python</span>

<span class="sd">        [0., 0.1, 0.5, 0.9, 1.] (Xout = 5, align_corners=False)</span>
<span class="sd">        [0., 0.25, 0.5, 0.75, 1.] (Xout = 5, align_corners=True)</span>
<span class="sd">        [0., 0., 0.33, 0.67, 1., 1.] (Xout = 6, align_corners=False)</span>
<span class="sd">        [0., 0.2, 0.4, 0.6, 0.8, 1.] (Xout = 6, align_corners=True)</span>

<span class="sd">    Note the following similarities:</span>

<span class="sd">    * ``align_corners=False`` is the same as</span>
<span class="sd">      ``tf.raw_ops.ResizeBilinear(align_corners=False, half_pixel_centers=True)``.</span>

<span class="sd">    * ``align_corners=True`` is the same as</span>
<span class="sd">      ``tf.raw_ops.ResizeBilinear(align_corners=True, half_pixel_centers=False)``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor&lt;[\*D, H2, W2], T&gt;</span>
<span class="sd">        * Tensor with same type as the input.</span>
<span class="sd">        * ``H2`` = floor(``H1`` * ``scale_factor_height``).</span>
<span class="sd">        * ``W2`` = floor(``W1`` * ``scale_factor_width``).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    T: fp16, fp32</span>
<span class="sd">    U : fp32, i32</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">input_spec</span> <span class="o">=</span> <span class="n">InputSpec</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">type_domain</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">),</span>
        <span class="n">scale_factor_height</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span>
            <span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">optional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">type_domain</span><span class="o">=</span><span class="s2">&quot;U&quot;</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">scale_factor_width</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span>
            <span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">optional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">type_domain</span><span class="o">=</span><span class="s2">&quot;U&quot;</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">align_corners</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span>
            <span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">optional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">bool</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="n">type_domains</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">fp16</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">fp32</span><span class="p">),</span>
        <span class="s2">&quot;U&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">fp32</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">default_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">DefaultInputs</span><span class="p">(</span>
            <span class="n">scale_factor_height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">scale_factor_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">align_corners</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">type_inference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">rank</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;input to the &quot;upsample_bilinear&quot; op must have rank at least 3&#39;</span>
            <span class="p">)</span>

        <span class="n">ret_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">ret_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_factor_width</span><span class="o">.</span><span class="n">val</span> <span class="o">*</span> <span class="n">ret_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symbolic</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">else</span> <span class="n">get_new_symbol</span><span class="p">()</span>
        <span class="n">ret_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_factor_height</span><span class="o">.</span><span class="n">val</span> <span class="o">*</span> <span class="n">ret_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symbolic</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="k">else</span> <span class="n">get_new_symbol</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ret_shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="resize_bilinear"><a class="viewcode-back" href="../../../../../../../../source/coremltools.converters.mil.mil.ops.defs.html#coremltools.converters.mil.mil.ops.defs.iOS15.image_resizing.resize_bilinear">[docs]</a><span class="nd">@register_op</span>
<span class="k">class</span> <span class="nc">resize_bilinear</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resize the spatial (last two) dimensions to the specified target size</span>
<span class="sd">    using bilinear interpolation. Although this op is similar to</span>
<span class="sd">    ``upsample_bilinear``, ``resize_bilinear`` works with a target size</span>
<span class="sd">    rather than with scale factors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: tensor&lt;[\*D, H1, W1],T&gt; (Required)</span>
<span class="sd">        * Must be at least rank ``3``.</span>
<span class="sd">    target_size_height: const&lt;int32&gt; (Optional, default=1)</span>
<span class="sd">        * Target spatial size for the height dimension (``axis=-2``).</span>
<span class="sd">    target_size_width: const&lt;int32&gt; (Optional, default=1)</span>
<span class="sd">        * Target spatial size for the width dimension (``axis=-1``).</span>
<span class="sd">    sampling_mode: const&lt;str&gt; (Optional, default=&quot;DEFAULT&quot;)</span>
<span class="sd">        * This parameter can take ``&quot;STRICT_ALIGN_CORNERS‚Äù``, ``&quot;ALIGN_CORNERS&quot;``,</span>
<span class="sd">          ``&quot;DEFAULT&quot;``, ``&quot;OFFSET_CORNERS&quot;`` or ``UNALIGN_CORNERS`` as values.</span>
<span class="sd">          For details, see the Notes section.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    To understand the ``sampling_mode`` parameter, consider the 1-D case.</span>
<span class="sd">    You need to sample a grid of pixels whose values are computed using</span>
<span class="sd">    linear interpolation. This parameter controls how the grid is sampled.</span>
<span class="sd">    If the input grid is ``[0, Xin-1]`` (corresponding to an input size of</span>
<span class="sd">    ``Xin``), and if the output size is ``Xout``, then the grid points are</span>
<span class="sd">    sampled in the following manner:</span>

<span class="sd">    .. sourcecode:: python</span>

<span class="sd">        # &quot;STRICT_ALIGN_CORNERS&quot;:</span>
<span class="sd">        spacing = (Xin - 1) / (Xout - 1)</span>
<span class="sd">        grid_point[i] = min(Xin-1, max(0, i*spacing)), for i=0,1,...,Xout-1</span>

<span class="sd">        # &quot;ALIGN_CORNERS&quot;: Same as &quot;STRICT_ALIGN_CORNERS&quot; unless Xout=1,</span>
<span class="sd">        # in which case:</span>
<span class="sd">        grid_point[0] = (Xin-1) / 2, if Xout==1</span>

<span class="sd">        # &quot;DEFAULT&quot;:</span>
<span class="sd">        spacing = (Xin - Xin/Xout) / (Xout - 1)</span>
<span class="sd">        grid_point[i] = min(Xin-1, max(0, i*spacing)), for i=0,1,...,Xout-1</span>

<span class="sd">        # &quot;OFFSET_CORNERS&quot;:</span>
<span class="sd">        delta = max(1, Xin - 1) / Xout</span>
<span class="sd">        spacing = ((Xout - 1) * delta) / (Xout - 1)</span>
<span class="sd">        grid_point[i] = min(Xin-1, max(0, 0.5*delta + i*spacing)), for</span>
<span class="sd">        ...   i=0,1,...,Xout-1</span>

<span class="sd">        # &quot;UNALIGN_CORNERS&quot;:</span>
<span class="sd">        spacing = Xin / Xout</span>
<span class="sd">        grid_point[i] = min(Xin - 1, max(0, i*spacing + 0.5*spacing - 0.5)), for i=0,1,...,Xout-1</span>

<span class="sd">    For example:</span>

<span class="sd">    .. sourcecode:: python</span>

<span class="sd">        Xin = 2</span>
<span class="sd">        input_interval = [0,1]</span>

<span class="sd">    Grid points:</span>

<span class="sd">    .. sourcecode:: python</span>

<span class="sd">        [0., 0.1, 0.5, 0.9, 1.] (Xout = 5, UNALIGN_CORNERS)</span>
<span class="sd">        [0., 0.25, 0.5, 0.75, 1.] (Xout = 5, &quot;STRICT_ALIGN_CORNERS&quot; / &quot;ALIGN_CORNERS&quot;)</span>
<span class="sd">        [0., 0.4, 0.8, 1., 1.] (Xout = 5, &quot;DEFAULT&quot;)</span>
<span class="sd">        [0.1, 0.3, 0.5, 0.7, 0.9] (Xout = 5, &quot;OFFSET_CORNERS&quot;)</span>

<span class="sd">        [0., 0., 0.33, 0.67, 1., 1.] (Xout = 6, UNALIGN_CORNERS)</span>
<span class="sd">        [0., 0.2, 0.4, 0.6, 0.8, 1.] (Xout = 6, &quot;STRICT_ALIGN_CORNERS&quot; / &quot;ALIGN_CORNERS&quot;)</span>
<span class="sd">        [0., 0.33, 0.67, 1., 1., 1.] (Xout = 6, &quot;DEFAULT&quot;)</span>
<span class="sd">        [0.08, 0.25, 0.42, 0.58, 0.75, 0.92] (Xout = 6, &quot;OFFSET_CORNERS&quot;)</span>

<span class="sd">    Note the following similarities:</span>

<span class="sd">        * ``&quot;DEFAULT&quot;`` is same as</span>
<span class="sd">          ``tf.raw_ops.ResizeBilinear(align_corners=False,</span>
<span class="sd">          half_pixel_centers=False)``.</span>
<span class="sd">        * ``&quot;STRICT_ALIGN_CORNERS&quot;`` is same as</span>
<span class="sd">          ``tf.raw_ops.ResizeBilinear(align_corners=True,</span>
<span class="sd">          half_pixel_centers=False)``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor&lt;[\*D, H2, W2],T&gt;</span>
<span class="sd">        * Tensor with same type as the input.</span>
<span class="sd">        * ``H2`` = ``target_size_height``.</span>
<span class="sd">        * ``W2`` = ``target_size_width``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    T: fp16, fp32</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">input_spec</span> <span class="o">=</span> <span class="n">InputSpec</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">type_domain</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">),</span>
        <span class="n">target_size_height</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span>
            <span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">optional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">int32</span>
        <span class="p">),</span>
        <span class="n">target_size_width</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span>
            <span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">optional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">int32</span>
        <span class="p">),</span>
        <span class="n">sampling_mode</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span>
            <span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">optional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">str</span>
        <span class="p">),</span>
    <span class="p">)</span>

    <span class="n">type_domains</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">fp16</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">fp32</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">default_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">DefaultInputs</span><span class="p">(</span>
            <span class="n">target_size_height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">target_size_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">sampling_mode</span><span class="o">=</span><span class="s2">&quot;DEFAULT&quot;</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">type_inference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">rank</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;input to the &quot;resize_bilinear&quot; op must have rank at least 3&#39;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_mode</span><span class="o">.</span><span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span>
            <span class="s2">&quot;STRICT_ALIGN_CORNERS&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ALIGN_CORNERS&quot;</span><span class="p">,</span>
            <span class="s2">&quot;UNALIGN_CORNERS&quot;</span><span class="p">,</span>
            <span class="s2">&quot;DEFAULT&quot;</span><span class="p">,</span>
            <span class="s2">&quot;OFFSET_CORNERS&quot;</span><span class="p">,</span>
        <span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;&quot;resize_bilinear&quot; op: unrecognized sampling mode &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sampling_mode</span><span class="o">.</span><span class="n">val</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">ret_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">ret_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_size_width</span><span class="o">.</span><span class="n">val</span>
        <span class="n">ret_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_size_height</span><span class="o">.</span><span class="n">val</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ret_shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="crop_resize"><a class="viewcode-back" href="../../../../../../../../source/coremltools.converters.mil.mil.ops.defs.html#coremltools.converters.mil.mil.ops.defs.iOS15.image_resizing.crop_resize">[docs]</a><span class="nd">@register_op</span>
<span class="k">class</span> <span class="nc">crop_resize</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resize the spatial dimensions (last two dimensions) of the first input</span>
<span class="sd">    according to the bounding boxes specified in the second input, using</span>
<span class="sd">    bilinear interpolation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    x: tensor&lt;[B, C, H, W],T&gt; (Required)</span>
<span class="sd">        * The input, from which patches (regions of interest) are extracted</span>
<span class="sd">          and resized using bilinear interpolation.</span>
<span class="sd">        * Rank ``4``.</span>

<span class="sd">    roi: tensor&lt;[N,1,4,1,1], T&gt; or tensor&lt;[N,1,5,1,1], T&gt; (Required)</span>
<span class="sd">        * Regions of interest, or coordinates of the boxes. The above input</span>
<span class="sd">          represents coordinates of ``N`` boxes.</span>
<span class="sd">        * The convention to express coordinates  depends on the value of the</span>
<span class="sd">          input ``box_coordinate_mode``.</span>
<span class="sd">        * Rank ``5``.</span>
<span class="sd">        * If ``tensor&lt;[N,1,4,1,1], T&gt;``: Resized images are computed for all</span>
<span class="sd">          ``B`` input images.</span>
<span class="sd">        * If ``tensor&lt;[N,1,5,1,1], T&gt;``: The first element from ``axis=-3``</span>
<span class="sd">          to be resized is an index. It must be within range ``[0, B)``.</span>

<span class="sd">    target_height: const&lt;i32&gt; (Optional, Default=1)</span>
<span class="sd">        * Target height for resizing each patch.</span>

<span class="sd">    target_width: const&lt;i32&gt; (Optional, Default=1)</span>
<span class="sd">        * Target width for resizing each patch.</span>

<span class="sd">    normalized_coordinates : const&lt;bool&gt; (Optional, default=False)</span>
<span class="sd">        * If ``True``, the bounding box coordinates must be in the</span>
<span class="sd">          interval ``[0, 1]``. Scaling is based on the input spatial</span>
<span class="sd">          dimensions: ``(H_in - 1)`` for height and ``(W_in - 1)`` for width.</span>
<span class="sd">        * If ``False``, the bounding box coordinates must be in the interval</span>
<span class="sd">          ``[0, H_in - 1]`` for height dimensions and ``[0, W_in - 1]`` for</span>
<span class="sd">          width dimensions.</span>

<span class="sd">    spatial_scale : const&lt;fp32&gt; (Optional, default=1.0)</span>
<span class="sd">        * Additional spatial scale that multiplies the bounding box coordinates.</span>
<span class="sd">          You would use this to implement the RoI Align layer, which typically</span>
<span class="sd">          uses unnormalized RoI coordinates along with a spatial scale that is</span>
<span class="sd">          less than or equal to 1.</span>

<span class="sd">    box_coordinate_mode: const&lt;str&gt; (Optional, default=&quot;CORNERS_HEIGHT_FIRST&quot;)</span>
<span class="sd">        * Specifies the convention for specifying the four bounding box</span>
<span class="sd">          coordinates for an image of size ``(Height, Width)``. The ``(0,0)``</span>
<span class="sd">          coordinate corresponds to the top-left corner of the image.</span>
<span class="sd">        * This parameter can take one of four values:</span>

<span class="sd">          ``&quot;CORNERS_HEIGHT_FIRST&quot;``: ``[h_start, w_start, h_end, w_end]``</span>

<span class="sd">          ``&quot;CORNERS_WIDTH_FIRST&quot;``: ``[w_start, h_start, w_end, h_end]``</span>

<span class="sd">          ``&quot;CENTER_SIZE_HEIGHT_FIRST&quot;``: ``[h_center, w_center, box_height, box_width]``</span>

<span class="sd">          ``&quot;CENTER_SIZE_WIDTH_FIRST&quot;``: ``[w_center, h_center, box_width, box_height]``</span>

<span class="sd">    sampling_mode : const&lt;str&gt; (Optional, default=&quot;DEFAULT&quot;)</span>
<span class="sd">        * This parameter can take ``&quot;STRICT_ALIGN_CORNERS&quot;``,</span>
<span class="sd">          ``&quot;ALIGN_CORNERS&quot;``, ``&quot;DEFAULT&quot;``, ``&quot;OFFSET_CORNERS&quot;`` or</span>
<span class="sd">          ``UNALIGN_CORNERS`` as values.</span>
<span class="sd">        * This same convention is used by the ``resize_bilinear`` op (see</span>
<span class="sd">          that op for details).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    resize_bilinear</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor&lt;[N, B, C, target_height, target_width],T&gt; or tensor&lt;[N, 1, C, target_height, target_width],T&gt;</span>
<span class="sd">        * Tensor with same type as the input.</span>
<span class="sd">        * If ``roi : tensor&lt;[N,1,4,1,1], T&gt;``, the output is</span>
<span class="sd">          ``tensor&lt;[N, B, C, target_height, target_width],T&gt;``.</span>
<span class="sd">          Total crops = ``N*B``; that is, ``N`` crops for each input in the batch.</span>
<span class="sd">        * If ``roi : tensor&lt;[N,1,5,1,1], T&gt;``, the output is</span>
<span class="sd">          ``tensor&lt;[N, 1, C, target_height, target_width],T&gt;``.</span>
<span class="sd">          Total crops = ``N``; that is, 1 crop for given input image index</span>
<span class="sd">          in the batch.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    T: fp16, fp32</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">input_spec</span> <span class="o">=</span> <span class="n">InputSpec</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">type_domain</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">),</span>
        <span class="n">roi</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">type_domain</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">),</span>
        <span class="n">target_height</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
        <span class="n">target_width</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
        <span class="n">normalized_coordinates</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">bool</span><span class="p">),</span>
        <span class="n">spatial_scale</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">fp32</span><span class="p">),</span>
        <span class="n">box_coordinate_mode</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">str</span><span class="p">),</span>
        <span class="n">sampling_mode</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">str</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="n">type_domains</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">fp16</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">fp32</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="n">_VALID_SAMPLING_MODES</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;STRICT_ALIGN_CORNERS&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ALIGN_CORNERS&quot;</span><span class="p">,</span>
        <span class="s2">&quot;UNALIGN_CORNERS&quot;</span><span class="p">,</span>
        <span class="s2">&quot;DEFAULT&quot;</span><span class="p">,</span>
        <span class="s2">&quot;OFFSET_CORNERS&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">_VALID_BOX_COORDINATE_MODES</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;CORNERS_HEIGHT_FIRST&quot;</span><span class="p">,</span>
        <span class="s2">&quot;CORNERS_WIDTH_FIRST&quot;</span><span class="p">,</span>
        <span class="s2">&quot;CENTER_SIZE_HEIGHT_FIRST&quot;</span><span class="p">,</span>
        <span class="s2">&quot;CENTER_SIZE_WIDTH_FIRST&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">default_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">DefaultInputs</span><span class="p">(</span>
            <span class="n">target_height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">target_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">normalized_coordinates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">spatial_scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
            <span class="n">box_coordinate_mode</span><span class="o">=</span><span class="s2">&quot;CORNERS_HEIGHT_FIRST&quot;</span><span class="p">,</span>
            <span class="n">sampling_mode</span><span class="o">=</span><span class="s2">&quot;DEFAULT&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;input to the &quot;crop_resize&quot; op must be of rank 4. Provided </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">rank</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;ROI input to the &quot;crop_resize&quot; op must be of rank 5, provided </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">roi</span><span class="o">.</span><span class="n">rank</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_coordinate_mode</span><span class="o">.</span><span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VALID_BOX_COORDINATE_MODES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;&quot;crop_resize&quot; op: unrecognized box_coordinate_mode &quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">box_coordinate_mode</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s1">&quot;&#39;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_mode</span><span class="o">.</span><span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VALID_SAMPLING_MODES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;&quot;crop_resize&quot; op: unrecognized sampling mode &quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_mode</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s1">&quot;&#39;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">type_inference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_input</span><span class="p">()</span>
        <span class="c1"># ret_shape: [N] + [B, C, h_out, w_out]</span>
        <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ret_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_height</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_width</span><span class="o">.</span><span class="n">val</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ret_shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="crop"><a class="viewcode-back" href="../../../../../../../../source/coremltools.converters.mil.mil.ops.defs.html#coremltools.converters.mil.mil.ops.defs.iOS15.image_resizing.crop">[docs]</a><span class="nd">@register_op</span>
<span class="k">class</span> <span class="nc">crop</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crop the spatial dimensions (last two dimensions) of the input by the</span>
<span class="sd">    specified amounts.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: tensor&lt;[\*D, H1, W1],T&gt; (Required)</span>
<span class="sd">        * Must be at least rank ``3``.</span>
<span class="sd">    crop_height: const&lt;2, i32&gt; (Required)</span>
<span class="sd">        * Amount to be cropped from the top and bottom of the height dimension</span>
<span class="sd">          (``axis=-2``).</span>
<span class="sd">    crop_width: const&lt;2, i32&gt; (Required)</span>
<span class="sd">        * Amount to be cropped from the left and right sides of the width dimension (``axis=-1``).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor&lt;[\*D, H2, W2],T&gt;</span>
<span class="sd">        * Tensor with same type as the input.</span>
<span class="sd">        * ``H2`` = ``H1 - crop_height[0] - crop_height[1]``.</span>
<span class="sd">        * ``W2`` = ``W1 - crop_width[0] - crop_width[1]``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    T: fp16, fp32</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">input_spec</span> <span class="o">=</span> <span class="n">InputSpec</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">type_domain</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">),</span>
        <span class="n">crop_height</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
        <span class="n">crop_width</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="n">type_domains</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">fp16</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">fp32</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">type_inference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">rank</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;input to the &quot;crop&quot; op must at least be of rank 3. Provided </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">rank</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">crop_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop_height</span><span class="o">.</span><span class="n">val</span>
        <span class="n">crop_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop_width</span><span class="o">.</span><span class="n">val</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">crop_height</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;crop_height must have 2 elements. Provided </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">crop_height</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">crop_width</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;crop_width must have 2 elements. Provided </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">crop_width</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">input_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">ret_shape</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">input_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="o">+</span> <span class="p">[</span><span class="n">input_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">crop_height</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">crop_height</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="o">+</span> <span class="p">[</span><span class="n">input_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">crop_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">crop_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ret_shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="affine"><a class="viewcode-back" href="../../../../../../../../source/coremltools.converters.mil.mil.ops.defs.html#coremltools.converters.mil.mil.ops.defs.iOS15.image_resizing.affine">[docs]</a><span class="nd">@register_op</span><span class="p">(</span><span class="n">opset_version</span><span class="o">=</span><span class="n">_IOS15_TARGET</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">affine</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a linear affine transform to the input 2D image tensor. The value at the</span>
<span class="sd">    ``(x, y)`` (i.e., ``(w, h)``) coordinate of the output is computed by first computing</span>
<span class="sd">    the coordinates ``x‚Äô`` and ``y‚Äô`` with the following equation, and then computing the</span>
<span class="sd">    value at the coordinate ``(x‚Äô,y‚Äô)`` in the input image using either bilinear or</span>
<span class="sd">    nearest neighbor interpolation. If the ``(x‚Äô, y‚Äô)`` point falls outside the input</span>
<span class="sd">    image, then padding information is used to compute the value::</span>

<span class="sd">        x‚Äô = a0 * x + a1 * y + a2</span>
<span class="sd">        y‚Äô = b0 * x + b1 * y + b2</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: tensor&lt;[B, C, H1, W1], T&gt;</span>
<span class="sd">       * Must be rank ``4``.</span>
<span class="sd">    transform_matrix: tensor&lt;[D, 6], T&gt;</span>
<span class="sd">       * Must be rank ``2``.</span>
<span class="sd">       * ``D`` can be either ``B`` or 1.</span>
<span class="sd">          * If ``D == B``, there is a separate transform matrix for each batch.</span>
<span class="sd">          * If ``D == 1``, the same matrix is used for all input batches.</span>
<span class="sd">          * For each batch: ``[a0, a1, a2, b0, b1, b2]``.</span>
<span class="sd">    output_height: const&lt;i32&gt;</span>
<span class="sd">       * Target output height</span>
<span class="sd">    output_width: const&lt;i32&gt;</span>
<span class="sd">       * Target output width</span>
<span class="sd">    sampling_mode: const&lt;str&gt;</span>
<span class="sd">       * Allowed values: ``&quot;bilinear&quot;``</span>
<span class="sd">    padding_mode: const&lt;str&gt;</span>
<span class="sd">       * Allowed values: ``&quot;constant&quot;``.</span>
<span class="sd">       * Note that the following example is 1D case for brevity. The op supports only 2D image input.</span>
<span class="sd">       * If ``padding_mode == &quot;constant&quot;``:</span>
<span class="sd">          * The input image is assumed to be padded with the padding_value.</span>
<span class="sd">          * For example, ``|1, 2, 3| -&gt; |0, 0, 0, 1, 2, 3, 0, 0, 0|``.</span>
<span class="sd">    padding_value: const&lt;T&gt;</span>
<span class="sd">       * Currently non-zero values are not supported.</span>
<span class="sd">       * To be used only when ``padding_mode == &quot;constant&quot;``, ignored in other cases.</span>
<span class="sd">    coordinates_mode: const&lt;str&gt;</span>
<span class="sd">       * Allowed values: ``&quot;normalized_minus_one_to_one&quot;``.</span>
<span class="sd">       * If ``coordinates_mode == &quot;normalized_minus_one_to_one&quot;``, in-image values are ``[-1, 1]``.</span>
<span class="sd">       * For example, if ``coordinates_mode == &quot;normalized_minus_one_to_one&quot;``, the in-range values are ``[-1, 1]``. That is:</span>
<span class="sd">          * ``(-1, -1)``, i.e. ``(w=-1, h=-1)``, corresponds to the top-left pixel.</span>
<span class="sd">          * ``(1, -1)``, i.e. ``(w=1, h=-1)``, corresponds to the top-right pixel.</span>
<span class="sd">          * ``(-1, 1)``, i.e. ``(w=-1, h=1)``, corresponds to the bottom-left pixel.</span>
<span class="sd">          * ``(1, 1)``, i.e. ``(w=1, h=1)``, corresponds to the bottom-right pixel.</span>
<span class="sd">    align_corners: const&lt;bool&gt;</span>
<span class="sd">       * Currently ``align_corners=False`` is not supported.</span>
<span class="sd">       * To be used only when ``coordinates_mode != unnormalized``, ignored otherwise.</span>
<span class="sd">       * If ``align_corners == True``, the extrema coordinates correspond to the center of the first and last corner pixels.</span>
<span class="sd">       * If ``align_corners == False``, the extrema coordinates correspond to the edge of the first and last corner pixels.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor&lt;[B, C, output_height, output_width], T&gt;</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    T: fp16, fp32</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">input_spec</span> <span class="o">=</span> <span class="n">InputSpec</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">type_domain</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">),</span>
        <span class="n">transform_matrix</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">type_domain</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">),</span>
        <span class="n">output_height</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
        <span class="n">output_width</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
        <span class="n">sampling_mode</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">str</span><span class="p">),</span>
        <span class="n">padding_mode</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">str</span><span class="p">),</span>
        <span class="n">padding_value</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">),</span>
        <span class="n">coordinates_mode</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">str</span><span class="p">),</span>
        <span class="n">align_corners</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">bool</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="n">type_domains</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">fp16</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">fp32</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">type_inference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;input &quot;x&quot; to the &quot;affine&quot; op must be a rank 4 tensor. &#39;</span>
                <span class="s2">&quot;Got rank </span><span class="si">{}</span><span class="s2"> tensor of shape </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_matrix</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;input &quot;transform_matrix&quot; to the &quot;affine&quot; op must be a rank 2 tensor. &#39;</span>
                <span class="s2">&quot;Got rank </span><span class="si">{}</span><span class="s2"> tensor of shape </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">transform_matrix</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span>  <span class="bp">self</span><span class="o">.</span><span class="n">transform_matrix</span><span class="o">.</span><span class="n">shape</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_mode</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;bilinear&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s1">&#39;input &quot;sampling_mode&quot; to the &quot;affine&quot; not implemented. &#39;</span>
                <span class="s1">&#39;Got &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_mode</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates_mode</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;normalized_minus_one_to_one&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s1">&#39;input &quot;coordinates_mode&quot; to the &quot;affine&quot; not implemented. &#39;</span>
                <span class="s1">&#39;Got &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates_mode</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;constant&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_value</span><span class="o">.</span><span class="n">val</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s1">&#39;input &quot;padding_mode&quot; to the &quot;affine&quot; not implemented. &#39;</span>
                <span class="s1">&#39;Got &quot;</span><span class="si">{}</span><span class="s1">&quot; with &quot;padding_value=</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_value</span><span class="o">.</span><span class="n">val</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">input_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">transform_matrix_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_matrix</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">is_symbolic</span><span class="p">(</span><span class="n">transform_matrix_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="ow">and</span> <span class="n">transform_matrix_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">6</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;input &quot;transform_matrix&quot; to the &quot;affine&quot; op last dimension must be 6 &#39;</span>
                <span class="s2">&quot;[a0, a1, a2, b0, b1, b2], &quot;</span>
                <span class="s2">&quot;Got </span><span class="si">{}</span><span class="s2"> for last dimension&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">transform_matrix_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>

        <span class="n">ret_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span>
        <span class="n">ret_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_height</span><span class="o">.</span><span class="n">val</span>
        <span class="n">ret_shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_width</span><span class="o">.</span><span class="n">val</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">))</span></div>


<div class="viewcode-block" id="resample"><a class="viewcode-back" href="../../../../../../../../source/coremltools.converters.mil.mil.ops.defs.html#coremltools.converters.mil.mil.ops.defs.iOS15.image_resizing.resample">[docs]</a><span class="nd">@register_op</span><span class="p">(</span><span class="n">opset_version</span><span class="o">=</span><span class="n">_IOS15_TARGET</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">resample</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resample the input image tensor ``x`` at the ``coordinates``.</span>
<span class="sd">    Resampling is required if the coordinates do not correspond to exact</span>
<span class="sd">    pixels in the input image. The ``sampling_mode`` determines</span>
<span class="sd">    the algorithm used for resampling and computing the values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: tensor&lt;[B, C, H1, W1], T&gt;</span>
<span class="sd">        * Must be rank ``4``.</span>
<span class="sd">    coordinates: tensor&lt;[B, H2, W2, 2], U&gt;</span>
<span class="sd">        * Must be rank ``4``.</span>
<span class="sd">        * Coordinates are provided in the order ``(x, y)`` (i.e. ``(w, h)``).</span>
<span class="sd">        * The value of each output location ``output[b, c, h, w]`` is calculated</span>
<span class="sd">          by sampling from the input image ``x[b, c, :, :]``.</span>
<span class="sd">        * The pixel at the ``(x, y)`` location corresponds to the length-2</span>
<span class="sd">          vector: ``coordinates[b, h, w, :]``.</span>
<span class="sd">        * Coordinate (normalized or unnormalized) should be specified according</span>
<span class="sd">          to ``coordinates_mode``.</span>
<span class="sd">    sampling_mode: const&lt;str&gt;</span>
<span class="sd">        * Allowed values: ``&quot;bilinear&quot;`` , ``&quot;nearest&quot;``</span>
<span class="sd">    padding_mode: const&lt;str&gt;</span>
<span class="sd">        * Allowed values: ``&quot;constant&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``, ``&quot;symmetric&quot;``</span>
<span class="sd">        * Note that the following example is 1D case for brevity.</span>
<span class="sd">          The op supports only 2D image input.</span>
<span class="sd">        * If ``padding_mode == &quot;constant&quot;``:</span>
<span class="sd">           * The input image is assumed to be padded with the ``padding_value``.</span>
<span class="sd">           * For example: ``|1, 2, 3| -&gt; |0, 0, 0, 1, 2, 3, 0, 0, 0|``</span>
<span class="sd">        * if ``padding_mode == &quot;border&quot;``:</span>
<span class="sd">           * The input image is assumed to be padded with the values replicated</span>
<span class="sd">             from the values at the edge. This is also referred to as the</span>
<span class="sd">             &quot;clamped&quot; or &quot;replication&quot; mode, since the padded values are</span>
<span class="sd">             clamped to the border values.</span>
<span class="sd">           * For example: ``|1, 2, 3| -&gt; |1, 1, 1, 1, 2, 3, 3, 3, 3|``</span>
<span class="sd">        * If ``padding_mode == &quot;reflection&quot;``:</span>
<span class="sd">           * The border values are reflected, *not* including the values at the edge/border.</span>
<span class="sd">           * For example: ``|1, 2, 3| -&gt; |2, 3, 2, 1, 2, 3, 2, 1, 2|``</span>
<span class="sd">        * If ``padding_mode == &quot;symmetric&quot;``:</span>
<span class="sd">           * Values are reflected, including the border/edge values.</span>
<span class="sd">           * For example: ``|1, 2, 3| -&gt; |3, 2, 1 , 1, 2, 3, 3, 2, 1|``</span>
<span class="sd">    padding_value: const&lt;T&gt;</span>
<span class="sd">        * To be used only when ``padding_mode == &quot;constant&quot;``, ignored in other cases.</span>
<span class="sd">    coordinates_mode: const&lt;str&gt;</span>
<span class="sd">        * Allowed values: ``&quot;unnormalized&quot;``, ``&quot;normalized_minus_one_to_one&quot;``,</span>
<span class="sd">          ``&quot;normalized_zero_to_one&quot;``</span>
<span class="sd">        * If ``coordinates_mode == &quot;unnormalized&quot;``, the coordinates input values</span>
<span class="sd">          are interpreted to be in range ``[0, W - 1] / [0, H - 1]``, which</span>
<span class="sd">          corresponds to the in-image point.</span>
<span class="sd">        * If ``coordinates_mode == &quot;normalized_minus_one_to_one&quot;``,</span>
<span class="sd">          the in-image values are ``[-1, 1]``.</span>
<span class="sd">        * If ``coordinates_mode == &quot;normalized_zero_to_one&quot;``,</span>
<span class="sd">          in-image values are ``[0, 1]``.</span>
<span class="sd">        * For example, if ``coordinates_mode == &quot;normalized_minus_one_to_one&quot;``, the in range values are [-1, 1]. That is:</span>
<span class="sd">           * ``(-1, -1)``, i.e. ``(w=-1, h=-1)``, corresponds to the top-left pixel.</span>
<span class="sd">           * ``(1, -1)``, i.e. ``(w=1, h=-1)``, corresponds to the top-right pixel.</span>
<span class="sd">           * ``(-1, 1)``, i.e. ``(w=-1, h=1)``, corresponds to the bottom-left pixel.</span>
<span class="sd">           * ``(1, 1)``, i.e. ``(w=1, h=1)``, corresponds to the bottom-right pixel.</span>
<span class="sd">    align_corners: const&lt;bool&gt;</span>
<span class="sd">        * If ``align_corners == True``, the extrema coordinates correspond to the center of the first and last corner pixels.</span>
<span class="sd">        * If ``align_corners == False``, the extrema coordinates correspond to the edge of the first and last corner pixels.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor&lt;[B, C, H2, W2], T&gt;</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    T: fp16, fp32</span>
<span class="sd">    U: fp32, int32</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">input_spec</span> <span class="o">=</span> <span class="n">InputSpec</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">type_domain</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">),</span>
        <span class="n">coordinates</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">type_domain</span><span class="o">=</span><span class="s2">&quot;U&quot;</span><span class="p">),</span>
        <span class="n">sampling_mode</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">str</span><span class="p">),</span>
        <span class="n">padding_mode</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">str</span><span class="p">),</span>
        <span class="n">padding_value</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">),</span>
        <span class="n">coordinates_mode</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">str</span><span class="p">),</span>
        <span class="n">align_corners</span><span class="o">=</span><span class="n">TensorInputType</span><span class="p">(</span><span class="n">const</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">type_domain</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">bool</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="n">type_domains</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">fp16</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">fp32</span><span class="p">),</span>
        <span class="s2">&quot;U&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">fp32</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">type_inference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;input &quot;x&quot; to the &quot;resample&quot; op must be a rank 4 tensor. &#39;</span>
                <span class="s2">&quot;Got rank </span><span class="si">{}</span><span class="s2"> tensor of shape </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;input &quot;coordinates&quot; to the &quot;resample&quot; op must be a rank 4 tensor. &#39;</span>
                <span class="s2">&quot;Got rank </span><span class="si">{}</span><span class="s2"> tensor of shape </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">input_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">coord_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">is_symbolic</span><span class="p">(</span><span class="n">input_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_symbolic</span><span class="p">(</span><span class="n">coord_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="ow">and</span> <span class="n">input_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">coord_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;input &quot;x&quot; and &quot;coordinates&quot; to the &quot;resample&quot; must agree on &#39;</span>
                <span class="s2">&quot;dimension of batch size: </span><span class="si">{}</span><span class="s2"> vs. </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">input_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coord_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symbolic</span><span class="p">(</span><span class="n">coord_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="n">coord_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;input &quot;coordinates&quot; to the &quot;resample&quot; op last dimension must be 2. &#39;</span>
                <span class="s2">&quot;Got </span><span class="si">{}</span><span class="s2"> for last dimension&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">coord_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">ret_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span>
        <span class="n">ret_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Output height</span>
        <span class="n">ret_shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># Output width</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">))</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Apple Inc.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>