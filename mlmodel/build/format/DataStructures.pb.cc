// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DataStructures.proto

#include "DataStructures.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace CoreML {
namespace Specification {
constexpr StringToInt64Map_MapEntry_DoNotUse::StringToInt64Map_MapEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct StringToInt64Map_MapEntry_DoNotUseDefaultTypeInternal {
  constexpr StringToInt64Map_MapEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StringToInt64Map_MapEntry_DoNotUseDefaultTypeInternal() {}
  union {
    StringToInt64Map_MapEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StringToInt64Map_MapEntry_DoNotUseDefaultTypeInternal _StringToInt64Map_MapEntry_DoNotUse_default_instance_;
constexpr StringToInt64Map::StringToInt64Map(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : map_(){}
struct StringToInt64MapDefaultTypeInternal {
  constexpr StringToInt64MapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StringToInt64MapDefaultTypeInternal() {}
  union {
    StringToInt64Map _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StringToInt64MapDefaultTypeInternal _StringToInt64Map_default_instance_;
constexpr Int64ToStringMap_MapEntry_DoNotUse::Int64ToStringMap_MapEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct Int64ToStringMap_MapEntry_DoNotUseDefaultTypeInternal {
  constexpr Int64ToStringMap_MapEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Int64ToStringMap_MapEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Int64ToStringMap_MapEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Int64ToStringMap_MapEntry_DoNotUseDefaultTypeInternal _Int64ToStringMap_MapEntry_DoNotUse_default_instance_;
constexpr Int64ToStringMap::Int64ToStringMap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : map_(){}
struct Int64ToStringMapDefaultTypeInternal {
  constexpr Int64ToStringMapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Int64ToStringMapDefaultTypeInternal() {}
  union {
    Int64ToStringMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Int64ToStringMapDefaultTypeInternal _Int64ToStringMap_default_instance_;
constexpr StringToDoubleMap_MapEntry_DoNotUse::StringToDoubleMap_MapEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct StringToDoubleMap_MapEntry_DoNotUseDefaultTypeInternal {
  constexpr StringToDoubleMap_MapEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StringToDoubleMap_MapEntry_DoNotUseDefaultTypeInternal() {}
  union {
    StringToDoubleMap_MapEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StringToDoubleMap_MapEntry_DoNotUseDefaultTypeInternal _StringToDoubleMap_MapEntry_DoNotUse_default_instance_;
constexpr StringToDoubleMap::StringToDoubleMap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : map_(){}
struct StringToDoubleMapDefaultTypeInternal {
  constexpr StringToDoubleMapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StringToDoubleMapDefaultTypeInternal() {}
  union {
    StringToDoubleMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StringToDoubleMapDefaultTypeInternal _StringToDoubleMap_default_instance_;
constexpr Int64ToDoubleMap_MapEntry_DoNotUse::Int64ToDoubleMap_MapEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct Int64ToDoubleMap_MapEntry_DoNotUseDefaultTypeInternal {
  constexpr Int64ToDoubleMap_MapEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Int64ToDoubleMap_MapEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Int64ToDoubleMap_MapEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Int64ToDoubleMap_MapEntry_DoNotUseDefaultTypeInternal _Int64ToDoubleMap_MapEntry_DoNotUse_default_instance_;
constexpr Int64ToDoubleMap::Int64ToDoubleMap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : map_(){}
struct Int64ToDoubleMapDefaultTypeInternal {
  constexpr Int64ToDoubleMapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Int64ToDoubleMapDefaultTypeInternal() {}
  union {
    Int64ToDoubleMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Int64ToDoubleMapDefaultTypeInternal _Int64ToDoubleMap_default_instance_;
constexpr StringVector::StringVector(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : vector_(){}
struct StringVectorDefaultTypeInternal {
  constexpr StringVectorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StringVectorDefaultTypeInternal() {}
  union {
    StringVector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StringVectorDefaultTypeInternal _StringVector_default_instance_;
constexpr Int64Vector::Int64Vector(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : vector_()
  , _vector_cached_byte_size_(0){}
struct Int64VectorDefaultTypeInternal {
  constexpr Int64VectorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Int64VectorDefaultTypeInternal() {}
  union {
    Int64Vector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Int64VectorDefaultTypeInternal _Int64Vector_default_instance_;
constexpr FloatVector::FloatVector(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : vector_(){}
struct FloatVectorDefaultTypeInternal {
  constexpr FloatVectorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FloatVectorDefaultTypeInternal() {}
  union {
    FloatVector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FloatVectorDefaultTypeInternal _FloatVector_default_instance_;
constexpr DoubleVector::DoubleVector(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : vector_(){}
struct DoubleVectorDefaultTypeInternal {
  constexpr DoubleVectorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DoubleVectorDefaultTypeInternal() {}
  union {
    DoubleVector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DoubleVectorDefaultTypeInternal _DoubleVector_default_instance_;
constexpr Int64Range::Int64Range(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : minvalue_(int64_t{0})
  , maxvalue_(int64_t{0}){}
struct Int64RangeDefaultTypeInternal {
  constexpr Int64RangeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Int64RangeDefaultTypeInternal() {}
  union {
    Int64Range _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Int64RangeDefaultTypeInternal _Int64Range_default_instance_;
constexpr Int64Set::Int64Set(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : values_()
  , _values_cached_byte_size_(0){}
struct Int64SetDefaultTypeInternal {
  constexpr Int64SetDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Int64SetDefaultTypeInternal() {}
  union {
    Int64Set _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Int64SetDefaultTypeInternal _Int64Set_default_instance_;
constexpr DoubleRange::DoubleRange(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : minvalue_(0)
  , maxvalue_(0){}
struct DoubleRangeDefaultTypeInternal {
  constexpr DoubleRangeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DoubleRangeDefaultTypeInternal() {}
  union {
    DoubleRange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DoubleRangeDefaultTypeInternal _DoubleRange_default_instance_;
constexpr PrecisionRecallCurve::PrecisionRecallCurve(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : precisionvalues_(nullptr)
  , precisionconfidencethresholds_(nullptr)
  , recallvalues_(nullptr)
  , recallconfidencethresholds_(nullptr){}
struct PrecisionRecallCurveDefaultTypeInternal {
  constexpr PrecisionRecallCurveDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PrecisionRecallCurveDefaultTypeInternal() {}
  union {
    PrecisionRecallCurve _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PrecisionRecallCurveDefaultTypeInternal _PrecisionRecallCurve_default_instance_;
}  // namespace Specification
}  // namespace CoreML
namespace CoreML {
namespace Specification {

// ===================================================================

StringToInt64Map_MapEntry_DoNotUse::StringToInt64Map_MapEntry_DoNotUse() {}
StringToInt64Map_MapEntry_DoNotUse::StringToInt64Map_MapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void StringToInt64Map_MapEntry_DoNotUse::MergeFrom(const StringToInt64Map_MapEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class StringToInt64Map::_Internal {
 public:
};

StringToInt64Map::StringToInt64Map(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  map_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.StringToInt64Map)
}
StringToInt64Map::StringToInt64Map(const StringToInt64Map& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  map_.MergeFrom(from.map_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.StringToInt64Map)
}

inline void StringToInt64Map::SharedCtor() {
}

StringToInt64Map::~StringToInt64Map() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.StringToInt64Map)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void StringToInt64Map::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StringToInt64Map::ArenaDtor(void* object) {
  StringToInt64Map* _this = reinterpret_cast< StringToInt64Map* >(object);
  (void)_this;
}
void StringToInt64Map::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StringToInt64Map::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StringToInt64Map::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.StringToInt64Map)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  map_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StringToInt64Map::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, int64> map = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&map_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StringToInt64Map::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.StringToInt64Map)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, int64> map = 1;
  if (!this->_internal_map().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.StringToInt64Map.MapEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_map().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_map().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >::const_iterator
          it = this->_internal_map().begin();
          it != this->_internal_map().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = StringToInt64Map_MapEntry_DoNotUse::Funcs::InternalSerialize(1, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >::const_iterator
          it = this->_internal_map().begin();
          it != this->_internal_map().end(); ++it) {
        target = StringToInt64Map_MapEntry_DoNotUse::Funcs::InternalSerialize(1, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.StringToInt64Map)
  return target;
}

size_t StringToInt64Map::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.StringToInt64Map)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, int64> map = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_map_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >::const_iterator
      it = this->_internal_map().begin();
      it != this->_internal_map().end(); ++it) {
    total_size += StringToInt64Map_MapEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StringToInt64Map::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StringToInt64Map*>(
      &from));
}

void StringToInt64Map::MergeFrom(const StringToInt64Map& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.StringToInt64Map)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  map_.MergeFrom(from.map_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StringToInt64Map::CopyFrom(const StringToInt64Map& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.StringToInt64Map)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringToInt64Map::IsInitialized() const {
  return true;
}

void StringToInt64Map::InternalSwap(StringToInt64Map* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  map_.InternalSwap(&other->map_);
}

std::string StringToInt64Map::GetTypeName() const {
  return "CoreML.Specification.StringToInt64Map";
}


// ===================================================================

Int64ToStringMap_MapEntry_DoNotUse::Int64ToStringMap_MapEntry_DoNotUse() {}
Int64ToStringMap_MapEntry_DoNotUse::Int64ToStringMap_MapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Int64ToStringMap_MapEntry_DoNotUse::MergeFrom(const Int64ToStringMap_MapEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class Int64ToStringMap::_Internal {
 public:
};

Int64ToStringMap::Int64ToStringMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  map_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.Int64ToStringMap)
}
Int64ToStringMap::Int64ToStringMap(const Int64ToStringMap& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  map_.MergeFrom(from.map_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Int64ToStringMap)
}

inline void Int64ToStringMap::SharedCtor() {
}

Int64ToStringMap::~Int64ToStringMap() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Int64ToStringMap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Int64ToStringMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Int64ToStringMap::ArenaDtor(void* object) {
  Int64ToStringMap* _this = reinterpret_cast< Int64ToStringMap* >(object);
  (void)_this;
}
void Int64ToStringMap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Int64ToStringMap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Int64ToStringMap::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Int64ToStringMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  map_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Int64ToStringMap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<int64, string> map = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&map_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Int64ToStringMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.Int64ToStringMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<int64, string> map = 1;
  if (!this->_internal_map().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< int64_t, std::string >::const_pointer
        ConstPtr;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::SortItem< int64_t, ConstPtr > SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByFirstField<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->second.data(), static_cast<int>(p->second.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.Int64ToStringMap.MapEntry.value");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_map().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_map().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< int64_t, std::string >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< int64_t, std::string >::const_iterator
          it = this->_internal_map().begin();
          it != this->_internal_map().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = Int64ToStringMap_MapEntry_DoNotUse::Funcs::InternalSerialize(1, items[static_cast<ptrdiff_t>(i)].second->first, items[static_cast<ptrdiff_t>(i)].second->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)].second));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< int64_t, std::string >::const_iterator
          it = this->_internal_map().begin();
          it != this->_internal_map().end(); ++it) {
        target = Int64ToStringMap_MapEntry_DoNotUse::Funcs::InternalSerialize(1, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.Int64ToStringMap)
  return target;
}

size_t Int64ToStringMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Int64ToStringMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int64, string> map = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_map_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int64_t, std::string >::const_iterator
      it = this->_internal_map().begin();
      it != this->_internal_map().end(); ++it) {
    total_size += Int64ToStringMap_MapEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Int64ToStringMap::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Int64ToStringMap*>(
      &from));
}

void Int64ToStringMap::MergeFrom(const Int64ToStringMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Int64ToStringMap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  map_.MergeFrom(from.map_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Int64ToStringMap::CopyFrom(const Int64ToStringMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Int64ToStringMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int64ToStringMap::IsInitialized() const {
  return true;
}

void Int64ToStringMap::InternalSwap(Int64ToStringMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  map_.InternalSwap(&other->map_);
}

std::string Int64ToStringMap::GetTypeName() const {
  return "CoreML.Specification.Int64ToStringMap";
}


// ===================================================================

StringToDoubleMap_MapEntry_DoNotUse::StringToDoubleMap_MapEntry_DoNotUse() {}
StringToDoubleMap_MapEntry_DoNotUse::StringToDoubleMap_MapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void StringToDoubleMap_MapEntry_DoNotUse::MergeFrom(const StringToDoubleMap_MapEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class StringToDoubleMap::_Internal {
 public:
};

StringToDoubleMap::StringToDoubleMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  map_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.StringToDoubleMap)
}
StringToDoubleMap::StringToDoubleMap(const StringToDoubleMap& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  map_.MergeFrom(from.map_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.StringToDoubleMap)
}

inline void StringToDoubleMap::SharedCtor() {
}

StringToDoubleMap::~StringToDoubleMap() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.StringToDoubleMap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void StringToDoubleMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StringToDoubleMap::ArenaDtor(void* object) {
  StringToDoubleMap* _this = reinterpret_cast< StringToDoubleMap* >(object);
  (void)_this;
}
void StringToDoubleMap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StringToDoubleMap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StringToDoubleMap::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.StringToDoubleMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  map_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StringToDoubleMap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, double> map = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&map_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StringToDoubleMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.StringToDoubleMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, double> map = 1;
  if (!this->_internal_map().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.StringToDoubleMap.MapEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_map().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_map().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
          it = this->_internal_map().begin();
          it != this->_internal_map().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = StringToDoubleMap_MapEntry_DoNotUse::Funcs::InternalSerialize(1, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
          it = this->_internal_map().begin();
          it != this->_internal_map().end(); ++it) {
        target = StringToDoubleMap_MapEntry_DoNotUse::Funcs::InternalSerialize(1, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.StringToDoubleMap)
  return target;
}

size_t StringToDoubleMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.StringToDoubleMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, double> map = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_map_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_map().begin();
      it != this->_internal_map().end(); ++it) {
    total_size += StringToDoubleMap_MapEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StringToDoubleMap::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StringToDoubleMap*>(
      &from));
}

void StringToDoubleMap::MergeFrom(const StringToDoubleMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.StringToDoubleMap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  map_.MergeFrom(from.map_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StringToDoubleMap::CopyFrom(const StringToDoubleMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.StringToDoubleMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringToDoubleMap::IsInitialized() const {
  return true;
}

void StringToDoubleMap::InternalSwap(StringToDoubleMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  map_.InternalSwap(&other->map_);
}

std::string StringToDoubleMap::GetTypeName() const {
  return "CoreML.Specification.StringToDoubleMap";
}


// ===================================================================

Int64ToDoubleMap_MapEntry_DoNotUse::Int64ToDoubleMap_MapEntry_DoNotUse() {}
Int64ToDoubleMap_MapEntry_DoNotUse::Int64ToDoubleMap_MapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Int64ToDoubleMap_MapEntry_DoNotUse::MergeFrom(const Int64ToDoubleMap_MapEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class Int64ToDoubleMap::_Internal {
 public:
};

Int64ToDoubleMap::Int64ToDoubleMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  map_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.Int64ToDoubleMap)
}
Int64ToDoubleMap::Int64ToDoubleMap(const Int64ToDoubleMap& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  map_.MergeFrom(from.map_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Int64ToDoubleMap)
}

inline void Int64ToDoubleMap::SharedCtor() {
}

Int64ToDoubleMap::~Int64ToDoubleMap() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Int64ToDoubleMap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Int64ToDoubleMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Int64ToDoubleMap::ArenaDtor(void* object) {
  Int64ToDoubleMap* _this = reinterpret_cast< Int64ToDoubleMap* >(object);
  (void)_this;
}
void Int64ToDoubleMap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Int64ToDoubleMap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Int64ToDoubleMap::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Int64ToDoubleMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  map_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Int64ToDoubleMap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<int64, double> map = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&map_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Int64ToDoubleMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.Int64ToDoubleMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<int64, double> map = 1;
  if (!this->_internal_map().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< int64_t, double >::const_pointer
        ConstPtr;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::SortItem< int64_t, ConstPtr > SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByFirstField<SortItem> Less;

    if (stream->IsSerializationDeterministic() &&
        this->_internal_map().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_map().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< int64_t, double >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< int64_t, double >::const_iterator
          it = this->_internal_map().begin();
          it != this->_internal_map().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = Int64ToDoubleMap_MapEntry_DoNotUse::Funcs::InternalSerialize(1, items[static_cast<ptrdiff_t>(i)].second->first, items[static_cast<ptrdiff_t>(i)].second->second, target, stream);
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< int64_t, double >::const_iterator
          it = this->_internal_map().begin();
          it != this->_internal_map().end(); ++it) {
        target = Int64ToDoubleMap_MapEntry_DoNotUse::Funcs::InternalSerialize(1, it->first, it->second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.Int64ToDoubleMap)
  return target;
}

size_t Int64ToDoubleMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Int64ToDoubleMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int64, double> map = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_map_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int64_t, double >::const_iterator
      it = this->_internal_map().begin();
      it != this->_internal_map().end(); ++it) {
    total_size += Int64ToDoubleMap_MapEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Int64ToDoubleMap::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Int64ToDoubleMap*>(
      &from));
}

void Int64ToDoubleMap::MergeFrom(const Int64ToDoubleMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Int64ToDoubleMap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  map_.MergeFrom(from.map_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Int64ToDoubleMap::CopyFrom(const Int64ToDoubleMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Int64ToDoubleMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int64ToDoubleMap::IsInitialized() const {
  return true;
}

void Int64ToDoubleMap::InternalSwap(Int64ToDoubleMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  map_.InternalSwap(&other->map_);
}

std::string Int64ToDoubleMap::GetTypeName() const {
  return "CoreML.Specification.Int64ToDoubleMap";
}


// ===================================================================

class StringVector::_Internal {
 public:
};

StringVector::StringVector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  vector_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.StringVector)
}
StringVector::StringVector(const StringVector& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      vector_(from.vector_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.StringVector)
}

inline void StringVector::SharedCtor() {
}

StringVector::~StringVector() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.StringVector)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void StringVector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StringVector::ArenaDtor(void* object) {
  StringVector* _this = reinterpret_cast< StringVector* >(object);
  (void)_this;
}
void StringVector::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StringVector::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StringVector::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.StringVector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vector_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StringVector::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string vector = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_vector();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StringVector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.StringVector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string vector = 1;
  for (int i = 0, n = this->_internal_vector_size(); i < n; i++) {
    const auto& s = this->_internal_vector(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.StringVector.vector");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.StringVector)
  return target;
}

size_t StringVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.StringVector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string vector = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(vector_.size());
  for (int i = 0, n = vector_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      vector_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StringVector::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StringVector*>(
      &from));
}

void StringVector::MergeFrom(const StringVector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.StringVector)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  vector_.MergeFrom(from.vector_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StringVector::CopyFrom(const StringVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.StringVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringVector::IsInitialized() const {
  return true;
}

void StringVector::InternalSwap(StringVector* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  vector_.InternalSwap(&other->vector_);
}

std::string StringVector::GetTypeName() const {
  return "CoreML.Specification.StringVector";
}


// ===================================================================

class Int64Vector::_Internal {
 public:
};

Int64Vector::Int64Vector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  vector_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.Int64Vector)
}
Int64Vector::Int64Vector(const Int64Vector& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      vector_(from.vector_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Int64Vector)
}

inline void Int64Vector::SharedCtor() {
}

Int64Vector::~Int64Vector() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Int64Vector)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Int64Vector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Int64Vector::ArenaDtor(void* object) {
  Int64Vector* _this = reinterpret_cast< Int64Vector* >(object);
  (void)_this;
}
void Int64Vector::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Int64Vector::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Int64Vector::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Int64Vector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vector_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Int64Vector::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 vector = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_vector(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_vector(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Int64Vector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.Int64Vector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 vector = 1;
  {
    int byte_size = _vector_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_vector(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.Int64Vector)
  return target;
}

size_t Int64Vector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Int64Vector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 vector = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->vector_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _vector_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Int64Vector::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Int64Vector*>(
      &from));
}

void Int64Vector::MergeFrom(const Int64Vector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Int64Vector)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  vector_.MergeFrom(from.vector_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Int64Vector::CopyFrom(const Int64Vector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Int64Vector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int64Vector::IsInitialized() const {
  return true;
}

void Int64Vector::InternalSwap(Int64Vector* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  vector_.InternalSwap(&other->vector_);
}

std::string Int64Vector::GetTypeName() const {
  return "CoreML.Specification.Int64Vector";
}


// ===================================================================

class FloatVector::_Internal {
 public:
};

FloatVector::FloatVector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  vector_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.FloatVector)
}
FloatVector::FloatVector(const FloatVector& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      vector_(from.vector_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.FloatVector)
}

inline void FloatVector::SharedCtor() {
}

FloatVector::~FloatVector() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.FloatVector)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FloatVector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FloatVector::ArenaDtor(void* object) {
  FloatVector* _this = reinterpret_cast< FloatVector* >(object);
  (void)_this;
}
void FloatVector::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FloatVector::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FloatVector::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.FloatVector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vector_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FloatVector::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float vector = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_vector(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 13) {
          _internal_add_vector(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FloatVector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.FloatVector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float vector = 1;
  if (this->_internal_vector_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_vector(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.FloatVector)
  return target;
}

size_t FloatVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.FloatVector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float vector = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_vector_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FloatVector::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FloatVector*>(
      &from));
}

void FloatVector::MergeFrom(const FloatVector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.FloatVector)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  vector_.MergeFrom(from.vector_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FloatVector::CopyFrom(const FloatVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.FloatVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FloatVector::IsInitialized() const {
  return true;
}

void FloatVector::InternalSwap(FloatVector* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  vector_.InternalSwap(&other->vector_);
}

std::string FloatVector::GetTypeName() const {
  return "CoreML.Specification.FloatVector";
}


// ===================================================================

class DoubleVector::_Internal {
 public:
};

DoubleVector::DoubleVector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  vector_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.DoubleVector)
}
DoubleVector::DoubleVector(const DoubleVector& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      vector_(from.vector_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DoubleVector)
}

inline void DoubleVector::SharedCtor() {
}

DoubleVector::~DoubleVector() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DoubleVector)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void DoubleVector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DoubleVector::ArenaDtor(void* object) {
  DoubleVector* _this = reinterpret_cast< DoubleVector* >(object);
  (void)_this;
}
void DoubleVector::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DoubleVector::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DoubleVector::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DoubleVector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vector_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DoubleVector::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated double vector = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_vector(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 9) {
          _internal_add_vector(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DoubleVector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.DoubleVector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double vector = 1;
  if (this->_internal_vector_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_vector(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.DoubleVector)
  return target;
}

size_t DoubleVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DoubleVector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double vector = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_vector_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DoubleVector::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DoubleVector*>(
      &from));
}

void DoubleVector::MergeFrom(const DoubleVector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DoubleVector)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  vector_.MergeFrom(from.vector_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DoubleVector::CopyFrom(const DoubleVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DoubleVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoubleVector::IsInitialized() const {
  return true;
}

void DoubleVector::InternalSwap(DoubleVector* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  vector_.InternalSwap(&other->vector_);
}

std::string DoubleVector::GetTypeName() const {
  return "CoreML.Specification.DoubleVector";
}


// ===================================================================

class Int64Range::_Internal {
 public:
};

Int64Range::Int64Range(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.Int64Range)
}
Int64Range::Int64Range(const Int64Range& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&minvalue_, &from.minvalue_,
    static_cast<size_t>(reinterpret_cast<char*>(&maxvalue_) -
    reinterpret_cast<char*>(&minvalue_)) + sizeof(maxvalue_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Int64Range)
}

inline void Int64Range::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&minvalue_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&maxvalue_) -
    reinterpret_cast<char*>(&minvalue_)) + sizeof(maxvalue_));
}

Int64Range::~Int64Range() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Int64Range)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Int64Range::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Int64Range::ArenaDtor(void* object) {
  Int64Range* _this = reinterpret_cast< Int64Range* >(object);
  (void)_this;
}
void Int64Range::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Int64Range::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Int64Range::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Int64Range)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&minvalue_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&maxvalue_) -
      reinterpret_cast<char*>(&minvalue_)) + sizeof(maxvalue_));
  _internal_metadata_.Clear<std::string>();
}

const char* Int64Range::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 minValue = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          minvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 maxValue = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          maxvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Int64Range::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.Int64Range)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 minValue = 1;
  if (this->_internal_minvalue() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_minvalue(), target);
  }

  // int64 maxValue = 2;
  if (this->_internal_maxvalue() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_maxvalue(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.Int64Range)
  return target;
}

size_t Int64Range::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Int64Range)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 minValue = 1;
  if (this->_internal_minvalue() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_minvalue());
  }

  // int64 maxValue = 2;
  if (this->_internal_maxvalue() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_maxvalue());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Int64Range::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Int64Range*>(
      &from));
}

void Int64Range::MergeFrom(const Int64Range& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Int64Range)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_minvalue() != 0) {
    _internal_set_minvalue(from._internal_minvalue());
  }
  if (from._internal_maxvalue() != 0) {
    _internal_set_maxvalue(from._internal_maxvalue());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Int64Range::CopyFrom(const Int64Range& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Int64Range)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int64Range::IsInitialized() const {
  return true;
}

void Int64Range::InternalSwap(Int64Range* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Int64Range, maxvalue_)
      + sizeof(Int64Range::maxvalue_)
      - PROTOBUF_FIELD_OFFSET(Int64Range, minvalue_)>(
          reinterpret_cast<char*>(&minvalue_),
          reinterpret_cast<char*>(&other->minvalue_));
}

std::string Int64Range::GetTypeName() const {
  return "CoreML.Specification.Int64Range";
}


// ===================================================================

class Int64Set::_Internal {
 public:
};

Int64Set::Int64Set(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.Int64Set)
}
Int64Set::Int64Set(const Int64Set& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Int64Set)
}

inline void Int64Set::SharedCtor() {
}

Int64Set::~Int64Set() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Int64Set)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Int64Set::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Int64Set::ArenaDtor(void* object) {
  Int64Set* _this = reinterpret_cast< Int64Set* >(object);
  (void)_this;
}
void Int64Set::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Int64Set::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Int64Set::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Int64Set)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Int64Set::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_values(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_values(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Int64Set::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.Int64Set)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 values = 1;
  {
    int byte_size = _values_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_values(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.Int64Set)
  return target;
}

size_t Int64Set::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Int64Set)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 values = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->values_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _values_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Int64Set::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Int64Set*>(
      &from));
}

void Int64Set::MergeFrom(const Int64Set& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Int64Set)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Int64Set::CopyFrom(const Int64Set& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Int64Set)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int64Set::IsInitialized() const {
  return true;
}

void Int64Set::InternalSwap(Int64Set* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string Int64Set::GetTypeName() const {
  return "CoreML.Specification.Int64Set";
}


// ===================================================================

class DoubleRange::_Internal {
 public:
};

DoubleRange::DoubleRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.DoubleRange)
}
DoubleRange::DoubleRange(const DoubleRange& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&minvalue_, &from.minvalue_,
    static_cast<size_t>(reinterpret_cast<char*>(&maxvalue_) -
    reinterpret_cast<char*>(&minvalue_)) + sizeof(maxvalue_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DoubleRange)
}

inline void DoubleRange::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&minvalue_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&maxvalue_) -
    reinterpret_cast<char*>(&minvalue_)) + sizeof(maxvalue_));
}

DoubleRange::~DoubleRange() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DoubleRange)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void DoubleRange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DoubleRange::ArenaDtor(void* object) {
  DoubleRange* _this = reinterpret_cast< DoubleRange* >(object);
  (void)_this;
}
void DoubleRange::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DoubleRange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DoubleRange::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DoubleRange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&minvalue_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&maxvalue_) -
      reinterpret_cast<char*>(&minvalue_)) + sizeof(maxvalue_));
  _internal_metadata_.Clear<std::string>();
}

const char* DoubleRange::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double minValue = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          minvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double maxValue = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          maxvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DoubleRange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.DoubleRange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double minValue = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_minvalue = this->_internal_minvalue();
  uint64_t raw_minvalue;
  memcpy(&raw_minvalue, &tmp_minvalue, sizeof(tmp_minvalue));
  if (raw_minvalue != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_minvalue(), target);
  }

  // double maxValue = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_maxvalue = this->_internal_maxvalue();
  uint64_t raw_maxvalue;
  memcpy(&raw_maxvalue, &tmp_maxvalue, sizeof(tmp_maxvalue));
  if (raw_maxvalue != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_maxvalue(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.DoubleRange)
  return target;
}

size_t DoubleRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DoubleRange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double minValue = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_minvalue = this->_internal_minvalue();
  uint64_t raw_minvalue;
  memcpy(&raw_minvalue, &tmp_minvalue, sizeof(tmp_minvalue));
  if (raw_minvalue != 0) {
    total_size += 1 + 8;
  }

  // double maxValue = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_maxvalue = this->_internal_maxvalue();
  uint64_t raw_maxvalue;
  memcpy(&raw_maxvalue, &tmp_maxvalue, sizeof(tmp_maxvalue));
  if (raw_maxvalue != 0) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DoubleRange::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DoubleRange*>(
      &from));
}

void DoubleRange::MergeFrom(const DoubleRange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DoubleRange)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_minvalue = from._internal_minvalue();
  uint64_t raw_minvalue;
  memcpy(&raw_minvalue, &tmp_minvalue, sizeof(tmp_minvalue));
  if (raw_minvalue != 0) {
    _internal_set_minvalue(from._internal_minvalue());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_maxvalue = from._internal_maxvalue();
  uint64_t raw_maxvalue;
  memcpy(&raw_maxvalue, &tmp_maxvalue, sizeof(tmp_maxvalue));
  if (raw_maxvalue != 0) {
    _internal_set_maxvalue(from._internal_maxvalue());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DoubleRange::CopyFrom(const DoubleRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DoubleRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoubleRange::IsInitialized() const {
  return true;
}

void DoubleRange::InternalSwap(DoubleRange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DoubleRange, maxvalue_)
      + sizeof(DoubleRange::maxvalue_)
      - PROTOBUF_FIELD_OFFSET(DoubleRange, minvalue_)>(
          reinterpret_cast<char*>(&minvalue_),
          reinterpret_cast<char*>(&other->minvalue_));
}

std::string DoubleRange::GetTypeName() const {
  return "CoreML.Specification.DoubleRange";
}


// ===================================================================

class PrecisionRecallCurve::_Internal {
 public:
  static const ::CoreML::Specification::FloatVector& precisionvalues(const PrecisionRecallCurve* msg);
  static const ::CoreML::Specification::FloatVector& precisionconfidencethresholds(const PrecisionRecallCurve* msg);
  static const ::CoreML::Specification::FloatVector& recallvalues(const PrecisionRecallCurve* msg);
  static const ::CoreML::Specification::FloatVector& recallconfidencethresholds(const PrecisionRecallCurve* msg);
};

const ::CoreML::Specification::FloatVector&
PrecisionRecallCurve::_Internal::precisionvalues(const PrecisionRecallCurve* msg) {
  return *msg->precisionvalues_;
}
const ::CoreML::Specification::FloatVector&
PrecisionRecallCurve::_Internal::precisionconfidencethresholds(const PrecisionRecallCurve* msg) {
  return *msg->precisionconfidencethresholds_;
}
const ::CoreML::Specification::FloatVector&
PrecisionRecallCurve::_Internal::recallvalues(const PrecisionRecallCurve* msg) {
  return *msg->recallvalues_;
}
const ::CoreML::Specification::FloatVector&
PrecisionRecallCurve::_Internal::recallconfidencethresholds(const PrecisionRecallCurve* msg) {
  return *msg->recallconfidencethresholds_;
}
PrecisionRecallCurve::PrecisionRecallCurve(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.PrecisionRecallCurve)
}
PrecisionRecallCurve::PrecisionRecallCurve(const PrecisionRecallCurve& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_precisionvalues()) {
    precisionvalues_ = new ::CoreML::Specification::FloatVector(*from.precisionvalues_);
  } else {
    precisionvalues_ = nullptr;
  }
  if (from._internal_has_precisionconfidencethresholds()) {
    precisionconfidencethresholds_ = new ::CoreML::Specification::FloatVector(*from.precisionconfidencethresholds_);
  } else {
    precisionconfidencethresholds_ = nullptr;
  }
  if (from._internal_has_recallvalues()) {
    recallvalues_ = new ::CoreML::Specification::FloatVector(*from.recallvalues_);
  } else {
    recallvalues_ = nullptr;
  }
  if (from._internal_has_recallconfidencethresholds()) {
    recallconfidencethresholds_ = new ::CoreML::Specification::FloatVector(*from.recallconfidencethresholds_);
  } else {
    recallconfidencethresholds_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.PrecisionRecallCurve)
}

inline void PrecisionRecallCurve::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&precisionvalues_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&recallconfidencethresholds_) -
    reinterpret_cast<char*>(&precisionvalues_)) + sizeof(recallconfidencethresholds_));
}

PrecisionRecallCurve::~PrecisionRecallCurve() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.PrecisionRecallCurve)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PrecisionRecallCurve::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete precisionvalues_;
  if (this != internal_default_instance()) delete precisionconfidencethresholds_;
  if (this != internal_default_instance()) delete recallvalues_;
  if (this != internal_default_instance()) delete recallconfidencethresholds_;
}

void PrecisionRecallCurve::ArenaDtor(void* object) {
  PrecisionRecallCurve* _this = reinterpret_cast< PrecisionRecallCurve* >(object);
  (void)_this;
}
void PrecisionRecallCurve::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PrecisionRecallCurve::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PrecisionRecallCurve::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.PrecisionRecallCurve)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && precisionvalues_ != nullptr) {
    delete precisionvalues_;
  }
  precisionvalues_ = nullptr;
  if (GetArenaForAllocation() == nullptr && precisionconfidencethresholds_ != nullptr) {
    delete precisionconfidencethresholds_;
  }
  precisionconfidencethresholds_ = nullptr;
  if (GetArenaForAllocation() == nullptr && recallvalues_ != nullptr) {
    delete recallvalues_;
  }
  recallvalues_ = nullptr;
  if (GetArenaForAllocation() == nullptr && recallconfidencethresholds_ != nullptr) {
    delete recallconfidencethresholds_;
  }
  recallconfidencethresholds_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* PrecisionRecallCurve::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.FloatVector precisionValues = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_precisionvalues(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.FloatVector precisionConfidenceThresholds = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_precisionconfidencethresholds(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.FloatVector recallValues = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_recallvalues(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.FloatVector recallConfidenceThresholds = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_recallconfidencethresholds(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PrecisionRecallCurve::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.PrecisionRecallCurve)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.FloatVector precisionValues = 1;
  if (this->_internal_has_precisionvalues()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::precisionvalues(this), target, stream);
  }

  // .CoreML.Specification.FloatVector precisionConfidenceThresholds = 2;
  if (this->_internal_has_precisionconfidencethresholds()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::precisionconfidencethresholds(this), target, stream);
  }

  // .CoreML.Specification.FloatVector recallValues = 3;
  if (this->_internal_has_recallvalues()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::recallvalues(this), target, stream);
  }

  // .CoreML.Specification.FloatVector recallConfidenceThresholds = 4;
  if (this->_internal_has_recallconfidencethresholds()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::recallconfidencethresholds(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.PrecisionRecallCurve)
  return target;
}

size_t PrecisionRecallCurve::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.PrecisionRecallCurve)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.FloatVector precisionValues = 1;
  if (this->_internal_has_precisionvalues()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *precisionvalues_);
  }

  // .CoreML.Specification.FloatVector precisionConfidenceThresholds = 2;
  if (this->_internal_has_precisionconfidencethresholds()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *precisionconfidencethresholds_);
  }

  // .CoreML.Specification.FloatVector recallValues = 3;
  if (this->_internal_has_recallvalues()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *recallvalues_);
  }

  // .CoreML.Specification.FloatVector recallConfidenceThresholds = 4;
  if (this->_internal_has_recallconfidencethresholds()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *recallconfidencethresholds_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PrecisionRecallCurve::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PrecisionRecallCurve*>(
      &from));
}

void PrecisionRecallCurve::MergeFrom(const PrecisionRecallCurve& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.PrecisionRecallCurve)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_precisionvalues()) {
    _internal_mutable_precisionvalues()->::CoreML::Specification::FloatVector::MergeFrom(from._internal_precisionvalues());
  }
  if (from._internal_has_precisionconfidencethresholds()) {
    _internal_mutable_precisionconfidencethresholds()->::CoreML::Specification::FloatVector::MergeFrom(from._internal_precisionconfidencethresholds());
  }
  if (from._internal_has_recallvalues()) {
    _internal_mutable_recallvalues()->::CoreML::Specification::FloatVector::MergeFrom(from._internal_recallvalues());
  }
  if (from._internal_has_recallconfidencethresholds()) {
    _internal_mutable_recallconfidencethresholds()->::CoreML::Specification::FloatVector::MergeFrom(from._internal_recallconfidencethresholds());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PrecisionRecallCurve::CopyFrom(const PrecisionRecallCurve& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.PrecisionRecallCurve)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrecisionRecallCurve::IsInitialized() const {
  return true;
}

void PrecisionRecallCurve::InternalSwap(PrecisionRecallCurve* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PrecisionRecallCurve, recallconfidencethresholds_)
      + sizeof(PrecisionRecallCurve::recallconfidencethresholds_)
      - PROTOBUF_FIELD_OFFSET(PrecisionRecallCurve, precisionvalues_)>(
          reinterpret_cast<char*>(&precisionvalues_),
          reinterpret_cast<char*>(&other->precisionvalues_));
}

std::string PrecisionRecallCurve::GetTypeName() const {
  return "CoreML.Specification.PrecisionRecallCurve";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace Specification
}  // namespace CoreML
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CoreML::Specification::StringToInt64Map_MapEntry_DoNotUse* Arena::CreateMaybeMessage< ::CoreML::Specification::StringToInt64Map_MapEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::StringToInt64Map_MapEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::StringToInt64Map* Arena::CreateMaybeMessage< ::CoreML::Specification::StringToInt64Map >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::StringToInt64Map >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Int64ToStringMap_MapEntry_DoNotUse* Arena::CreateMaybeMessage< ::CoreML::Specification::Int64ToStringMap_MapEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Int64ToStringMap_MapEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Int64ToStringMap* Arena::CreateMaybeMessage< ::CoreML::Specification::Int64ToStringMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Int64ToStringMap >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::StringToDoubleMap_MapEntry_DoNotUse* Arena::CreateMaybeMessage< ::CoreML::Specification::StringToDoubleMap_MapEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::StringToDoubleMap_MapEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::StringToDoubleMap* Arena::CreateMaybeMessage< ::CoreML::Specification::StringToDoubleMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::StringToDoubleMap >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Int64ToDoubleMap_MapEntry_DoNotUse* Arena::CreateMaybeMessage< ::CoreML::Specification::Int64ToDoubleMap_MapEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Int64ToDoubleMap_MapEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Int64ToDoubleMap* Arena::CreateMaybeMessage< ::CoreML::Specification::Int64ToDoubleMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Int64ToDoubleMap >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::StringVector* Arena::CreateMaybeMessage< ::CoreML::Specification::StringVector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::StringVector >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Int64Vector* Arena::CreateMaybeMessage< ::CoreML::Specification::Int64Vector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Int64Vector >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::FloatVector* Arena::CreateMaybeMessage< ::CoreML::Specification::FloatVector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::FloatVector >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::DoubleVector* Arena::CreateMaybeMessage< ::CoreML::Specification::DoubleVector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::DoubleVector >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Int64Range* Arena::CreateMaybeMessage< ::CoreML::Specification::Int64Range >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Int64Range >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Int64Set* Arena::CreateMaybeMessage< ::CoreML::Specification::Int64Set >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Int64Set >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::DoubleRange* Arena::CreateMaybeMessage< ::CoreML::Specification::DoubleRange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::DoubleRange >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::PrecisionRecallCurve* Arena::CreateMaybeMessage< ::CoreML::Specification::PrecisionRecallCurve >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::PrecisionRecallCurve >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
