// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Model.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Model_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Model_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include "VisionFeaturePrint.pb.h"
#include "AudioFeaturePrint.pb.h"
#include "TextClassifier.pb.h"
#include "WordTagger.pb.h"
#include "Gazetteer.pb.h"
#include "WordEmbedding.pb.h"
#include "ArrayFeatureExtractor.pb.h"
#include "BayesianProbitRegressor.pb.h"
#include "CategoricalMapping.pb.h"
#include "CustomModel.pb.h"
#include "DictVectorizer.pb.h"
#include "FeatureTypes.pb.h"
#include "FeatureVectorizer.pb.h"
#include "GLMRegressor.pb.h"
#include "GLMClassifier.pb.h"
#include "NearestNeighbors.pb.h"
#include "Identity.pb.h"
#include "Imputer.pb.h"
#include "MIL.pb.h"
#include "NeuralNetwork.pb.h"
#include "Normalizer.pb.h"
#include "OneHotEncoder.pb.h"
#include "Scaler.pb.h"
#include "NonMaximumSuppression.pb.h"
#include "SVM.pb.h"
#include "TreeEnsemble.pb.h"
#include "Parameters.pb.h"
#include "ItemSimilarityRecommender.pb.h"
#include "SoundAnalysisPreprocessing.pb.h"
#include "LinkedModel.pb.h"
#include "ClassConfidenceThresholding.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Model_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Model_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace CoreML {
namespace Specification {
class FeatureDescription;
struct FeatureDescriptionDefaultTypeInternal;
extern FeatureDescriptionDefaultTypeInternal _FeatureDescription_default_instance_;
class FunctionDescription;
struct FunctionDescriptionDefaultTypeInternal;
extern FunctionDescriptionDefaultTypeInternal _FunctionDescription_default_instance_;
class Metadata;
struct MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class Metadata_UserDefinedEntry_DoNotUse;
struct Metadata_UserDefinedEntry_DoNotUseDefaultTypeInternal;
extern Metadata_UserDefinedEntry_DoNotUseDefaultTypeInternal _Metadata_UserDefinedEntry_DoNotUse_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class ModelDescription;
struct ModelDescriptionDefaultTypeInternal;
extern ModelDescriptionDefaultTypeInternal _ModelDescription_default_instance_;
class Pipeline;
struct PipelineDefaultTypeInternal;
extern PipelineDefaultTypeInternal _Pipeline_default_instance_;
class PipelineClassifier;
struct PipelineClassifierDefaultTypeInternal;
extern PipelineClassifierDefaultTypeInternal _PipelineClassifier_default_instance_;
class PipelineRegressor;
struct PipelineRegressorDefaultTypeInternal;
extern PipelineRegressorDefaultTypeInternal _PipelineRegressor_default_instance_;
class SerializedModel;
struct SerializedModelDefaultTypeInternal;
extern SerializedModelDefaultTypeInternal _SerializedModel_default_instance_;
}  // namespace Specification
}  // namespace CoreML
PROTOBUF_NAMESPACE_OPEN
template<> ::CoreML::Specification::FeatureDescription* Arena::CreateMaybeMessage<::CoreML::Specification::FeatureDescription>(Arena*);
template<> ::CoreML::Specification::FunctionDescription* Arena::CreateMaybeMessage<::CoreML::Specification::FunctionDescription>(Arena*);
template<> ::CoreML::Specification::Metadata* Arena::CreateMaybeMessage<::CoreML::Specification::Metadata>(Arena*);
template<> ::CoreML::Specification::Metadata_UserDefinedEntry_DoNotUse* Arena::CreateMaybeMessage<::CoreML::Specification::Metadata_UserDefinedEntry_DoNotUse>(Arena*);
template<> ::CoreML::Specification::Model* Arena::CreateMaybeMessage<::CoreML::Specification::Model>(Arena*);
template<> ::CoreML::Specification::ModelDescription* Arena::CreateMaybeMessage<::CoreML::Specification::ModelDescription>(Arena*);
template<> ::CoreML::Specification::Pipeline* Arena::CreateMaybeMessage<::CoreML::Specification::Pipeline>(Arena*);
template<> ::CoreML::Specification::PipelineClassifier* Arena::CreateMaybeMessage<::CoreML::Specification::PipelineClassifier>(Arena*);
template<> ::CoreML::Specification::PipelineRegressor* Arena::CreateMaybeMessage<::CoreML::Specification::PipelineRegressor>(Arena*);
template<> ::CoreML::Specification::SerializedModel* Arena::CreateMaybeMessage<::CoreML::Specification::SerializedModel>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace CoreML {
namespace Specification {

// ===================================================================

class Pipeline final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.Pipeline) */ {
 public:
  inline Pipeline() : Pipeline(nullptr) {}
  ~Pipeline() override;
  explicit constexpr Pipeline(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pipeline(const Pipeline& from);
  Pipeline(Pipeline&& from) noexcept
    : Pipeline() {
    *this = ::std::move(from);
  }

  inline Pipeline& operator=(const Pipeline& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pipeline& operator=(Pipeline&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Pipeline& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pipeline* internal_default_instance() {
    return reinterpret_cast<const Pipeline*>(
               &_Pipeline_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Pipeline& a, Pipeline& b) {
    a.Swap(&b);
  }
  inline void Swap(Pipeline* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pipeline* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pipeline* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pipeline>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Pipeline& from);
  void MergeFrom(const Pipeline& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Pipeline* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.Pipeline";
  }
  protected:
  explicit Pipeline(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelsFieldNumber = 1,
    kNamesFieldNumber = 2,
  };
  // repeated .CoreML.Specification.Model models = 1;
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::CoreML::Specification::Model* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::Model >*
      mutable_models();
  private:
  const ::CoreML::Specification::Model& _internal_models(int index) const;
  ::CoreML::Specification::Model* _internal_add_models();
  public:
  const ::CoreML::Specification::Model& models(int index) const;
  ::CoreML::Specification::Model* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::Model >&
      models() const;

  // repeated string names = 2;
  int names_size() const;
  private:
  int _internal_names_size() const;
  public:
  void clear_names();
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  void set_names(int index, const std::string& value);
  void set_names(int index, std::string&& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  std::string* add_names();
  void add_names(const std::string& value);
  void add_names(std::string&& value);
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_names();
  private:
  const std::string& _internal_names(int index) const;
  std::string* _internal_add_names();
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.Pipeline)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::Model > models_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> names_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Model_2eproto;
};
// -------------------------------------------------------------------

class PipelineClassifier final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.PipelineClassifier) */ {
 public:
  inline PipelineClassifier() : PipelineClassifier(nullptr) {}
  ~PipelineClassifier() override;
  explicit constexpr PipelineClassifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PipelineClassifier(const PipelineClassifier& from);
  PipelineClassifier(PipelineClassifier&& from) noexcept
    : PipelineClassifier() {
    *this = ::std::move(from);
  }

  inline PipelineClassifier& operator=(const PipelineClassifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline PipelineClassifier& operator=(PipelineClassifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PipelineClassifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const PipelineClassifier* internal_default_instance() {
    return reinterpret_cast<const PipelineClassifier*>(
               &_PipelineClassifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PipelineClassifier& a, PipelineClassifier& b) {
    a.Swap(&b);
  }
  inline void Swap(PipelineClassifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PipelineClassifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PipelineClassifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PipelineClassifier>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PipelineClassifier& from);
  void MergeFrom(const PipelineClassifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PipelineClassifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.PipelineClassifier";
  }
  protected:
  explicit PipelineClassifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPipelineFieldNumber = 1,
  };
  // .CoreML.Specification.Pipeline pipeline = 1;
  bool has_pipeline() const;
  private:
  bool _internal_has_pipeline() const;
  public:
  void clear_pipeline();
  const ::CoreML::Specification::Pipeline& pipeline() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::Pipeline* release_pipeline();
  ::CoreML::Specification::Pipeline* mutable_pipeline();
  void set_allocated_pipeline(::CoreML::Specification::Pipeline* pipeline);
  private:
  const ::CoreML::Specification::Pipeline& _internal_pipeline() const;
  ::CoreML::Specification::Pipeline* _internal_mutable_pipeline();
  public:
  void unsafe_arena_set_allocated_pipeline(
      ::CoreML::Specification::Pipeline* pipeline);
  ::CoreML::Specification::Pipeline* unsafe_arena_release_pipeline();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.PipelineClassifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::CoreML::Specification::Pipeline* pipeline_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Model_2eproto;
};
// -------------------------------------------------------------------

class PipelineRegressor final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.PipelineRegressor) */ {
 public:
  inline PipelineRegressor() : PipelineRegressor(nullptr) {}
  ~PipelineRegressor() override;
  explicit constexpr PipelineRegressor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PipelineRegressor(const PipelineRegressor& from);
  PipelineRegressor(PipelineRegressor&& from) noexcept
    : PipelineRegressor() {
    *this = ::std::move(from);
  }

  inline PipelineRegressor& operator=(const PipelineRegressor& from) {
    CopyFrom(from);
    return *this;
  }
  inline PipelineRegressor& operator=(PipelineRegressor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PipelineRegressor& default_instance() {
    return *internal_default_instance();
  }
  static inline const PipelineRegressor* internal_default_instance() {
    return reinterpret_cast<const PipelineRegressor*>(
               &_PipelineRegressor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PipelineRegressor& a, PipelineRegressor& b) {
    a.Swap(&b);
  }
  inline void Swap(PipelineRegressor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PipelineRegressor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PipelineRegressor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PipelineRegressor>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PipelineRegressor& from);
  void MergeFrom(const PipelineRegressor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PipelineRegressor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.PipelineRegressor";
  }
  protected:
  explicit PipelineRegressor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPipelineFieldNumber = 1,
  };
  // .CoreML.Specification.Pipeline pipeline = 1;
  bool has_pipeline() const;
  private:
  bool _internal_has_pipeline() const;
  public:
  void clear_pipeline();
  const ::CoreML::Specification::Pipeline& pipeline() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::Pipeline* release_pipeline();
  ::CoreML::Specification::Pipeline* mutable_pipeline();
  void set_allocated_pipeline(::CoreML::Specification::Pipeline* pipeline);
  private:
  const ::CoreML::Specification::Pipeline& _internal_pipeline() const;
  ::CoreML::Specification::Pipeline* _internal_mutable_pipeline();
  public:
  void unsafe_arena_set_allocated_pipeline(
      ::CoreML::Specification::Pipeline* pipeline);
  ::CoreML::Specification::Pipeline* unsafe_arena_release_pipeline();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.PipelineRegressor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::CoreML::Specification::Pipeline* pipeline_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Model_2eproto;
};
// -------------------------------------------------------------------

class FeatureDescription final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.FeatureDescription) */ {
 public:
  inline FeatureDescription() : FeatureDescription(nullptr) {}
  ~FeatureDescription() override;
  explicit constexpr FeatureDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeatureDescription(const FeatureDescription& from);
  FeatureDescription(FeatureDescription&& from) noexcept
    : FeatureDescription() {
    *this = ::std::move(from);
  }

  inline FeatureDescription& operator=(const FeatureDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeatureDescription& operator=(FeatureDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const FeatureDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeatureDescription* internal_default_instance() {
    return reinterpret_cast<const FeatureDescription*>(
               &_FeatureDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FeatureDescription& a, FeatureDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(FeatureDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeatureDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeatureDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeatureDescription>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FeatureDescription& from);
  void MergeFrom(const FeatureDescription& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FeatureDescription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.FeatureDescription";
  }
  protected:
  explicit FeatureDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kShortDescriptionFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string shortDescription = 2;
  void clear_shortdescription();
  const std::string& shortdescription() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shortdescription(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shortdescription();
  PROTOBUF_NODISCARD std::string* release_shortdescription();
  void set_allocated_shortdescription(std::string* shortdescription);
  private:
  const std::string& _internal_shortdescription() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shortdescription(const std::string& value);
  std::string* _internal_mutable_shortdescription();
  public:

  // .CoreML.Specification.FeatureType type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::CoreML::Specification::FeatureType& type() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::FeatureType* release_type();
  ::CoreML::Specification::FeatureType* mutable_type();
  void set_allocated_type(::CoreML::Specification::FeatureType* type);
  private:
  const ::CoreML::Specification::FeatureType& _internal_type() const;
  ::CoreML::Specification::FeatureType* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::CoreML::Specification::FeatureType* type);
  ::CoreML::Specification::FeatureType* unsafe_arena_release_type();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.FeatureDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shortdescription_;
  ::CoreML::Specification::FeatureType* type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Model_2eproto;
};
// -------------------------------------------------------------------

class Metadata_UserDefinedEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Metadata_UserDefinedEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Metadata_UserDefinedEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Metadata_UserDefinedEntry_DoNotUse();
  explicit constexpr Metadata_UserDefinedEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Metadata_UserDefinedEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Metadata_UserDefinedEntry_DoNotUse& other);
  static const Metadata_UserDefinedEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Metadata_UserDefinedEntry_DoNotUse*>(&_Metadata_UserDefinedEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "CoreML.Specification.Metadata.UserDefinedEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "CoreML.Specification.Metadata.UserDefinedEntry.value");
 }
};

// -------------------------------------------------------------------

class Metadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.Metadata) */ {
 public:
  inline Metadata() : Metadata(nullptr) {}
  ~Metadata() override;
  explicit constexpr Metadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metadata(const Metadata& from);
  Metadata(Metadata&& from) noexcept
    : Metadata() {
    *this = ::std::move(from);
  }

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metadata& operator=(Metadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Metadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metadata* internal_default_instance() {
    return reinterpret_cast<const Metadata*>(
               &_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Metadata& a, Metadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Metadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Metadata& from);
  void MergeFrom(const Metadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Metadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.Metadata";
  }
  protected:
  explicit Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kUserDefinedFieldNumber = 100,
    kShortDescriptionFieldNumber = 1,
    kVersionStringFieldNumber = 2,
    kAuthorFieldNumber = 3,
    kLicenseFieldNumber = 4,
  };
  // map<string, string> userDefined = 100;
  int userdefined_size() const;
  private:
  int _internal_userdefined_size() const;
  public:
  void clear_userdefined();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_userdefined() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_userdefined();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      userdefined() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_userdefined();

  // string shortDescription = 1;
  void clear_shortdescription();
  const std::string& shortdescription() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shortdescription(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shortdescription();
  PROTOBUF_NODISCARD std::string* release_shortdescription();
  void set_allocated_shortdescription(std::string* shortdescription);
  private:
  const std::string& _internal_shortdescription() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shortdescription(const std::string& value);
  std::string* _internal_mutable_shortdescription();
  public:

  // string versionString = 2;
  void clear_versionstring();
  const std::string& versionstring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_versionstring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_versionstring();
  PROTOBUF_NODISCARD std::string* release_versionstring();
  void set_allocated_versionstring(std::string* versionstring);
  private:
  const std::string& _internal_versionstring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_versionstring(const std::string& value);
  std::string* _internal_mutable_versionstring();
  public:

  // string author = 3;
  void clear_author();
  const std::string& author() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_author(ArgT0&& arg0, ArgT... args);
  std::string* mutable_author();
  PROTOBUF_NODISCARD std::string* release_author();
  void set_allocated_author(std::string* author);
  private:
  const std::string& _internal_author() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_author(const std::string& value);
  std::string* _internal_mutable_author();
  public:

  // string license = 4;
  void clear_license();
  const std::string& license() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_license(ArgT0&& arg0, ArgT... args);
  std::string* mutable_license();
  PROTOBUF_NODISCARD std::string* release_license();
  void set_allocated_license(std::string* license);
  private:
  const std::string& _internal_license() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_license(const std::string& value);
  std::string* _internal_mutable_license();
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.Metadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Metadata_UserDefinedEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> userdefined_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shortdescription_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr versionstring_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr author_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr license_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Model_2eproto;
};
// -------------------------------------------------------------------

class FunctionDescription final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.FunctionDescription) */ {
 public:
  inline FunctionDescription() : FunctionDescription(nullptr) {}
  ~FunctionDescription() override;
  explicit constexpr FunctionDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FunctionDescription(const FunctionDescription& from);
  FunctionDescription(FunctionDescription&& from) noexcept
    : FunctionDescription() {
    *this = ::std::move(from);
  }

  inline FunctionDescription& operator=(const FunctionDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionDescription& operator=(FunctionDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const FunctionDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const FunctionDescription* internal_default_instance() {
    return reinterpret_cast<const FunctionDescription*>(
               &_FunctionDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FunctionDescription& a, FunctionDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FunctionDescription>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FunctionDescription& from);
  void MergeFrom(const FunctionDescription& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FunctionDescription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.FunctionDescription";
  }
  protected:
  explicit FunctionDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 2,
    kOutputFieldNumber = 3,
    kStateFieldNumber = 6,
    kNameFieldNumber = 1,
    kPredictedFeatureNameFieldNumber = 4,
    kPredictedProbabilitiesNameFieldNumber = 5,
  };
  // repeated .CoreML.Specification.FeatureDescription input = 2;
  int input_size() const;
  private:
  int _internal_input_size() const;
  public:
  void clear_input();
  ::CoreML::Specification::FeatureDescription* mutable_input(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
      mutable_input();
  private:
  const ::CoreML::Specification::FeatureDescription& _internal_input(int index) const;
  ::CoreML::Specification::FeatureDescription* _internal_add_input();
  public:
  const ::CoreML::Specification::FeatureDescription& input(int index) const;
  ::CoreML::Specification::FeatureDescription* add_input();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
      input() const;

  // repeated .CoreML.Specification.FeatureDescription output = 3;
  int output_size() const;
  private:
  int _internal_output_size() const;
  public:
  void clear_output();
  ::CoreML::Specification::FeatureDescription* mutable_output(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
      mutable_output();
  private:
  const ::CoreML::Specification::FeatureDescription& _internal_output(int index) const;
  ::CoreML::Specification::FeatureDescription* _internal_add_output();
  public:
  const ::CoreML::Specification::FeatureDescription& output(int index) const;
  ::CoreML::Specification::FeatureDescription* add_output();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
      output() const;

  // repeated .CoreML.Specification.FeatureDescription state = 6;
  int state_size() const;
  private:
  int _internal_state_size() const;
  public:
  void clear_state();
  ::CoreML::Specification::FeatureDescription* mutable_state(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
      mutable_state();
  private:
  const ::CoreML::Specification::FeatureDescription& _internal_state(int index) const;
  ::CoreML::Specification::FeatureDescription* _internal_add_state();
  public:
  const ::CoreML::Specification::FeatureDescription& state(int index) const;
  ::CoreML::Specification::FeatureDescription* add_state();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
      state() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string predictedFeatureName = 4;
  void clear_predictedfeaturename();
  const std::string& predictedfeaturename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_predictedfeaturename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_predictedfeaturename();
  PROTOBUF_NODISCARD std::string* release_predictedfeaturename();
  void set_allocated_predictedfeaturename(std::string* predictedfeaturename);
  private:
  const std::string& _internal_predictedfeaturename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_predictedfeaturename(const std::string& value);
  std::string* _internal_mutable_predictedfeaturename();
  public:

  // string predictedProbabilitiesName = 5;
  void clear_predictedprobabilitiesname();
  const std::string& predictedprobabilitiesname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_predictedprobabilitiesname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_predictedprobabilitiesname();
  PROTOBUF_NODISCARD std::string* release_predictedprobabilitiesname();
  void set_allocated_predictedprobabilitiesname(std::string* predictedprobabilitiesname);
  private:
  const std::string& _internal_predictedprobabilitiesname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_predictedprobabilitiesname(const std::string& value);
  std::string* _internal_mutable_predictedprobabilitiesname();
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.FunctionDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription > input_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription > output_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription > state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr predictedfeaturename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr predictedprobabilitiesname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Model_2eproto;
};
// -------------------------------------------------------------------

class ModelDescription final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ModelDescription) */ {
 public:
  inline ModelDescription() : ModelDescription(nullptr) {}
  ~ModelDescription() override;
  explicit constexpr ModelDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelDescription(const ModelDescription& from);
  ModelDescription(ModelDescription&& from) noexcept
    : ModelDescription() {
    *this = ::std::move(from);
  }

  inline ModelDescription& operator=(const ModelDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelDescription& operator=(ModelDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ModelDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelDescription* internal_default_instance() {
    return reinterpret_cast<const ModelDescription*>(
               &_ModelDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ModelDescription& a, ModelDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelDescription>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ModelDescription& from);
  void MergeFrom(const ModelDescription& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelDescription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.ModelDescription";
  }
  protected:
  explicit ModelDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 1,
    kOutputFieldNumber = 10,
    kStateFieldNumber = 13,
    kFunctionsFieldNumber = 20,
    kTrainingInputFieldNumber = 50,
    kPredictedFeatureNameFieldNumber = 11,
    kPredictedProbabilitiesNameFieldNumber = 12,
    kDefaultFunctionNameFieldNumber = 21,
    kMetadataFieldNumber = 100,
  };
  // repeated .CoreML.Specification.FeatureDescription input = 1;
  int input_size() const;
  private:
  int _internal_input_size() const;
  public:
  void clear_input();
  ::CoreML::Specification::FeatureDescription* mutable_input(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
      mutable_input();
  private:
  const ::CoreML::Specification::FeatureDescription& _internal_input(int index) const;
  ::CoreML::Specification::FeatureDescription* _internal_add_input();
  public:
  const ::CoreML::Specification::FeatureDescription& input(int index) const;
  ::CoreML::Specification::FeatureDescription* add_input();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
      input() const;

  // repeated .CoreML.Specification.FeatureDescription output = 10;
  int output_size() const;
  private:
  int _internal_output_size() const;
  public:
  void clear_output();
  ::CoreML::Specification::FeatureDescription* mutable_output(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
      mutable_output();
  private:
  const ::CoreML::Specification::FeatureDescription& _internal_output(int index) const;
  ::CoreML::Specification::FeatureDescription* _internal_add_output();
  public:
  const ::CoreML::Specification::FeatureDescription& output(int index) const;
  ::CoreML::Specification::FeatureDescription* add_output();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
      output() const;

  // repeated .CoreML.Specification.FeatureDescription state = 13;
  int state_size() const;
  private:
  int _internal_state_size() const;
  public:
  void clear_state();
  ::CoreML::Specification::FeatureDescription* mutable_state(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
      mutable_state();
  private:
  const ::CoreML::Specification::FeatureDescription& _internal_state(int index) const;
  ::CoreML::Specification::FeatureDescription* _internal_add_state();
  public:
  const ::CoreML::Specification::FeatureDescription& state(int index) const;
  ::CoreML::Specification::FeatureDescription* add_state();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
      state() const;

  // repeated .CoreML.Specification.FunctionDescription functions = 20;
  int functions_size() const;
  private:
  int _internal_functions_size() const;
  public:
  void clear_functions();
  ::CoreML::Specification::FunctionDescription* mutable_functions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FunctionDescription >*
      mutable_functions();
  private:
  const ::CoreML::Specification::FunctionDescription& _internal_functions(int index) const;
  ::CoreML::Specification::FunctionDescription* _internal_add_functions();
  public:
  const ::CoreML::Specification::FunctionDescription& functions(int index) const;
  ::CoreML::Specification::FunctionDescription* add_functions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FunctionDescription >&
      functions() const;

  // repeated .CoreML.Specification.FeatureDescription trainingInput = 50;
  int traininginput_size() const;
  private:
  int _internal_traininginput_size() const;
  public:
  void clear_traininginput();
  ::CoreML::Specification::FeatureDescription* mutable_traininginput(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
      mutable_traininginput();
  private:
  const ::CoreML::Specification::FeatureDescription& _internal_traininginput(int index) const;
  ::CoreML::Specification::FeatureDescription* _internal_add_traininginput();
  public:
  const ::CoreML::Specification::FeatureDescription& traininginput(int index) const;
  ::CoreML::Specification::FeatureDescription* add_traininginput();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
      traininginput() const;

  // string predictedFeatureName = 11;
  void clear_predictedfeaturename();
  const std::string& predictedfeaturename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_predictedfeaturename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_predictedfeaturename();
  PROTOBUF_NODISCARD std::string* release_predictedfeaturename();
  void set_allocated_predictedfeaturename(std::string* predictedfeaturename);
  private:
  const std::string& _internal_predictedfeaturename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_predictedfeaturename(const std::string& value);
  std::string* _internal_mutable_predictedfeaturename();
  public:

  // string predictedProbabilitiesName = 12;
  void clear_predictedprobabilitiesname();
  const std::string& predictedprobabilitiesname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_predictedprobabilitiesname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_predictedprobabilitiesname();
  PROTOBUF_NODISCARD std::string* release_predictedprobabilitiesname();
  void set_allocated_predictedprobabilitiesname(std::string* predictedprobabilitiesname);
  private:
  const std::string& _internal_predictedprobabilitiesname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_predictedprobabilitiesname(const std::string& value);
  std::string* _internal_mutable_predictedprobabilitiesname();
  public:

  // string defaultFunctionName = 21;
  void clear_defaultfunctionname();
  const std::string& defaultfunctionname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_defaultfunctionname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_defaultfunctionname();
  PROTOBUF_NODISCARD std::string* release_defaultfunctionname();
  void set_allocated_defaultfunctionname(std::string* defaultfunctionname);
  private:
  const std::string& _internal_defaultfunctionname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_defaultfunctionname(const std::string& value);
  std::string* _internal_mutable_defaultfunctionname();
  public:

  // .CoreML.Specification.Metadata metadata = 100;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::CoreML::Specification::Metadata& metadata() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::Metadata* release_metadata();
  ::CoreML::Specification::Metadata* mutable_metadata();
  void set_allocated_metadata(::CoreML::Specification::Metadata* metadata);
  private:
  const ::CoreML::Specification::Metadata& _internal_metadata() const;
  ::CoreML::Specification::Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::CoreML::Specification::Metadata* metadata);
  ::CoreML::Specification::Metadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ModelDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription > input_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription > output_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription > state_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FunctionDescription > functions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription > traininginput_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr predictedfeaturename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr predictedprobabilitiesname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr defaultfunctionname_;
  ::CoreML::Specification::Metadata* metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Model_2eproto;
};
// -------------------------------------------------------------------

class SerializedModel final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.SerializedModel) */ {
 public:
  inline SerializedModel() : SerializedModel(nullptr) {}
  ~SerializedModel() override;
  explicit constexpr SerializedModel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SerializedModel(const SerializedModel& from);
  SerializedModel(SerializedModel&& from) noexcept
    : SerializedModel() {
    *this = ::std::move(from);
  }

  inline SerializedModel& operator=(const SerializedModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline SerializedModel& operator=(SerializedModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SerializedModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const SerializedModel* internal_default_instance() {
    return reinterpret_cast<const SerializedModel*>(
               &_SerializedModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SerializedModel& a, SerializedModel& b) {
    a.Swap(&b);
  }
  inline void Swap(SerializedModel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SerializedModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SerializedModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SerializedModel>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SerializedModel& from);
  void MergeFrom(const SerializedModel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SerializedModel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.SerializedModel";
  }
  protected:
  explicit SerializedModel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
    kModelFieldNumber = 2,
  };
  // string identifier = 1;
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // bytes model = 2;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.SerializedModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Model_2eproto;
};
// -------------------------------------------------------------------

class Model final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  ~Model() override;
  explicit constexpr Model(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Model& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kPipelineClassifier = 200,
    kPipelineRegressor = 201,
    kPipeline = 202,
    kGlmRegressor = 300,
    kSupportVectorRegressor = 301,
    kTreeEnsembleRegressor = 302,
    kNeuralNetworkRegressor = 303,
    kBayesianProbitRegressor = 304,
    kGlmClassifier = 400,
    kSupportVectorClassifier = 401,
    kTreeEnsembleClassifier = 402,
    kNeuralNetworkClassifier = 403,
    kKNearestNeighborsClassifier = 404,
    kNeuralNetwork = 500,
    kItemSimilarityRecommender = 501,
    kMlProgram = 502,
    kCustomModel = 555,
    kLinkedModel = 556,
    kClassConfidenceThresholding = 560,
    kOneHotEncoder = 600,
    kImputer = 601,
    kFeatureVectorizer = 602,
    kDictVectorizer = 603,
    kScaler = 604,
    kCategoricalMapping = 606,
    kNormalizer = 607,
    kArrayFeatureExtractor = 609,
    kNonMaximumSuppression = 610,
    kIdentity = 900,
    kTextClassifier = 2000,
    kWordTagger = 2001,
    kVisionFeaturePrint = 2002,
    kSoundAnalysisPreprocessing = 2003,
    kGazetteer = 2004,
    kWordEmbedding = 2005,
    kAudioFeaturePrint = 2006,
    kSerializedModel = 3000,
    TYPE_NOT_SET = 0,
  };

  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Model* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.Model";
  }
  protected:
  explicit Model(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 2,
    kSpecificationVersionFieldNumber = 1,
    kIsUpdatableFieldNumber = 10,
    kPipelineClassifierFieldNumber = 200,
    kPipelineRegressorFieldNumber = 201,
    kPipelineFieldNumber = 202,
    kGlmRegressorFieldNumber = 300,
    kSupportVectorRegressorFieldNumber = 301,
    kTreeEnsembleRegressorFieldNumber = 302,
    kNeuralNetworkRegressorFieldNumber = 303,
    kBayesianProbitRegressorFieldNumber = 304,
    kGlmClassifierFieldNumber = 400,
    kSupportVectorClassifierFieldNumber = 401,
    kTreeEnsembleClassifierFieldNumber = 402,
    kNeuralNetworkClassifierFieldNumber = 403,
    kKNearestNeighborsClassifierFieldNumber = 404,
    kNeuralNetworkFieldNumber = 500,
    kItemSimilarityRecommenderFieldNumber = 501,
    kMlProgramFieldNumber = 502,
    kCustomModelFieldNumber = 555,
    kLinkedModelFieldNumber = 556,
    kClassConfidenceThresholdingFieldNumber = 560,
    kOneHotEncoderFieldNumber = 600,
    kImputerFieldNumber = 601,
    kFeatureVectorizerFieldNumber = 602,
    kDictVectorizerFieldNumber = 603,
    kScalerFieldNumber = 604,
    kCategoricalMappingFieldNumber = 606,
    kNormalizerFieldNumber = 607,
    kArrayFeatureExtractorFieldNumber = 609,
    kNonMaximumSuppressionFieldNumber = 610,
    kIdentityFieldNumber = 900,
    kTextClassifierFieldNumber = 2000,
    kWordTaggerFieldNumber = 2001,
    kVisionFeaturePrintFieldNumber = 2002,
    kSoundAnalysisPreprocessingFieldNumber = 2003,
    kGazetteerFieldNumber = 2004,
    kWordEmbeddingFieldNumber = 2005,
    kAudioFeaturePrintFieldNumber = 2006,
    kSerializedModelFieldNumber = 3000,
  };
  // .CoreML.Specification.ModelDescription description = 2;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const ::CoreML::Specification::ModelDescription& description() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::ModelDescription* release_description();
  ::CoreML::Specification::ModelDescription* mutable_description();
  void set_allocated_description(::CoreML::Specification::ModelDescription* description);
  private:
  const ::CoreML::Specification::ModelDescription& _internal_description() const;
  ::CoreML::Specification::ModelDescription* _internal_mutable_description();
  public:
  void unsafe_arena_set_allocated_description(
      ::CoreML::Specification::ModelDescription* description);
  ::CoreML::Specification::ModelDescription* unsafe_arena_release_description();

  // int32 specificationVersion = 1;
  void clear_specificationversion();
  int32_t specificationversion() const;
  void set_specificationversion(int32_t value);
  private:
  int32_t _internal_specificationversion() const;
  void _internal_set_specificationversion(int32_t value);
  public:

  // bool isUpdatable = 10;
  void clear_isupdatable();
  bool isupdatable() const;
  void set_isupdatable(bool value);
  private:
  bool _internal_isupdatable() const;
  void _internal_set_isupdatable(bool value);
  public:

  // .CoreML.Specification.PipelineClassifier pipelineClassifier = 200;
  bool has_pipelineclassifier() const;
  private:
  bool _internal_has_pipelineclassifier() const;
  public:
  void clear_pipelineclassifier();
  const ::CoreML::Specification::PipelineClassifier& pipelineclassifier() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::PipelineClassifier* release_pipelineclassifier();
  ::CoreML::Specification::PipelineClassifier* mutable_pipelineclassifier();
  void set_allocated_pipelineclassifier(::CoreML::Specification::PipelineClassifier* pipelineclassifier);
  private:
  const ::CoreML::Specification::PipelineClassifier& _internal_pipelineclassifier() const;
  ::CoreML::Specification::PipelineClassifier* _internal_mutable_pipelineclassifier();
  public:
  void unsafe_arena_set_allocated_pipelineclassifier(
      ::CoreML::Specification::PipelineClassifier* pipelineclassifier);
  ::CoreML::Specification::PipelineClassifier* unsafe_arena_release_pipelineclassifier();

  // .CoreML.Specification.PipelineRegressor pipelineRegressor = 201;
  bool has_pipelineregressor() const;
  private:
  bool _internal_has_pipelineregressor() const;
  public:
  void clear_pipelineregressor();
  const ::CoreML::Specification::PipelineRegressor& pipelineregressor() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::PipelineRegressor* release_pipelineregressor();
  ::CoreML::Specification::PipelineRegressor* mutable_pipelineregressor();
  void set_allocated_pipelineregressor(::CoreML::Specification::PipelineRegressor* pipelineregressor);
  private:
  const ::CoreML::Specification::PipelineRegressor& _internal_pipelineregressor() const;
  ::CoreML::Specification::PipelineRegressor* _internal_mutable_pipelineregressor();
  public:
  void unsafe_arena_set_allocated_pipelineregressor(
      ::CoreML::Specification::PipelineRegressor* pipelineregressor);
  ::CoreML::Specification::PipelineRegressor* unsafe_arena_release_pipelineregressor();

  // .CoreML.Specification.Pipeline pipeline = 202;
  bool has_pipeline() const;
  private:
  bool _internal_has_pipeline() const;
  public:
  void clear_pipeline();
  const ::CoreML::Specification::Pipeline& pipeline() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::Pipeline* release_pipeline();
  ::CoreML::Specification::Pipeline* mutable_pipeline();
  void set_allocated_pipeline(::CoreML::Specification::Pipeline* pipeline);
  private:
  const ::CoreML::Specification::Pipeline& _internal_pipeline() const;
  ::CoreML::Specification::Pipeline* _internal_mutable_pipeline();
  public:
  void unsafe_arena_set_allocated_pipeline(
      ::CoreML::Specification::Pipeline* pipeline);
  ::CoreML::Specification::Pipeline* unsafe_arena_release_pipeline();

  // .CoreML.Specification.GLMRegressor glmRegressor = 300;
  bool has_glmregressor() const;
  private:
  bool _internal_has_glmregressor() const;
  public:
  void clear_glmregressor();
  const ::CoreML::Specification::GLMRegressor& glmregressor() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::GLMRegressor* release_glmregressor();
  ::CoreML::Specification::GLMRegressor* mutable_glmregressor();
  void set_allocated_glmregressor(::CoreML::Specification::GLMRegressor* glmregressor);
  private:
  const ::CoreML::Specification::GLMRegressor& _internal_glmregressor() const;
  ::CoreML::Specification::GLMRegressor* _internal_mutable_glmregressor();
  public:
  void unsafe_arena_set_allocated_glmregressor(
      ::CoreML::Specification::GLMRegressor* glmregressor);
  ::CoreML::Specification::GLMRegressor* unsafe_arena_release_glmregressor();

  // .CoreML.Specification.SupportVectorRegressor supportVectorRegressor = 301;
  bool has_supportvectorregressor() const;
  private:
  bool _internal_has_supportvectorregressor() const;
  public:
  void clear_supportvectorregressor();
  const ::CoreML::Specification::SupportVectorRegressor& supportvectorregressor() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::SupportVectorRegressor* release_supportvectorregressor();
  ::CoreML::Specification::SupportVectorRegressor* mutable_supportvectorregressor();
  void set_allocated_supportvectorregressor(::CoreML::Specification::SupportVectorRegressor* supportvectorregressor);
  private:
  const ::CoreML::Specification::SupportVectorRegressor& _internal_supportvectorregressor() const;
  ::CoreML::Specification::SupportVectorRegressor* _internal_mutable_supportvectorregressor();
  public:
  void unsafe_arena_set_allocated_supportvectorregressor(
      ::CoreML::Specification::SupportVectorRegressor* supportvectorregressor);
  ::CoreML::Specification::SupportVectorRegressor* unsafe_arena_release_supportvectorregressor();

  // .CoreML.Specification.TreeEnsembleRegressor treeEnsembleRegressor = 302;
  bool has_treeensembleregressor() const;
  private:
  bool _internal_has_treeensembleregressor() const;
  public:
  void clear_treeensembleregressor();
  const ::CoreML::Specification::TreeEnsembleRegressor& treeensembleregressor() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::TreeEnsembleRegressor* release_treeensembleregressor();
  ::CoreML::Specification::TreeEnsembleRegressor* mutable_treeensembleregressor();
  void set_allocated_treeensembleregressor(::CoreML::Specification::TreeEnsembleRegressor* treeensembleregressor);
  private:
  const ::CoreML::Specification::TreeEnsembleRegressor& _internal_treeensembleregressor() const;
  ::CoreML::Specification::TreeEnsembleRegressor* _internal_mutable_treeensembleregressor();
  public:
  void unsafe_arena_set_allocated_treeensembleregressor(
      ::CoreML::Specification::TreeEnsembleRegressor* treeensembleregressor);
  ::CoreML::Specification::TreeEnsembleRegressor* unsafe_arena_release_treeensembleregressor();

  // .CoreML.Specification.NeuralNetworkRegressor neuralNetworkRegressor = 303;
  bool has_neuralnetworkregressor() const;
  private:
  bool _internal_has_neuralnetworkregressor() const;
  public:
  void clear_neuralnetworkregressor();
  const ::CoreML::Specification::NeuralNetworkRegressor& neuralnetworkregressor() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::NeuralNetworkRegressor* release_neuralnetworkregressor();
  ::CoreML::Specification::NeuralNetworkRegressor* mutable_neuralnetworkregressor();
  void set_allocated_neuralnetworkregressor(::CoreML::Specification::NeuralNetworkRegressor* neuralnetworkregressor);
  private:
  const ::CoreML::Specification::NeuralNetworkRegressor& _internal_neuralnetworkregressor() const;
  ::CoreML::Specification::NeuralNetworkRegressor* _internal_mutable_neuralnetworkregressor();
  public:
  void unsafe_arena_set_allocated_neuralnetworkregressor(
      ::CoreML::Specification::NeuralNetworkRegressor* neuralnetworkregressor);
  ::CoreML::Specification::NeuralNetworkRegressor* unsafe_arena_release_neuralnetworkregressor();

  // .CoreML.Specification.BayesianProbitRegressor bayesianProbitRegressor = 304;
  bool has_bayesianprobitregressor() const;
  private:
  bool _internal_has_bayesianprobitregressor() const;
  public:
  void clear_bayesianprobitregressor();
  const ::CoreML::Specification::BayesianProbitRegressor& bayesianprobitregressor() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::BayesianProbitRegressor* release_bayesianprobitregressor();
  ::CoreML::Specification::BayesianProbitRegressor* mutable_bayesianprobitregressor();
  void set_allocated_bayesianprobitregressor(::CoreML::Specification::BayesianProbitRegressor* bayesianprobitregressor);
  private:
  const ::CoreML::Specification::BayesianProbitRegressor& _internal_bayesianprobitregressor() const;
  ::CoreML::Specification::BayesianProbitRegressor* _internal_mutable_bayesianprobitregressor();
  public:
  void unsafe_arena_set_allocated_bayesianprobitregressor(
      ::CoreML::Specification::BayesianProbitRegressor* bayesianprobitregressor);
  ::CoreML::Specification::BayesianProbitRegressor* unsafe_arena_release_bayesianprobitregressor();

  // .CoreML.Specification.GLMClassifier glmClassifier = 400;
  bool has_glmclassifier() const;
  private:
  bool _internal_has_glmclassifier() const;
  public:
  void clear_glmclassifier();
  const ::CoreML::Specification::GLMClassifier& glmclassifier() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::GLMClassifier* release_glmclassifier();
  ::CoreML::Specification::GLMClassifier* mutable_glmclassifier();
  void set_allocated_glmclassifier(::CoreML::Specification::GLMClassifier* glmclassifier);
  private:
  const ::CoreML::Specification::GLMClassifier& _internal_glmclassifier() const;
  ::CoreML::Specification::GLMClassifier* _internal_mutable_glmclassifier();
  public:
  void unsafe_arena_set_allocated_glmclassifier(
      ::CoreML::Specification::GLMClassifier* glmclassifier);
  ::CoreML::Specification::GLMClassifier* unsafe_arena_release_glmclassifier();

  // .CoreML.Specification.SupportVectorClassifier supportVectorClassifier = 401;
  bool has_supportvectorclassifier() const;
  private:
  bool _internal_has_supportvectorclassifier() const;
  public:
  void clear_supportvectorclassifier();
  const ::CoreML::Specification::SupportVectorClassifier& supportvectorclassifier() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::SupportVectorClassifier* release_supportvectorclassifier();
  ::CoreML::Specification::SupportVectorClassifier* mutable_supportvectorclassifier();
  void set_allocated_supportvectorclassifier(::CoreML::Specification::SupportVectorClassifier* supportvectorclassifier);
  private:
  const ::CoreML::Specification::SupportVectorClassifier& _internal_supportvectorclassifier() const;
  ::CoreML::Specification::SupportVectorClassifier* _internal_mutable_supportvectorclassifier();
  public:
  void unsafe_arena_set_allocated_supportvectorclassifier(
      ::CoreML::Specification::SupportVectorClassifier* supportvectorclassifier);
  ::CoreML::Specification::SupportVectorClassifier* unsafe_arena_release_supportvectorclassifier();

  // .CoreML.Specification.TreeEnsembleClassifier treeEnsembleClassifier = 402;
  bool has_treeensembleclassifier() const;
  private:
  bool _internal_has_treeensembleclassifier() const;
  public:
  void clear_treeensembleclassifier();
  const ::CoreML::Specification::TreeEnsembleClassifier& treeensembleclassifier() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::TreeEnsembleClassifier* release_treeensembleclassifier();
  ::CoreML::Specification::TreeEnsembleClassifier* mutable_treeensembleclassifier();
  void set_allocated_treeensembleclassifier(::CoreML::Specification::TreeEnsembleClassifier* treeensembleclassifier);
  private:
  const ::CoreML::Specification::TreeEnsembleClassifier& _internal_treeensembleclassifier() const;
  ::CoreML::Specification::TreeEnsembleClassifier* _internal_mutable_treeensembleclassifier();
  public:
  void unsafe_arena_set_allocated_treeensembleclassifier(
      ::CoreML::Specification::TreeEnsembleClassifier* treeensembleclassifier);
  ::CoreML::Specification::TreeEnsembleClassifier* unsafe_arena_release_treeensembleclassifier();

  // .CoreML.Specification.NeuralNetworkClassifier neuralNetworkClassifier = 403;
  bool has_neuralnetworkclassifier() const;
  private:
  bool _internal_has_neuralnetworkclassifier() const;
  public:
  void clear_neuralnetworkclassifier();
  const ::CoreML::Specification::NeuralNetworkClassifier& neuralnetworkclassifier() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::NeuralNetworkClassifier* release_neuralnetworkclassifier();
  ::CoreML::Specification::NeuralNetworkClassifier* mutable_neuralnetworkclassifier();
  void set_allocated_neuralnetworkclassifier(::CoreML::Specification::NeuralNetworkClassifier* neuralnetworkclassifier);
  private:
  const ::CoreML::Specification::NeuralNetworkClassifier& _internal_neuralnetworkclassifier() const;
  ::CoreML::Specification::NeuralNetworkClassifier* _internal_mutable_neuralnetworkclassifier();
  public:
  void unsafe_arena_set_allocated_neuralnetworkclassifier(
      ::CoreML::Specification::NeuralNetworkClassifier* neuralnetworkclassifier);
  ::CoreML::Specification::NeuralNetworkClassifier* unsafe_arena_release_neuralnetworkclassifier();

  // .CoreML.Specification.KNearestNeighborsClassifier kNearestNeighborsClassifier = 404;
  bool has_knearestneighborsclassifier() const;
  private:
  bool _internal_has_knearestneighborsclassifier() const;
  public:
  void clear_knearestneighborsclassifier();
  const ::CoreML::Specification::KNearestNeighborsClassifier& knearestneighborsclassifier() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::KNearestNeighborsClassifier* release_knearestneighborsclassifier();
  ::CoreML::Specification::KNearestNeighborsClassifier* mutable_knearestneighborsclassifier();
  void set_allocated_knearestneighborsclassifier(::CoreML::Specification::KNearestNeighborsClassifier* knearestneighborsclassifier);
  private:
  const ::CoreML::Specification::KNearestNeighborsClassifier& _internal_knearestneighborsclassifier() const;
  ::CoreML::Specification::KNearestNeighborsClassifier* _internal_mutable_knearestneighborsclassifier();
  public:
  void unsafe_arena_set_allocated_knearestneighborsclassifier(
      ::CoreML::Specification::KNearestNeighborsClassifier* knearestneighborsclassifier);
  ::CoreML::Specification::KNearestNeighborsClassifier* unsafe_arena_release_knearestneighborsclassifier();

  // .CoreML.Specification.NeuralNetwork neuralNetwork = 500;
  bool has_neuralnetwork() const;
  private:
  bool _internal_has_neuralnetwork() const;
  public:
  void clear_neuralnetwork();
  const ::CoreML::Specification::NeuralNetwork& neuralnetwork() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::NeuralNetwork* release_neuralnetwork();
  ::CoreML::Specification::NeuralNetwork* mutable_neuralnetwork();
  void set_allocated_neuralnetwork(::CoreML::Specification::NeuralNetwork* neuralnetwork);
  private:
  const ::CoreML::Specification::NeuralNetwork& _internal_neuralnetwork() const;
  ::CoreML::Specification::NeuralNetwork* _internal_mutable_neuralnetwork();
  public:
  void unsafe_arena_set_allocated_neuralnetwork(
      ::CoreML::Specification::NeuralNetwork* neuralnetwork);
  ::CoreML::Specification::NeuralNetwork* unsafe_arena_release_neuralnetwork();

  // .CoreML.Specification.ItemSimilarityRecommender itemSimilarityRecommender = 501;
  bool has_itemsimilarityrecommender() const;
  private:
  bool _internal_has_itemsimilarityrecommender() const;
  public:
  void clear_itemsimilarityrecommender();
  const ::CoreML::Specification::ItemSimilarityRecommender& itemsimilarityrecommender() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::ItemSimilarityRecommender* release_itemsimilarityrecommender();
  ::CoreML::Specification::ItemSimilarityRecommender* mutable_itemsimilarityrecommender();
  void set_allocated_itemsimilarityrecommender(::CoreML::Specification::ItemSimilarityRecommender* itemsimilarityrecommender);
  private:
  const ::CoreML::Specification::ItemSimilarityRecommender& _internal_itemsimilarityrecommender() const;
  ::CoreML::Specification::ItemSimilarityRecommender* _internal_mutable_itemsimilarityrecommender();
  public:
  void unsafe_arena_set_allocated_itemsimilarityrecommender(
      ::CoreML::Specification::ItemSimilarityRecommender* itemsimilarityrecommender);
  ::CoreML::Specification::ItemSimilarityRecommender* unsafe_arena_release_itemsimilarityrecommender();

  // .CoreML.Specification.MILSpec.Program mlProgram = 502;
  bool has_mlprogram() const;
  private:
  bool _internal_has_mlprogram() const;
  public:
  void clear_mlprogram();
  const ::CoreML::Specification::MILSpec::Program& mlprogram() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::Program* release_mlprogram();
  ::CoreML::Specification::MILSpec::Program* mutable_mlprogram();
  void set_allocated_mlprogram(::CoreML::Specification::MILSpec::Program* mlprogram);
  private:
  const ::CoreML::Specification::MILSpec::Program& _internal_mlprogram() const;
  ::CoreML::Specification::MILSpec::Program* _internal_mutable_mlprogram();
  public:
  void unsafe_arena_set_allocated_mlprogram(
      ::CoreML::Specification::MILSpec::Program* mlprogram);
  ::CoreML::Specification::MILSpec::Program* unsafe_arena_release_mlprogram();

  // .CoreML.Specification.CustomModel customModel = 555;
  bool has_custommodel() const;
  private:
  bool _internal_has_custommodel() const;
  public:
  void clear_custommodel();
  const ::CoreML::Specification::CustomModel& custommodel() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::CustomModel* release_custommodel();
  ::CoreML::Specification::CustomModel* mutable_custommodel();
  void set_allocated_custommodel(::CoreML::Specification::CustomModel* custommodel);
  private:
  const ::CoreML::Specification::CustomModel& _internal_custommodel() const;
  ::CoreML::Specification::CustomModel* _internal_mutable_custommodel();
  public:
  void unsafe_arena_set_allocated_custommodel(
      ::CoreML::Specification::CustomModel* custommodel);
  ::CoreML::Specification::CustomModel* unsafe_arena_release_custommodel();

  // .CoreML.Specification.LinkedModel linkedModel = 556;
  bool has_linkedmodel() const;
  private:
  bool _internal_has_linkedmodel() const;
  public:
  void clear_linkedmodel();
  const ::CoreML::Specification::LinkedModel& linkedmodel() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::LinkedModel* release_linkedmodel();
  ::CoreML::Specification::LinkedModel* mutable_linkedmodel();
  void set_allocated_linkedmodel(::CoreML::Specification::LinkedModel* linkedmodel);
  private:
  const ::CoreML::Specification::LinkedModel& _internal_linkedmodel() const;
  ::CoreML::Specification::LinkedModel* _internal_mutable_linkedmodel();
  public:
  void unsafe_arena_set_allocated_linkedmodel(
      ::CoreML::Specification::LinkedModel* linkedmodel);
  ::CoreML::Specification::LinkedModel* unsafe_arena_release_linkedmodel();

  // .CoreML.Specification.ClassConfidenceThresholding classConfidenceThresholding = 560;
  bool has_classconfidencethresholding() const;
  private:
  bool _internal_has_classconfidencethresholding() const;
  public:
  void clear_classconfidencethresholding();
  const ::CoreML::Specification::ClassConfidenceThresholding& classconfidencethresholding() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::ClassConfidenceThresholding* release_classconfidencethresholding();
  ::CoreML::Specification::ClassConfidenceThresholding* mutable_classconfidencethresholding();
  void set_allocated_classconfidencethresholding(::CoreML::Specification::ClassConfidenceThresholding* classconfidencethresholding);
  private:
  const ::CoreML::Specification::ClassConfidenceThresholding& _internal_classconfidencethresholding() const;
  ::CoreML::Specification::ClassConfidenceThresholding* _internal_mutable_classconfidencethresholding();
  public:
  void unsafe_arena_set_allocated_classconfidencethresholding(
      ::CoreML::Specification::ClassConfidenceThresholding* classconfidencethresholding);
  ::CoreML::Specification::ClassConfidenceThresholding* unsafe_arena_release_classconfidencethresholding();

  // .CoreML.Specification.OneHotEncoder oneHotEncoder = 600;
  bool has_onehotencoder() const;
  private:
  bool _internal_has_onehotencoder() const;
  public:
  void clear_onehotencoder();
  const ::CoreML::Specification::OneHotEncoder& onehotencoder() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::OneHotEncoder* release_onehotencoder();
  ::CoreML::Specification::OneHotEncoder* mutable_onehotencoder();
  void set_allocated_onehotencoder(::CoreML::Specification::OneHotEncoder* onehotencoder);
  private:
  const ::CoreML::Specification::OneHotEncoder& _internal_onehotencoder() const;
  ::CoreML::Specification::OneHotEncoder* _internal_mutable_onehotencoder();
  public:
  void unsafe_arena_set_allocated_onehotencoder(
      ::CoreML::Specification::OneHotEncoder* onehotencoder);
  ::CoreML::Specification::OneHotEncoder* unsafe_arena_release_onehotencoder();

  // .CoreML.Specification.Imputer imputer = 601;
  bool has_imputer() const;
  private:
  bool _internal_has_imputer() const;
  public:
  void clear_imputer();
  const ::CoreML::Specification::Imputer& imputer() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::Imputer* release_imputer();
  ::CoreML::Specification::Imputer* mutable_imputer();
  void set_allocated_imputer(::CoreML::Specification::Imputer* imputer);
  private:
  const ::CoreML::Specification::Imputer& _internal_imputer() const;
  ::CoreML::Specification::Imputer* _internal_mutable_imputer();
  public:
  void unsafe_arena_set_allocated_imputer(
      ::CoreML::Specification::Imputer* imputer);
  ::CoreML::Specification::Imputer* unsafe_arena_release_imputer();

  // .CoreML.Specification.FeatureVectorizer featureVectorizer = 602;
  bool has_featurevectorizer() const;
  private:
  bool _internal_has_featurevectorizer() const;
  public:
  void clear_featurevectorizer();
  const ::CoreML::Specification::FeatureVectorizer& featurevectorizer() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::FeatureVectorizer* release_featurevectorizer();
  ::CoreML::Specification::FeatureVectorizer* mutable_featurevectorizer();
  void set_allocated_featurevectorizer(::CoreML::Specification::FeatureVectorizer* featurevectorizer);
  private:
  const ::CoreML::Specification::FeatureVectorizer& _internal_featurevectorizer() const;
  ::CoreML::Specification::FeatureVectorizer* _internal_mutable_featurevectorizer();
  public:
  void unsafe_arena_set_allocated_featurevectorizer(
      ::CoreML::Specification::FeatureVectorizer* featurevectorizer);
  ::CoreML::Specification::FeatureVectorizer* unsafe_arena_release_featurevectorizer();

  // .CoreML.Specification.DictVectorizer dictVectorizer = 603;
  bool has_dictvectorizer() const;
  private:
  bool _internal_has_dictvectorizer() const;
  public:
  void clear_dictvectorizer();
  const ::CoreML::Specification::DictVectorizer& dictvectorizer() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::DictVectorizer* release_dictvectorizer();
  ::CoreML::Specification::DictVectorizer* mutable_dictvectorizer();
  void set_allocated_dictvectorizer(::CoreML::Specification::DictVectorizer* dictvectorizer);
  private:
  const ::CoreML::Specification::DictVectorizer& _internal_dictvectorizer() const;
  ::CoreML::Specification::DictVectorizer* _internal_mutable_dictvectorizer();
  public:
  void unsafe_arena_set_allocated_dictvectorizer(
      ::CoreML::Specification::DictVectorizer* dictvectorizer);
  ::CoreML::Specification::DictVectorizer* unsafe_arena_release_dictvectorizer();

  // .CoreML.Specification.Scaler scaler = 604;
  bool has_scaler() const;
  private:
  bool _internal_has_scaler() const;
  public:
  void clear_scaler();
  const ::CoreML::Specification::Scaler& scaler() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::Scaler* release_scaler();
  ::CoreML::Specification::Scaler* mutable_scaler();
  void set_allocated_scaler(::CoreML::Specification::Scaler* scaler);
  private:
  const ::CoreML::Specification::Scaler& _internal_scaler() const;
  ::CoreML::Specification::Scaler* _internal_mutable_scaler();
  public:
  void unsafe_arena_set_allocated_scaler(
      ::CoreML::Specification::Scaler* scaler);
  ::CoreML::Specification::Scaler* unsafe_arena_release_scaler();

  // .CoreML.Specification.CategoricalMapping categoricalMapping = 606;
  bool has_categoricalmapping() const;
  private:
  bool _internal_has_categoricalmapping() const;
  public:
  void clear_categoricalmapping();
  const ::CoreML::Specification::CategoricalMapping& categoricalmapping() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::CategoricalMapping* release_categoricalmapping();
  ::CoreML::Specification::CategoricalMapping* mutable_categoricalmapping();
  void set_allocated_categoricalmapping(::CoreML::Specification::CategoricalMapping* categoricalmapping);
  private:
  const ::CoreML::Specification::CategoricalMapping& _internal_categoricalmapping() const;
  ::CoreML::Specification::CategoricalMapping* _internal_mutable_categoricalmapping();
  public:
  void unsafe_arena_set_allocated_categoricalmapping(
      ::CoreML::Specification::CategoricalMapping* categoricalmapping);
  ::CoreML::Specification::CategoricalMapping* unsafe_arena_release_categoricalmapping();

  // .CoreML.Specification.Normalizer normalizer = 607;
  bool has_normalizer() const;
  private:
  bool _internal_has_normalizer() const;
  public:
  void clear_normalizer();
  const ::CoreML::Specification::Normalizer& normalizer() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::Normalizer* release_normalizer();
  ::CoreML::Specification::Normalizer* mutable_normalizer();
  void set_allocated_normalizer(::CoreML::Specification::Normalizer* normalizer);
  private:
  const ::CoreML::Specification::Normalizer& _internal_normalizer() const;
  ::CoreML::Specification::Normalizer* _internal_mutable_normalizer();
  public:
  void unsafe_arena_set_allocated_normalizer(
      ::CoreML::Specification::Normalizer* normalizer);
  ::CoreML::Specification::Normalizer* unsafe_arena_release_normalizer();

  // .CoreML.Specification.ArrayFeatureExtractor arrayFeatureExtractor = 609;
  bool has_arrayfeatureextractor() const;
  private:
  bool _internal_has_arrayfeatureextractor() const;
  public:
  void clear_arrayfeatureextractor();
  const ::CoreML::Specification::ArrayFeatureExtractor& arrayfeatureextractor() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::ArrayFeatureExtractor* release_arrayfeatureextractor();
  ::CoreML::Specification::ArrayFeatureExtractor* mutable_arrayfeatureextractor();
  void set_allocated_arrayfeatureextractor(::CoreML::Specification::ArrayFeatureExtractor* arrayfeatureextractor);
  private:
  const ::CoreML::Specification::ArrayFeatureExtractor& _internal_arrayfeatureextractor() const;
  ::CoreML::Specification::ArrayFeatureExtractor* _internal_mutable_arrayfeatureextractor();
  public:
  void unsafe_arena_set_allocated_arrayfeatureextractor(
      ::CoreML::Specification::ArrayFeatureExtractor* arrayfeatureextractor);
  ::CoreML::Specification::ArrayFeatureExtractor* unsafe_arena_release_arrayfeatureextractor();

  // .CoreML.Specification.NonMaximumSuppression nonMaximumSuppression = 610;
  bool has_nonmaximumsuppression() const;
  private:
  bool _internal_has_nonmaximumsuppression() const;
  public:
  void clear_nonmaximumsuppression();
  const ::CoreML::Specification::NonMaximumSuppression& nonmaximumsuppression() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::NonMaximumSuppression* release_nonmaximumsuppression();
  ::CoreML::Specification::NonMaximumSuppression* mutable_nonmaximumsuppression();
  void set_allocated_nonmaximumsuppression(::CoreML::Specification::NonMaximumSuppression* nonmaximumsuppression);
  private:
  const ::CoreML::Specification::NonMaximumSuppression& _internal_nonmaximumsuppression() const;
  ::CoreML::Specification::NonMaximumSuppression* _internal_mutable_nonmaximumsuppression();
  public:
  void unsafe_arena_set_allocated_nonmaximumsuppression(
      ::CoreML::Specification::NonMaximumSuppression* nonmaximumsuppression);
  ::CoreML::Specification::NonMaximumSuppression* unsafe_arena_release_nonmaximumsuppression();

  // .CoreML.Specification.Identity identity = 900;
  bool has_identity() const;
  private:
  bool _internal_has_identity() const;
  public:
  void clear_identity();
  const ::CoreML::Specification::Identity& identity() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::Identity* release_identity();
  ::CoreML::Specification::Identity* mutable_identity();
  void set_allocated_identity(::CoreML::Specification::Identity* identity);
  private:
  const ::CoreML::Specification::Identity& _internal_identity() const;
  ::CoreML::Specification::Identity* _internal_mutable_identity();
  public:
  void unsafe_arena_set_allocated_identity(
      ::CoreML::Specification::Identity* identity);
  ::CoreML::Specification::Identity* unsafe_arena_release_identity();

  // .CoreML.Specification.CoreMLModels.TextClassifier textClassifier = 2000;
  bool has_textclassifier() const;
  private:
  bool _internal_has_textclassifier() const;
  public:
  void clear_textclassifier();
  const ::CoreML::Specification::CoreMLModels::TextClassifier& textclassifier() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::CoreMLModels::TextClassifier* release_textclassifier();
  ::CoreML::Specification::CoreMLModels::TextClassifier* mutable_textclassifier();
  void set_allocated_textclassifier(::CoreML::Specification::CoreMLModels::TextClassifier* textclassifier);
  private:
  const ::CoreML::Specification::CoreMLModels::TextClassifier& _internal_textclassifier() const;
  ::CoreML::Specification::CoreMLModels::TextClassifier* _internal_mutable_textclassifier();
  public:
  void unsafe_arena_set_allocated_textclassifier(
      ::CoreML::Specification::CoreMLModels::TextClassifier* textclassifier);
  ::CoreML::Specification::CoreMLModels::TextClassifier* unsafe_arena_release_textclassifier();

  // .CoreML.Specification.CoreMLModels.WordTagger wordTagger = 2001;
  bool has_wordtagger() const;
  private:
  bool _internal_has_wordtagger() const;
  public:
  void clear_wordtagger();
  const ::CoreML::Specification::CoreMLModels::WordTagger& wordtagger() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::CoreMLModels::WordTagger* release_wordtagger();
  ::CoreML::Specification::CoreMLModels::WordTagger* mutable_wordtagger();
  void set_allocated_wordtagger(::CoreML::Specification::CoreMLModels::WordTagger* wordtagger);
  private:
  const ::CoreML::Specification::CoreMLModels::WordTagger& _internal_wordtagger() const;
  ::CoreML::Specification::CoreMLModels::WordTagger* _internal_mutable_wordtagger();
  public:
  void unsafe_arena_set_allocated_wordtagger(
      ::CoreML::Specification::CoreMLModels::WordTagger* wordtagger);
  ::CoreML::Specification::CoreMLModels::WordTagger* unsafe_arena_release_wordtagger();

  // .CoreML.Specification.CoreMLModels.VisionFeaturePrint visionFeaturePrint = 2002;
  bool has_visionfeatureprint() const;
  private:
  bool _internal_has_visionfeatureprint() const;
  public:
  void clear_visionfeatureprint();
  const ::CoreML::Specification::CoreMLModels::VisionFeaturePrint& visionfeatureprint() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* release_visionfeatureprint();
  ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* mutable_visionfeatureprint();
  void set_allocated_visionfeatureprint(::CoreML::Specification::CoreMLModels::VisionFeaturePrint* visionfeatureprint);
  private:
  const ::CoreML::Specification::CoreMLModels::VisionFeaturePrint& _internal_visionfeatureprint() const;
  ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* _internal_mutable_visionfeatureprint();
  public:
  void unsafe_arena_set_allocated_visionfeatureprint(
      ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* visionfeatureprint);
  ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* unsafe_arena_release_visionfeatureprint();

  // .CoreML.Specification.CoreMLModels.SoundAnalysisPreprocessing soundAnalysisPreprocessing = 2003;
  bool has_soundanalysispreprocessing() const;
  private:
  bool _internal_has_soundanalysispreprocessing() const;
  public:
  void clear_soundanalysispreprocessing();
  const ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing& soundanalysispreprocessing() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing* release_soundanalysispreprocessing();
  ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing* mutable_soundanalysispreprocessing();
  void set_allocated_soundanalysispreprocessing(::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing* soundanalysispreprocessing);
  private:
  const ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing& _internal_soundanalysispreprocessing() const;
  ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing* _internal_mutable_soundanalysispreprocessing();
  public:
  void unsafe_arena_set_allocated_soundanalysispreprocessing(
      ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing* soundanalysispreprocessing);
  ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing* unsafe_arena_release_soundanalysispreprocessing();

  // .CoreML.Specification.CoreMLModels.Gazetteer gazetteer = 2004;
  bool has_gazetteer() const;
  private:
  bool _internal_has_gazetteer() const;
  public:
  void clear_gazetteer();
  const ::CoreML::Specification::CoreMLModels::Gazetteer& gazetteer() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::CoreMLModels::Gazetteer* release_gazetteer();
  ::CoreML::Specification::CoreMLModels::Gazetteer* mutable_gazetteer();
  void set_allocated_gazetteer(::CoreML::Specification::CoreMLModels::Gazetteer* gazetteer);
  private:
  const ::CoreML::Specification::CoreMLModels::Gazetteer& _internal_gazetteer() const;
  ::CoreML::Specification::CoreMLModels::Gazetteer* _internal_mutable_gazetteer();
  public:
  void unsafe_arena_set_allocated_gazetteer(
      ::CoreML::Specification::CoreMLModels::Gazetteer* gazetteer);
  ::CoreML::Specification::CoreMLModels::Gazetteer* unsafe_arena_release_gazetteer();

  // .CoreML.Specification.CoreMLModels.WordEmbedding wordEmbedding = 2005;
  bool has_wordembedding() const;
  private:
  bool _internal_has_wordembedding() const;
  public:
  void clear_wordembedding();
  const ::CoreML::Specification::CoreMLModels::WordEmbedding& wordembedding() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::CoreMLModels::WordEmbedding* release_wordembedding();
  ::CoreML::Specification::CoreMLModels::WordEmbedding* mutable_wordembedding();
  void set_allocated_wordembedding(::CoreML::Specification::CoreMLModels::WordEmbedding* wordembedding);
  private:
  const ::CoreML::Specification::CoreMLModels::WordEmbedding& _internal_wordembedding() const;
  ::CoreML::Specification::CoreMLModels::WordEmbedding* _internal_mutable_wordembedding();
  public:
  void unsafe_arena_set_allocated_wordembedding(
      ::CoreML::Specification::CoreMLModels::WordEmbedding* wordembedding);
  ::CoreML::Specification::CoreMLModels::WordEmbedding* unsafe_arena_release_wordembedding();

  // .CoreML.Specification.CoreMLModels.AudioFeaturePrint audioFeaturePrint = 2006;
  bool has_audiofeatureprint() const;
  private:
  bool _internal_has_audiofeatureprint() const;
  public:
  void clear_audiofeatureprint();
  const ::CoreML::Specification::CoreMLModels::AudioFeaturePrint& audiofeatureprint() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::CoreMLModels::AudioFeaturePrint* release_audiofeatureprint();
  ::CoreML::Specification::CoreMLModels::AudioFeaturePrint* mutable_audiofeatureprint();
  void set_allocated_audiofeatureprint(::CoreML::Specification::CoreMLModels::AudioFeaturePrint* audiofeatureprint);
  private:
  const ::CoreML::Specification::CoreMLModels::AudioFeaturePrint& _internal_audiofeatureprint() const;
  ::CoreML::Specification::CoreMLModels::AudioFeaturePrint* _internal_mutable_audiofeatureprint();
  public:
  void unsafe_arena_set_allocated_audiofeatureprint(
      ::CoreML::Specification::CoreMLModels::AudioFeaturePrint* audiofeatureprint);
  ::CoreML::Specification::CoreMLModels::AudioFeaturePrint* unsafe_arena_release_audiofeatureprint();

  // .CoreML.Specification.SerializedModel serializedModel = 3000;
  bool has_serializedmodel() const;
  private:
  bool _internal_has_serializedmodel() const;
  public:
  void clear_serializedmodel();
  const ::CoreML::Specification::SerializedModel& serializedmodel() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::SerializedModel* release_serializedmodel();
  ::CoreML::Specification::SerializedModel* mutable_serializedmodel();
  void set_allocated_serializedmodel(::CoreML::Specification::SerializedModel* serializedmodel);
  private:
  const ::CoreML::Specification::SerializedModel& _internal_serializedmodel() const;
  ::CoreML::Specification::SerializedModel* _internal_mutable_serializedmodel();
  public:
  void unsafe_arena_set_allocated_serializedmodel(
      ::CoreML::Specification::SerializedModel* serializedmodel);
  ::CoreML::Specification::SerializedModel* unsafe_arena_release_serializedmodel();

  void clear_Type();
  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.Model)
 private:
  class _Internal;
  void set_has_pipelineclassifier();
  void set_has_pipelineregressor();
  void set_has_pipeline();
  void set_has_glmregressor();
  void set_has_supportvectorregressor();
  void set_has_treeensembleregressor();
  void set_has_neuralnetworkregressor();
  void set_has_bayesianprobitregressor();
  void set_has_glmclassifier();
  void set_has_supportvectorclassifier();
  void set_has_treeensembleclassifier();
  void set_has_neuralnetworkclassifier();
  void set_has_knearestneighborsclassifier();
  void set_has_neuralnetwork();
  void set_has_itemsimilarityrecommender();
  void set_has_mlprogram();
  void set_has_custommodel();
  void set_has_linkedmodel();
  void set_has_classconfidencethresholding();
  void set_has_onehotencoder();
  void set_has_imputer();
  void set_has_featurevectorizer();
  void set_has_dictvectorizer();
  void set_has_scaler();
  void set_has_categoricalmapping();
  void set_has_normalizer();
  void set_has_arrayfeatureextractor();
  void set_has_nonmaximumsuppression();
  void set_has_identity();
  void set_has_textclassifier();
  void set_has_wordtagger();
  void set_has_visionfeatureprint();
  void set_has_soundanalysispreprocessing();
  void set_has_gazetteer();
  void set_has_wordembedding();
  void set_has_audiofeatureprint();
  void set_has_serializedmodel();

  inline bool has_Type() const;
  inline void clear_has_Type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::CoreML::Specification::ModelDescription* description_;
  int32_t specificationversion_;
  bool isupdatable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CoreML::Specification::PipelineClassifier* pipelineclassifier_;
    ::CoreML::Specification::PipelineRegressor* pipelineregressor_;
    ::CoreML::Specification::Pipeline* pipeline_;
    ::CoreML::Specification::GLMRegressor* glmregressor_;
    ::CoreML::Specification::SupportVectorRegressor* supportvectorregressor_;
    ::CoreML::Specification::TreeEnsembleRegressor* treeensembleregressor_;
    ::CoreML::Specification::NeuralNetworkRegressor* neuralnetworkregressor_;
    ::CoreML::Specification::BayesianProbitRegressor* bayesianprobitregressor_;
    ::CoreML::Specification::GLMClassifier* glmclassifier_;
    ::CoreML::Specification::SupportVectorClassifier* supportvectorclassifier_;
    ::CoreML::Specification::TreeEnsembleClassifier* treeensembleclassifier_;
    ::CoreML::Specification::NeuralNetworkClassifier* neuralnetworkclassifier_;
    ::CoreML::Specification::KNearestNeighborsClassifier* knearestneighborsclassifier_;
    ::CoreML::Specification::NeuralNetwork* neuralnetwork_;
    ::CoreML::Specification::ItemSimilarityRecommender* itemsimilarityrecommender_;
    ::CoreML::Specification::MILSpec::Program* mlprogram_;
    ::CoreML::Specification::CustomModel* custommodel_;
    ::CoreML::Specification::LinkedModel* linkedmodel_;
    ::CoreML::Specification::ClassConfidenceThresholding* classconfidencethresholding_;
    ::CoreML::Specification::OneHotEncoder* onehotencoder_;
    ::CoreML::Specification::Imputer* imputer_;
    ::CoreML::Specification::FeatureVectorizer* featurevectorizer_;
    ::CoreML::Specification::DictVectorizer* dictvectorizer_;
    ::CoreML::Specification::Scaler* scaler_;
    ::CoreML::Specification::CategoricalMapping* categoricalmapping_;
    ::CoreML::Specification::Normalizer* normalizer_;
    ::CoreML::Specification::ArrayFeatureExtractor* arrayfeatureextractor_;
    ::CoreML::Specification::NonMaximumSuppression* nonmaximumsuppression_;
    ::CoreML::Specification::Identity* identity_;
    ::CoreML::Specification::CoreMLModels::TextClassifier* textclassifier_;
    ::CoreML::Specification::CoreMLModels::WordTagger* wordtagger_;
    ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* visionfeatureprint_;
    ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing* soundanalysispreprocessing_;
    ::CoreML::Specification::CoreMLModels::Gazetteer* gazetteer_;
    ::CoreML::Specification::CoreMLModels::WordEmbedding* wordembedding_;
    ::CoreML::Specification::CoreMLModels::AudioFeaturePrint* audiofeatureprint_;
    ::CoreML::Specification::SerializedModel* serializedmodel_;
  } Type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_Model_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Pipeline

// repeated .CoreML.Specification.Model models = 1;
inline int Pipeline::_internal_models_size() const {
  return models_.size();
}
inline int Pipeline::models_size() const {
  return _internal_models_size();
}
inline void Pipeline::clear_models() {
  models_.Clear();
}
inline ::CoreML::Specification::Model* Pipeline::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Pipeline.models)
  return models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::Model >*
Pipeline::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.Pipeline.models)
  return &models_;
}
inline const ::CoreML::Specification::Model& Pipeline::_internal_models(int index) const {
  return models_.Get(index);
}
inline const ::CoreML::Specification::Model& Pipeline::models(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Pipeline.models)
  return _internal_models(index);
}
inline ::CoreML::Specification::Model* Pipeline::_internal_add_models() {
  return models_.Add();
}
inline ::CoreML::Specification::Model* Pipeline::add_models() {
  ::CoreML::Specification::Model* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:CoreML.Specification.Pipeline.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::Model >&
Pipeline::models() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.Pipeline.models)
  return models_;
}

// repeated string names = 2;
inline int Pipeline::_internal_names_size() const {
  return names_.size();
}
inline int Pipeline::names_size() const {
  return _internal_names_size();
}
inline void Pipeline::clear_names() {
  names_.Clear();
}
inline std::string* Pipeline::add_names() {
  std::string* _s = _internal_add_names();
  // @@protoc_insertion_point(field_add_mutable:CoreML.Specification.Pipeline.names)
  return _s;
}
inline const std::string& Pipeline::_internal_names(int index) const {
  return names_.Get(index);
}
inline const std::string& Pipeline::names(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Pipeline.names)
  return _internal_names(index);
}
inline std::string* Pipeline::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Pipeline.names)
  return names_.Mutable(index);
}
inline void Pipeline::set_names(int index, const std::string& value) {
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Pipeline.names)
}
inline void Pipeline::set_names(int index, std::string&& value) {
  names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:CoreML.Specification.Pipeline.names)
}
inline void Pipeline::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.Pipeline.names)
}
inline void Pipeline::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.Pipeline.names)
}
inline std::string* Pipeline::_internal_add_names() {
  return names_.Add();
}
inline void Pipeline::add_names(const std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.Pipeline.names)
}
inline void Pipeline::add_names(std::string&& value) {
  names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CoreML.Specification.Pipeline.names)
}
inline void Pipeline::add_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CoreML.Specification.Pipeline.names)
}
inline void Pipeline::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CoreML.Specification.Pipeline.names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Pipeline::names() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.Pipeline.names)
  return names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Pipeline::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.Pipeline.names)
  return &names_;
}

// -------------------------------------------------------------------

// PipelineClassifier

// .CoreML.Specification.Pipeline pipeline = 1;
inline bool PipelineClassifier::_internal_has_pipeline() const {
  return this != internal_default_instance() && pipeline_ != nullptr;
}
inline bool PipelineClassifier::has_pipeline() const {
  return _internal_has_pipeline();
}
inline void PipelineClassifier::clear_pipeline() {
  if (GetArenaForAllocation() == nullptr && pipeline_ != nullptr) {
    delete pipeline_;
  }
  pipeline_ = nullptr;
}
inline const ::CoreML::Specification::Pipeline& PipelineClassifier::_internal_pipeline() const {
  const ::CoreML::Specification::Pipeline* p = pipeline_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::Pipeline&>(
      ::CoreML::Specification::_Pipeline_default_instance_);
}
inline const ::CoreML::Specification::Pipeline& PipelineClassifier::pipeline() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PipelineClassifier.pipeline)
  return _internal_pipeline();
}
inline void PipelineClassifier::unsafe_arena_set_allocated_pipeline(
    ::CoreML::Specification::Pipeline* pipeline) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pipeline_);
  }
  pipeline_ = pipeline;
  if (pipeline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.PipelineClassifier.pipeline)
}
inline ::CoreML::Specification::Pipeline* PipelineClassifier::release_pipeline() {
  
  ::CoreML::Specification::Pipeline* temp = pipeline_;
  pipeline_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::Pipeline* PipelineClassifier::unsafe_arena_release_pipeline() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.PipelineClassifier.pipeline)
  
  ::CoreML::Specification::Pipeline* temp = pipeline_;
  pipeline_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::Pipeline* PipelineClassifier::_internal_mutable_pipeline() {
  
  if (pipeline_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::Pipeline>(GetArenaForAllocation());
    pipeline_ = p;
  }
  return pipeline_;
}
inline ::CoreML::Specification::Pipeline* PipelineClassifier::mutable_pipeline() {
  ::CoreML::Specification::Pipeline* _msg = _internal_mutable_pipeline();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.PipelineClassifier.pipeline)
  return _msg;
}
inline void PipelineClassifier::set_allocated_pipeline(::CoreML::Specification::Pipeline* pipeline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pipeline_;
  }
  if (pipeline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::Pipeline>::GetOwningArena(pipeline);
    if (message_arena != submessage_arena) {
      pipeline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pipeline, submessage_arena);
    }
    
  } else {
    
  }
  pipeline_ = pipeline;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PipelineClassifier.pipeline)
}

// -------------------------------------------------------------------

// PipelineRegressor

// .CoreML.Specification.Pipeline pipeline = 1;
inline bool PipelineRegressor::_internal_has_pipeline() const {
  return this != internal_default_instance() && pipeline_ != nullptr;
}
inline bool PipelineRegressor::has_pipeline() const {
  return _internal_has_pipeline();
}
inline void PipelineRegressor::clear_pipeline() {
  if (GetArenaForAllocation() == nullptr && pipeline_ != nullptr) {
    delete pipeline_;
  }
  pipeline_ = nullptr;
}
inline const ::CoreML::Specification::Pipeline& PipelineRegressor::_internal_pipeline() const {
  const ::CoreML::Specification::Pipeline* p = pipeline_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::Pipeline&>(
      ::CoreML::Specification::_Pipeline_default_instance_);
}
inline const ::CoreML::Specification::Pipeline& PipelineRegressor::pipeline() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PipelineRegressor.pipeline)
  return _internal_pipeline();
}
inline void PipelineRegressor::unsafe_arena_set_allocated_pipeline(
    ::CoreML::Specification::Pipeline* pipeline) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pipeline_);
  }
  pipeline_ = pipeline;
  if (pipeline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.PipelineRegressor.pipeline)
}
inline ::CoreML::Specification::Pipeline* PipelineRegressor::release_pipeline() {
  
  ::CoreML::Specification::Pipeline* temp = pipeline_;
  pipeline_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::Pipeline* PipelineRegressor::unsafe_arena_release_pipeline() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.PipelineRegressor.pipeline)
  
  ::CoreML::Specification::Pipeline* temp = pipeline_;
  pipeline_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::Pipeline* PipelineRegressor::_internal_mutable_pipeline() {
  
  if (pipeline_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::Pipeline>(GetArenaForAllocation());
    pipeline_ = p;
  }
  return pipeline_;
}
inline ::CoreML::Specification::Pipeline* PipelineRegressor::mutable_pipeline() {
  ::CoreML::Specification::Pipeline* _msg = _internal_mutable_pipeline();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.PipelineRegressor.pipeline)
  return _msg;
}
inline void PipelineRegressor::set_allocated_pipeline(::CoreML::Specification::Pipeline* pipeline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pipeline_;
  }
  if (pipeline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::Pipeline>::GetOwningArena(pipeline);
    if (message_arena != submessage_arena) {
      pipeline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pipeline, submessage_arena);
    }
    
  } else {
    
  }
  pipeline_ = pipeline;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PipelineRegressor.pipeline)
}

// -------------------------------------------------------------------

// FeatureDescription

// string name = 1;
inline void FeatureDescription::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& FeatureDescription::name() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureDescription.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeatureDescription::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.FeatureDescription.name)
}
inline std::string* FeatureDescription::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureDescription.name)
  return _s;
}
inline const std::string& FeatureDescription::_internal_name() const {
  return name_.Get();
}
inline void FeatureDescription::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FeatureDescription::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FeatureDescription::release_name() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureDescription.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FeatureDescription::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureDescription.name)
}

// string shortDescription = 2;
inline void FeatureDescription::clear_shortdescription() {
  shortdescription_.ClearToEmpty();
}
inline const std::string& FeatureDescription::shortdescription() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureDescription.shortDescription)
  return _internal_shortdescription();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeatureDescription::set_shortdescription(ArgT0&& arg0, ArgT... args) {
 
 shortdescription_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.FeatureDescription.shortDescription)
}
inline std::string* FeatureDescription::mutable_shortdescription() {
  std::string* _s = _internal_mutable_shortdescription();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureDescription.shortDescription)
  return _s;
}
inline const std::string& FeatureDescription::_internal_shortdescription() const {
  return shortdescription_.Get();
}
inline void FeatureDescription::_internal_set_shortdescription(const std::string& value) {
  
  shortdescription_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FeatureDescription::_internal_mutable_shortdescription() {
  
  return shortdescription_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FeatureDescription::release_shortdescription() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureDescription.shortDescription)
  return shortdescription_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FeatureDescription::set_allocated_shortdescription(std::string* shortdescription) {
  if (shortdescription != nullptr) {
    
  } else {
    
  }
  shortdescription_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), shortdescription,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (shortdescription_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    shortdescription_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureDescription.shortDescription)
}

// .CoreML.Specification.FeatureType type = 3;
inline bool FeatureDescription::_internal_has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline bool FeatureDescription::has_type() const {
  return _internal_has_type();
}
inline const ::CoreML::Specification::FeatureType& FeatureDescription::_internal_type() const {
  const ::CoreML::Specification::FeatureType* p = type_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::FeatureType&>(
      ::CoreML::Specification::_FeatureType_default_instance_);
}
inline const ::CoreML::Specification::FeatureType& FeatureDescription::type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureDescription.type)
  return _internal_type();
}
inline void FeatureDescription::unsafe_arena_set_allocated_type(
    ::CoreML::Specification::FeatureType* type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.FeatureDescription.type)
}
inline ::CoreML::Specification::FeatureType* FeatureDescription::release_type() {
  
  ::CoreML::Specification::FeatureType* temp = type_;
  type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::FeatureType* FeatureDescription::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureDescription.type)
  
  ::CoreML::Specification::FeatureType* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::FeatureType* FeatureDescription::_internal_mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::FeatureType>(GetArenaForAllocation());
    type_ = p;
  }
  return type_;
}
inline ::CoreML::Specification::FeatureType* FeatureDescription::mutable_type() {
  ::CoreML::Specification::FeatureType* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureDescription.type)
  return _msg;
}
inline void FeatureDescription::set_allocated_type(::CoreML::Specification::FeatureType* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type));
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureDescription.type)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Metadata

// string shortDescription = 1;
inline void Metadata::clear_shortdescription() {
  shortdescription_.ClearToEmpty();
}
inline const std::string& Metadata::shortdescription() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Metadata.shortDescription)
  return _internal_shortdescription();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata::set_shortdescription(ArgT0&& arg0, ArgT... args) {
 
 shortdescription_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.Metadata.shortDescription)
}
inline std::string* Metadata::mutable_shortdescription() {
  std::string* _s = _internal_mutable_shortdescription();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Metadata.shortDescription)
  return _s;
}
inline const std::string& Metadata::_internal_shortdescription() const {
  return shortdescription_.Get();
}
inline void Metadata::_internal_set_shortdescription(const std::string& value) {
  
  shortdescription_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_shortdescription() {
  
  return shortdescription_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Metadata::release_shortdescription() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Metadata.shortDescription)
  return shortdescription_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Metadata::set_allocated_shortdescription(std::string* shortdescription) {
  if (shortdescription != nullptr) {
    
  } else {
    
  }
  shortdescription_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), shortdescription,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (shortdescription_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    shortdescription_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Metadata.shortDescription)
}

// string versionString = 2;
inline void Metadata::clear_versionstring() {
  versionstring_.ClearToEmpty();
}
inline const std::string& Metadata::versionstring() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Metadata.versionString)
  return _internal_versionstring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata::set_versionstring(ArgT0&& arg0, ArgT... args) {
 
 versionstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.Metadata.versionString)
}
inline std::string* Metadata::mutable_versionstring() {
  std::string* _s = _internal_mutable_versionstring();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Metadata.versionString)
  return _s;
}
inline const std::string& Metadata::_internal_versionstring() const {
  return versionstring_.Get();
}
inline void Metadata::_internal_set_versionstring(const std::string& value) {
  
  versionstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_versionstring() {
  
  return versionstring_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Metadata::release_versionstring() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Metadata.versionString)
  return versionstring_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Metadata::set_allocated_versionstring(std::string* versionstring) {
  if (versionstring != nullptr) {
    
  } else {
    
  }
  versionstring_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), versionstring,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (versionstring_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    versionstring_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Metadata.versionString)
}

// string author = 3;
inline void Metadata::clear_author() {
  author_.ClearToEmpty();
}
inline const std::string& Metadata::author() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Metadata.author)
  return _internal_author();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata::set_author(ArgT0&& arg0, ArgT... args) {
 
 author_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.Metadata.author)
}
inline std::string* Metadata::mutable_author() {
  std::string* _s = _internal_mutable_author();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Metadata.author)
  return _s;
}
inline const std::string& Metadata::_internal_author() const {
  return author_.Get();
}
inline void Metadata::_internal_set_author(const std::string& value) {
  
  author_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_author() {
  
  return author_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Metadata::release_author() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Metadata.author)
  return author_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Metadata::set_allocated_author(std::string* author) {
  if (author != nullptr) {
    
  } else {
    
  }
  author_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), author,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (author_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    author_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Metadata.author)
}

// string license = 4;
inline void Metadata::clear_license() {
  license_.ClearToEmpty();
}
inline const std::string& Metadata::license() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Metadata.license)
  return _internal_license();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata::set_license(ArgT0&& arg0, ArgT... args) {
 
 license_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.Metadata.license)
}
inline std::string* Metadata::mutable_license() {
  std::string* _s = _internal_mutable_license();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Metadata.license)
  return _s;
}
inline const std::string& Metadata::_internal_license() const {
  return license_.Get();
}
inline void Metadata::_internal_set_license(const std::string& value) {
  
  license_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_license() {
  
  return license_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Metadata::release_license() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Metadata.license)
  return license_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Metadata::set_allocated_license(std::string* license) {
  if (license != nullptr) {
    
  } else {
    
  }
  license_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), license,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (license_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    license_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Metadata.license)
}

// map<string, string> userDefined = 100;
inline int Metadata::_internal_userdefined_size() const {
  return userdefined_.size();
}
inline int Metadata::userdefined_size() const {
  return _internal_userdefined_size();
}
inline void Metadata::clear_userdefined() {
  userdefined_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Metadata::_internal_userdefined() const {
  return userdefined_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Metadata::userdefined() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.Metadata.userDefined)
  return _internal_userdefined();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Metadata::_internal_mutable_userdefined() {
  return userdefined_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Metadata::mutable_userdefined() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.Metadata.userDefined)
  return _internal_mutable_userdefined();
}

// -------------------------------------------------------------------

// FunctionDescription

// string name = 1;
inline void FunctionDescription::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& FunctionDescription::name() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FunctionDescription.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunctionDescription::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.FunctionDescription.name)
}
inline std::string* FunctionDescription::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FunctionDescription.name)
  return _s;
}
inline const std::string& FunctionDescription::_internal_name() const {
  return name_.Get();
}
inline void FunctionDescription::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunctionDescription::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunctionDescription::release_name() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FunctionDescription.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FunctionDescription::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FunctionDescription.name)
}

// repeated .CoreML.Specification.FeatureDescription input = 2;
inline int FunctionDescription::_internal_input_size() const {
  return input_.size();
}
inline int FunctionDescription::input_size() const {
  return _internal_input_size();
}
inline void FunctionDescription::clear_input() {
  input_.Clear();
}
inline ::CoreML::Specification::FeatureDescription* FunctionDescription::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FunctionDescription.input)
  return input_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
FunctionDescription::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.FunctionDescription.input)
  return &input_;
}
inline const ::CoreML::Specification::FeatureDescription& FunctionDescription::_internal_input(int index) const {
  return input_.Get(index);
}
inline const ::CoreML::Specification::FeatureDescription& FunctionDescription::input(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FunctionDescription.input)
  return _internal_input(index);
}
inline ::CoreML::Specification::FeatureDescription* FunctionDescription::_internal_add_input() {
  return input_.Add();
}
inline ::CoreML::Specification::FeatureDescription* FunctionDescription::add_input() {
  ::CoreML::Specification::FeatureDescription* _add = _internal_add_input();
  // @@protoc_insertion_point(field_add:CoreML.Specification.FunctionDescription.input)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
FunctionDescription::input() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.FunctionDescription.input)
  return input_;
}

// repeated .CoreML.Specification.FeatureDescription output = 3;
inline int FunctionDescription::_internal_output_size() const {
  return output_.size();
}
inline int FunctionDescription::output_size() const {
  return _internal_output_size();
}
inline void FunctionDescription::clear_output() {
  output_.Clear();
}
inline ::CoreML::Specification::FeatureDescription* FunctionDescription::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FunctionDescription.output)
  return output_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
FunctionDescription::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.FunctionDescription.output)
  return &output_;
}
inline const ::CoreML::Specification::FeatureDescription& FunctionDescription::_internal_output(int index) const {
  return output_.Get(index);
}
inline const ::CoreML::Specification::FeatureDescription& FunctionDescription::output(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FunctionDescription.output)
  return _internal_output(index);
}
inline ::CoreML::Specification::FeatureDescription* FunctionDescription::_internal_add_output() {
  return output_.Add();
}
inline ::CoreML::Specification::FeatureDescription* FunctionDescription::add_output() {
  ::CoreML::Specification::FeatureDescription* _add = _internal_add_output();
  // @@protoc_insertion_point(field_add:CoreML.Specification.FunctionDescription.output)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
FunctionDescription::output() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.FunctionDescription.output)
  return output_;
}

// repeated .CoreML.Specification.FeatureDescription state = 6;
inline int FunctionDescription::_internal_state_size() const {
  return state_.size();
}
inline int FunctionDescription::state_size() const {
  return _internal_state_size();
}
inline void FunctionDescription::clear_state() {
  state_.Clear();
}
inline ::CoreML::Specification::FeatureDescription* FunctionDescription::mutable_state(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FunctionDescription.state)
  return state_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
FunctionDescription::mutable_state() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.FunctionDescription.state)
  return &state_;
}
inline const ::CoreML::Specification::FeatureDescription& FunctionDescription::_internal_state(int index) const {
  return state_.Get(index);
}
inline const ::CoreML::Specification::FeatureDescription& FunctionDescription::state(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FunctionDescription.state)
  return _internal_state(index);
}
inline ::CoreML::Specification::FeatureDescription* FunctionDescription::_internal_add_state() {
  return state_.Add();
}
inline ::CoreML::Specification::FeatureDescription* FunctionDescription::add_state() {
  ::CoreML::Specification::FeatureDescription* _add = _internal_add_state();
  // @@protoc_insertion_point(field_add:CoreML.Specification.FunctionDescription.state)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
FunctionDescription::state() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.FunctionDescription.state)
  return state_;
}

// string predictedFeatureName = 4;
inline void FunctionDescription::clear_predictedfeaturename() {
  predictedfeaturename_.ClearToEmpty();
}
inline const std::string& FunctionDescription::predictedfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FunctionDescription.predictedFeatureName)
  return _internal_predictedfeaturename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunctionDescription::set_predictedfeaturename(ArgT0&& arg0, ArgT... args) {
 
 predictedfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.FunctionDescription.predictedFeatureName)
}
inline std::string* FunctionDescription::mutable_predictedfeaturename() {
  std::string* _s = _internal_mutable_predictedfeaturename();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FunctionDescription.predictedFeatureName)
  return _s;
}
inline const std::string& FunctionDescription::_internal_predictedfeaturename() const {
  return predictedfeaturename_.Get();
}
inline void FunctionDescription::_internal_set_predictedfeaturename(const std::string& value) {
  
  predictedfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunctionDescription::_internal_mutable_predictedfeaturename() {
  
  return predictedfeaturename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunctionDescription::release_predictedfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FunctionDescription.predictedFeatureName)
  return predictedfeaturename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FunctionDescription::set_allocated_predictedfeaturename(std::string* predictedfeaturename) {
  if (predictedfeaturename != nullptr) {
    
  } else {
    
  }
  predictedfeaturename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), predictedfeaturename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (predictedfeaturename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    predictedfeaturename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FunctionDescription.predictedFeatureName)
}

// string predictedProbabilitiesName = 5;
inline void FunctionDescription::clear_predictedprobabilitiesname() {
  predictedprobabilitiesname_.ClearToEmpty();
}
inline const std::string& FunctionDescription::predictedprobabilitiesname() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FunctionDescription.predictedProbabilitiesName)
  return _internal_predictedprobabilitiesname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunctionDescription::set_predictedprobabilitiesname(ArgT0&& arg0, ArgT... args) {
 
 predictedprobabilitiesname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.FunctionDescription.predictedProbabilitiesName)
}
inline std::string* FunctionDescription::mutable_predictedprobabilitiesname() {
  std::string* _s = _internal_mutable_predictedprobabilitiesname();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FunctionDescription.predictedProbabilitiesName)
  return _s;
}
inline const std::string& FunctionDescription::_internal_predictedprobabilitiesname() const {
  return predictedprobabilitiesname_.Get();
}
inline void FunctionDescription::_internal_set_predictedprobabilitiesname(const std::string& value) {
  
  predictedprobabilitiesname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunctionDescription::_internal_mutable_predictedprobabilitiesname() {
  
  return predictedprobabilitiesname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunctionDescription::release_predictedprobabilitiesname() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FunctionDescription.predictedProbabilitiesName)
  return predictedprobabilitiesname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FunctionDescription::set_allocated_predictedprobabilitiesname(std::string* predictedprobabilitiesname) {
  if (predictedprobabilitiesname != nullptr) {
    
  } else {
    
  }
  predictedprobabilitiesname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), predictedprobabilitiesname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (predictedprobabilitiesname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    predictedprobabilitiesname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FunctionDescription.predictedProbabilitiesName)
}

// -------------------------------------------------------------------

// ModelDescription

// repeated .CoreML.Specification.FunctionDescription functions = 20;
inline int ModelDescription::_internal_functions_size() const {
  return functions_.size();
}
inline int ModelDescription::functions_size() const {
  return _internal_functions_size();
}
inline void ModelDescription::clear_functions() {
  functions_.Clear();
}
inline ::CoreML::Specification::FunctionDescription* ModelDescription::mutable_functions(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.functions)
  return functions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FunctionDescription >*
ModelDescription::mutable_functions() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ModelDescription.functions)
  return &functions_;
}
inline const ::CoreML::Specification::FunctionDescription& ModelDescription::_internal_functions(int index) const {
  return functions_.Get(index);
}
inline const ::CoreML::Specification::FunctionDescription& ModelDescription::functions(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.functions)
  return _internal_functions(index);
}
inline ::CoreML::Specification::FunctionDescription* ModelDescription::_internal_add_functions() {
  return functions_.Add();
}
inline ::CoreML::Specification::FunctionDescription* ModelDescription::add_functions() {
  ::CoreML::Specification::FunctionDescription* _add = _internal_add_functions();
  // @@protoc_insertion_point(field_add:CoreML.Specification.ModelDescription.functions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FunctionDescription >&
ModelDescription::functions() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ModelDescription.functions)
  return functions_;
}

// string defaultFunctionName = 21;
inline void ModelDescription::clear_defaultfunctionname() {
  defaultfunctionname_.ClearToEmpty();
}
inline const std::string& ModelDescription::defaultfunctionname() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.defaultFunctionName)
  return _internal_defaultfunctionname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelDescription::set_defaultfunctionname(ArgT0&& arg0, ArgT... args) {
 
 defaultfunctionname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.ModelDescription.defaultFunctionName)
}
inline std::string* ModelDescription::mutable_defaultfunctionname() {
  std::string* _s = _internal_mutable_defaultfunctionname();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.defaultFunctionName)
  return _s;
}
inline const std::string& ModelDescription::_internal_defaultfunctionname() const {
  return defaultfunctionname_.Get();
}
inline void ModelDescription::_internal_set_defaultfunctionname(const std::string& value) {
  
  defaultfunctionname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ModelDescription::_internal_mutable_defaultfunctionname() {
  
  return defaultfunctionname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ModelDescription::release_defaultfunctionname() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ModelDescription.defaultFunctionName)
  return defaultfunctionname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ModelDescription::set_allocated_defaultfunctionname(std::string* defaultfunctionname) {
  if (defaultfunctionname != nullptr) {
    
  } else {
    
  }
  defaultfunctionname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), defaultfunctionname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (defaultfunctionname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    defaultfunctionname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ModelDescription.defaultFunctionName)
}

// .CoreML.Specification.Metadata metadata = 100;
inline bool ModelDescription::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool ModelDescription::has_metadata() const {
  return _internal_has_metadata();
}
inline void ModelDescription::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::CoreML::Specification::Metadata& ModelDescription::_internal_metadata() const {
  const ::CoreML::Specification::Metadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::Metadata&>(
      ::CoreML::Specification::_Metadata_default_instance_);
}
inline const ::CoreML::Specification::Metadata& ModelDescription::metadata() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.metadata)
  return _internal_metadata();
}
inline void ModelDescription::unsafe_arena_set_allocated_metadata(
    ::CoreML::Specification::Metadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.ModelDescription.metadata)
}
inline ::CoreML::Specification::Metadata* ModelDescription::release_metadata() {
  
  ::CoreML::Specification::Metadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::Metadata* ModelDescription::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ModelDescription.metadata)
  
  ::CoreML::Specification::Metadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::Metadata* ModelDescription::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::Metadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::CoreML::Specification::Metadata* ModelDescription::mutable_metadata() {
  ::CoreML::Specification::Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.metadata)
  return _msg;
}
inline void ModelDescription::set_allocated_metadata(::CoreML::Specification::Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::Metadata>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ModelDescription.metadata)
}

// repeated .CoreML.Specification.FeatureDescription input = 1;
inline int ModelDescription::_internal_input_size() const {
  return input_.size();
}
inline int ModelDescription::input_size() const {
  return _internal_input_size();
}
inline void ModelDescription::clear_input() {
  input_.Clear();
}
inline ::CoreML::Specification::FeatureDescription* ModelDescription::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.input)
  return input_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
ModelDescription::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ModelDescription.input)
  return &input_;
}
inline const ::CoreML::Specification::FeatureDescription& ModelDescription::_internal_input(int index) const {
  return input_.Get(index);
}
inline const ::CoreML::Specification::FeatureDescription& ModelDescription::input(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.input)
  return _internal_input(index);
}
inline ::CoreML::Specification::FeatureDescription* ModelDescription::_internal_add_input() {
  return input_.Add();
}
inline ::CoreML::Specification::FeatureDescription* ModelDescription::add_input() {
  ::CoreML::Specification::FeatureDescription* _add = _internal_add_input();
  // @@protoc_insertion_point(field_add:CoreML.Specification.ModelDescription.input)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
ModelDescription::input() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ModelDescription.input)
  return input_;
}

// repeated .CoreML.Specification.FeatureDescription output = 10;
inline int ModelDescription::_internal_output_size() const {
  return output_.size();
}
inline int ModelDescription::output_size() const {
  return _internal_output_size();
}
inline void ModelDescription::clear_output() {
  output_.Clear();
}
inline ::CoreML::Specification::FeatureDescription* ModelDescription::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.output)
  return output_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
ModelDescription::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ModelDescription.output)
  return &output_;
}
inline const ::CoreML::Specification::FeatureDescription& ModelDescription::_internal_output(int index) const {
  return output_.Get(index);
}
inline const ::CoreML::Specification::FeatureDescription& ModelDescription::output(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.output)
  return _internal_output(index);
}
inline ::CoreML::Specification::FeatureDescription* ModelDescription::_internal_add_output() {
  return output_.Add();
}
inline ::CoreML::Specification::FeatureDescription* ModelDescription::add_output() {
  ::CoreML::Specification::FeatureDescription* _add = _internal_add_output();
  // @@protoc_insertion_point(field_add:CoreML.Specification.ModelDescription.output)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
ModelDescription::output() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ModelDescription.output)
  return output_;
}

// repeated .CoreML.Specification.FeatureDescription state = 13;
inline int ModelDescription::_internal_state_size() const {
  return state_.size();
}
inline int ModelDescription::state_size() const {
  return _internal_state_size();
}
inline void ModelDescription::clear_state() {
  state_.Clear();
}
inline ::CoreML::Specification::FeatureDescription* ModelDescription::mutable_state(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.state)
  return state_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
ModelDescription::mutable_state() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ModelDescription.state)
  return &state_;
}
inline const ::CoreML::Specification::FeatureDescription& ModelDescription::_internal_state(int index) const {
  return state_.Get(index);
}
inline const ::CoreML::Specification::FeatureDescription& ModelDescription::state(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.state)
  return _internal_state(index);
}
inline ::CoreML::Specification::FeatureDescription* ModelDescription::_internal_add_state() {
  return state_.Add();
}
inline ::CoreML::Specification::FeatureDescription* ModelDescription::add_state() {
  ::CoreML::Specification::FeatureDescription* _add = _internal_add_state();
  // @@protoc_insertion_point(field_add:CoreML.Specification.ModelDescription.state)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
ModelDescription::state() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ModelDescription.state)
  return state_;
}

// string predictedFeatureName = 11;
inline void ModelDescription::clear_predictedfeaturename() {
  predictedfeaturename_.ClearToEmpty();
}
inline const std::string& ModelDescription::predictedfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.predictedFeatureName)
  return _internal_predictedfeaturename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelDescription::set_predictedfeaturename(ArgT0&& arg0, ArgT... args) {
 
 predictedfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.ModelDescription.predictedFeatureName)
}
inline std::string* ModelDescription::mutable_predictedfeaturename() {
  std::string* _s = _internal_mutable_predictedfeaturename();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.predictedFeatureName)
  return _s;
}
inline const std::string& ModelDescription::_internal_predictedfeaturename() const {
  return predictedfeaturename_.Get();
}
inline void ModelDescription::_internal_set_predictedfeaturename(const std::string& value) {
  
  predictedfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ModelDescription::_internal_mutable_predictedfeaturename() {
  
  return predictedfeaturename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ModelDescription::release_predictedfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ModelDescription.predictedFeatureName)
  return predictedfeaturename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ModelDescription::set_allocated_predictedfeaturename(std::string* predictedfeaturename) {
  if (predictedfeaturename != nullptr) {
    
  } else {
    
  }
  predictedfeaturename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), predictedfeaturename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (predictedfeaturename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    predictedfeaturename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ModelDescription.predictedFeatureName)
}

// string predictedProbabilitiesName = 12;
inline void ModelDescription::clear_predictedprobabilitiesname() {
  predictedprobabilitiesname_.ClearToEmpty();
}
inline const std::string& ModelDescription::predictedprobabilitiesname() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
  return _internal_predictedprobabilitiesname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelDescription::set_predictedprobabilitiesname(ArgT0&& arg0, ArgT... args) {
 
 predictedprobabilitiesname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
}
inline std::string* ModelDescription::mutable_predictedprobabilitiesname() {
  std::string* _s = _internal_mutable_predictedprobabilitiesname();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
  return _s;
}
inline const std::string& ModelDescription::_internal_predictedprobabilitiesname() const {
  return predictedprobabilitiesname_.Get();
}
inline void ModelDescription::_internal_set_predictedprobabilitiesname(const std::string& value) {
  
  predictedprobabilitiesname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ModelDescription::_internal_mutable_predictedprobabilitiesname() {
  
  return predictedprobabilitiesname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ModelDescription::release_predictedprobabilitiesname() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
  return predictedprobabilitiesname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ModelDescription::set_allocated_predictedprobabilitiesname(std::string* predictedprobabilitiesname) {
  if (predictedprobabilitiesname != nullptr) {
    
  } else {
    
  }
  predictedprobabilitiesname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), predictedprobabilitiesname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (predictedprobabilitiesname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    predictedprobabilitiesname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
}

// repeated .CoreML.Specification.FeatureDescription trainingInput = 50;
inline int ModelDescription::_internal_traininginput_size() const {
  return traininginput_.size();
}
inline int ModelDescription::traininginput_size() const {
  return _internal_traininginput_size();
}
inline void ModelDescription::clear_traininginput() {
  traininginput_.Clear();
}
inline ::CoreML::Specification::FeatureDescription* ModelDescription::mutable_traininginput(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.trainingInput)
  return traininginput_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
ModelDescription::mutable_traininginput() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ModelDescription.trainingInput)
  return &traininginput_;
}
inline const ::CoreML::Specification::FeatureDescription& ModelDescription::_internal_traininginput(int index) const {
  return traininginput_.Get(index);
}
inline const ::CoreML::Specification::FeatureDescription& ModelDescription::traininginput(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.trainingInput)
  return _internal_traininginput(index);
}
inline ::CoreML::Specification::FeatureDescription* ModelDescription::_internal_add_traininginput() {
  return traininginput_.Add();
}
inline ::CoreML::Specification::FeatureDescription* ModelDescription::add_traininginput() {
  ::CoreML::Specification::FeatureDescription* _add = _internal_add_traininginput();
  // @@protoc_insertion_point(field_add:CoreML.Specification.ModelDescription.trainingInput)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
ModelDescription::traininginput() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ModelDescription.trainingInput)
  return traininginput_;
}

// -------------------------------------------------------------------

// SerializedModel

// string identifier = 1;
inline void SerializedModel::clear_identifier() {
  identifier_.ClearToEmpty();
}
inline const std::string& SerializedModel::identifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SerializedModel.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SerializedModel::set_identifier(ArgT0&& arg0, ArgT... args) {
 
 identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.SerializedModel.identifier)
}
inline std::string* SerializedModel::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SerializedModel.identifier)
  return _s;
}
inline const std::string& SerializedModel::_internal_identifier() const {
  return identifier_.Get();
}
inline void SerializedModel::_internal_set_identifier(const std::string& value) {
  
  identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SerializedModel::_internal_mutable_identifier() {
  
  return identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SerializedModel::release_identifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SerializedModel.identifier)
  return identifier_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SerializedModel::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    
  } else {
    
  }
  identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SerializedModel.identifier)
}

// bytes model = 2;
inline void SerializedModel::clear_model() {
  model_.ClearToEmpty();
}
inline const std::string& SerializedModel::model() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SerializedModel.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SerializedModel::set_model(ArgT0&& arg0, ArgT... args) {
 
 model_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.SerializedModel.model)
}
inline std::string* SerializedModel::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SerializedModel.model)
  return _s;
}
inline const std::string& SerializedModel::_internal_model() const {
  return model_.Get();
}
inline void SerializedModel::_internal_set_model(const std::string& value) {
  
  model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SerializedModel::_internal_mutable_model() {
  
  return model_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SerializedModel::release_model() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SerializedModel.model)
  return model_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SerializedModel::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SerializedModel.model)
}

// -------------------------------------------------------------------

// Model

// int32 specificationVersion = 1;
inline void Model::clear_specificationversion() {
  specificationversion_ = 0;
}
inline int32_t Model::_internal_specificationversion() const {
  return specificationversion_;
}
inline int32_t Model::specificationversion() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.specificationVersion)
  return _internal_specificationversion();
}
inline void Model::_internal_set_specificationversion(int32_t value) {
  
  specificationversion_ = value;
}
inline void Model::set_specificationversion(int32_t value) {
  _internal_set_specificationversion(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Model.specificationVersion)
}

// .CoreML.Specification.ModelDescription description = 2;
inline bool Model::_internal_has_description() const {
  return this != internal_default_instance() && description_ != nullptr;
}
inline bool Model::has_description() const {
  return _internal_has_description();
}
inline void Model::clear_description() {
  if (GetArenaForAllocation() == nullptr && description_ != nullptr) {
    delete description_;
  }
  description_ = nullptr;
}
inline const ::CoreML::Specification::ModelDescription& Model::_internal_description() const {
  const ::CoreML::Specification::ModelDescription* p = description_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::ModelDescription&>(
      ::CoreML::Specification::_ModelDescription_default_instance_);
}
inline const ::CoreML::Specification::ModelDescription& Model::description() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.description)
  return _internal_description();
}
inline void Model::unsafe_arena_set_allocated_description(
    ::CoreML::Specification::ModelDescription* description) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(description_);
  }
  description_ = description;
  if (description) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.description)
}
inline ::CoreML::Specification::ModelDescription* Model::release_description() {
  
  ::CoreML::Specification::ModelDescription* temp = description_;
  description_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::ModelDescription* Model::unsafe_arena_release_description() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.description)
  
  ::CoreML::Specification::ModelDescription* temp = description_;
  description_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::ModelDescription* Model::_internal_mutable_description() {
  
  if (description_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::ModelDescription>(GetArenaForAllocation());
    description_ = p;
  }
  return description_;
}
inline ::CoreML::Specification::ModelDescription* Model::mutable_description() {
  ::CoreML::Specification::ModelDescription* _msg = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.description)
  return _msg;
}
inline void Model::set_allocated_description(::CoreML::Specification::ModelDescription* description) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete description_;
  }
  if (description) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ModelDescription>::GetOwningArena(description);
    if (message_arena != submessage_arena) {
      description = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, description, submessage_arena);
    }
    
  } else {
    
  }
  description_ = description;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.description)
}

// bool isUpdatable = 10;
inline void Model::clear_isupdatable() {
  isupdatable_ = false;
}
inline bool Model::_internal_isupdatable() const {
  return isupdatable_;
}
inline bool Model::isupdatable() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.isUpdatable)
  return _internal_isupdatable();
}
inline void Model::_internal_set_isupdatable(bool value) {
  
  isupdatable_ = value;
}
inline void Model::set_isupdatable(bool value) {
  _internal_set_isupdatable(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Model.isUpdatable)
}

// .CoreML.Specification.PipelineClassifier pipelineClassifier = 200;
inline bool Model::_internal_has_pipelineclassifier() const {
  return Type_case() == kPipelineClassifier;
}
inline bool Model::has_pipelineclassifier() const {
  return _internal_has_pipelineclassifier();
}
inline void Model::set_has_pipelineclassifier() {
  _oneof_case_[0] = kPipelineClassifier;
}
inline void Model::clear_pipelineclassifier() {
  if (_internal_has_pipelineclassifier()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.pipelineclassifier_;
    }
    clear_has_Type();
  }
}
inline ::CoreML::Specification::PipelineClassifier* Model::release_pipelineclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.pipelineClassifier)
  if (_internal_has_pipelineclassifier()) {
    clear_has_Type();
      ::CoreML::Specification::PipelineClassifier* temp = Type_.pipelineclassifier_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.pipelineclassifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::PipelineClassifier& Model::_internal_pipelineclassifier() const {
  return _internal_has_pipelineclassifier()
      ? *Type_.pipelineclassifier_
      : reinterpret_cast< ::CoreML::Specification::PipelineClassifier&>(::CoreML::Specification::_PipelineClassifier_default_instance_);
}
inline const ::CoreML::Specification::PipelineClassifier& Model::pipelineclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.pipelineClassifier)
  return _internal_pipelineclassifier();
}
inline ::CoreML::Specification::PipelineClassifier* Model::unsafe_arena_release_pipelineclassifier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.pipelineClassifier)
  if (_internal_has_pipelineclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::PipelineClassifier* temp = Type_.pipelineclassifier_;
    Type_.pipelineclassifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_pipelineclassifier(::CoreML::Specification::PipelineClassifier* pipelineclassifier) {
  clear_Type();
  if (pipelineclassifier) {
    set_has_pipelineclassifier();
    Type_.pipelineclassifier_ = pipelineclassifier;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.pipelineClassifier)
}
inline ::CoreML::Specification::PipelineClassifier* Model::_internal_mutable_pipelineclassifier() {
  if (!_internal_has_pipelineclassifier()) {
    clear_Type();
    set_has_pipelineclassifier();
    Type_.pipelineclassifier_ = CreateMaybeMessage< ::CoreML::Specification::PipelineClassifier >(GetArenaForAllocation());
  }
  return Type_.pipelineclassifier_;
}
inline ::CoreML::Specification::PipelineClassifier* Model::mutable_pipelineclassifier() {
  ::CoreML::Specification::PipelineClassifier* _msg = _internal_mutable_pipelineclassifier();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.pipelineClassifier)
  return _msg;
}

// .CoreML.Specification.PipelineRegressor pipelineRegressor = 201;
inline bool Model::_internal_has_pipelineregressor() const {
  return Type_case() == kPipelineRegressor;
}
inline bool Model::has_pipelineregressor() const {
  return _internal_has_pipelineregressor();
}
inline void Model::set_has_pipelineregressor() {
  _oneof_case_[0] = kPipelineRegressor;
}
inline void Model::clear_pipelineregressor() {
  if (_internal_has_pipelineregressor()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.pipelineregressor_;
    }
    clear_has_Type();
  }
}
inline ::CoreML::Specification::PipelineRegressor* Model::release_pipelineregressor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.pipelineRegressor)
  if (_internal_has_pipelineregressor()) {
    clear_has_Type();
      ::CoreML::Specification::PipelineRegressor* temp = Type_.pipelineregressor_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.pipelineregressor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::PipelineRegressor& Model::_internal_pipelineregressor() const {
  return _internal_has_pipelineregressor()
      ? *Type_.pipelineregressor_
      : reinterpret_cast< ::CoreML::Specification::PipelineRegressor&>(::CoreML::Specification::_PipelineRegressor_default_instance_);
}
inline const ::CoreML::Specification::PipelineRegressor& Model::pipelineregressor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.pipelineRegressor)
  return _internal_pipelineregressor();
}
inline ::CoreML::Specification::PipelineRegressor* Model::unsafe_arena_release_pipelineregressor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.pipelineRegressor)
  if (_internal_has_pipelineregressor()) {
    clear_has_Type();
    ::CoreML::Specification::PipelineRegressor* temp = Type_.pipelineregressor_;
    Type_.pipelineregressor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_pipelineregressor(::CoreML::Specification::PipelineRegressor* pipelineregressor) {
  clear_Type();
  if (pipelineregressor) {
    set_has_pipelineregressor();
    Type_.pipelineregressor_ = pipelineregressor;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.pipelineRegressor)
}
inline ::CoreML::Specification::PipelineRegressor* Model::_internal_mutable_pipelineregressor() {
  if (!_internal_has_pipelineregressor()) {
    clear_Type();
    set_has_pipelineregressor();
    Type_.pipelineregressor_ = CreateMaybeMessage< ::CoreML::Specification::PipelineRegressor >(GetArenaForAllocation());
  }
  return Type_.pipelineregressor_;
}
inline ::CoreML::Specification::PipelineRegressor* Model::mutable_pipelineregressor() {
  ::CoreML::Specification::PipelineRegressor* _msg = _internal_mutable_pipelineregressor();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.pipelineRegressor)
  return _msg;
}

// .CoreML.Specification.Pipeline pipeline = 202;
inline bool Model::_internal_has_pipeline() const {
  return Type_case() == kPipeline;
}
inline bool Model::has_pipeline() const {
  return _internal_has_pipeline();
}
inline void Model::set_has_pipeline() {
  _oneof_case_[0] = kPipeline;
}
inline void Model::clear_pipeline() {
  if (_internal_has_pipeline()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.pipeline_;
    }
    clear_has_Type();
  }
}
inline ::CoreML::Specification::Pipeline* Model::release_pipeline() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.pipeline)
  if (_internal_has_pipeline()) {
    clear_has_Type();
      ::CoreML::Specification::Pipeline* temp = Type_.pipeline_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.pipeline_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::Pipeline& Model::_internal_pipeline() const {
  return _internal_has_pipeline()
      ? *Type_.pipeline_
      : reinterpret_cast< ::CoreML::Specification::Pipeline&>(::CoreML::Specification::_Pipeline_default_instance_);
}
inline const ::CoreML::Specification::Pipeline& Model::pipeline() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.pipeline)
  return _internal_pipeline();
}
inline ::CoreML::Specification::Pipeline* Model::unsafe_arena_release_pipeline() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.pipeline)
  if (_internal_has_pipeline()) {
    clear_has_Type();
    ::CoreML::Specification::Pipeline* temp = Type_.pipeline_;
    Type_.pipeline_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_pipeline(::CoreML::Specification::Pipeline* pipeline) {
  clear_Type();
  if (pipeline) {
    set_has_pipeline();
    Type_.pipeline_ = pipeline;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.pipeline)
}
inline ::CoreML::Specification::Pipeline* Model::_internal_mutable_pipeline() {
  if (!_internal_has_pipeline()) {
    clear_Type();
    set_has_pipeline();
    Type_.pipeline_ = CreateMaybeMessage< ::CoreML::Specification::Pipeline >(GetArenaForAllocation());
  }
  return Type_.pipeline_;
}
inline ::CoreML::Specification::Pipeline* Model::mutable_pipeline() {
  ::CoreML::Specification::Pipeline* _msg = _internal_mutable_pipeline();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.pipeline)
  return _msg;
}

// .CoreML.Specification.GLMRegressor glmRegressor = 300;
inline bool Model::_internal_has_glmregressor() const {
  return Type_case() == kGlmRegressor;
}
inline bool Model::has_glmregressor() const {
  return _internal_has_glmregressor();
}
inline void Model::set_has_glmregressor() {
  _oneof_case_[0] = kGlmRegressor;
}
inline ::CoreML::Specification::GLMRegressor* Model::release_glmregressor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.glmRegressor)
  if (_internal_has_glmregressor()) {
    clear_has_Type();
      ::CoreML::Specification::GLMRegressor* temp = Type_.glmregressor_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.glmregressor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::GLMRegressor& Model::_internal_glmregressor() const {
  return _internal_has_glmregressor()
      ? *Type_.glmregressor_
      : reinterpret_cast< ::CoreML::Specification::GLMRegressor&>(::CoreML::Specification::_GLMRegressor_default_instance_);
}
inline const ::CoreML::Specification::GLMRegressor& Model::glmregressor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.glmRegressor)
  return _internal_glmregressor();
}
inline ::CoreML::Specification::GLMRegressor* Model::unsafe_arena_release_glmregressor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.glmRegressor)
  if (_internal_has_glmregressor()) {
    clear_has_Type();
    ::CoreML::Specification::GLMRegressor* temp = Type_.glmregressor_;
    Type_.glmregressor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_glmregressor(::CoreML::Specification::GLMRegressor* glmregressor) {
  clear_Type();
  if (glmregressor) {
    set_has_glmregressor();
    Type_.glmregressor_ = glmregressor;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.glmRegressor)
}
inline ::CoreML::Specification::GLMRegressor* Model::_internal_mutable_glmregressor() {
  if (!_internal_has_glmregressor()) {
    clear_Type();
    set_has_glmregressor();
    Type_.glmregressor_ = CreateMaybeMessage< ::CoreML::Specification::GLMRegressor >(GetArenaForAllocation());
  }
  return Type_.glmregressor_;
}
inline ::CoreML::Specification::GLMRegressor* Model::mutable_glmregressor() {
  ::CoreML::Specification::GLMRegressor* _msg = _internal_mutable_glmregressor();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.glmRegressor)
  return _msg;
}

// .CoreML.Specification.SupportVectorRegressor supportVectorRegressor = 301;
inline bool Model::_internal_has_supportvectorregressor() const {
  return Type_case() == kSupportVectorRegressor;
}
inline bool Model::has_supportvectorregressor() const {
  return _internal_has_supportvectorregressor();
}
inline void Model::set_has_supportvectorregressor() {
  _oneof_case_[0] = kSupportVectorRegressor;
}
inline ::CoreML::Specification::SupportVectorRegressor* Model::release_supportvectorregressor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.supportVectorRegressor)
  if (_internal_has_supportvectorregressor()) {
    clear_has_Type();
      ::CoreML::Specification::SupportVectorRegressor* temp = Type_.supportvectorregressor_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.supportvectorregressor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::SupportVectorRegressor& Model::_internal_supportvectorregressor() const {
  return _internal_has_supportvectorregressor()
      ? *Type_.supportvectorregressor_
      : reinterpret_cast< ::CoreML::Specification::SupportVectorRegressor&>(::CoreML::Specification::_SupportVectorRegressor_default_instance_);
}
inline const ::CoreML::Specification::SupportVectorRegressor& Model::supportvectorregressor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.supportVectorRegressor)
  return _internal_supportvectorregressor();
}
inline ::CoreML::Specification::SupportVectorRegressor* Model::unsafe_arena_release_supportvectorregressor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.supportVectorRegressor)
  if (_internal_has_supportvectorregressor()) {
    clear_has_Type();
    ::CoreML::Specification::SupportVectorRegressor* temp = Type_.supportvectorregressor_;
    Type_.supportvectorregressor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_supportvectorregressor(::CoreML::Specification::SupportVectorRegressor* supportvectorregressor) {
  clear_Type();
  if (supportvectorregressor) {
    set_has_supportvectorregressor();
    Type_.supportvectorregressor_ = supportvectorregressor;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.supportVectorRegressor)
}
inline ::CoreML::Specification::SupportVectorRegressor* Model::_internal_mutable_supportvectorregressor() {
  if (!_internal_has_supportvectorregressor()) {
    clear_Type();
    set_has_supportvectorregressor();
    Type_.supportvectorregressor_ = CreateMaybeMessage< ::CoreML::Specification::SupportVectorRegressor >(GetArenaForAllocation());
  }
  return Type_.supportvectorregressor_;
}
inline ::CoreML::Specification::SupportVectorRegressor* Model::mutable_supportvectorregressor() {
  ::CoreML::Specification::SupportVectorRegressor* _msg = _internal_mutable_supportvectorregressor();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.supportVectorRegressor)
  return _msg;
}

// .CoreML.Specification.TreeEnsembleRegressor treeEnsembleRegressor = 302;
inline bool Model::_internal_has_treeensembleregressor() const {
  return Type_case() == kTreeEnsembleRegressor;
}
inline bool Model::has_treeensembleregressor() const {
  return _internal_has_treeensembleregressor();
}
inline void Model::set_has_treeensembleregressor() {
  _oneof_case_[0] = kTreeEnsembleRegressor;
}
inline ::CoreML::Specification::TreeEnsembleRegressor* Model::release_treeensembleregressor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.treeEnsembleRegressor)
  if (_internal_has_treeensembleregressor()) {
    clear_has_Type();
      ::CoreML::Specification::TreeEnsembleRegressor* temp = Type_.treeensembleregressor_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.treeensembleregressor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::TreeEnsembleRegressor& Model::_internal_treeensembleregressor() const {
  return _internal_has_treeensembleregressor()
      ? *Type_.treeensembleregressor_
      : reinterpret_cast< ::CoreML::Specification::TreeEnsembleRegressor&>(::CoreML::Specification::_TreeEnsembleRegressor_default_instance_);
}
inline const ::CoreML::Specification::TreeEnsembleRegressor& Model::treeensembleregressor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.treeEnsembleRegressor)
  return _internal_treeensembleregressor();
}
inline ::CoreML::Specification::TreeEnsembleRegressor* Model::unsafe_arena_release_treeensembleregressor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.treeEnsembleRegressor)
  if (_internal_has_treeensembleregressor()) {
    clear_has_Type();
    ::CoreML::Specification::TreeEnsembleRegressor* temp = Type_.treeensembleregressor_;
    Type_.treeensembleregressor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_treeensembleregressor(::CoreML::Specification::TreeEnsembleRegressor* treeensembleregressor) {
  clear_Type();
  if (treeensembleregressor) {
    set_has_treeensembleregressor();
    Type_.treeensembleregressor_ = treeensembleregressor;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.treeEnsembleRegressor)
}
inline ::CoreML::Specification::TreeEnsembleRegressor* Model::_internal_mutable_treeensembleregressor() {
  if (!_internal_has_treeensembleregressor()) {
    clear_Type();
    set_has_treeensembleregressor();
    Type_.treeensembleregressor_ = CreateMaybeMessage< ::CoreML::Specification::TreeEnsembleRegressor >(GetArenaForAllocation());
  }
  return Type_.treeensembleregressor_;
}
inline ::CoreML::Specification::TreeEnsembleRegressor* Model::mutable_treeensembleregressor() {
  ::CoreML::Specification::TreeEnsembleRegressor* _msg = _internal_mutable_treeensembleregressor();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.treeEnsembleRegressor)
  return _msg;
}

// .CoreML.Specification.NeuralNetworkRegressor neuralNetworkRegressor = 303;
inline bool Model::_internal_has_neuralnetworkregressor() const {
  return Type_case() == kNeuralNetworkRegressor;
}
inline bool Model::has_neuralnetworkregressor() const {
  return _internal_has_neuralnetworkregressor();
}
inline void Model::set_has_neuralnetworkregressor() {
  _oneof_case_[0] = kNeuralNetworkRegressor;
}
inline ::CoreML::Specification::NeuralNetworkRegressor* Model::release_neuralnetworkregressor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.neuralNetworkRegressor)
  if (_internal_has_neuralnetworkregressor()) {
    clear_has_Type();
      ::CoreML::Specification::NeuralNetworkRegressor* temp = Type_.neuralnetworkregressor_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.neuralnetworkregressor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::NeuralNetworkRegressor& Model::_internal_neuralnetworkregressor() const {
  return _internal_has_neuralnetworkregressor()
      ? *Type_.neuralnetworkregressor_
      : reinterpret_cast< ::CoreML::Specification::NeuralNetworkRegressor&>(::CoreML::Specification::_NeuralNetworkRegressor_default_instance_);
}
inline const ::CoreML::Specification::NeuralNetworkRegressor& Model::neuralnetworkregressor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.neuralNetworkRegressor)
  return _internal_neuralnetworkregressor();
}
inline ::CoreML::Specification::NeuralNetworkRegressor* Model::unsafe_arena_release_neuralnetworkregressor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.neuralNetworkRegressor)
  if (_internal_has_neuralnetworkregressor()) {
    clear_has_Type();
    ::CoreML::Specification::NeuralNetworkRegressor* temp = Type_.neuralnetworkregressor_;
    Type_.neuralnetworkregressor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_neuralnetworkregressor(::CoreML::Specification::NeuralNetworkRegressor* neuralnetworkregressor) {
  clear_Type();
  if (neuralnetworkregressor) {
    set_has_neuralnetworkregressor();
    Type_.neuralnetworkregressor_ = neuralnetworkregressor;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.neuralNetworkRegressor)
}
inline ::CoreML::Specification::NeuralNetworkRegressor* Model::_internal_mutable_neuralnetworkregressor() {
  if (!_internal_has_neuralnetworkregressor()) {
    clear_Type();
    set_has_neuralnetworkregressor();
    Type_.neuralnetworkregressor_ = CreateMaybeMessage< ::CoreML::Specification::NeuralNetworkRegressor >(GetArenaForAllocation());
  }
  return Type_.neuralnetworkregressor_;
}
inline ::CoreML::Specification::NeuralNetworkRegressor* Model::mutable_neuralnetworkregressor() {
  ::CoreML::Specification::NeuralNetworkRegressor* _msg = _internal_mutable_neuralnetworkregressor();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.neuralNetworkRegressor)
  return _msg;
}

// .CoreML.Specification.BayesianProbitRegressor bayesianProbitRegressor = 304;
inline bool Model::_internal_has_bayesianprobitregressor() const {
  return Type_case() == kBayesianProbitRegressor;
}
inline bool Model::has_bayesianprobitregressor() const {
  return _internal_has_bayesianprobitregressor();
}
inline void Model::set_has_bayesianprobitregressor() {
  _oneof_case_[0] = kBayesianProbitRegressor;
}
inline ::CoreML::Specification::BayesianProbitRegressor* Model::release_bayesianprobitregressor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.bayesianProbitRegressor)
  if (_internal_has_bayesianprobitregressor()) {
    clear_has_Type();
      ::CoreML::Specification::BayesianProbitRegressor* temp = Type_.bayesianprobitregressor_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.bayesianprobitregressor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::BayesianProbitRegressor& Model::_internal_bayesianprobitregressor() const {
  return _internal_has_bayesianprobitregressor()
      ? *Type_.bayesianprobitregressor_
      : reinterpret_cast< ::CoreML::Specification::BayesianProbitRegressor&>(::CoreML::Specification::_BayesianProbitRegressor_default_instance_);
}
inline const ::CoreML::Specification::BayesianProbitRegressor& Model::bayesianprobitregressor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.bayesianProbitRegressor)
  return _internal_bayesianprobitregressor();
}
inline ::CoreML::Specification::BayesianProbitRegressor* Model::unsafe_arena_release_bayesianprobitregressor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.bayesianProbitRegressor)
  if (_internal_has_bayesianprobitregressor()) {
    clear_has_Type();
    ::CoreML::Specification::BayesianProbitRegressor* temp = Type_.bayesianprobitregressor_;
    Type_.bayesianprobitregressor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_bayesianprobitregressor(::CoreML::Specification::BayesianProbitRegressor* bayesianprobitregressor) {
  clear_Type();
  if (bayesianprobitregressor) {
    set_has_bayesianprobitregressor();
    Type_.bayesianprobitregressor_ = bayesianprobitregressor;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.bayesianProbitRegressor)
}
inline ::CoreML::Specification::BayesianProbitRegressor* Model::_internal_mutable_bayesianprobitregressor() {
  if (!_internal_has_bayesianprobitregressor()) {
    clear_Type();
    set_has_bayesianprobitregressor();
    Type_.bayesianprobitregressor_ = CreateMaybeMessage< ::CoreML::Specification::BayesianProbitRegressor >(GetArenaForAllocation());
  }
  return Type_.bayesianprobitregressor_;
}
inline ::CoreML::Specification::BayesianProbitRegressor* Model::mutable_bayesianprobitregressor() {
  ::CoreML::Specification::BayesianProbitRegressor* _msg = _internal_mutable_bayesianprobitregressor();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.bayesianProbitRegressor)
  return _msg;
}

// .CoreML.Specification.GLMClassifier glmClassifier = 400;
inline bool Model::_internal_has_glmclassifier() const {
  return Type_case() == kGlmClassifier;
}
inline bool Model::has_glmclassifier() const {
  return _internal_has_glmclassifier();
}
inline void Model::set_has_glmclassifier() {
  _oneof_case_[0] = kGlmClassifier;
}
inline ::CoreML::Specification::GLMClassifier* Model::release_glmclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.glmClassifier)
  if (_internal_has_glmclassifier()) {
    clear_has_Type();
      ::CoreML::Specification::GLMClassifier* temp = Type_.glmclassifier_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.glmclassifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::GLMClassifier& Model::_internal_glmclassifier() const {
  return _internal_has_glmclassifier()
      ? *Type_.glmclassifier_
      : reinterpret_cast< ::CoreML::Specification::GLMClassifier&>(::CoreML::Specification::_GLMClassifier_default_instance_);
}
inline const ::CoreML::Specification::GLMClassifier& Model::glmclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.glmClassifier)
  return _internal_glmclassifier();
}
inline ::CoreML::Specification::GLMClassifier* Model::unsafe_arena_release_glmclassifier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.glmClassifier)
  if (_internal_has_glmclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::GLMClassifier* temp = Type_.glmclassifier_;
    Type_.glmclassifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_glmclassifier(::CoreML::Specification::GLMClassifier* glmclassifier) {
  clear_Type();
  if (glmclassifier) {
    set_has_glmclassifier();
    Type_.glmclassifier_ = glmclassifier;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.glmClassifier)
}
inline ::CoreML::Specification::GLMClassifier* Model::_internal_mutable_glmclassifier() {
  if (!_internal_has_glmclassifier()) {
    clear_Type();
    set_has_glmclassifier();
    Type_.glmclassifier_ = CreateMaybeMessage< ::CoreML::Specification::GLMClassifier >(GetArenaForAllocation());
  }
  return Type_.glmclassifier_;
}
inline ::CoreML::Specification::GLMClassifier* Model::mutable_glmclassifier() {
  ::CoreML::Specification::GLMClassifier* _msg = _internal_mutable_glmclassifier();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.glmClassifier)
  return _msg;
}

// .CoreML.Specification.SupportVectorClassifier supportVectorClassifier = 401;
inline bool Model::_internal_has_supportvectorclassifier() const {
  return Type_case() == kSupportVectorClassifier;
}
inline bool Model::has_supportvectorclassifier() const {
  return _internal_has_supportvectorclassifier();
}
inline void Model::set_has_supportvectorclassifier() {
  _oneof_case_[0] = kSupportVectorClassifier;
}
inline ::CoreML::Specification::SupportVectorClassifier* Model::release_supportvectorclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.supportVectorClassifier)
  if (_internal_has_supportvectorclassifier()) {
    clear_has_Type();
      ::CoreML::Specification::SupportVectorClassifier* temp = Type_.supportvectorclassifier_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.supportvectorclassifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::SupportVectorClassifier& Model::_internal_supportvectorclassifier() const {
  return _internal_has_supportvectorclassifier()
      ? *Type_.supportvectorclassifier_
      : reinterpret_cast< ::CoreML::Specification::SupportVectorClassifier&>(::CoreML::Specification::_SupportVectorClassifier_default_instance_);
}
inline const ::CoreML::Specification::SupportVectorClassifier& Model::supportvectorclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.supportVectorClassifier)
  return _internal_supportvectorclassifier();
}
inline ::CoreML::Specification::SupportVectorClassifier* Model::unsafe_arena_release_supportvectorclassifier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.supportVectorClassifier)
  if (_internal_has_supportvectorclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::SupportVectorClassifier* temp = Type_.supportvectorclassifier_;
    Type_.supportvectorclassifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_supportvectorclassifier(::CoreML::Specification::SupportVectorClassifier* supportvectorclassifier) {
  clear_Type();
  if (supportvectorclassifier) {
    set_has_supportvectorclassifier();
    Type_.supportvectorclassifier_ = supportvectorclassifier;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.supportVectorClassifier)
}
inline ::CoreML::Specification::SupportVectorClassifier* Model::_internal_mutable_supportvectorclassifier() {
  if (!_internal_has_supportvectorclassifier()) {
    clear_Type();
    set_has_supportvectorclassifier();
    Type_.supportvectorclassifier_ = CreateMaybeMessage< ::CoreML::Specification::SupportVectorClassifier >(GetArenaForAllocation());
  }
  return Type_.supportvectorclassifier_;
}
inline ::CoreML::Specification::SupportVectorClassifier* Model::mutable_supportvectorclassifier() {
  ::CoreML::Specification::SupportVectorClassifier* _msg = _internal_mutable_supportvectorclassifier();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.supportVectorClassifier)
  return _msg;
}

// .CoreML.Specification.TreeEnsembleClassifier treeEnsembleClassifier = 402;
inline bool Model::_internal_has_treeensembleclassifier() const {
  return Type_case() == kTreeEnsembleClassifier;
}
inline bool Model::has_treeensembleclassifier() const {
  return _internal_has_treeensembleclassifier();
}
inline void Model::set_has_treeensembleclassifier() {
  _oneof_case_[0] = kTreeEnsembleClassifier;
}
inline ::CoreML::Specification::TreeEnsembleClassifier* Model::release_treeensembleclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.treeEnsembleClassifier)
  if (_internal_has_treeensembleclassifier()) {
    clear_has_Type();
      ::CoreML::Specification::TreeEnsembleClassifier* temp = Type_.treeensembleclassifier_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.treeensembleclassifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::TreeEnsembleClassifier& Model::_internal_treeensembleclassifier() const {
  return _internal_has_treeensembleclassifier()
      ? *Type_.treeensembleclassifier_
      : reinterpret_cast< ::CoreML::Specification::TreeEnsembleClassifier&>(::CoreML::Specification::_TreeEnsembleClassifier_default_instance_);
}
inline const ::CoreML::Specification::TreeEnsembleClassifier& Model::treeensembleclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.treeEnsembleClassifier)
  return _internal_treeensembleclassifier();
}
inline ::CoreML::Specification::TreeEnsembleClassifier* Model::unsafe_arena_release_treeensembleclassifier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.treeEnsembleClassifier)
  if (_internal_has_treeensembleclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::TreeEnsembleClassifier* temp = Type_.treeensembleclassifier_;
    Type_.treeensembleclassifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_treeensembleclassifier(::CoreML::Specification::TreeEnsembleClassifier* treeensembleclassifier) {
  clear_Type();
  if (treeensembleclassifier) {
    set_has_treeensembleclassifier();
    Type_.treeensembleclassifier_ = treeensembleclassifier;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.treeEnsembleClassifier)
}
inline ::CoreML::Specification::TreeEnsembleClassifier* Model::_internal_mutable_treeensembleclassifier() {
  if (!_internal_has_treeensembleclassifier()) {
    clear_Type();
    set_has_treeensembleclassifier();
    Type_.treeensembleclassifier_ = CreateMaybeMessage< ::CoreML::Specification::TreeEnsembleClassifier >(GetArenaForAllocation());
  }
  return Type_.treeensembleclassifier_;
}
inline ::CoreML::Specification::TreeEnsembleClassifier* Model::mutable_treeensembleclassifier() {
  ::CoreML::Specification::TreeEnsembleClassifier* _msg = _internal_mutable_treeensembleclassifier();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.treeEnsembleClassifier)
  return _msg;
}

// .CoreML.Specification.NeuralNetworkClassifier neuralNetworkClassifier = 403;
inline bool Model::_internal_has_neuralnetworkclassifier() const {
  return Type_case() == kNeuralNetworkClassifier;
}
inline bool Model::has_neuralnetworkclassifier() const {
  return _internal_has_neuralnetworkclassifier();
}
inline void Model::set_has_neuralnetworkclassifier() {
  _oneof_case_[0] = kNeuralNetworkClassifier;
}
inline ::CoreML::Specification::NeuralNetworkClassifier* Model::release_neuralnetworkclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.neuralNetworkClassifier)
  if (_internal_has_neuralnetworkclassifier()) {
    clear_has_Type();
      ::CoreML::Specification::NeuralNetworkClassifier* temp = Type_.neuralnetworkclassifier_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.neuralnetworkclassifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::NeuralNetworkClassifier& Model::_internal_neuralnetworkclassifier() const {
  return _internal_has_neuralnetworkclassifier()
      ? *Type_.neuralnetworkclassifier_
      : reinterpret_cast< ::CoreML::Specification::NeuralNetworkClassifier&>(::CoreML::Specification::_NeuralNetworkClassifier_default_instance_);
}
inline const ::CoreML::Specification::NeuralNetworkClassifier& Model::neuralnetworkclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.neuralNetworkClassifier)
  return _internal_neuralnetworkclassifier();
}
inline ::CoreML::Specification::NeuralNetworkClassifier* Model::unsafe_arena_release_neuralnetworkclassifier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.neuralNetworkClassifier)
  if (_internal_has_neuralnetworkclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::NeuralNetworkClassifier* temp = Type_.neuralnetworkclassifier_;
    Type_.neuralnetworkclassifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_neuralnetworkclassifier(::CoreML::Specification::NeuralNetworkClassifier* neuralnetworkclassifier) {
  clear_Type();
  if (neuralnetworkclassifier) {
    set_has_neuralnetworkclassifier();
    Type_.neuralnetworkclassifier_ = neuralnetworkclassifier;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.neuralNetworkClassifier)
}
inline ::CoreML::Specification::NeuralNetworkClassifier* Model::_internal_mutable_neuralnetworkclassifier() {
  if (!_internal_has_neuralnetworkclassifier()) {
    clear_Type();
    set_has_neuralnetworkclassifier();
    Type_.neuralnetworkclassifier_ = CreateMaybeMessage< ::CoreML::Specification::NeuralNetworkClassifier >(GetArenaForAllocation());
  }
  return Type_.neuralnetworkclassifier_;
}
inline ::CoreML::Specification::NeuralNetworkClassifier* Model::mutable_neuralnetworkclassifier() {
  ::CoreML::Specification::NeuralNetworkClassifier* _msg = _internal_mutable_neuralnetworkclassifier();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.neuralNetworkClassifier)
  return _msg;
}

// .CoreML.Specification.KNearestNeighborsClassifier kNearestNeighborsClassifier = 404;
inline bool Model::_internal_has_knearestneighborsclassifier() const {
  return Type_case() == kKNearestNeighborsClassifier;
}
inline bool Model::has_knearestneighborsclassifier() const {
  return _internal_has_knearestneighborsclassifier();
}
inline void Model::set_has_knearestneighborsclassifier() {
  _oneof_case_[0] = kKNearestNeighborsClassifier;
}
inline ::CoreML::Specification::KNearestNeighborsClassifier* Model::release_knearestneighborsclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.kNearestNeighborsClassifier)
  if (_internal_has_knearestneighborsclassifier()) {
    clear_has_Type();
      ::CoreML::Specification::KNearestNeighborsClassifier* temp = Type_.knearestneighborsclassifier_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.knearestneighborsclassifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::KNearestNeighborsClassifier& Model::_internal_knearestneighborsclassifier() const {
  return _internal_has_knearestneighborsclassifier()
      ? *Type_.knearestneighborsclassifier_
      : reinterpret_cast< ::CoreML::Specification::KNearestNeighborsClassifier&>(::CoreML::Specification::_KNearestNeighborsClassifier_default_instance_);
}
inline const ::CoreML::Specification::KNearestNeighborsClassifier& Model::knearestneighborsclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.kNearestNeighborsClassifier)
  return _internal_knearestneighborsclassifier();
}
inline ::CoreML::Specification::KNearestNeighborsClassifier* Model::unsafe_arena_release_knearestneighborsclassifier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.kNearestNeighborsClassifier)
  if (_internal_has_knearestneighborsclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::KNearestNeighborsClassifier* temp = Type_.knearestneighborsclassifier_;
    Type_.knearestneighborsclassifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_knearestneighborsclassifier(::CoreML::Specification::KNearestNeighborsClassifier* knearestneighborsclassifier) {
  clear_Type();
  if (knearestneighborsclassifier) {
    set_has_knearestneighborsclassifier();
    Type_.knearestneighborsclassifier_ = knearestneighborsclassifier;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.kNearestNeighborsClassifier)
}
inline ::CoreML::Specification::KNearestNeighborsClassifier* Model::_internal_mutable_knearestneighborsclassifier() {
  if (!_internal_has_knearestneighborsclassifier()) {
    clear_Type();
    set_has_knearestneighborsclassifier();
    Type_.knearestneighborsclassifier_ = CreateMaybeMessage< ::CoreML::Specification::KNearestNeighborsClassifier >(GetArenaForAllocation());
  }
  return Type_.knearestneighborsclassifier_;
}
inline ::CoreML::Specification::KNearestNeighborsClassifier* Model::mutable_knearestneighborsclassifier() {
  ::CoreML::Specification::KNearestNeighborsClassifier* _msg = _internal_mutable_knearestneighborsclassifier();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.kNearestNeighborsClassifier)
  return _msg;
}

// .CoreML.Specification.NeuralNetwork neuralNetwork = 500;
inline bool Model::_internal_has_neuralnetwork() const {
  return Type_case() == kNeuralNetwork;
}
inline bool Model::has_neuralnetwork() const {
  return _internal_has_neuralnetwork();
}
inline void Model::set_has_neuralnetwork() {
  _oneof_case_[0] = kNeuralNetwork;
}
inline ::CoreML::Specification::NeuralNetwork* Model::release_neuralnetwork() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.neuralNetwork)
  if (_internal_has_neuralnetwork()) {
    clear_has_Type();
      ::CoreML::Specification::NeuralNetwork* temp = Type_.neuralnetwork_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.neuralnetwork_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::NeuralNetwork& Model::_internal_neuralnetwork() const {
  return _internal_has_neuralnetwork()
      ? *Type_.neuralnetwork_
      : reinterpret_cast< ::CoreML::Specification::NeuralNetwork&>(::CoreML::Specification::_NeuralNetwork_default_instance_);
}
inline const ::CoreML::Specification::NeuralNetwork& Model::neuralnetwork() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.neuralNetwork)
  return _internal_neuralnetwork();
}
inline ::CoreML::Specification::NeuralNetwork* Model::unsafe_arena_release_neuralnetwork() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.neuralNetwork)
  if (_internal_has_neuralnetwork()) {
    clear_has_Type();
    ::CoreML::Specification::NeuralNetwork* temp = Type_.neuralnetwork_;
    Type_.neuralnetwork_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_neuralnetwork(::CoreML::Specification::NeuralNetwork* neuralnetwork) {
  clear_Type();
  if (neuralnetwork) {
    set_has_neuralnetwork();
    Type_.neuralnetwork_ = neuralnetwork;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.neuralNetwork)
}
inline ::CoreML::Specification::NeuralNetwork* Model::_internal_mutable_neuralnetwork() {
  if (!_internal_has_neuralnetwork()) {
    clear_Type();
    set_has_neuralnetwork();
    Type_.neuralnetwork_ = CreateMaybeMessage< ::CoreML::Specification::NeuralNetwork >(GetArenaForAllocation());
  }
  return Type_.neuralnetwork_;
}
inline ::CoreML::Specification::NeuralNetwork* Model::mutable_neuralnetwork() {
  ::CoreML::Specification::NeuralNetwork* _msg = _internal_mutable_neuralnetwork();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.neuralNetwork)
  return _msg;
}

// .CoreML.Specification.ItemSimilarityRecommender itemSimilarityRecommender = 501;
inline bool Model::_internal_has_itemsimilarityrecommender() const {
  return Type_case() == kItemSimilarityRecommender;
}
inline bool Model::has_itemsimilarityrecommender() const {
  return _internal_has_itemsimilarityrecommender();
}
inline void Model::set_has_itemsimilarityrecommender() {
  _oneof_case_[0] = kItemSimilarityRecommender;
}
inline ::CoreML::Specification::ItemSimilarityRecommender* Model::release_itemsimilarityrecommender() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.itemSimilarityRecommender)
  if (_internal_has_itemsimilarityrecommender()) {
    clear_has_Type();
      ::CoreML::Specification::ItemSimilarityRecommender* temp = Type_.itemsimilarityrecommender_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.itemsimilarityrecommender_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::ItemSimilarityRecommender& Model::_internal_itemsimilarityrecommender() const {
  return _internal_has_itemsimilarityrecommender()
      ? *Type_.itemsimilarityrecommender_
      : reinterpret_cast< ::CoreML::Specification::ItemSimilarityRecommender&>(::CoreML::Specification::_ItemSimilarityRecommender_default_instance_);
}
inline const ::CoreML::Specification::ItemSimilarityRecommender& Model::itemsimilarityrecommender() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.itemSimilarityRecommender)
  return _internal_itemsimilarityrecommender();
}
inline ::CoreML::Specification::ItemSimilarityRecommender* Model::unsafe_arena_release_itemsimilarityrecommender() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.itemSimilarityRecommender)
  if (_internal_has_itemsimilarityrecommender()) {
    clear_has_Type();
    ::CoreML::Specification::ItemSimilarityRecommender* temp = Type_.itemsimilarityrecommender_;
    Type_.itemsimilarityrecommender_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_itemsimilarityrecommender(::CoreML::Specification::ItemSimilarityRecommender* itemsimilarityrecommender) {
  clear_Type();
  if (itemsimilarityrecommender) {
    set_has_itemsimilarityrecommender();
    Type_.itemsimilarityrecommender_ = itemsimilarityrecommender;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.itemSimilarityRecommender)
}
inline ::CoreML::Specification::ItemSimilarityRecommender* Model::_internal_mutable_itemsimilarityrecommender() {
  if (!_internal_has_itemsimilarityrecommender()) {
    clear_Type();
    set_has_itemsimilarityrecommender();
    Type_.itemsimilarityrecommender_ = CreateMaybeMessage< ::CoreML::Specification::ItemSimilarityRecommender >(GetArenaForAllocation());
  }
  return Type_.itemsimilarityrecommender_;
}
inline ::CoreML::Specification::ItemSimilarityRecommender* Model::mutable_itemsimilarityrecommender() {
  ::CoreML::Specification::ItemSimilarityRecommender* _msg = _internal_mutable_itemsimilarityrecommender();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.itemSimilarityRecommender)
  return _msg;
}

// .CoreML.Specification.MILSpec.Program mlProgram = 502;
inline bool Model::_internal_has_mlprogram() const {
  return Type_case() == kMlProgram;
}
inline bool Model::has_mlprogram() const {
  return _internal_has_mlprogram();
}
inline void Model::set_has_mlprogram() {
  _oneof_case_[0] = kMlProgram;
}
inline ::CoreML::Specification::MILSpec::Program* Model::release_mlprogram() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.mlProgram)
  if (_internal_has_mlprogram()) {
    clear_has_Type();
      ::CoreML::Specification::MILSpec::Program* temp = Type_.mlprogram_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.mlprogram_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::Program& Model::_internal_mlprogram() const {
  return _internal_has_mlprogram()
      ? *Type_.mlprogram_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::Program&>(::CoreML::Specification::MILSpec::_Program_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::Program& Model::mlprogram() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.mlProgram)
  return _internal_mlprogram();
}
inline ::CoreML::Specification::MILSpec::Program* Model::unsafe_arena_release_mlprogram() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.mlProgram)
  if (_internal_has_mlprogram()) {
    clear_has_Type();
    ::CoreML::Specification::MILSpec::Program* temp = Type_.mlprogram_;
    Type_.mlprogram_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_mlprogram(::CoreML::Specification::MILSpec::Program* mlprogram) {
  clear_Type();
  if (mlprogram) {
    set_has_mlprogram();
    Type_.mlprogram_ = mlprogram;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.mlProgram)
}
inline ::CoreML::Specification::MILSpec::Program* Model::_internal_mutable_mlprogram() {
  if (!_internal_has_mlprogram()) {
    clear_Type();
    set_has_mlprogram();
    Type_.mlprogram_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::Program >(GetArenaForAllocation());
  }
  return Type_.mlprogram_;
}
inline ::CoreML::Specification::MILSpec::Program* Model::mutable_mlprogram() {
  ::CoreML::Specification::MILSpec::Program* _msg = _internal_mutable_mlprogram();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.mlProgram)
  return _msg;
}

// .CoreML.Specification.CustomModel customModel = 555;
inline bool Model::_internal_has_custommodel() const {
  return Type_case() == kCustomModel;
}
inline bool Model::has_custommodel() const {
  return _internal_has_custommodel();
}
inline void Model::set_has_custommodel() {
  _oneof_case_[0] = kCustomModel;
}
inline ::CoreML::Specification::CustomModel* Model::release_custommodel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.customModel)
  if (_internal_has_custommodel()) {
    clear_has_Type();
      ::CoreML::Specification::CustomModel* temp = Type_.custommodel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.custommodel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::CustomModel& Model::_internal_custommodel() const {
  return _internal_has_custommodel()
      ? *Type_.custommodel_
      : reinterpret_cast< ::CoreML::Specification::CustomModel&>(::CoreML::Specification::_CustomModel_default_instance_);
}
inline const ::CoreML::Specification::CustomModel& Model::custommodel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.customModel)
  return _internal_custommodel();
}
inline ::CoreML::Specification::CustomModel* Model::unsafe_arena_release_custommodel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.customModel)
  if (_internal_has_custommodel()) {
    clear_has_Type();
    ::CoreML::Specification::CustomModel* temp = Type_.custommodel_;
    Type_.custommodel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_custommodel(::CoreML::Specification::CustomModel* custommodel) {
  clear_Type();
  if (custommodel) {
    set_has_custommodel();
    Type_.custommodel_ = custommodel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.customModel)
}
inline ::CoreML::Specification::CustomModel* Model::_internal_mutable_custommodel() {
  if (!_internal_has_custommodel()) {
    clear_Type();
    set_has_custommodel();
    Type_.custommodel_ = CreateMaybeMessage< ::CoreML::Specification::CustomModel >(GetArenaForAllocation());
  }
  return Type_.custommodel_;
}
inline ::CoreML::Specification::CustomModel* Model::mutable_custommodel() {
  ::CoreML::Specification::CustomModel* _msg = _internal_mutable_custommodel();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.customModel)
  return _msg;
}

// .CoreML.Specification.LinkedModel linkedModel = 556;
inline bool Model::_internal_has_linkedmodel() const {
  return Type_case() == kLinkedModel;
}
inline bool Model::has_linkedmodel() const {
  return _internal_has_linkedmodel();
}
inline void Model::set_has_linkedmodel() {
  _oneof_case_[0] = kLinkedModel;
}
inline ::CoreML::Specification::LinkedModel* Model::release_linkedmodel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.linkedModel)
  if (_internal_has_linkedmodel()) {
    clear_has_Type();
      ::CoreML::Specification::LinkedModel* temp = Type_.linkedmodel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.linkedmodel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::LinkedModel& Model::_internal_linkedmodel() const {
  return _internal_has_linkedmodel()
      ? *Type_.linkedmodel_
      : reinterpret_cast< ::CoreML::Specification::LinkedModel&>(::CoreML::Specification::_LinkedModel_default_instance_);
}
inline const ::CoreML::Specification::LinkedModel& Model::linkedmodel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.linkedModel)
  return _internal_linkedmodel();
}
inline ::CoreML::Specification::LinkedModel* Model::unsafe_arena_release_linkedmodel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.linkedModel)
  if (_internal_has_linkedmodel()) {
    clear_has_Type();
    ::CoreML::Specification::LinkedModel* temp = Type_.linkedmodel_;
    Type_.linkedmodel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_linkedmodel(::CoreML::Specification::LinkedModel* linkedmodel) {
  clear_Type();
  if (linkedmodel) {
    set_has_linkedmodel();
    Type_.linkedmodel_ = linkedmodel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.linkedModel)
}
inline ::CoreML::Specification::LinkedModel* Model::_internal_mutable_linkedmodel() {
  if (!_internal_has_linkedmodel()) {
    clear_Type();
    set_has_linkedmodel();
    Type_.linkedmodel_ = CreateMaybeMessage< ::CoreML::Specification::LinkedModel >(GetArenaForAllocation());
  }
  return Type_.linkedmodel_;
}
inline ::CoreML::Specification::LinkedModel* Model::mutable_linkedmodel() {
  ::CoreML::Specification::LinkedModel* _msg = _internal_mutable_linkedmodel();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.linkedModel)
  return _msg;
}

// .CoreML.Specification.ClassConfidenceThresholding classConfidenceThresholding = 560;
inline bool Model::_internal_has_classconfidencethresholding() const {
  return Type_case() == kClassConfidenceThresholding;
}
inline bool Model::has_classconfidencethresholding() const {
  return _internal_has_classconfidencethresholding();
}
inline void Model::set_has_classconfidencethresholding() {
  _oneof_case_[0] = kClassConfidenceThresholding;
}
inline ::CoreML::Specification::ClassConfidenceThresholding* Model::release_classconfidencethresholding() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.classConfidenceThresholding)
  if (_internal_has_classconfidencethresholding()) {
    clear_has_Type();
      ::CoreML::Specification::ClassConfidenceThresholding* temp = Type_.classconfidencethresholding_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.classconfidencethresholding_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::ClassConfidenceThresholding& Model::_internal_classconfidencethresholding() const {
  return _internal_has_classconfidencethresholding()
      ? *Type_.classconfidencethresholding_
      : reinterpret_cast< ::CoreML::Specification::ClassConfidenceThresholding&>(::CoreML::Specification::_ClassConfidenceThresholding_default_instance_);
}
inline const ::CoreML::Specification::ClassConfidenceThresholding& Model::classconfidencethresholding() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.classConfidenceThresholding)
  return _internal_classconfidencethresholding();
}
inline ::CoreML::Specification::ClassConfidenceThresholding* Model::unsafe_arena_release_classconfidencethresholding() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.classConfidenceThresholding)
  if (_internal_has_classconfidencethresholding()) {
    clear_has_Type();
    ::CoreML::Specification::ClassConfidenceThresholding* temp = Type_.classconfidencethresholding_;
    Type_.classconfidencethresholding_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_classconfidencethresholding(::CoreML::Specification::ClassConfidenceThresholding* classconfidencethresholding) {
  clear_Type();
  if (classconfidencethresholding) {
    set_has_classconfidencethresholding();
    Type_.classconfidencethresholding_ = classconfidencethresholding;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.classConfidenceThresholding)
}
inline ::CoreML::Specification::ClassConfidenceThresholding* Model::_internal_mutable_classconfidencethresholding() {
  if (!_internal_has_classconfidencethresholding()) {
    clear_Type();
    set_has_classconfidencethresholding();
    Type_.classconfidencethresholding_ = CreateMaybeMessage< ::CoreML::Specification::ClassConfidenceThresholding >(GetArenaForAllocation());
  }
  return Type_.classconfidencethresholding_;
}
inline ::CoreML::Specification::ClassConfidenceThresholding* Model::mutable_classconfidencethresholding() {
  ::CoreML::Specification::ClassConfidenceThresholding* _msg = _internal_mutable_classconfidencethresholding();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.classConfidenceThresholding)
  return _msg;
}

// .CoreML.Specification.OneHotEncoder oneHotEncoder = 600;
inline bool Model::_internal_has_onehotencoder() const {
  return Type_case() == kOneHotEncoder;
}
inline bool Model::has_onehotencoder() const {
  return _internal_has_onehotencoder();
}
inline void Model::set_has_onehotencoder() {
  _oneof_case_[0] = kOneHotEncoder;
}
inline ::CoreML::Specification::OneHotEncoder* Model::release_onehotencoder() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.oneHotEncoder)
  if (_internal_has_onehotencoder()) {
    clear_has_Type();
      ::CoreML::Specification::OneHotEncoder* temp = Type_.onehotencoder_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.onehotencoder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::OneHotEncoder& Model::_internal_onehotencoder() const {
  return _internal_has_onehotencoder()
      ? *Type_.onehotencoder_
      : reinterpret_cast< ::CoreML::Specification::OneHotEncoder&>(::CoreML::Specification::_OneHotEncoder_default_instance_);
}
inline const ::CoreML::Specification::OneHotEncoder& Model::onehotencoder() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.oneHotEncoder)
  return _internal_onehotencoder();
}
inline ::CoreML::Specification::OneHotEncoder* Model::unsafe_arena_release_onehotencoder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.oneHotEncoder)
  if (_internal_has_onehotencoder()) {
    clear_has_Type();
    ::CoreML::Specification::OneHotEncoder* temp = Type_.onehotencoder_;
    Type_.onehotencoder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_onehotencoder(::CoreML::Specification::OneHotEncoder* onehotencoder) {
  clear_Type();
  if (onehotencoder) {
    set_has_onehotencoder();
    Type_.onehotencoder_ = onehotencoder;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.oneHotEncoder)
}
inline ::CoreML::Specification::OneHotEncoder* Model::_internal_mutable_onehotencoder() {
  if (!_internal_has_onehotencoder()) {
    clear_Type();
    set_has_onehotencoder();
    Type_.onehotencoder_ = CreateMaybeMessage< ::CoreML::Specification::OneHotEncoder >(GetArenaForAllocation());
  }
  return Type_.onehotencoder_;
}
inline ::CoreML::Specification::OneHotEncoder* Model::mutable_onehotencoder() {
  ::CoreML::Specification::OneHotEncoder* _msg = _internal_mutable_onehotencoder();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.oneHotEncoder)
  return _msg;
}

// .CoreML.Specification.Imputer imputer = 601;
inline bool Model::_internal_has_imputer() const {
  return Type_case() == kImputer;
}
inline bool Model::has_imputer() const {
  return _internal_has_imputer();
}
inline void Model::set_has_imputer() {
  _oneof_case_[0] = kImputer;
}
inline ::CoreML::Specification::Imputer* Model::release_imputer() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.imputer)
  if (_internal_has_imputer()) {
    clear_has_Type();
      ::CoreML::Specification::Imputer* temp = Type_.imputer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.imputer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::Imputer& Model::_internal_imputer() const {
  return _internal_has_imputer()
      ? *Type_.imputer_
      : reinterpret_cast< ::CoreML::Specification::Imputer&>(::CoreML::Specification::_Imputer_default_instance_);
}
inline const ::CoreML::Specification::Imputer& Model::imputer() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.imputer)
  return _internal_imputer();
}
inline ::CoreML::Specification::Imputer* Model::unsafe_arena_release_imputer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.imputer)
  if (_internal_has_imputer()) {
    clear_has_Type();
    ::CoreML::Specification::Imputer* temp = Type_.imputer_;
    Type_.imputer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_imputer(::CoreML::Specification::Imputer* imputer) {
  clear_Type();
  if (imputer) {
    set_has_imputer();
    Type_.imputer_ = imputer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.imputer)
}
inline ::CoreML::Specification::Imputer* Model::_internal_mutable_imputer() {
  if (!_internal_has_imputer()) {
    clear_Type();
    set_has_imputer();
    Type_.imputer_ = CreateMaybeMessage< ::CoreML::Specification::Imputer >(GetArenaForAllocation());
  }
  return Type_.imputer_;
}
inline ::CoreML::Specification::Imputer* Model::mutable_imputer() {
  ::CoreML::Specification::Imputer* _msg = _internal_mutable_imputer();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.imputer)
  return _msg;
}

// .CoreML.Specification.FeatureVectorizer featureVectorizer = 602;
inline bool Model::_internal_has_featurevectorizer() const {
  return Type_case() == kFeatureVectorizer;
}
inline bool Model::has_featurevectorizer() const {
  return _internal_has_featurevectorizer();
}
inline void Model::set_has_featurevectorizer() {
  _oneof_case_[0] = kFeatureVectorizer;
}
inline ::CoreML::Specification::FeatureVectorizer* Model::release_featurevectorizer() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.featureVectorizer)
  if (_internal_has_featurevectorizer()) {
    clear_has_Type();
      ::CoreML::Specification::FeatureVectorizer* temp = Type_.featurevectorizer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.featurevectorizer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::FeatureVectorizer& Model::_internal_featurevectorizer() const {
  return _internal_has_featurevectorizer()
      ? *Type_.featurevectorizer_
      : reinterpret_cast< ::CoreML::Specification::FeatureVectorizer&>(::CoreML::Specification::_FeatureVectorizer_default_instance_);
}
inline const ::CoreML::Specification::FeatureVectorizer& Model::featurevectorizer() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.featureVectorizer)
  return _internal_featurevectorizer();
}
inline ::CoreML::Specification::FeatureVectorizer* Model::unsafe_arena_release_featurevectorizer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.featureVectorizer)
  if (_internal_has_featurevectorizer()) {
    clear_has_Type();
    ::CoreML::Specification::FeatureVectorizer* temp = Type_.featurevectorizer_;
    Type_.featurevectorizer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_featurevectorizer(::CoreML::Specification::FeatureVectorizer* featurevectorizer) {
  clear_Type();
  if (featurevectorizer) {
    set_has_featurevectorizer();
    Type_.featurevectorizer_ = featurevectorizer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.featureVectorizer)
}
inline ::CoreML::Specification::FeatureVectorizer* Model::_internal_mutable_featurevectorizer() {
  if (!_internal_has_featurevectorizer()) {
    clear_Type();
    set_has_featurevectorizer();
    Type_.featurevectorizer_ = CreateMaybeMessage< ::CoreML::Specification::FeatureVectorizer >(GetArenaForAllocation());
  }
  return Type_.featurevectorizer_;
}
inline ::CoreML::Specification::FeatureVectorizer* Model::mutable_featurevectorizer() {
  ::CoreML::Specification::FeatureVectorizer* _msg = _internal_mutable_featurevectorizer();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.featureVectorizer)
  return _msg;
}

// .CoreML.Specification.DictVectorizer dictVectorizer = 603;
inline bool Model::_internal_has_dictvectorizer() const {
  return Type_case() == kDictVectorizer;
}
inline bool Model::has_dictvectorizer() const {
  return _internal_has_dictvectorizer();
}
inline void Model::set_has_dictvectorizer() {
  _oneof_case_[0] = kDictVectorizer;
}
inline ::CoreML::Specification::DictVectorizer* Model::release_dictvectorizer() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.dictVectorizer)
  if (_internal_has_dictvectorizer()) {
    clear_has_Type();
      ::CoreML::Specification::DictVectorizer* temp = Type_.dictvectorizer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.dictvectorizer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::DictVectorizer& Model::_internal_dictvectorizer() const {
  return _internal_has_dictvectorizer()
      ? *Type_.dictvectorizer_
      : reinterpret_cast< ::CoreML::Specification::DictVectorizer&>(::CoreML::Specification::_DictVectorizer_default_instance_);
}
inline const ::CoreML::Specification::DictVectorizer& Model::dictvectorizer() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.dictVectorizer)
  return _internal_dictvectorizer();
}
inline ::CoreML::Specification::DictVectorizer* Model::unsafe_arena_release_dictvectorizer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.dictVectorizer)
  if (_internal_has_dictvectorizer()) {
    clear_has_Type();
    ::CoreML::Specification::DictVectorizer* temp = Type_.dictvectorizer_;
    Type_.dictvectorizer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_dictvectorizer(::CoreML::Specification::DictVectorizer* dictvectorizer) {
  clear_Type();
  if (dictvectorizer) {
    set_has_dictvectorizer();
    Type_.dictvectorizer_ = dictvectorizer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.dictVectorizer)
}
inline ::CoreML::Specification::DictVectorizer* Model::_internal_mutable_dictvectorizer() {
  if (!_internal_has_dictvectorizer()) {
    clear_Type();
    set_has_dictvectorizer();
    Type_.dictvectorizer_ = CreateMaybeMessage< ::CoreML::Specification::DictVectorizer >(GetArenaForAllocation());
  }
  return Type_.dictvectorizer_;
}
inline ::CoreML::Specification::DictVectorizer* Model::mutable_dictvectorizer() {
  ::CoreML::Specification::DictVectorizer* _msg = _internal_mutable_dictvectorizer();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.dictVectorizer)
  return _msg;
}

// .CoreML.Specification.Scaler scaler = 604;
inline bool Model::_internal_has_scaler() const {
  return Type_case() == kScaler;
}
inline bool Model::has_scaler() const {
  return _internal_has_scaler();
}
inline void Model::set_has_scaler() {
  _oneof_case_[0] = kScaler;
}
inline ::CoreML::Specification::Scaler* Model::release_scaler() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.scaler)
  if (_internal_has_scaler()) {
    clear_has_Type();
      ::CoreML::Specification::Scaler* temp = Type_.scaler_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.scaler_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::Scaler& Model::_internal_scaler() const {
  return _internal_has_scaler()
      ? *Type_.scaler_
      : reinterpret_cast< ::CoreML::Specification::Scaler&>(::CoreML::Specification::_Scaler_default_instance_);
}
inline const ::CoreML::Specification::Scaler& Model::scaler() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.scaler)
  return _internal_scaler();
}
inline ::CoreML::Specification::Scaler* Model::unsafe_arena_release_scaler() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.scaler)
  if (_internal_has_scaler()) {
    clear_has_Type();
    ::CoreML::Specification::Scaler* temp = Type_.scaler_;
    Type_.scaler_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_scaler(::CoreML::Specification::Scaler* scaler) {
  clear_Type();
  if (scaler) {
    set_has_scaler();
    Type_.scaler_ = scaler;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.scaler)
}
inline ::CoreML::Specification::Scaler* Model::_internal_mutable_scaler() {
  if (!_internal_has_scaler()) {
    clear_Type();
    set_has_scaler();
    Type_.scaler_ = CreateMaybeMessage< ::CoreML::Specification::Scaler >(GetArenaForAllocation());
  }
  return Type_.scaler_;
}
inline ::CoreML::Specification::Scaler* Model::mutable_scaler() {
  ::CoreML::Specification::Scaler* _msg = _internal_mutable_scaler();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.scaler)
  return _msg;
}

// .CoreML.Specification.CategoricalMapping categoricalMapping = 606;
inline bool Model::_internal_has_categoricalmapping() const {
  return Type_case() == kCategoricalMapping;
}
inline bool Model::has_categoricalmapping() const {
  return _internal_has_categoricalmapping();
}
inline void Model::set_has_categoricalmapping() {
  _oneof_case_[0] = kCategoricalMapping;
}
inline ::CoreML::Specification::CategoricalMapping* Model::release_categoricalmapping() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.categoricalMapping)
  if (_internal_has_categoricalmapping()) {
    clear_has_Type();
      ::CoreML::Specification::CategoricalMapping* temp = Type_.categoricalmapping_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.categoricalmapping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::CategoricalMapping& Model::_internal_categoricalmapping() const {
  return _internal_has_categoricalmapping()
      ? *Type_.categoricalmapping_
      : reinterpret_cast< ::CoreML::Specification::CategoricalMapping&>(::CoreML::Specification::_CategoricalMapping_default_instance_);
}
inline const ::CoreML::Specification::CategoricalMapping& Model::categoricalmapping() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.categoricalMapping)
  return _internal_categoricalmapping();
}
inline ::CoreML::Specification::CategoricalMapping* Model::unsafe_arena_release_categoricalmapping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.categoricalMapping)
  if (_internal_has_categoricalmapping()) {
    clear_has_Type();
    ::CoreML::Specification::CategoricalMapping* temp = Type_.categoricalmapping_;
    Type_.categoricalmapping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_categoricalmapping(::CoreML::Specification::CategoricalMapping* categoricalmapping) {
  clear_Type();
  if (categoricalmapping) {
    set_has_categoricalmapping();
    Type_.categoricalmapping_ = categoricalmapping;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.categoricalMapping)
}
inline ::CoreML::Specification::CategoricalMapping* Model::_internal_mutable_categoricalmapping() {
  if (!_internal_has_categoricalmapping()) {
    clear_Type();
    set_has_categoricalmapping();
    Type_.categoricalmapping_ = CreateMaybeMessage< ::CoreML::Specification::CategoricalMapping >(GetArenaForAllocation());
  }
  return Type_.categoricalmapping_;
}
inline ::CoreML::Specification::CategoricalMapping* Model::mutable_categoricalmapping() {
  ::CoreML::Specification::CategoricalMapping* _msg = _internal_mutable_categoricalmapping();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.categoricalMapping)
  return _msg;
}

// .CoreML.Specification.Normalizer normalizer = 607;
inline bool Model::_internal_has_normalizer() const {
  return Type_case() == kNormalizer;
}
inline bool Model::has_normalizer() const {
  return _internal_has_normalizer();
}
inline void Model::set_has_normalizer() {
  _oneof_case_[0] = kNormalizer;
}
inline ::CoreML::Specification::Normalizer* Model::release_normalizer() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.normalizer)
  if (_internal_has_normalizer()) {
    clear_has_Type();
      ::CoreML::Specification::Normalizer* temp = Type_.normalizer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.normalizer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::Normalizer& Model::_internal_normalizer() const {
  return _internal_has_normalizer()
      ? *Type_.normalizer_
      : reinterpret_cast< ::CoreML::Specification::Normalizer&>(::CoreML::Specification::_Normalizer_default_instance_);
}
inline const ::CoreML::Specification::Normalizer& Model::normalizer() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.normalizer)
  return _internal_normalizer();
}
inline ::CoreML::Specification::Normalizer* Model::unsafe_arena_release_normalizer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.normalizer)
  if (_internal_has_normalizer()) {
    clear_has_Type();
    ::CoreML::Specification::Normalizer* temp = Type_.normalizer_;
    Type_.normalizer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_normalizer(::CoreML::Specification::Normalizer* normalizer) {
  clear_Type();
  if (normalizer) {
    set_has_normalizer();
    Type_.normalizer_ = normalizer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.normalizer)
}
inline ::CoreML::Specification::Normalizer* Model::_internal_mutable_normalizer() {
  if (!_internal_has_normalizer()) {
    clear_Type();
    set_has_normalizer();
    Type_.normalizer_ = CreateMaybeMessage< ::CoreML::Specification::Normalizer >(GetArenaForAllocation());
  }
  return Type_.normalizer_;
}
inline ::CoreML::Specification::Normalizer* Model::mutable_normalizer() {
  ::CoreML::Specification::Normalizer* _msg = _internal_mutable_normalizer();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.normalizer)
  return _msg;
}

// .CoreML.Specification.ArrayFeatureExtractor arrayFeatureExtractor = 609;
inline bool Model::_internal_has_arrayfeatureextractor() const {
  return Type_case() == kArrayFeatureExtractor;
}
inline bool Model::has_arrayfeatureextractor() const {
  return _internal_has_arrayfeatureextractor();
}
inline void Model::set_has_arrayfeatureextractor() {
  _oneof_case_[0] = kArrayFeatureExtractor;
}
inline ::CoreML::Specification::ArrayFeatureExtractor* Model::release_arrayfeatureextractor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.arrayFeatureExtractor)
  if (_internal_has_arrayfeatureextractor()) {
    clear_has_Type();
      ::CoreML::Specification::ArrayFeatureExtractor* temp = Type_.arrayfeatureextractor_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.arrayfeatureextractor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::ArrayFeatureExtractor& Model::_internal_arrayfeatureextractor() const {
  return _internal_has_arrayfeatureextractor()
      ? *Type_.arrayfeatureextractor_
      : reinterpret_cast< ::CoreML::Specification::ArrayFeatureExtractor&>(::CoreML::Specification::_ArrayFeatureExtractor_default_instance_);
}
inline const ::CoreML::Specification::ArrayFeatureExtractor& Model::arrayfeatureextractor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.arrayFeatureExtractor)
  return _internal_arrayfeatureextractor();
}
inline ::CoreML::Specification::ArrayFeatureExtractor* Model::unsafe_arena_release_arrayfeatureextractor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.arrayFeatureExtractor)
  if (_internal_has_arrayfeatureextractor()) {
    clear_has_Type();
    ::CoreML::Specification::ArrayFeatureExtractor* temp = Type_.arrayfeatureextractor_;
    Type_.arrayfeatureextractor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_arrayfeatureextractor(::CoreML::Specification::ArrayFeatureExtractor* arrayfeatureextractor) {
  clear_Type();
  if (arrayfeatureextractor) {
    set_has_arrayfeatureextractor();
    Type_.arrayfeatureextractor_ = arrayfeatureextractor;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.arrayFeatureExtractor)
}
inline ::CoreML::Specification::ArrayFeatureExtractor* Model::_internal_mutable_arrayfeatureextractor() {
  if (!_internal_has_arrayfeatureextractor()) {
    clear_Type();
    set_has_arrayfeatureextractor();
    Type_.arrayfeatureextractor_ = CreateMaybeMessage< ::CoreML::Specification::ArrayFeatureExtractor >(GetArenaForAllocation());
  }
  return Type_.arrayfeatureextractor_;
}
inline ::CoreML::Specification::ArrayFeatureExtractor* Model::mutable_arrayfeatureextractor() {
  ::CoreML::Specification::ArrayFeatureExtractor* _msg = _internal_mutable_arrayfeatureextractor();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.arrayFeatureExtractor)
  return _msg;
}

// .CoreML.Specification.NonMaximumSuppression nonMaximumSuppression = 610;
inline bool Model::_internal_has_nonmaximumsuppression() const {
  return Type_case() == kNonMaximumSuppression;
}
inline bool Model::has_nonmaximumsuppression() const {
  return _internal_has_nonmaximumsuppression();
}
inline void Model::set_has_nonmaximumsuppression() {
  _oneof_case_[0] = kNonMaximumSuppression;
}
inline ::CoreML::Specification::NonMaximumSuppression* Model::release_nonmaximumsuppression() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.nonMaximumSuppression)
  if (_internal_has_nonmaximumsuppression()) {
    clear_has_Type();
      ::CoreML::Specification::NonMaximumSuppression* temp = Type_.nonmaximumsuppression_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.nonmaximumsuppression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::NonMaximumSuppression& Model::_internal_nonmaximumsuppression() const {
  return _internal_has_nonmaximumsuppression()
      ? *Type_.nonmaximumsuppression_
      : reinterpret_cast< ::CoreML::Specification::NonMaximumSuppression&>(::CoreML::Specification::_NonMaximumSuppression_default_instance_);
}
inline const ::CoreML::Specification::NonMaximumSuppression& Model::nonmaximumsuppression() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.nonMaximumSuppression)
  return _internal_nonmaximumsuppression();
}
inline ::CoreML::Specification::NonMaximumSuppression* Model::unsafe_arena_release_nonmaximumsuppression() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.nonMaximumSuppression)
  if (_internal_has_nonmaximumsuppression()) {
    clear_has_Type();
    ::CoreML::Specification::NonMaximumSuppression* temp = Type_.nonmaximumsuppression_;
    Type_.nonmaximumsuppression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_nonmaximumsuppression(::CoreML::Specification::NonMaximumSuppression* nonmaximumsuppression) {
  clear_Type();
  if (nonmaximumsuppression) {
    set_has_nonmaximumsuppression();
    Type_.nonmaximumsuppression_ = nonmaximumsuppression;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.nonMaximumSuppression)
}
inline ::CoreML::Specification::NonMaximumSuppression* Model::_internal_mutable_nonmaximumsuppression() {
  if (!_internal_has_nonmaximumsuppression()) {
    clear_Type();
    set_has_nonmaximumsuppression();
    Type_.nonmaximumsuppression_ = CreateMaybeMessage< ::CoreML::Specification::NonMaximumSuppression >(GetArenaForAllocation());
  }
  return Type_.nonmaximumsuppression_;
}
inline ::CoreML::Specification::NonMaximumSuppression* Model::mutable_nonmaximumsuppression() {
  ::CoreML::Specification::NonMaximumSuppression* _msg = _internal_mutable_nonmaximumsuppression();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.nonMaximumSuppression)
  return _msg;
}

// .CoreML.Specification.Identity identity = 900;
inline bool Model::_internal_has_identity() const {
  return Type_case() == kIdentity;
}
inline bool Model::has_identity() const {
  return _internal_has_identity();
}
inline void Model::set_has_identity() {
  _oneof_case_[0] = kIdentity;
}
inline ::CoreML::Specification::Identity* Model::release_identity() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.identity)
  if (_internal_has_identity()) {
    clear_has_Type();
      ::CoreML::Specification::Identity* temp = Type_.identity_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.identity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::Identity& Model::_internal_identity() const {
  return _internal_has_identity()
      ? *Type_.identity_
      : reinterpret_cast< ::CoreML::Specification::Identity&>(::CoreML::Specification::_Identity_default_instance_);
}
inline const ::CoreML::Specification::Identity& Model::identity() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.identity)
  return _internal_identity();
}
inline ::CoreML::Specification::Identity* Model::unsafe_arena_release_identity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.identity)
  if (_internal_has_identity()) {
    clear_has_Type();
    ::CoreML::Specification::Identity* temp = Type_.identity_;
    Type_.identity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_identity(::CoreML::Specification::Identity* identity) {
  clear_Type();
  if (identity) {
    set_has_identity();
    Type_.identity_ = identity;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.identity)
}
inline ::CoreML::Specification::Identity* Model::_internal_mutable_identity() {
  if (!_internal_has_identity()) {
    clear_Type();
    set_has_identity();
    Type_.identity_ = CreateMaybeMessage< ::CoreML::Specification::Identity >(GetArenaForAllocation());
  }
  return Type_.identity_;
}
inline ::CoreML::Specification::Identity* Model::mutable_identity() {
  ::CoreML::Specification::Identity* _msg = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.identity)
  return _msg;
}

// .CoreML.Specification.CoreMLModels.TextClassifier textClassifier = 2000;
inline bool Model::_internal_has_textclassifier() const {
  return Type_case() == kTextClassifier;
}
inline bool Model::has_textclassifier() const {
  return _internal_has_textclassifier();
}
inline void Model::set_has_textclassifier() {
  _oneof_case_[0] = kTextClassifier;
}
inline ::CoreML::Specification::CoreMLModels::TextClassifier* Model::release_textclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.textClassifier)
  if (_internal_has_textclassifier()) {
    clear_has_Type();
      ::CoreML::Specification::CoreMLModels::TextClassifier* temp = Type_.textclassifier_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.textclassifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::CoreMLModels::TextClassifier& Model::_internal_textclassifier() const {
  return _internal_has_textclassifier()
      ? *Type_.textclassifier_
      : reinterpret_cast< ::CoreML::Specification::CoreMLModels::TextClassifier&>(::CoreML::Specification::CoreMLModels::_TextClassifier_default_instance_);
}
inline const ::CoreML::Specification::CoreMLModels::TextClassifier& Model::textclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.textClassifier)
  return _internal_textclassifier();
}
inline ::CoreML::Specification::CoreMLModels::TextClassifier* Model::unsafe_arena_release_textclassifier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.textClassifier)
  if (_internal_has_textclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::CoreMLModels::TextClassifier* temp = Type_.textclassifier_;
    Type_.textclassifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_textclassifier(::CoreML::Specification::CoreMLModels::TextClassifier* textclassifier) {
  clear_Type();
  if (textclassifier) {
    set_has_textclassifier();
    Type_.textclassifier_ = textclassifier;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.textClassifier)
}
inline ::CoreML::Specification::CoreMLModels::TextClassifier* Model::_internal_mutable_textclassifier() {
  if (!_internal_has_textclassifier()) {
    clear_Type();
    set_has_textclassifier();
    Type_.textclassifier_ = CreateMaybeMessage< ::CoreML::Specification::CoreMLModels::TextClassifier >(GetArenaForAllocation());
  }
  return Type_.textclassifier_;
}
inline ::CoreML::Specification::CoreMLModels::TextClassifier* Model::mutable_textclassifier() {
  ::CoreML::Specification::CoreMLModels::TextClassifier* _msg = _internal_mutable_textclassifier();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.textClassifier)
  return _msg;
}

// .CoreML.Specification.CoreMLModels.WordTagger wordTagger = 2001;
inline bool Model::_internal_has_wordtagger() const {
  return Type_case() == kWordTagger;
}
inline bool Model::has_wordtagger() const {
  return _internal_has_wordtagger();
}
inline void Model::set_has_wordtagger() {
  _oneof_case_[0] = kWordTagger;
}
inline ::CoreML::Specification::CoreMLModels::WordTagger* Model::release_wordtagger() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.wordTagger)
  if (_internal_has_wordtagger()) {
    clear_has_Type();
      ::CoreML::Specification::CoreMLModels::WordTagger* temp = Type_.wordtagger_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.wordtagger_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::CoreMLModels::WordTagger& Model::_internal_wordtagger() const {
  return _internal_has_wordtagger()
      ? *Type_.wordtagger_
      : reinterpret_cast< ::CoreML::Specification::CoreMLModels::WordTagger&>(::CoreML::Specification::CoreMLModels::_WordTagger_default_instance_);
}
inline const ::CoreML::Specification::CoreMLModels::WordTagger& Model::wordtagger() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.wordTagger)
  return _internal_wordtagger();
}
inline ::CoreML::Specification::CoreMLModels::WordTagger* Model::unsafe_arena_release_wordtagger() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.wordTagger)
  if (_internal_has_wordtagger()) {
    clear_has_Type();
    ::CoreML::Specification::CoreMLModels::WordTagger* temp = Type_.wordtagger_;
    Type_.wordtagger_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_wordtagger(::CoreML::Specification::CoreMLModels::WordTagger* wordtagger) {
  clear_Type();
  if (wordtagger) {
    set_has_wordtagger();
    Type_.wordtagger_ = wordtagger;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.wordTagger)
}
inline ::CoreML::Specification::CoreMLModels::WordTagger* Model::_internal_mutable_wordtagger() {
  if (!_internal_has_wordtagger()) {
    clear_Type();
    set_has_wordtagger();
    Type_.wordtagger_ = CreateMaybeMessage< ::CoreML::Specification::CoreMLModels::WordTagger >(GetArenaForAllocation());
  }
  return Type_.wordtagger_;
}
inline ::CoreML::Specification::CoreMLModels::WordTagger* Model::mutable_wordtagger() {
  ::CoreML::Specification::CoreMLModels::WordTagger* _msg = _internal_mutable_wordtagger();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.wordTagger)
  return _msg;
}

// .CoreML.Specification.CoreMLModels.VisionFeaturePrint visionFeaturePrint = 2002;
inline bool Model::_internal_has_visionfeatureprint() const {
  return Type_case() == kVisionFeaturePrint;
}
inline bool Model::has_visionfeatureprint() const {
  return _internal_has_visionfeatureprint();
}
inline void Model::set_has_visionfeatureprint() {
  _oneof_case_[0] = kVisionFeaturePrint;
}
inline ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* Model::release_visionfeatureprint() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.visionFeaturePrint)
  if (_internal_has_visionfeatureprint()) {
    clear_has_Type();
      ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* temp = Type_.visionfeatureprint_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.visionfeatureprint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::CoreMLModels::VisionFeaturePrint& Model::_internal_visionfeatureprint() const {
  return _internal_has_visionfeatureprint()
      ? *Type_.visionfeatureprint_
      : reinterpret_cast< ::CoreML::Specification::CoreMLModels::VisionFeaturePrint&>(::CoreML::Specification::CoreMLModels::_VisionFeaturePrint_default_instance_);
}
inline const ::CoreML::Specification::CoreMLModels::VisionFeaturePrint& Model::visionfeatureprint() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.visionFeaturePrint)
  return _internal_visionfeatureprint();
}
inline ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* Model::unsafe_arena_release_visionfeatureprint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.visionFeaturePrint)
  if (_internal_has_visionfeatureprint()) {
    clear_has_Type();
    ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* temp = Type_.visionfeatureprint_;
    Type_.visionfeatureprint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_visionfeatureprint(::CoreML::Specification::CoreMLModels::VisionFeaturePrint* visionfeatureprint) {
  clear_Type();
  if (visionfeatureprint) {
    set_has_visionfeatureprint();
    Type_.visionfeatureprint_ = visionfeatureprint;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.visionFeaturePrint)
}
inline ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* Model::_internal_mutable_visionfeatureprint() {
  if (!_internal_has_visionfeatureprint()) {
    clear_Type();
    set_has_visionfeatureprint();
    Type_.visionfeatureprint_ = CreateMaybeMessage< ::CoreML::Specification::CoreMLModels::VisionFeaturePrint >(GetArenaForAllocation());
  }
  return Type_.visionfeatureprint_;
}
inline ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* Model::mutable_visionfeatureprint() {
  ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* _msg = _internal_mutable_visionfeatureprint();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.visionFeaturePrint)
  return _msg;
}

// .CoreML.Specification.CoreMLModels.SoundAnalysisPreprocessing soundAnalysisPreprocessing = 2003;
inline bool Model::_internal_has_soundanalysispreprocessing() const {
  return Type_case() == kSoundAnalysisPreprocessing;
}
inline bool Model::has_soundanalysispreprocessing() const {
  return _internal_has_soundanalysispreprocessing();
}
inline void Model::set_has_soundanalysispreprocessing() {
  _oneof_case_[0] = kSoundAnalysisPreprocessing;
}
inline ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing* Model::release_soundanalysispreprocessing() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.soundAnalysisPreprocessing)
  if (_internal_has_soundanalysispreprocessing()) {
    clear_has_Type();
      ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing* temp = Type_.soundanalysispreprocessing_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.soundanalysispreprocessing_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing& Model::_internal_soundanalysispreprocessing() const {
  return _internal_has_soundanalysispreprocessing()
      ? *Type_.soundanalysispreprocessing_
      : reinterpret_cast< ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing&>(::CoreML::Specification::CoreMLModels::_SoundAnalysisPreprocessing_default_instance_);
}
inline const ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing& Model::soundanalysispreprocessing() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.soundAnalysisPreprocessing)
  return _internal_soundanalysispreprocessing();
}
inline ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing* Model::unsafe_arena_release_soundanalysispreprocessing() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.soundAnalysisPreprocessing)
  if (_internal_has_soundanalysispreprocessing()) {
    clear_has_Type();
    ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing* temp = Type_.soundanalysispreprocessing_;
    Type_.soundanalysispreprocessing_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_soundanalysispreprocessing(::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing* soundanalysispreprocessing) {
  clear_Type();
  if (soundanalysispreprocessing) {
    set_has_soundanalysispreprocessing();
    Type_.soundanalysispreprocessing_ = soundanalysispreprocessing;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.soundAnalysisPreprocessing)
}
inline ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing* Model::_internal_mutable_soundanalysispreprocessing() {
  if (!_internal_has_soundanalysispreprocessing()) {
    clear_Type();
    set_has_soundanalysispreprocessing();
    Type_.soundanalysispreprocessing_ = CreateMaybeMessage< ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing >(GetArenaForAllocation());
  }
  return Type_.soundanalysispreprocessing_;
}
inline ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing* Model::mutable_soundanalysispreprocessing() {
  ::CoreML::Specification::CoreMLModels::SoundAnalysisPreprocessing* _msg = _internal_mutable_soundanalysispreprocessing();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.soundAnalysisPreprocessing)
  return _msg;
}

// .CoreML.Specification.CoreMLModels.Gazetteer gazetteer = 2004;
inline bool Model::_internal_has_gazetteer() const {
  return Type_case() == kGazetteer;
}
inline bool Model::has_gazetteer() const {
  return _internal_has_gazetteer();
}
inline void Model::set_has_gazetteer() {
  _oneof_case_[0] = kGazetteer;
}
inline ::CoreML::Specification::CoreMLModels::Gazetteer* Model::release_gazetteer() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.gazetteer)
  if (_internal_has_gazetteer()) {
    clear_has_Type();
      ::CoreML::Specification::CoreMLModels::Gazetteer* temp = Type_.gazetteer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.gazetteer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::CoreMLModels::Gazetteer& Model::_internal_gazetteer() const {
  return _internal_has_gazetteer()
      ? *Type_.gazetteer_
      : reinterpret_cast< ::CoreML::Specification::CoreMLModels::Gazetteer&>(::CoreML::Specification::CoreMLModels::_Gazetteer_default_instance_);
}
inline const ::CoreML::Specification::CoreMLModels::Gazetteer& Model::gazetteer() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.gazetteer)
  return _internal_gazetteer();
}
inline ::CoreML::Specification::CoreMLModels::Gazetteer* Model::unsafe_arena_release_gazetteer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.gazetteer)
  if (_internal_has_gazetteer()) {
    clear_has_Type();
    ::CoreML::Specification::CoreMLModels::Gazetteer* temp = Type_.gazetteer_;
    Type_.gazetteer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_gazetteer(::CoreML::Specification::CoreMLModels::Gazetteer* gazetteer) {
  clear_Type();
  if (gazetteer) {
    set_has_gazetteer();
    Type_.gazetteer_ = gazetteer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.gazetteer)
}
inline ::CoreML::Specification::CoreMLModels::Gazetteer* Model::_internal_mutable_gazetteer() {
  if (!_internal_has_gazetteer()) {
    clear_Type();
    set_has_gazetteer();
    Type_.gazetteer_ = CreateMaybeMessage< ::CoreML::Specification::CoreMLModels::Gazetteer >(GetArenaForAllocation());
  }
  return Type_.gazetteer_;
}
inline ::CoreML::Specification::CoreMLModels::Gazetteer* Model::mutable_gazetteer() {
  ::CoreML::Specification::CoreMLModels::Gazetteer* _msg = _internal_mutable_gazetteer();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.gazetteer)
  return _msg;
}

// .CoreML.Specification.CoreMLModels.WordEmbedding wordEmbedding = 2005;
inline bool Model::_internal_has_wordembedding() const {
  return Type_case() == kWordEmbedding;
}
inline bool Model::has_wordembedding() const {
  return _internal_has_wordembedding();
}
inline void Model::set_has_wordembedding() {
  _oneof_case_[0] = kWordEmbedding;
}
inline ::CoreML::Specification::CoreMLModels::WordEmbedding* Model::release_wordembedding() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.wordEmbedding)
  if (_internal_has_wordembedding()) {
    clear_has_Type();
      ::CoreML::Specification::CoreMLModels::WordEmbedding* temp = Type_.wordembedding_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.wordembedding_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::CoreMLModels::WordEmbedding& Model::_internal_wordembedding() const {
  return _internal_has_wordembedding()
      ? *Type_.wordembedding_
      : reinterpret_cast< ::CoreML::Specification::CoreMLModels::WordEmbedding&>(::CoreML::Specification::CoreMLModels::_WordEmbedding_default_instance_);
}
inline const ::CoreML::Specification::CoreMLModels::WordEmbedding& Model::wordembedding() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.wordEmbedding)
  return _internal_wordembedding();
}
inline ::CoreML::Specification::CoreMLModels::WordEmbedding* Model::unsafe_arena_release_wordembedding() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.wordEmbedding)
  if (_internal_has_wordembedding()) {
    clear_has_Type();
    ::CoreML::Specification::CoreMLModels::WordEmbedding* temp = Type_.wordembedding_;
    Type_.wordembedding_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_wordembedding(::CoreML::Specification::CoreMLModels::WordEmbedding* wordembedding) {
  clear_Type();
  if (wordembedding) {
    set_has_wordembedding();
    Type_.wordembedding_ = wordembedding;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.wordEmbedding)
}
inline ::CoreML::Specification::CoreMLModels::WordEmbedding* Model::_internal_mutable_wordembedding() {
  if (!_internal_has_wordembedding()) {
    clear_Type();
    set_has_wordembedding();
    Type_.wordembedding_ = CreateMaybeMessage< ::CoreML::Specification::CoreMLModels::WordEmbedding >(GetArenaForAllocation());
  }
  return Type_.wordembedding_;
}
inline ::CoreML::Specification::CoreMLModels::WordEmbedding* Model::mutable_wordembedding() {
  ::CoreML::Specification::CoreMLModels::WordEmbedding* _msg = _internal_mutable_wordembedding();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.wordEmbedding)
  return _msg;
}

// .CoreML.Specification.CoreMLModels.AudioFeaturePrint audioFeaturePrint = 2006;
inline bool Model::_internal_has_audiofeatureprint() const {
  return Type_case() == kAudioFeaturePrint;
}
inline bool Model::has_audiofeatureprint() const {
  return _internal_has_audiofeatureprint();
}
inline void Model::set_has_audiofeatureprint() {
  _oneof_case_[0] = kAudioFeaturePrint;
}
inline ::CoreML::Specification::CoreMLModels::AudioFeaturePrint* Model::release_audiofeatureprint() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.audioFeaturePrint)
  if (_internal_has_audiofeatureprint()) {
    clear_has_Type();
      ::CoreML::Specification::CoreMLModels::AudioFeaturePrint* temp = Type_.audiofeatureprint_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.audiofeatureprint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::CoreMLModels::AudioFeaturePrint& Model::_internal_audiofeatureprint() const {
  return _internal_has_audiofeatureprint()
      ? *Type_.audiofeatureprint_
      : reinterpret_cast< ::CoreML::Specification::CoreMLModels::AudioFeaturePrint&>(::CoreML::Specification::CoreMLModels::_AudioFeaturePrint_default_instance_);
}
inline const ::CoreML::Specification::CoreMLModels::AudioFeaturePrint& Model::audiofeatureprint() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.audioFeaturePrint)
  return _internal_audiofeatureprint();
}
inline ::CoreML::Specification::CoreMLModels::AudioFeaturePrint* Model::unsafe_arena_release_audiofeatureprint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.audioFeaturePrint)
  if (_internal_has_audiofeatureprint()) {
    clear_has_Type();
    ::CoreML::Specification::CoreMLModels::AudioFeaturePrint* temp = Type_.audiofeatureprint_;
    Type_.audiofeatureprint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_audiofeatureprint(::CoreML::Specification::CoreMLModels::AudioFeaturePrint* audiofeatureprint) {
  clear_Type();
  if (audiofeatureprint) {
    set_has_audiofeatureprint();
    Type_.audiofeatureprint_ = audiofeatureprint;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.audioFeaturePrint)
}
inline ::CoreML::Specification::CoreMLModels::AudioFeaturePrint* Model::_internal_mutable_audiofeatureprint() {
  if (!_internal_has_audiofeatureprint()) {
    clear_Type();
    set_has_audiofeatureprint();
    Type_.audiofeatureprint_ = CreateMaybeMessage< ::CoreML::Specification::CoreMLModels::AudioFeaturePrint >(GetArenaForAllocation());
  }
  return Type_.audiofeatureprint_;
}
inline ::CoreML::Specification::CoreMLModels::AudioFeaturePrint* Model::mutable_audiofeatureprint() {
  ::CoreML::Specification::CoreMLModels::AudioFeaturePrint* _msg = _internal_mutable_audiofeatureprint();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.audioFeaturePrint)
  return _msg;
}

// .CoreML.Specification.SerializedModel serializedModel = 3000;
inline bool Model::_internal_has_serializedmodel() const {
  return Type_case() == kSerializedModel;
}
inline bool Model::has_serializedmodel() const {
  return _internal_has_serializedmodel();
}
inline void Model::set_has_serializedmodel() {
  _oneof_case_[0] = kSerializedModel;
}
inline void Model::clear_serializedmodel() {
  if (_internal_has_serializedmodel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.serializedmodel_;
    }
    clear_has_Type();
  }
}
inline ::CoreML::Specification::SerializedModel* Model::release_serializedmodel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.serializedModel)
  if (_internal_has_serializedmodel()) {
    clear_has_Type();
      ::CoreML::Specification::SerializedModel* temp = Type_.serializedmodel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.serializedmodel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::SerializedModel& Model::_internal_serializedmodel() const {
  return _internal_has_serializedmodel()
      ? *Type_.serializedmodel_
      : reinterpret_cast< ::CoreML::Specification::SerializedModel&>(::CoreML::Specification::_SerializedModel_default_instance_);
}
inline const ::CoreML::Specification::SerializedModel& Model::serializedmodel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.serializedModel)
  return _internal_serializedmodel();
}
inline ::CoreML::Specification::SerializedModel* Model::unsafe_arena_release_serializedmodel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.Model.serializedModel)
  if (_internal_has_serializedmodel()) {
    clear_has_Type();
    ::CoreML::Specification::SerializedModel* temp = Type_.serializedmodel_;
    Type_.serializedmodel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_serializedmodel(::CoreML::Specification::SerializedModel* serializedmodel) {
  clear_Type();
  if (serializedmodel) {
    set_has_serializedmodel();
    Type_.serializedmodel_ = serializedmodel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.Model.serializedModel)
}
inline ::CoreML::Specification::SerializedModel* Model::_internal_mutable_serializedmodel() {
  if (!_internal_has_serializedmodel()) {
    clear_Type();
    set_has_serializedmodel();
    Type_.serializedmodel_ = CreateMaybeMessage< ::CoreML::Specification::SerializedModel >(GetArenaForAllocation());
  }
  return Type_.serializedmodel_;
}
inline ::CoreML::Specification::SerializedModel* Model::mutable_serializedmodel() {
  ::CoreML::Specification::SerializedModel* _msg = _internal_mutable_serializedmodel();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.serializedModel)
  return _msg;
}

inline bool Model::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void Model::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Model::TypeCase Model::Type_case() const {
  return Model::TypeCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Specification
}  // namespace CoreML

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Model_2eproto
