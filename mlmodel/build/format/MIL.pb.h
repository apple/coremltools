// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MIL.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_MIL_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_MIL_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_MIL_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_MIL_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[39]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace CoreML {
namespace Specification {
namespace MILSpec {
class Argument;
struct ArgumentDefaultTypeInternal;
extern ArgumentDefaultTypeInternal _Argument_default_instance_;
class Argument_Binding;
struct Argument_BindingDefaultTypeInternal;
extern Argument_BindingDefaultTypeInternal _Argument_Binding_default_instance_;
class Block;
struct BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class Block_AttributesEntry_DoNotUse;
struct Block_AttributesEntry_DoNotUseDefaultTypeInternal;
extern Block_AttributesEntry_DoNotUseDefaultTypeInternal _Block_AttributesEntry_DoNotUse_default_instance_;
class DictionaryType;
struct DictionaryTypeDefaultTypeInternal;
extern DictionaryTypeDefaultTypeInternal _DictionaryType_default_instance_;
class DictionaryValue;
struct DictionaryValueDefaultTypeInternal;
extern DictionaryValueDefaultTypeInternal _DictionaryValue_default_instance_;
class DictionaryValue_KeyValuePair;
struct DictionaryValue_KeyValuePairDefaultTypeInternal;
extern DictionaryValue_KeyValuePairDefaultTypeInternal _DictionaryValue_KeyValuePair_default_instance_;
class Dimension;
struct DimensionDefaultTypeInternal;
extern DimensionDefaultTypeInternal _Dimension_default_instance_;
class Dimension_ConstantDimension;
struct Dimension_ConstantDimensionDefaultTypeInternal;
extern Dimension_ConstantDimensionDefaultTypeInternal _Dimension_ConstantDimension_default_instance_;
class Dimension_UnknownDimension;
struct Dimension_UnknownDimensionDefaultTypeInternal;
extern Dimension_UnknownDimensionDefaultTypeInternal _Dimension_UnknownDimension_default_instance_;
class Function;
struct FunctionDefaultTypeInternal;
extern FunctionDefaultTypeInternal _Function_default_instance_;
class Function_AttributesEntry_DoNotUse;
struct Function_AttributesEntry_DoNotUseDefaultTypeInternal;
extern Function_AttributesEntry_DoNotUseDefaultTypeInternal _Function_AttributesEntry_DoNotUse_default_instance_;
class Function_BlockSpecializationsEntry_DoNotUse;
struct Function_BlockSpecializationsEntry_DoNotUseDefaultTypeInternal;
extern Function_BlockSpecializationsEntry_DoNotUseDefaultTypeInternal _Function_BlockSpecializationsEntry_DoNotUse_default_instance_;
class ListType;
struct ListTypeDefaultTypeInternal;
extern ListTypeDefaultTypeInternal _ListType_default_instance_;
class ListValue;
struct ListValueDefaultTypeInternal;
extern ListValueDefaultTypeInternal _ListValue_default_instance_;
class NamedValueType;
struct NamedValueTypeDefaultTypeInternal;
extern NamedValueTypeDefaultTypeInternal _NamedValueType_default_instance_;
class Operation;
struct OperationDefaultTypeInternal;
extern OperationDefaultTypeInternal _Operation_default_instance_;
class Operation_AttributesEntry_DoNotUse;
struct Operation_AttributesEntry_DoNotUseDefaultTypeInternal;
extern Operation_AttributesEntry_DoNotUseDefaultTypeInternal _Operation_AttributesEntry_DoNotUse_default_instance_;
class Operation_InputsEntry_DoNotUse;
struct Operation_InputsEntry_DoNotUseDefaultTypeInternal;
extern Operation_InputsEntry_DoNotUseDefaultTypeInternal _Operation_InputsEntry_DoNotUse_default_instance_;
class Program;
struct ProgramDefaultTypeInternal;
extern ProgramDefaultTypeInternal _Program_default_instance_;
class Program_AttributesEntry_DoNotUse;
struct Program_AttributesEntry_DoNotUseDefaultTypeInternal;
extern Program_AttributesEntry_DoNotUseDefaultTypeInternal _Program_AttributesEntry_DoNotUse_default_instance_;
class Program_FunctionsEntry_DoNotUse;
struct Program_FunctionsEntry_DoNotUseDefaultTypeInternal;
extern Program_FunctionsEntry_DoNotUseDefaultTypeInternal _Program_FunctionsEntry_DoNotUse_default_instance_;
class StateType;
struct StateTypeDefaultTypeInternal;
extern StateTypeDefaultTypeInternal _StateType_default_instance_;
class TensorType;
struct TensorTypeDefaultTypeInternal;
extern TensorTypeDefaultTypeInternal _TensorType_default_instance_;
class TensorType_AttributesEntry_DoNotUse;
struct TensorType_AttributesEntry_DoNotUseDefaultTypeInternal;
extern TensorType_AttributesEntry_DoNotUseDefaultTypeInternal _TensorType_AttributesEntry_DoNotUse_default_instance_;
class TensorValue;
struct TensorValueDefaultTypeInternal;
extern TensorValueDefaultTypeInternal _TensorValue_default_instance_;
class TensorValue_RepeatedBools;
struct TensorValue_RepeatedBoolsDefaultTypeInternal;
extern TensorValue_RepeatedBoolsDefaultTypeInternal _TensorValue_RepeatedBools_default_instance_;
class TensorValue_RepeatedBytes;
struct TensorValue_RepeatedBytesDefaultTypeInternal;
extern TensorValue_RepeatedBytesDefaultTypeInternal _TensorValue_RepeatedBytes_default_instance_;
class TensorValue_RepeatedDoubles;
struct TensorValue_RepeatedDoublesDefaultTypeInternal;
extern TensorValue_RepeatedDoublesDefaultTypeInternal _TensorValue_RepeatedDoubles_default_instance_;
class TensorValue_RepeatedFloats;
struct TensorValue_RepeatedFloatsDefaultTypeInternal;
extern TensorValue_RepeatedFloatsDefaultTypeInternal _TensorValue_RepeatedFloats_default_instance_;
class TensorValue_RepeatedInts;
struct TensorValue_RepeatedIntsDefaultTypeInternal;
extern TensorValue_RepeatedIntsDefaultTypeInternal _TensorValue_RepeatedInts_default_instance_;
class TensorValue_RepeatedLongInts;
struct TensorValue_RepeatedLongIntsDefaultTypeInternal;
extern TensorValue_RepeatedLongIntsDefaultTypeInternal _TensorValue_RepeatedLongInts_default_instance_;
class TensorValue_RepeatedStrings;
struct TensorValue_RepeatedStringsDefaultTypeInternal;
extern TensorValue_RepeatedStringsDefaultTypeInternal _TensorValue_RepeatedStrings_default_instance_;
class TupleType;
struct TupleTypeDefaultTypeInternal;
extern TupleTypeDefaultTypeInternal _TupleType_default_instance_;
class TupleValue;
struct TupleValueDefaultTypeInternal;
extern TupleValueDefaultTypeInternal _TupleValue_default_instance_;
class Value;
struct ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class ValueType;
struct ValueTypeDefaultTypeInternal;
extern ValueTypeDefaultTypeInternal _ValueType_default_instance_;
class Value_BlobFileValue;
struct Value_BlobFileValueDefaultTypeInternal;
extern Value_BlobFileValueDefaultTypeInternal _Value_BlobFileValue_default_instance_;
class Value_ImmediateValue;
struct Value_ImmediateValueDefaultTypeInternal;
extern Value_ImmediateValueDefaultTypeInternal _Value_ImmediateValue_default_instance_;
}  // namespace MILSpec
}  // namespace Specification
}  // namespace CoreML
PROTOBUF_NAMESPACE_OPEN
template<> ::CoreML::Specification::MILSpec::Argument* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Argument>(Arena*);
template<> ::CoreML::Specification::MILSpec::Argument_Binding* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Argument_Binding>(Arena*);
template<> ::CoreML::Specification::MILSpec::Block* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Block>(Arena*);
template<> ::CoreML::Specification::MILSpec::Block_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Block_AttributesEntry_DoNotUse>(Arena*);
template<> ::CoreML::Specification::MILSpec::DictionaryType* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::DictionaryType>(Arena*);
template<> ::CoreML::Specification::MILSpec::DictionaryValue* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::DictionaryValue>(Arena*);
template<> ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair>(Arena*);
template<> ::CoreML::Specification::MILSpec::Dimension* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Dimension>(Arena*);
template<> ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Dimension_ConstantDimension>(Arena*);
template<> ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Dimension_UnknownDimension>(Arena*);
template<> ::CoreML::Specification::MILSpec::Function* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Function>(Arena*);
template<> ::CoreML::Specification::MILSpec::Function_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Function_AttributesEntry_DoNotUse>(Arena*);
template<> ::CoreML::Specification::MILSpec::Function_BlockSpecializationsEntry_DoNotUse* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Function_BlockSpecializationsEntry_DoNotUse>(Arena*);
template<> ::CoreML::Specification::MILSpec::ListType* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::ListType>(Arena*);
template<> ::CoreML::Specification::MILSpec::ListValue* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::ListValue>(Arena*);
template<> ::CoreML::Specification::MILSpec::NamedValueType* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::NamedValueType>(Arena*);
template<> ::CoreML::Specification::MILSpec::Operation* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Operation>(Arena*);
template<> ::CoreML::Specification::MILSpec::Operation_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Operation_AttributesEntry_DoNotUse>(Arena*);
template<> ::CoreML::Specification::MILSpec::Operation_InputsEntry_DoNotUse* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Operation_InputsEntry_DoNotUse>(Arena*);
template<> ::CoreML::Specification::MILSpec::Program* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Program>(Arena*);
template<> ::CoreML::Specification::MILSpec::Program_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Program_AttributesEntry_DoNotUse>(Arena*);
template<> ::CoreML::Specification::MILSpec::Program_FunctionsEntry_DoNotUse* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Program_FunctionsEntry_DoNotUse>(Arena*);
template<> ::CoreML::Specification::MILSpec::StateType* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::StateType>(Arena*);
template<> ::CoreML::Specification::MILSpec::TensorType* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::TensorType>(Arena*);
template<> ::CoreML::Specification::MILSpec::TensorType_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::TensorType_AttributesEntry_DoNotUse>(Arena*);
template<> ::CoreML::Specification::MILSpec::TensorValue* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::TensorValue>(Arena*);
template<> ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::TensorValue_RepeatedBools>(Arena*);
template<> ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes>(Arena*);
template<> ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles>(Arena*);
template<> ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats>(Arena*);
template<> ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::TensorValue_RepeatedInts>(Arena*);
template<> ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts>(Arena*);
template<> ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings>(Arena*);
template<> ::CoreML::Specification::MILSpec::TupleType* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::TupleType>(Arena*);
template<> ::CoreML::Specification::MILSpec::TupleValue* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::TupleValue>(Arena*);
template<> ::CoreML::Specification::MILSpec::Value* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Value>(Arena*);
template<> ::CoreML::Specification::MILSpec::ValueType* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::ValueType>(Arena*);
template<> ::CoreML::Specification::MILSpec::Value_BlobFileValue* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Value_BlobFileValue>(Arena*);
template<> ::CoreML::Specification::MILSpec::Value_ImmediateValue* Arena::CreateMaybeMessage<::CoreML::Specification::MILSpec::Value_ImmediateValue>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace CoreML {
namespace Specification {
namespace MILSpec {

enum DataType : int {
  UNUSED_TYPE = 0,
  BOOL = 1,
  STRING = 2,
  FLOAT8E4M3FN = 40,
  FLOAT8E5M2 = 41,
  FLOAT16 = 10,
  FLOAT32 = 11,
  FLOAT64 = 12,
  BFLOAT16 = 13,
  INT8 = 21,
  INT16 = 22,
  INT32 = 23,
  INT64 = 24,
  INT4 = 25,
  UINT8 = 31,
  UINT16 = 32,
  UINT32 = 33,
  UINT64 = 34,
  UINT4 = 35,
  UINT2 = 36,
  UINT1 = 37,
  UINT6 = 38,
  UINT3 = 39,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataType_IsValid(int value);
constexpr DataType DataType_MIN = UNUSED_TYPE;
constexpr DataType DataType_MAX = FLOAT8E5M2;
constexpr int DataType_ARRAYSIZE = DataType_MAX + 1;

const std::string& DataType_Name(DataType value);
template<typename T>
inline const std::string& DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataType_Name.");
  return DataType_Name(static_cast<DataType>(enum_t_value));
}
bool DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataType* value);
// ===================================================================

class Program_FunctionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Program_FunctionsEntry_DoNotUse, 
    std::string, ::CoreML::Specification::MILSpec::Function,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Program_FunctionsEntry_DoNotUse, 
    std::string, ::CoreML::Specification::MILSpec::Function,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Program_FunctionsEntry_DoNotUse();
  explicit constexpr Program_FunctionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Program_FunctionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Program_FunctionsEntry_DoNotUse& other);
  static const Program_FunctionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Program_FunctionsEntry_DoNotUse*>(&_Program_FunctionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "CoreML.Specification.MILSpec.Program.FunctionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class Program_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Program_AttributesEntry_DoNotUse, 
    std::string, ::CoreML::Specification::MILSpec::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Program_AttributesEntry_DoNotUse, 
    std::string, ::CoreML::Specification::MILSpec::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Program_AttributesEntry_DoNotUse();
  explicit constexpr Program_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Program_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Program_AttributesEntry_DoNotUse& other);
  static const Program_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Program_AttributesEntry_DoNotUse*>(&_Program_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "CoreML.Specification.MILSpec.Program.AttributesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class Program final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Program) */ {
 public:
  inline Program() : Program(nullptr) {}
  ~Program() override;
  explicit constexpr Program(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Program(const Program& from);
  Program(Program&& from) noexcept
    : Program() {
    *this = ::std::move(from);
  }

  inline Program& operator=(const Program& from) {
    CopyFrom(from);
    return *this;
  }
  inline Program& operator=(Program&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Program& default_instance() {
    return *internal_default_instance();
  }
  static inline const Program* internal_default_instance() {
    return reinterpret_cast<const Program*>(
               &_Program_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Program& a, Program& b) {
    a.Swap(&b);
  }
  inline void Swap(Program* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Program* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Program* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Program>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Program& from);
  void MergeFrom(const Program& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Program* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.Program";
  }
  protected:
  explicit Program(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFunctionsFieldNumber = 2,
    kAttributesFieldNumber = 4,
    kDocStringFieldNumber = 3,
    kVersionFieldNumber = 1,
  };
  // map<string, .CoreML.Specification.MILSpec.Function> functions = 2;
  int functions_size() const;
  private:
  int _internal_functions_size() const;
  public:
  void clear_functions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Function >&
      _internal_functions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Function >*
      _internal_mutable_functions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Function >&
      functions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Function >*
      mutable_functions();

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
      mutable_attributes();

  // string docString = 3;
  void clear_docstring();
  const std::string& docstring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_docstring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_docstring();
  PROTOBUF_NODISCARD std::string* release_docstring();
  void set_allocated_docstring(std::string* docstring);
  private:
  const std::string& _internal_docstring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_docstring(const std::string& value);
  std::string* _internal_mutable_docstring();
  public:

  // int64 version = 1;
  void clear_version();
  int64_t version() const;
  void set_version(int64_t value);
  private:
  int64_t _internal_version() const;
  void _internal_set_version(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Program)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Program_FunctionsEntry_DoNotUse,
      std::string, ::CoreML::Specification::MILSpec::Function,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> functions_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Program_AttributesEntry_DoNotUse,
      std::string, ::CoreML::Specification::MILSpec::Value,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> attributes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr docstring_;
  int64_t version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class Function_BlockSpecializationsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Function_BlockSpecializationsEntry_DoNotUse, 
    std::string, ::CoreML::Specification::MILSpec::Block,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Function_BlockSpecializationsEntry_DoNotUse, 
    std::string, ::CoreML::Specification::MILSpec::Block,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Function_BlockSpecializationsEntry_DoNotUse();
  explicit constexpr Function_BlockSpecializationsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Function_BlockSpecializationsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Function_BlockSpecializationsEntry_DoNotUse& other);
  static const Function_BlockSpecializationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Function_BlockSpecializationsEntry_DoNotUse*>(&_Function_BlockSpecializationsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "CoreML.Specification.MILSpec.Function.BlockSpecializationsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class Function_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Function_AttributesEntry_DoNotUse, 
    std::string, ::CoreML::Specification::MILSpec::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Function_AttributesEntry_DoNotUse, 
    std::string, ::CoreML::Specification::MILSpec::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Function_AttributesEntry_DoNotUse();
  explicit constexpr Function_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Function_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Function_AttributesEntry_DoNotUse& other);
  static const Function_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Function_AttributesEntry_DoNotUse*>(&_Function_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "CoreML.Specification.MILSpec.Function.AttributesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class Function final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Function) */ {
 public:
  inline Function() : Function(nullptr) {}
  ~Function() override;
  explicit constexpr Function(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Function(const Function& from);
  Function(Function&& from) noexcept
    : Function() {
    *this = ::std::move(from);
  }

  inline Function& operator=(const Function& from) {
    CopyFrom(from);
    return *this;
  }
  inline Function& operator=(Function&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Function& default_instance() {
    return *internal_default_instance();
  }
  static inline const Function* internal_default_instance() {
    return reinterpret_cast<const Function*>(
               &_Function_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Function& a, Function& b) {
    a.Swap(&b);
  }
  inline void Swap(Function* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Function* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Function* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Function>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Function& from);
  void MergeFrom(const Function& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Function* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.Function";
  }
  protected:
  explicit Function(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInputsFieldNumber = 1,
    kBlockSpecializationsFieldNumber = 3,
    kAttributesFieldNumber = 4,
    kOpsetFieldNumber = 2,
  };
  // repeated .CoreML.Specification.MILSpec.NamedValueType inputs = 1;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  ::CoreML::Specification::MILSpec::NamedValueType* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >*
      mutable_inputs();
  private:
  const ::CoreML::Specification::MILSpec::NamedValueType& _internal_inputs(int index) const;
  ::CoreML::Specification::MILSpec::NamedValueType* _internal_add_inputs();
  public:
  const ::CoreML::Specification::MILSpec::NamedValueType& inputs(int index) const;
  ::CoreML::Specification::MILSpec::NamedValueType* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >&
      inputs() const;

  // map<string, .CoreML.Specification.MILSpec.Block> block_specializations = 3;
  int block_specializations_size() const;
  private:
  int _internal_block_specializations_size() const;
  public:
  void clear_block_specializations();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Block >&
      _internal_block_specializations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Block >*
      _internal_mutable_block_specializations();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Block >&
      block_specializations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Block >*
      mutable_block_specializations();

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
      mutable_attributes();

  // string opset = 2;
  void clear_opset();
  const std::string& opset() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_opset(ArgT0&& arg0, ArgT... args);
  std::string* mutable_opset();
  PROTOBUF_NODISCARD std::string* release_opset();
  void set_allocated_opset(std::string* opset);
  private:
  const std::string& _internal_opset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_opset(const std::string& value);
  std::string* _internal_mutable_opset();
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Function)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType > inputs_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Function_BlockSpecializationsEntry_DoNotUse,
      std::string, ::CoreML::Specification::MILSpec::Block,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> block_specializations_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Function_AttributesEntry_DoNotUse,
      std::string, ::CoreML::Specification::MILSpec::Value,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> attributes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr opset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class Block_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Block_AttributesEntry_DoNotUse, 
    std::string, ::CoreML::Specification::MILSpec::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Block_AttributesEntry_DoNotUse, 
    std::string, ::CoreML::Specification::MILSpec::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Block_AttributesEntry_DoNotUse();
  explicit constexpr Block_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Block_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Block_AttributesEntry_DoNotUse& other);
  static const Block_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Block_AttributesEntry_DoNotUse*>(&_Block_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "CoreML.Specification.MILSpec.Block.AttributesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class Block final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Block) */ {
 public:
  inline Block() : Block(nullptr) {}
  ~Block() override;
  explicit constexpr Block(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Block(const Block& from);
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  inline Block& operator=(Block&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Block& default_instance() {
    return *internal_default_instance();
  }
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }
  inline void Swap(Block* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Block* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Block* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Block* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.Block";
  }
  protected:
  explicit Block(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInputsFieldNumber = 1,
    kOutputsFieldNumber = 2,
    kOperationsFieldNumber = 3,
    kAttributesFieldNumber = 4,
  };
  // repeated .CoreML.Specification.MILSpec.NamedValueType inputs = 1;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  ::CoreML::Specification::MILSpec::NamedValueType* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >*
      mutable_inputs();
  private:
  const ::CoreML::Specification::MILSpec::NamedValueType& _internal_inputs(int index) const;
  ::CoreML::Specification::MILSpec::NamedValueType* _internal_add_inputs();
  public:
  const ::CoreML::Specification::MILSpec::NamedValueType& inputs(int index) const;
  ::CoreML::Specification::MILSpec::NamedValueType* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >&
      inputs() const;

  // repeated string outputs = 2;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  const std::string& outputs(int index) const;
  std::string* mutable_outputs(int index);
  void set_outputs(int index, const std::string& value);
  void set_outputs(int index, std::string&& value);
  void set_outputs(int index, const char* value);
  void set_outputs(int index, const char* value, size_t size);
  std::string* add_outputs();
  void add_outputs(const std::string& value);
  void add_outputs(std::string&& value);
  void add_outputs(const char* value);
  void add_outputs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& outputs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_outputs();
  private:
  const std::string& _internal_outputs(int index) const;
  std::string* _internal_add_outputs();
  public:

  // repeated .CoreML.Specification.MILSpec.Operation operations = 3;
  int operations_size() const;
  private:
  int _internal_operations_size() const;
  public:
  void clear_operations();
  ::CoreML::Specification::MILSpec::Operation* mutable_operations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Operation >*
      mutable_operations();
  private:
  const ::CoreML::Specification::MILSpec::Operation& _internal_operations(int index) const;
  ::CoreML::Specification::MILSpec::Operation* _internal_add_operations();
  public:
  const ::CoreML::Specification::MILSpec::Operation& operations(int index) const;
  ::CoreML::Specification::MILSpec::Operation* add_operations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Operation >&
      operations() const;

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
      mutable_attributes();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Block)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType > inputs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> outputs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Operation > operations_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Block_AttributesEntry_DoNotUse,
      std::string, ::CoreML::Specification::MILSpec::Value,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> attributes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class Argument_Binding final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Argument.Binding) */ {
 public:
  inline Argument_Binding() : Argument_Binding(nullptr) {}
  ~Argument_Binding() override;
  explicit constexpr Argument_Binding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Argument_Binding(const Argument_Binding& from);
  Argument_Binding(Argument_Binding&& from) noexcept
    : Argument_Binding() {
    *this = ::std::move(from);
  }

  inline Argument_Binding& operator=(const Argument_Binding& from) {
    CopyFrom(from);
    return *this;
  }
  inline Argument_Binding& operator=(Argument_Binding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Argument_Binding& default_instance() {
    return *internal_default_instance();
  }
  enum BindingCase {
    kName = 1,
    kValue = 2,
    BINDING_NOT_SET = 0,
  };

  static inline const Argument_Binding* internal_default_instance() {
    return reinterpret_cast<const Argument_Binding*>(
               &_Argument_Binding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Argument_Binding& a, Argument_Binding& b) {
    a.Swap(&b);
  }
  inline void Swap(Argument_Binding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Argument_Binding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Argument_Binding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Argument_Binding>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Argument_Binding& from);
  void MergeFrom(const Argument_Binding& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Argument_Binding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.Argument.Binding";
  }
  protected:
  explicit Argument_Binding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .CoreML.Specification.MILSpec.Value value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::CoreML::Specification::MILSpec::Value& value() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::Value* release_value();
  ::CoreML::Specification::MILSpec::Value* mutable_value();
  void set_allocated_value(::CoreML::Specification::MILSpec::Value* value);
  private:
  const ::CoreML::Specification::MILSpec::Value& _internal_value() const;
  ::CoreML::Specification::MILSpec::Value* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::CoreML::Specification::MILSpec::Value* value);
  ::CoreML::Specification::MILSpec::Value* unsafe_arena_release_value();

  void clear_binding();
  BindingCase binding_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Argument.Binding)
 private:
  class _Internal;
  void set_has_name();
  void set_has_value();

  inline bool has_binding() const;
  inline void clear_has_binding();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union BindingUnion {
    constexpr BindingUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::CoreML::Specification::MILSpec::Value* value_;
  } binding_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class Argument final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Argument) */ {
 public:
  inline Argument() : Argument(nullptr) {}
  ~Argument() override;
  explicit constexpr Argument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Argument(const Argument& from);
  Argument(Argument&& from) noexcept
    : Argument() {
    *this = ::std::move(from);
  }

  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }
  inline Argument& operator=(Argument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Argument& default_instance() {
    return *internal_default_instance();
  }
  static inline const Argument* internal_default_instance() {
    return reinterpret_cast<const Argument*>(
               &_Argument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Argument& a, Argument& b) {
    a.Swap(&b);
  }
  inline void Swap(Argument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Argument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Argument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Argument>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Argument& from);
  void MergeFrom(const Argument& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Argument* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.Argument";
  }
  protected:
  explicit Argument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Argument_Binding Binding;

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 1,
  };
  // repeated .CoreML.Specification.MILSpec.Argument.Binding arguments = 1;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;
  public:
  void clear_arguments();
  ::CoreML::Specification::MILSpec::Argument_Binding* mutable_arguments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Argument_Binding >*
      mutable_arguments();
  private:
  const ::CoreML::Specification::MILSpec::Argument_Binding& _internal_arguments(int index) const;
  ::CoreML::Specification::MILSpec::Argument_Binding* _internal_add_arguments();
  public:
  const ::CoreML::Specification::MILSpec::Argument_Binding& arguments(int index) const;
  ::CoreML::Specification::MILSpec::Argument_Binding* add_arguments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Argument_Binding >&
      arguments() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Argument)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Argument_Binding > arguments_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class Operation_InputsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Operation_InputsEntry_DoNotUse, 
    std::string, ::CoreML::Specification::MILSpec::Argument,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Operation_InputsEntry_DoNotUse, 
    std::string, ::CoreML::Specification::MILSpec::Argument,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Operation_InputsEntry_DoNotUse();
  explicit constexpr Operation_InputsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Operation_InputsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Operation_InputsEntry_DoNotUse& other);
  static const Operation_InputsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Operation_InputsEntry_DoNotUse*>(&_Operation_InputsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "CoreML.Specification.MILSpec.Operation.InputsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class Operation_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Operation_AttributesEntry_DoNotUse, 
    std::string, ::CoreML::Specification::MILSpec::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Operation_AttributesEntry_DoNotUse, 
    std::string, ::CoreML::Specification::MILSpec::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Operation_AttributesEntry_DoNotUse();
  explicit constexpr Operation_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Operation_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Operation_AttributesEntry_DoNotUse& other);
  static const Operation_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Operation_AttributesEntry_DoNotUse*>(&_Operation_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "CoreML.Specification.MILSpec.Operation.AttributesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class Operation final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Operation) */ {
 public:
  inline Operation() : Operation(nullptr) {}
  ~Operation() override;
  explicit constexpr Operation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Operation(const Operation& from);
  Operation(Operation&& from) noexcept
    : Operation() {
    *this = ::std::move(from);
  }

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operation& operator=(Operation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Operation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Operation& a, Operation& b) {
    a.Swap(&b);
  }
  inline void Swap(Operation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Operation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Operation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Operation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Operation& from);
  void MergeFrom(const Operation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Operation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.Operation";
  }
  protected:
  explicit Operation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInputsFieldNumber = 2,
    kOutputsFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kAttributesFieldNumber = 5,
    kTypeFieldNumber = 1,
  };
  // map<string, .CoreML.Specification.MILSpec.Argument> inputs = 2;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Argument >&
      _internal_inputs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Argument >*
      _internal_mutable_inputs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Argument >&
      inputs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Argument >*
      mutable_inputs();

  // repeated .CoreML.Specification.MILSpec.NamedValueType outputs = 3;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::CoreML::Specification::MILSpec::NamedValueType* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >*
      mutable_outputs();
  private:
  const ::CoreML::Specification::MILSpec::NamedValueType& _internal_outputs(int index) const;
  ::CoreML::Specification::MILSpec::NamedValueType* _internal_add_outputs();
  public:
  const ::CoreML::Specification::MILSpec::NamedValueType& outputs(int index) const;
  ::CoreML::Specification::MILSpec::NamedValueType* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >&
      outputs() const;

  // repeated .CoreML.Specification.MILSpec.Block blocks = 4;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  ::CoreML::Specification::MILSpec::Block* mutable_blocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Block >*
      mutable_blocks();
  private:
  const ::CoreML::Specification::MILSpec::Block& _internal_blocks(int index) const;
  ::CoreML::Specification::MILSpec::Block* _internal_add_blocks();
  public:
  const ::CoreML::Specification::MILSpec::Block& blocks(int index) const;
  ::CoreML::Specification::MILSpec::Block* add_blocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Block >&
      blocks() const;

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 5;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
      mutable_attributes();

  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Operation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Operation_InputsEntry_DoNotUse,
      std::string, ::CoreML::Specification::MILSpec::Argument,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> inputs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType > outputs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Block > blocks_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Operation_AttributesEntry_DoNotUse,
      std::string, ::CoreML::Specification::MILSpec::Value,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> attributes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class NamedValueType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.NamedValueType) */ {
 public:
  inline NamedValueType() : NamedValueType(nullptr) {}
  ~NamedValueType() override;
  explicit constexpr NamedValueType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedValueType(const NamedValueType& from);
  NamedValueType(NamedValueType&& from) noexcept
    : NamedValueType() {
    *this = ::std::move(from);
  }

  inline NamedValueType& operator=(const NamedValueType& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedValueType& operator=(NamedValueType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const NamedValueType& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedValueType* internal_default_instance() {
    return reinterpret_cast<const NamedValueType*>(
               &_NamedValueType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(NamedValueType& a, NamedValueType& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedValueType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedValueType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedValueType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedValueType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NamedValueType& from);
  void MergeFrom(const NamedValueType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NamedValueType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.NamedValueType";
  }
  protected:
  explicit NamedValueType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .CoreML.Specification.MILSpec.ValueType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::CoreML::Specification::MILSpec::ValueType& type() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::ValueType* release_type();
  ::CoreML::Specification::MILSpec::ValueType* mutable_type();
  void set_allocated_type(::CoreML::Specification::MILSpec::ValueType* type);
  private:
  const ::CoreML::Specification::MILSpec::ValueType& _internal_type() const;
  ::CoreML::Specification::MILSpec::ValueType* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::CoreML::Specification::MILSpec::ValueType* type);
  ::CoreML::Specification::MILSpec::ValueType* unsafe_arena_release_type();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.NamedValueType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::CoreML::Specification::MILSpec::ValueType* type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class ValueType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.ValueType) */ {
 public:
  inline ValueType() : ValueType(nullptr) {}
  ~ValueType() override;
  explicit constexpr ValueType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValueType(const ValueType& from);
  ValueType(ValueType&& from) noexcept
    : ValueType() {
    *this = ::std::move(from);
  }

  inline ValueType& operator=(const ValueType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueType& operator=(ValueType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ValueType& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kTensorType = 1,
    kListType = 2,
    kTupleType = 3,
    kDictionaryType = 4,
    kStateType = 5,
    TYPE_NOT_SET = 0,
  };

  static inline const ValueType* internal_default_instance() {
    return reinterpret_cast<const ValueType*>(
               &_ValueType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ValueType& a, ValueType& b) {
    a.Swap(&b);
  }
  inline void Swap(ValueType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValueType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValueType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ValueType& from);
  void MergeFrom(const ValueType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ValueType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.ValueType";
  }
  protected:
  explicit ValueType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTensorTypeFieldNumber = 1,
    kListTypeFieldNumber = 2,
    kTupleTypeFieldNumber = 3,
    kDictionaryTypeFieldNumber = 4,
    kStateTypeFieldNumber = 5,
  };
  // .CoreML.Specification.MILSpec.TensorType tensorType = 1;
  bool has_tensortype() const;
  private:
  bool _internal_has_tensortype() const;
  public:
  void clear_tensortype();
  const ::CoreML::Specification::MILSpec::TensorType& tensortype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::TensorType* release_tensortype();
  ::CoreML::Specification::MILSpec::TensorType* mutable_tensortype();
  void set_allocated_tensortype(::CoreML::Specification::MILSpec::TensorType* tensortype);
  private:
  const ::CoreML::Specification::MILSpec::TensorType& _internal_tensortype() const;
  ::CoreML::Specification::MILSpec::TensorType* _internal_mutable_tensortype();
  public:
  void unsafe_arena_set_allocated_tensortype(
      ::CoreML::Specification::MILSpec::TensorType* tensortype);
  ::CoreML::Specification::MILSpec::TensorType* unsafe_arena_release_tensortype();

  // .CoreML.Specification.MILSpec.ListType listType = 2;
  bool has_listtype() const;
  private:
  bool _internal_has_listtype() const;
  public:
  void clear_listtype();
  const ::CoreML::Specification::MILSpec::ListType& listtype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::ListType* release_listtype();
  ::CoreML::Specification::MILSpec::ListType* mutable_listtype();
  void set_allocated_listtype(::CoreML::Specification::MILSpec::ListType* listtype);
  private:
  const ::CoreML::Specification::MILSpec::ListType& _internal_listtype() const;
  ::CoreML::Specification::MILSpec::ListType* _internal_mutable_listtype();
  public:
  void unsafe_arena_set_allocated_listtype(
      ::CoreML::Specification::MILSpec::ListType* listtype);
  ::CoreML::Specification::MILSpec::ListType* unsafe_arena_release_listtype();

  // .CoreML.Specification.MILSpec.TupleType tupleType = 3;
  bool has_tupletype() const;
  private:
  bool _internal_has_tupletype() const;
  public:
  void clear_tupletype();
  const ::CoreML::Specification::MILSpec::TupleType& tupletype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::TupleType* release_tupletype();
  ::CoreML::Specification::MILSpec::TupleType* mutable_tupletype();
  void set_allocated_tupletype(::CoreML::Specification::MILSpec::TupleType* tupletype);
  private:
  const ::CoreML::Specification::MILSpec::TupleType& _internal_tupletype() const;
  ::CoreML::Specification::MILSpec::TupleType* _internal_mutable_tupletype();
  public:
  void unsafe_arena_set_allocated_tupletype(
      ::CoreML::Specification::MILSpec::TupleType* tupletype);
  ::CoreML::Specification::MILSpec::TupleType* unsafe_arena_release_tupletype();

  // .CoreML.Specification.MILSpec.DictionaryType dictionaryType = 4;
  bool has_dictionarytype() const;
  private:
  bool _internal_has_dictionarytype() const;
  public:
  void clear_dictionarytype();
  const ::CoreML::Specification::MILSpec::DictionaryType& dictionarytype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::DictionaryType* release_dictionarytype();
  ::CoreML::Specification::MILSpec::DictionaryType* mutable_dictionarytype();
  void set_allocated_dictionarytype(::CoreML::Specification::MILSpec::DictionaryType* dictionarytype);
  private:
  const ::CoreML::Specification::MILSpec::DictionaryType& _internal_dictionarytype() const;
  ::CoreML::Specification::MILSpec::DictionaryType* _internal_mutable_dictionarytype();
  public:
  void unsafe_arena_set_allocated_dictionarytype(
      ::CoreML::Specification::MILSpec::DictionaryType* dictionarytype);
  ::CoreML::Specification::MILSpec::DictionaryType* unsafe_arena_release_dictionarytype();

  // .CoreML.Specification.MILSpec.StateType stateType = 5;
  bool has_statetype() const;
  private:
  bool _internal_has_statetype() const;
  public:
  void clear_statetype();
  const ::CoreML::Specification::MILSpec::StateType& statetype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::StateType* release_statetype();
  ::CoreML::Specification::MILSpec::StateType* mutable_statetype();
  void set_allocated_statetype(::CoreML::Specification::MILSpec::StateType* statetype);
  private:
  const ::CoreML::Specification::MILSpec::StateType& _internal_statetype() const;
  ::CoreML::Specification::MILSpec::StateType* _internal_mutable_statetype();
  public:
  void unsafe_arena_set_allocated_statetype(
      ::CoreML::Specification::MILSpec::StateType* statetype);
  ::CoreML::Specification::MILSpec::StateType* unsafe_arena_release_statetype();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.ValueType)
 private:
  class _Internal;
  void set_has_tensortype();
  void set_has_listtype();
  void set_has_tupletype();
  void set_has_dictionarytype();
  void set_has_statetype();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CoreML::Specification::MILSpec::TensorType* tensortype_;
    ::CoreML::Specification::MILSpec::ListType* listtype_;
    ::CoreML::Specification::MILSpec::TupleType* tupletype_;
    ::CoreML::Specification::MILSpec::DictionaryType* dictionarytype_;
    ::CoreML::Specification::MILSpec::StateType* statetype_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class TensorType_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<TensorType_AttributesEntry_DoNotUse, 
    std::string, ::CoreML::Specification::MILSpec::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<TensorType_AttributesEntry_DoNotUse, 
    std::string, ::CoreML::Specification::MILSpec::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TensorType_AttributesEntry_DoNotUse();
  explicit constexpr TensorType_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TensorType_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TensorType_AttributesEntry_DoNotUse& other);
  static const TensorType_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TensorType_AttributesEntry_DoNotUse*>(&_TensorType_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "CoreML.Specification.MILSpec.TensorType.AttributesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class TensorType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TensorType) */ {
 public:
  inline TensorType() : TensorType(nullptr) {}
  ~TensorType() override;
  explicit constexpr TensorType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TensorType(const TensorType& from);
  TensorType(TensorType&& from) noexcept
    : TensorType() {
    *this = ::std::move(from);
  }

  inline TensorType& operator=(const TensorType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorType& operator=(TensorType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TensorType& default_instance() {
    return *internal_default_instance();
  }
  static inline const TensorType* internal_default_instance() {
    return reinterpret_cast<const TensorType*>(
               &_TensorType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TensorType& a, TensorType& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TensorType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TensorType& from);
  void MergeFrom(const TensorType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.TensorType";
  }
  protected:
  explicit TensorType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDimensionsFieldNumber = 3,
    kAttributesFieldNumber = 4,
    kRankFieldNumber = 2,
    kDataTypeFieldNumber = 1,
  };
  // repeated .CoreML.Specification.MILSpec.Dimension dimensions = 3;
  int dimensions_size() const;
  private:
  int _internal_dimensions_size() const;
  public:
  void clear_dimensions();
  ::CoreML::Specification::MILSpec::Dimension* mutable_dimensions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Dimension >*
      mutable_dimensions();
  private:
  const ::CoreML::Specification::MILSpec::Dimension& _internal_dimensions(int index) const;
  ::CoreML::Specification::MILSpec::Dimension* _internal_add_dimensions();
  public:
  const ::CoreML::Specification::MILSpec::Dimension& dimensions(int index) const;
  ::CoreML::Specification::MILSpec::Dimension* add_dimensions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Dimension >&
      dimensions() const;

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
      mutable_attributes();

  // int64 rank = 2;
  void clear_rank();
  int64_t rank() const;
  void set_rank(int64_t value);
  private:
  int64_t _internal_rank() const;
  void _internal_set_rank(int64_t value);
  public:

  // .CoreML.Specification.MILSpec.DataType dataType = 1;
  void clear_datatype();
  ::CoreML::Specification::MILSpec::DataType datatype() const;
  void set_datatype(::CoreML::Specification::MILSpec::DataType value);
  private:
  ::CoreML::Specification::MILSpec::DataType _internal_datatype() const;
  void _internal_set_datatype(::CoreML::Specification::MILSpec::DataType value);
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TensorType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Dimension > dimensions_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      TensorType_AttributesEntry_DoNotUse,
      std::string, ::CoreML::Specification::MILSpec::Value,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> attributes_;
  int64_t rank_;
  int datatype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class TupleType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TupleType) */ {
 public:
  inline TupleType() : TupleType(nullptr) {}
  ~TupleType() override;
  explicit constexpr TupleType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TupleType(const TupleType& from);
  TupleType(TupleType&& from) noexcept
    : TupleType() {
    *this = ::std::move(from);
  }

  inline TupleType& operator=(const TupleType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TupleType& operator=(TupleType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TupleType& default_instance() {
    return *internal_default_instance();
  }
  static inline const TupleType* internal_default_instance() {
    return reinterpret_cast<const TupleType*>(
               &_TupleType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TupleType& a, TupleType& b) {
    a.Swap(&b);
  }
  inline void Swap(TupleType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TupleType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TupleType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TupleType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TupleType& from);
  void MergeFrom(const TupleType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TupleType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.TupleType";
  }
  protected:
  explicit TupleType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 1,
  };
  // repeated .CoreML.Specification.MILSpec.ValueType types = 1;
  int types_size() const;
  private:
  int _internal_types_size() const;
  public:
  void clear_types();
  ::CoreML::Specification::MILSpec::ValueType* mutable_types(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::ValueType >*
      mutable_types();
  private:
  const ::CoreML::Specification::MILSpec::ValueType& _internal_types(int index) const;
  ::CoreML::Specification::MILSpec::ValueType* _internal_add_types();
  public:
  const ::CoreML::Specification::MILSpec::ValueType& types(int index) const;
  ::CoreML::Specification::MILSpec::ValueType* add_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::ValueType >&
      types() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TupleType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::ValueType > types_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class ListType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.ListType) */ {
 public:
  inline ListType() : ListType(nullptr) {}
  ~ListType() override;
  explicit constexpr ListType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListType(const ListType& from);
  ListType(ListType&& from) noexcept
    : ListType() {
    *this = ::std::move(from);
  }

  inline ListType& operator=(const ListType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListType& operator=(ListType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ListType& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListType* internal_default_instance() {
    return reinterpret_cast<const ListType*>(
               &_ListType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ListType& a, ListType& b) {
    a.Swap(&b);
  }
  inline void Swap(ListType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ListType& from);
  void MergeFrom(const ListType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.ListType";
  }
  protected:
  explicit ListType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kLengthFieldNumber = 2,
  };
  // .CoreML.Specification.MILSpec.ValueType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::CoreML::Specification::MILSpec::ValueType& type() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::ValueType* release_type();
  ::CoreML::Specification::MILSpec::ValueType* mutable_type();
  void set_allocated_type(::CoreML::Specification::MILSpec::ValueType* type);
  private:
  const ::CoreML::Specification::MILSpec::ValueType& _internal_type() const;
  ::CoreML::Specification::MILSpec::ValueType* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::CoreML::Specification::MILSpec::ValueType* type);
  ::CoreML::Specification::MILSpec::ValueType* unsafe_arena_release_type();

  // .CoreML.Specification.MILSpec.Dimension length = 2;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  const ::CoreML::Specification::MILSpec::Dimension& length() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::Dimension* release_length();
  ::CoreML::Specification::MILSpec::Dimension* mutable_length();
  void set_allocated_length(::CoreML::Specification::MILSpec::Dimension* length);
  private:
  const ::CoreML::Specification::MILSpec::Dimension& _internal_length() const;
  ::CoreML::Specification::MILSpec::Dimension* _internal_mutable_length();
  public:
  void unsafe_arena_set_allocated_length(
      ::CoreML::Specification::MILSpec::Dimension* length);
  ::CoreML::Specification::MILSpec::Dimension* unsafe_arena_release_length();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.ListType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::CoreML::Specification::MILSpec::ValueType* type_;
  ::CoreML::Specification::MILSpec::Dimension* length_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class DictionaryType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.DictionaryType) */ {
 public:
  inline DictionaryType() : DictionaryType(nullptr) {}
  ~DictionaryType() override;
  explicit constexpr DictionaryType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DictionaryType(const DictionaryType& from);
  DictionaryType(DictionaryType&& from) noexcept
    : DictionaryType() {
    *this = ::std::move(from);
  }

  inline DictionaryType& operator=(const DictionaryType& from) {
    CopyFrom(from);
    return *this;
  }
  inline DictionaryType& operator=(DictionaryType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DictionaryType& default_instance() {
    return *internal_default_instance();
  }
  static inline const DictionaryType* internal_default_instance() {
    return reinterpret_cast<const DictionaryType*>(
               &_DictionaryType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DictionaryType& a, DictionaryType& b) {
    a.Swap(&b);
  }
  inline void Swap(DictionaryType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DictionaryType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DictionaryType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DictionaryType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DictionaryType& from);
  void MergeFrom(const DictionaryType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DictionaryType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.DictionaryType";
  }
  protected:
  explicit DictionaryType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyTypeFieldNumber = 1,
    kValueTypeFieldNumber = 2,
  };
  // .CoreML.Specification.MILSpec.ValueType keyType = 1;
  bool has_keytype() const;
  private:
  bool _internal_has_keytype() const;
  public:
  void clear_keytype();
  const ::CoreML::Specification::MILSpec::ValueType& keytype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::ValueType* release_keytype();
  ::CoreML::Specification::MILSpec::ValueType* mutable_keytype();
  void set_allocated_keytype(::CoreML::Specification::MILSpec::ValueType* keytype);
  private:
  const ::CoreML::Specification::MILSpec::ValueType& _internal_keytype() const;
  ::CoreML::Specification::MILSpec::ValueType* _internal_mutable_keytype();
  public:
  void unsafe_arena_set_allocated_keytype(
      ::CoreML::Specification::MILSpec::ValueType* keytype);
  ::CoreML::Specification::MILSpec::ValueType* unsafe_arena_release_keytype();

  // .CoreML.Specification.MILSpec.ValueType valueType = 2;
  bool has_valuetype() const;
  private:
  bool _internal_has_valuetype() const;
  public:
  void clear_valuetype();
  const ::CoreML::Specification::MILSpec::ValueType& valuetype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::ValueType* release_valuetype();
  ::CoreML::Specification::MILSpec::ValueType* mutable_valuetype();
  void set_allocated_valuetype(::CoreML::Specification::MILSpec::ValueType* valuetype);
  private:
  const ::CoreML::Specification::MILSpec::ValueType& _internal_valuetype() const;
  ::CoreML::Specification::MILSpec::ValueType* _internal_mutable_valuetype();
  public:
  void unsafe_arena_set_allocated_valuetype(
      ::CoreML::Specification::MILSpec::ValueType* valuetype);
  ::CoreML::Specification::MILSpec::ValueType* unsafe_arena_release_valuetype();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.DictionaryType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::CoreML::Specification::MILSpec::ValueType* keytype_;
  ::CoreML::Specification::MILSpec::ValueType* valuetype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class StateType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.StateType) */ {
 public:
  inline StateType() : StateType(nullptr) {}
  ~StateType() override;
  explicit constexpr StateType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StateType(const StateType& from);
  StateType(StateType&& from) noexcept
    : StateType() {
    *this = ::std::move(from);
  }

  inline StateType& operator=(const StateType& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateType& operator=(StateType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const StateType& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateType* internal_default_instance() {
    return reinterpret_cast<const StateType*>(
               &_StateType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(StateType& a, StateType& b) {
    a.Swap(&b);
  }
  inline void Swap(StateType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StateType& from);
  void MergeFrom(const StateType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StateType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.StateType";
  }
  protected:
  explicit StateType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWrappedTypeFieldNumber = 1,
  };
  // .CoreML.Specification.MILSpec.ValueType wrappedType = 1;
  bool has_wrappedtype() const;
  private:
  bool _internal_has_wrappedtype() const;
  public:
  void clear_wrappedtype();
  const ::CoreML::Specification::MILSpec::ValueType& wrappedtype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::ValueType* release_wrappedtype();
  ::CoreML::Specification::MILSpec::ValueType* mutable_wrappedtype();
  void set_allocated_wrappedtype(::CoreML::Specification::MILSpec::ValueType* wrappedtype);
  private:
  const ::CoreML::Specification::MILSpec::ValueType& _internal_wrappedtype() const;
  ::CoreML::Specification::MILSpec::ValueType* _internal_mutable_wrappedtype();
  public:
  void unsafe_arena_set_allocated_wrappedtype(
      ::CoreML::Specification::MILSpec::ValueType* wrappedtype);
  ::CoreML::Specification::MILSpec::ValueType* unsafe_arena_release_wrappedtype();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.StateType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::CoreML::Specification::MILSpec::ValueType* wrappedtype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class Dimension_ConstantDimension final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Dimension.ConstantDimension) */ {
 public:
  inline Dimension_ConstantDimension() : Dimension_ConstantDimension(nullptr) {}
  ~Dimension_ConstantDimension() override;
  explicit constexpr Dimension_ConstantDimension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dimension_ConstantDimension(const Dimension_ConstantDimension& from);
  Dimension_ConstantDimension(Dimension_ConstantDimension&& from) noexcept
    : Dimension_ConstantDimension() {
    *this = ::std::move(from);
  }

  inline Dimension_ConstantDimension& operator=(const Dimension_ConstantDimension& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dimension_ConstantDimension& operator=(Dimension_ConstantDimension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Dimension_ConstantDimension& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dimension_ConstantDimension* internal_default_instance() {
    return reinterpret_cast<const Dimension_ConstantDimension*>(
               &_Dimension_ConstantDimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Dimension_ConstantDimension& a, Dimension_ConstantDimension& b) {
    a.Swap(&b);
  }
  inline void Swap(Dimension_ConstantDimension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dimension_ConstantDimension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dimension_ConstantDimension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dimension_ConstantDimension>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Dimension_ConstantDimension& from);
  void MergeFrom(const Dimension_ConstantDimension& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Dimension_ConstantDimension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.Dimension.ConstantDimension";
  }
  protected:
  explicit Dimension_ConstantDimension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
  };
  // uint64 size = 1;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Dimension.ConstantDimension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class Dimension_UnknownDimension final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Dimension.UnknownDimension) */ {
 public:
  inline Dimension_UnknownDimension() : Dimension_UnknownDimension(nullptr) {}
  ~Dimension_UnknownDimension() override;
  explicit constexpr Dimension_UnknownDimension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dimension_UnknownDimension(const Dimension_UnknownDimension& from);
  Dimension_UnknownDimension(Dimension_UnknownDimension&& from) noexcept
    : Dimension_UnknownDimension() {
    *this = ::std::move(from);
  }

  inline Dimension_UnknownDimension& operator=(const Dimension_UnknownDimension& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dimension_UnknownDimension& operator=(Dimension_UnknownDimension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Dimension_UnknownDimension& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dimension_UnknownDimension* internal_default_instance() {
    return reinterpret_cast<const Dimension_UnknownDimension*>(
               &_Dimension_UnknownDimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Dimension_UnknownDimension& a, Dimension_UnknownDimension& b) {
    a.Swap(&b);
  }
  inline void Swap(Dimension_UnknownDimension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dimension_UnknownDimension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dimension_UnknownDimension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dimension_UnknownDimension>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Dimension_UnknownDimension& from);
  void MergeFrom(const Dimension_UnknownDimension& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Dimension_UnknownDimension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.Dimension.UnknownDimension";
  }
  protected:
  explicit Dimension_UnknownDimension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVariadicFieldNumber = 1,
  };
  // bool variadic = 1;
  void clear_variadic();
  bool variadic() const;
  void set_variadic(bool value);
  private:
  bool _internal_variadic() const;
  void _internal_set_variadic(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Dimension.UnknownDimension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool variadic_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class Dimension final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Dimension) */ {
 public:
  inline Dimension() : Dimension(nullptr) {}
  ~Dimension() override;
  explicit constexpr Dimension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dimension(const Dimension& from);
  Dimension(Dimension&& from) noexcept
    : Dimension() {
    *this = ::std::move(from);
  }

  inline Dimension& operator=(const Dimension& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dimension& operator=(Dimension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Dimension& default_instance() {
    return *internal_default_instance();
  }
  enum DimensionCase {
    kConstant = 1,
    kUnknown = 2,
    DIMENSION_NOT_SET = 0,
  };

  static inline const Dimension* internal_default_instance() {
    return reinterpret_cast<const Dimension*>(
               &_Dimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Dimension& a, Dimension& b) {
    a.Swap(&b);
  }
  inline void Swap(Dimension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dimension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dimension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dimension>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Dimension& from);
  void MergeFrom(const Dimension& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Dimension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.Dimension";
  }
  protected:
  explicit Dimension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Dimension_ConstantDimension ConstantDimension;
  typedef Dimension_UnknownDimension UnknownDimension;

  // accessors -------------------------------------------------------

  enum : int {
    kConstantFieldNumber = 1,
    kUnknownFieldNumber = 2,
  };
  // .CoreML.Specification.MILSpec.Dimension.ConstantDimension constant = 1;
  bool has_constant() const;
  private:
  bool _internal_has_constant() const;
  public:
  void clear_constant();
  const ::CoreML::Specification::MILSpec::Dimension_ConstantDimension& constant() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* release_constant();
  ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* mutable_constant();
  void set_allocated_constant(::CoreML::Specification::MILSpec::Dimension_ConstantDimension* constant);
  private:
  const ::CoreML::Specification::MILSpec::Dimension_ConstantDimension& _internal_constant() const;
  ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* _internal_mutable_constant();
  public:
  void unsafe_arena_set_allocated_constant(
      ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* constant);
  ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* unsafe_arena_release_constant();

  // .CoreML.Specification.MILSpec.Dimension.UnknownDimension unknown = 2;
  bool has_unknown() const;
  private:
  bool _internal_has_unknown() const;
  public:
  void clear_unknown();
  const ::CoreML::Specification::MILSpec::Dimension_UnknownDimension& unknown() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* release_unknown();
  ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* mutable_unknown();
  void set_allocated_unknown(::CoreML::Specification::MILSpec::Dimension_UnknownDimension* unknown);
  private:
  const ::CoreML::Specification::MILSpec::Dimension_UnknownDimension& _internal_unknown() const;
  ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* _internal_mutable_unknown();
  public:
  void unsafe_arena_set_allocated_unknown(
      ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* unknown);
  ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* unsafe_arena_release_unknown();

  void clear_dimension();
  DimensionCase dimension_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Dimension)
 private:
  class _Internal;
  void set_has_constant();
  void set_has_unknown();

  inline bool has_dimension() const;
  inline void clear_has_dimension();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union DimensionUnion {
    constexpr DimensionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* constant_;
    ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* unknown_;
  } dimension_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class Value_ImmediateValue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Value.ImmediateValue) */ {
 public:
  inline Value_ImmediateValue() : Value_ImmediateValue(nullptr) {}
  ~Value_ImmediateValue() override;
  explicit constexpr Value_ImmediateValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Value_ImmediateValue(const Value_ImmediateValue& from);
  Value_ImmediateValue(Value_ImmediateValue&& from) noexcept
    : Value_ImmediateValue() {
    *this = ::std::move(from);
  }

  inline Value_ImmediateValue& operator=(const Value_ImmediateValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value_ImmediateValue& operator=(Value_ImmediateValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Value_ImmediateValue& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kTensor = 1,
    kTuple = 2,
    kList = 3,
    kDictionary = 4,
    VALUE_NOT_SET = 0,
  };

  static inline const Value_ImmediateValue* internal_default_instance() {
    return reinterpret_cast<const Value_ImmediateValue*>(
               &_Value_ImmediateValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Value_ImmediateValue& a, Value_ImmediateValue& b) {
    a.Swap(&b);
  }
  inline void Swap(Value_ImmediateValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value_ImmediateValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value_ImmediateValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Value_ImmediateValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Value_ImmediateValue& from);
  void MergeFrom(const Value_ImmediateValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Value_ImmediateValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.Value.ImmediateValue";
  }
  protected:
  explicit Value_ImmediateValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTensorFieldNumber = 1,
    kTupleFieldNumber = 2,
    kListFieldNumber = 3,
    kDictionaryFieldNumber = 4,
  };
  // .CoreML.Specification.MILSpec.TensorValue tensor = 1;
  bool has_tensor() const;
  private:
  bool _internal_has_tensor() const;
  public:
  void clear_tensor();
  const ::CoreML::Specification::MILSpec::TensorValue& tensor() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::TensorValue* release_tensor();
  ::CoreML::Specification::MILSpec::TensorValue* mutable_tensor();
  void set_allocated_tensor(::CoreML::Specification::MILSpec::TensorValue* tensor);
  private:
  const ::CoreML::Specification::MILSpec::TensorValue& _internal_tensor() const;
  ::CoreML::Specification::MILSpec::TensorValue* _internal_mutable_tensor();
  public:
  void unsafe_arena_set_allocated_tensor(
      ::CoreML::Specification::MILSpec::TensorValue* tensor);
  ::CoreML::Specification::MILSpec::TensorValue* unsafe_arena_release_tensor();

  // .CoreML.Specification.MILSpec.TupleValue tuple = 2;
  bool has_tuple() const;
  private:
  bool _internal_has_tuple() const;
  public:
  void clear_tuple();
  const ::CoreML::Specification::MILSpec::TupleValue& tuple() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::TupleValue* release_tuple();
  ::CoreML::Specification::MILSpec::TupleValue* mutable_tuple();
  void set_allocated_tuple(::CoreML::Specification::MILSpec::TupleValue* tuple);
  private:
  const ::CoreML::Specification::MILSpec::TupleValue& _internal_tuple() const;
  ::CoreML::Specification::MILSpec::TupleValue* _internal_mutable_tuple();
  public:
  void unsafe_arena_set_allocated_tuple(
      ::CoreML::Specification::MILSpec::TupleValue* tuple);
  ::CoreML::Specification::MILSpec::TupleValue* unsafe_arena_release_tuple();

  // .CoreML.Specification.MILSpec.ListValue list = 3;
  bool has_list() const;
  private:
  bool _internal_has_list() const;
  public:
  void clear_list();
  const ::CoreML::Specification::MILSpec::ListValue& list() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::ListValue* release_list();
  ::CoreML::Specification::MILSpec::ListValue* mutable_list();
  void set_allocated_list(::CoreML::Specification::MILSpec::ListValue* list);
  private:
  const ::CoreML::Specification::MILSpec::ListValue& _internal_list() const;
  ::CoreML::Specification::MILSpec::ListValue* _internal_mutable_list();
  public:
  void unsafe_arena_set_allocated_list(
      ::CoreML::Specification::MILSpec::ListValue* list);
  ::CoreML::Specification::MILSpec::ListValue* unsafe_arena_release_list();

  // .CoreML.Specification.MILSpec.DictionaryValue dictionary = 4;
  bool has_dictionary() const;
  private:
  bool _internal_has_dictionary() const;
  public:
  void clear_dictionary();
  const ::CoreML::Specification::MILSpec::DictionaryValue& dictionary() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::DictionaryValue* release_dictionary();
  ::CoreML::Specification::MILSpec::DictionaryValue* mutable_dictionary();
  void set_allocated_dictionary(::CoreML::Specification::MILSpec::DictionaryValue* dictionary);
  private:
  const ::CoreML::Specification::MILSpec::DictionaryValue& _internal_dictionary() const;
  ::CoreML::Specification::MILSpec::DictionaryValue* _internal_mutable_dictionary();
  public:
  void unsafe_arena_set_allocated_dictionary(
      ::CoreML::Specification::MILSpec::DictionaryValue* dictionary);
  ::CoreML::Specification::MILSpec::DictionaryValue* unsafe_arena_release_dictionary();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Value.ImmediateValue)
 private:
  class _Internal;
  void set_has_tensor();
  void set_has_tuple();
  void set_has_list();
  void set_has_dictionary();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CoreML::Specification::MILSpec::TensorValue* tensor_;
    ::CoreML::Specification::MILSpec::TupleValue* tuple_;
    ::CoreML::Specification::MILSpec::ListValue* list_;
    ::CoreML::Specification::MILSpec::DictionaryValue* dictionary_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class Value_BlobFileValue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Value.BlobFileValue) */ {
 public:
  inline Value_BlobFileValue() : Value_BlobFileValue(nullptr) {}
  ~Value_BlobFileValue() override;
  explicit constexpr Value_BlobFileValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Value_BlobFileValue(const Value_BlobFileValue& from);
  Value_BlobFileValue(Value_BlobFileValue&& from) noexcept
    : Value_BlobFileValue() {
    *this = ::std::move(from);
  }

  inline Value_BlobFileValue& operator=(const Value_BlobFileValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value_BlobFileValue& operator=(Value_BlobFileValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Value_BlobFileValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const Value_BlobFileValue* internal_default_instance() {
    return reinterpret_cast<const Value_BlobFileValue*>(
               &_Value_BlobFileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Value_BlobFileValue& a, Value_BlobFileValue& b) {
    a.Swap(&b);
  }
  inline void Swap(Value_BlobFileValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value_BlobFileValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value_BlobFileValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Value_BlobFileValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Value_BlobFileValue& from);
  void MergeFrom(const Value_BlobFileValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Value_BlobFileValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.Value.BlobFileValue";
  }
  protected:
  explicit Value_BlobFileValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 1,
    kOffsetFieldNumber = 2,
  };
  // string fileName = 1;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // uint64 offset = 2;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Value.BlobFileValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  uint64_t offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class Value final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  ~Value() override;
  explicit constexpr Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Value& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kImmediateValue = 3,
    kBlobFileValue = 5,
    VALUE_NOT_SET = 0,
  };

  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Value* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Value_ImmediateValue ImmediateValue;
  typedef Value_BlobFileValue BlobFileValue;

  // accessors -------------------------------------------------------

  enum : int {
    kDocStringFieldNumber = 1,
    kTypeFieldNumber = 2,
    kImmediateValueFieldNumber = 3,
    kBlobFileValueFieldNumber = 5,
  };
  // string docString = 1;
  void clear_docstring();
  const std::string& docstring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_docstring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_docstring();
  PROTOBUF_NODISCARD std::string* release_docstring();
  void set_allocated_docstring(std::string* docstring);
  private:
  const std::string& _internal_docstring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_docstring(const std::string& value);
  std::string* _internal_mutable_docstring();
  public:

  // .CoreML.Specification.MILSpec.ValueType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::CoreML::Specification::MILSpec::ValueType& type() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::ValueType* release_type();
  ::CoreML::Specification::MILSpec::ValueType* mutable_type();
  void set_allocated_type(::CoreML::Specification::MILSpec::ValueType* type);
  private:
  const ::CoreML::Specification::MILSpec::ValueType& _internal_type() const;
  ::CoreML::Specification::MILSpec::ValueType* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::CoreML::Specification::MILSpec::ValueType* type);
  ::CoreML::Specification::MILSpec::ValueType* unsafe_arena_release_type();

  // .CoreML.Specification.MILSpec.Value.ImmediateValue immediateValue = 3;
  bool has_immediatevalue() const;
  private:
  bool _internal_has_immediatevalue() const;
  public:
  void clear_immediatevalue();
  const ::CoreML::Specification::MILSpec::Value_ImmediateValue& immediatevalue() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::Value_ImmediateValue* release_immediatevalue();
  ::CoreML::Specification::MILSpec::Value_ImmediateValue* mutable_immediatevalue();
  void set_allocated_immediatevalue(::CoreML::Specification::MILSpec::Value_ImmediateValue* immediatevalue);
  private:
  const ::CoreML::Specification::MILSpec::Value_ImmediateValue& _internal_immediatevalue() const;
  ::CoreML::Specification::MILSpec::Value_ImmediateValue* _internal_mutable_immediatevalue();
  public:
  void unsafe_arena_set_allocated_immediatevalue(
      ::CoreML::Specification::MILSpec::Value_ImmediateValue* immediatevalue);
  ::CoreML::Specification::MILSpec::Value_ImmediateValue* unsafe_arena_release_immediatevalue();

  // .CoreML.Specification.MILSpec.Value.BlobFileValue blobFileValue = 5;
  bool has_blobfilevalue() const;
  private:
  bool _internal_has_blobfilevalue() const;
  public:
  void clear_blobfilevalue();
  const ::CoreML::Specification::MILSpec::Value_BlobFileValue& blobfilevalue() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::Value_BlobFileValue* release_blobfilevalue();
  ::CoreML::Specification::MILSpec::Value_BlobFileValue* mutable_blobfilevalue();
  void set_allocated_blobfilevalue(::CoreML::Specification::MILSpec::Value_BlobFileValue* blobfilevalue);
  private:
  const ::CoreML::Specification::MILSpec::Value_BlobFileValue& _internal_blobfilevalue() const;
  ::CoreML::Specification::MILSpec::Value_BlobFileValue* _internal_mutable_blobfilevalue();
  public:
  void unsafe_arena_set_allocated_blobfilevalue(
      ::CoreML::Specification::MILSpec::Value_BlobFileValue* blobfilevalue);
  ::CoreML::Specification::MILSpec::Value_BlobFileValue* unsafe_arena_release_blobfilevalue();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Value)
 private:
  class _Internal;
  void set_has_immediatevalue();
  void set_has_blobfilevalue();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr docstring_;
  ::CoreML::Specification::MILSpec::ValueType* type_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CoreML::Specification::MILSpec::Value_ImmediateValue* immediatevalue_;
    ::CoreML::Specification::MILSpec::Value_BlobFileValue* blobfilevalue_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class TensorValue_RepeatedFloats final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats) */ {
 public:
  inline TensorValue_RepeatedFloats() : TensorValue_RepeatedFloats(nullptr) {}
  ~TensorValue_RepeatedFloats() override;
  explicit constexpr TensorValue_RepeatedFloats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TensorValue_RepeatedFloats(const TensorValue_RepeatedFloats& from);
  TensorValue_RepeatedFloats(TensorValue_RepeatedFloats&& from) noexcept
    : TensorValue_RepeatedFloats() {
    *this = ::std::move(from);
  }

  inline TensorValue_RepeatedFloats& operator=(const TensorValue_RepeatedFloats& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorValue_RepeatedFloats& operator=(TensorValue_RepeatedFloats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TensorValue_RepeatedFloats& default_instance() {
    return *internal_default_instance();
  }
  static inline const TensorValue_RepeatedFloats* internal_default_instance() {
    return reinterpret_cast<const TensorValue_RepeatedFloats*>(
               &_TensorValue_RepeatedFloats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(TensorValue_RepeatedFloats& a, TensorValue_RepeatedFloats& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorValue_RepeatedFloats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorValue_RepeatedFloats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorValue_RepeatedFloats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TensorValue_RepeatedFloats>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TensorValue_RepeatedFloats& from);
  void MergeFrom(const TensorValue_RepeatedFloats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorValue_RepeatedFloats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.TensorValue.RepeatedFloats";
  }
  protected:
  explicit TensorValue_RepeatedFloats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated float values = 1 [packed = true];
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  float _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_values() const;
  void _internal_add_values(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_values();
  public:
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class TensorValue_RepeatedDoubles final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles) */ {
 public:
  inline TensorValue_RepeatedDoubles() : TensorValue_RepeatedDoubles(nullptr) {}
  ~TensorValue_RepeatedDoubles() override;
  explicit constexpr TensorValue_RepeatedDoubles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TensorValue_RepeatedDoubles(const TensorValue_RepeatedDoubles& from);
  TensorValue_RepeatedDoubles(TensorValue_RepeatedDoubles&& from) noexcept
    : TensorValue_RepeatedDoubles() {
    *this = ::std::move(from);
  }

  inline TensorValue_RepeatedDoubles& operator=(const TensorValue_RepeatedDoubles& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorValue_RepeatedDoubles& operator=(TensorValue_RepeatedDoubles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TensorValue_RepeatedDoubles& default_instance() {
    return *internal_default_instance();
  }
  static inline const TensorValue_RepeatedDoubles* internal_default_instance() {
    return reinterpret_cast<const TensorValue_RepeatedDoubles*>(
               &_TensorValue_RepeatedDoubles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(TensorValue_RepeatedDoubles& a, TensorValue_RepeatedDoubles& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorValue_RepeatedDoubles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorValue_RepeatedDoubles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorValue_RepeatedDoubles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TensorValue_RepeatedDoubles>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TensorValue_RepeatedDoubles& from);
  void MergeFrom(const TensorValue_RepeatedDoubles& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorValue_RepeatedDoubles* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles";
  }
  protected:
  explicit TensorValue_RepeatedDoubles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated double values = 1 [packed = true];
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  double _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_values() const;
  void _internal_add_values(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_values();
  public:
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class TensorValue_RepeatedInts final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TensorValue.RepeatedInts) */ {
 public:
  inline TensorValue_RepeatedInts() : TensorValue_RepeatedInts(nullptr) {}
  ~TensorValue_RepeatedInts() override;
  explicit constexpr TensorValue_RepeatedInts(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TensorValue_RepeatedInts(const TensorValue_RepeatedInts& from);
  TensorValue_RepeatedInts(TensorValue_RepeatedInts&& from) noexcept
    : TensorValue_RepeatedInts() {
    *this = ::std::move(from);
  }

  inline TensorValue_RepeatedInts& operator=(const TensorValue_RepeatedInts& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorValue_RepeatedInts& operator=(TensorValue_RepeatedInts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TensorValue_RepeatedInts& default_instance() {
    return *internal_default_instance();
  }
  static inline const TensorValue_RepeatedInts* internal_default_instance() {
    return reinterpret_cast<const TensorValue_RepeatedInts*>(
               &_TensorValue_RepeatedInts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(TensorValue_RepeatedInts& a, TensorValue_RepeatedInts& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorValue_RepeatedInts* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorValue_RepeatedInts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorValue_RepeatedInts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TensorValue_RepeatedInts>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TensorValue_RepeatedInts& from);
  void MergeFrom(const TensorValue_RepeatedInts& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorValue_RepeatedInts* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.TensorValue.RepeatedInts";
  }
  protected:
  explicit TensorValue_RepeatedInts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated int32 values = 1 [packed = true];
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  int32_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_values() const;
  void _internal_add_values(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_values();
  public:
  int32_t values(int index) const;
  void set_values(int index, int32_t value);
  void add_values(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TensorValue.RepeatedInts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > values_;
  mutable std::atomic<int> _values_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class TensorValue_RepeatedLongInts final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts) */ {
 public:
  inline TensorValue_RepeatedLongInts() : TensorValue_RepeatedLongInts(nullptr) {}
  ~TensorValue_RepeatedLongInts() override;
  explicit constexpr TensorValue_RepeatedLongInts(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TensorValue_RepeatedLongInts(const TensorValue_RepeatedLongInts& from);
  TensorValue_RepeatedLongInts(TensorValue_RepeatedLongInts&& from) noexcept
    : TensorValue_RepeatedLongInts() {
    *this = ::std::move(from);
  }

  inline TensorValue_RepeatedLongInts& operator=(const TensorValue_RepeatedLongInts& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorValue_RepeatedLongInts& operator=(TensorValue_RepeatedLongInts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TensorValue_RepeatedLongInts& default_instance() {
    return *internal_default_instance();
  }
  static inline const TensorValue_RepeatedLongInts* internal_default_instance() {
    return reinterpret_cast<const TensorValue_RepeatedLongInts*>(
               &_TensorValue_RepeatedLongInts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(TensorValue_RepeatedLongInts& a, TensorValue_RepeatedLongInts& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorValue_RepeatedLongInts* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorValue_RepeatedLongInts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorValue_RepeatedLongInts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TensorValue_RepeatedLongInts>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TensorValue_RepeatedLongInts& from);
  void MergeFrom(const TensorValue_RepeatedLongInts& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorValue_RepeatedLongInts* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts";
  }
  protected:
  explicit TensorValue_RepeatedLongInts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated int64 values = 1 [packed = true];
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  int64_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_values() const;
  void _internal_add_values(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_values();
  public:
  int64_t values(int index) const;
  void set_values(int index, int64_t value);
  void add_values(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > values_;
  mutable std::atomic<int> _values_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class TensorValue_RepeatedBools final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TensorValue.RepeatedBools) */ {
 public:
  inline TensorValue_RepeatedBools() : TensorValue_RepeatedBools(nullptr) {}
  ~TensorValue_RepeatedBools() override;
  explicit constexpr TensorValue_RepeatedBools(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TensorValue_RepeatedBools(const TensorValue_RepeatedBools& from);
  TensorValue_RepeatedBools(TensorValue_RepeatedBools&& from) noexcept
    : TensorValue_RepeatedBools() {
    *this = ::std::move(from);
  }

  inline TensorValue_RepeatedBools& operator=(const TensorValue_RepeatedBools& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorValue_RepeatedBools& operator=(TensorValue_RepeatedBools&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TensorValue_RepeatedBools& default_instance() {
    return *internal_default_instance();
  }
  static inline const TensorValue_RepeatedBools* internal_default_instance() {
    return reinterpret_cast<const TensorValue_RepeatedBools*>(
               &_TensorValue_RepeatedBools_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(TensorValue_RepeatedBools& a, TensorValue_RepeatedBools& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorValue_RepeatedBools* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorValue_RepeatedBools* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorValue_RepeatedBools* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TensorValue_RepeatedBools>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TensorValue_RepeatedBools& from);
  void MergeFrom(const TensorValue_RepeatedBools& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorValue_RepeatedBools* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.TensorValue.RepeatedBools";
  }
  protected:
  explicit TensorValue_RepeatedBools(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated bool values = 1 [packed = true];
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  bool _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_values() const;
  void _internal_add_values(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_values();
  public:
  bool values(int index) const;
  void set_values(int index, bool value);
  void add_values(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TensorValue.RepeatedBools)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class TensorValue_RepeatedStrings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings) */ {
 public:
  inline TensorValue_RepeatedStrings() : TensorValue_RepeatedStrings(nullptr) {}
  ~TensorValue_RepeatedStrings() override;
  explicit constexpr TensorValue_RepeatedStrings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TensorValue_RepeatedStrings(const TensorValue_RepeatedStrings& from);
  TensorValue_RepeatedStrings(TensorValue_RepeatedStrings&& from) noexcept
    : TensorValue_RepeatedStrings() {
    *this = ::std::move(from);
  }

  inline TensorValue_RepeatedStrings& operator=(const TensorValue_RepeatedStrings& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorValue_RepeatedStrings& operator=(TensorValue_RepeatedStrings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TensorValue_RepeatedStrings& default_instance() {
    return *internal_default_instance();
  }
  static inline const TensorValue_RepeatedStrings* internal_default_instance() {
    return reinterpret_cast<const TensorValue_RepeatedStrings*>(
               &_TensorValue_RepeatedStrings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(TensorValue_RepeatedStrings& a, TensorValue_RepeatedStrings& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorValue_RepeatedStrings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorValue_RepeatedStrings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorValue_RepeatedStrings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TensorValue_RepeatedStrings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TensorValue_RepeatedStrings& from);
  void MergeFrom(const TensorValue_RepeatedStrings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorValue_RepeatedStrings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.TensorValue.RepeatedStrings";
  }
  protected:
  explicit TensorValue_RepeatedStrings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated string values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_values();
  private:
  const std::string& _internal_values(int index) const;
  std::string* _internal_add_values();
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class TensorValue_RepeatedBytes final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes) */ {
 public:
  inline TensorValue_RepeatedBytes() : TensorValue_RepeatedBytes(nullptr) {}
  ~TensorValue_RepeatedBytes() override;
  explicit constexpr TensorValue_RepeatedBytes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TensorValue_RepeatedBytes(const TensorValue_RepeatedBytes& from);
  TensorValue_RepeatedBytes(TensorValue_RepeatedBytes&& from) noexcept
    : TensorValue_RepeatedBytes() {
    *this = ::std::move(from);
  }

  inline TensorValue_RepeatedBytes& operator=(const TensorValue_RepeatedBytes& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorValue_RepeatedBytes& operator=(TensorValue_RepeatedBytes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TensorValue_RepeatedBytes& default_instance() {
    return *internal_default_instance();
  }
  static inline const TensorValue_RepeatedBytes* internal_default_instance() {
    return reinterpret_cast<const TensorValue_RepeatedBytes*>(
               &_TensorValue_RepeatedBytes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(TensorValue_RepeatedBytes& a, TensorValue_RepeatedBytes& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorValue_RepeatedBytes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorValue_RepeatedBytes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorValue_RepeatedBytes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TensorValue_RepeatedBytes>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TensorValue_RepeatedBytes& from);
  void MergeFrom(const TensorValue_RepeatedBytes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorValue_RepeatedBytes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.TensorValue.RepeatedBytes";
  }
  protected:
  explicit TensorValue_RepeatedBytes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // bytes values = 1;
  void clear_values();
  const std::string& values() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_values(ArgT0&& arg0, ArgT... args);
  std::string* mutable_values();
  PROTOBUF_NODISCARD std::string* release_values();
  void set_allocated_values(std::string* values);
  private:
  const std::string& _internal_values() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_values(const std::string& value);
  std::string* _internal_mutable_values();
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class TensorValue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TensorValue) */ {
 public:
  inline TensorValue() : TensorValue(nullptr) {}
  ~TensorValue() override;
  explicit constexpr TensorValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TensorValue(const TensorValue& from);
  TensorValue(TensorValue&& from) noexcept
    : TensorValue() {
    *this = ::std::move(from);
  }

  inline TensorValue& operator=(const TensorValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorValue& operator=(TensorValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TensorValue& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kFloats = 1,
    kInts = 2,
    kBools = 3,
    kStrings = 4,
    kLongInts = 5,
    kDoubles = 6,
    kBytes = 7,
    VALUE_NOT_SET = 0,
  };

  static inline const TensorValue* internal_default_instance() {
    return reinterpret_cast<const TensorValue*>(
               &_TensorValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(TensorValue& a, TensorValue& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TensorValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TensorValue& from);
  void MergeFrom(const TensorValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.TensorValue";
  }
  protected:
  explicit TensorValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TensorValue_RepeatedFloats RepeatedFloats;
  typedef TensorValue_RepeatedDoubles RepeatedDoubles;
  typedef TensorValue_RepeatedInts RepeatedInts;
  typedef TensorValue_RepeatedLongInts RepeatedLongInts;
  typedef TensorValue_RepeatedBools RepeatedBools;
  typedef TensorValue_RepeatedStrings RepeatedStrings;
  typedef TensorValue_RepeatedBytes RepeatedBytes;

  // accessors -------------------------------------------------------

  enum : int {
    kFloatsFieldNumber = 1,
    kIntsFieldNumber = 2,
    kBoolsFieldNumber = 3,
    kStringsFieldNumber = 4,
    kLongIntsFieldNumber = 5,
    kDoublesFieldNumber = 6,
    kBytesFieldNumber = 7,
  };
  // .CoreML.Specification.MILSpec.TensorValue.RepeatedFloats floats = 1;
  bool has_floats() const;
  private:
  bool _internal_has_floats() const;
  public:
  void clear_floats();
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats& floats() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* release_floats();
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* mutable_floats();
  void set_allocated_floats(::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* floats);
  private:
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats& _internal_floats() const;
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* _internal_mutable_floats();
  public:
  void unsafe_arena_set_allocated_floats(
      ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* floats);
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* unsafe_arena_release_floats();

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedInts ints = 2;
  bool has_ints() const;
  private:
  bool _internal_has_ints() const;
  public:
  void clear_ints();
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts& ints() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* release_ints();
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* mutable_ints();
  void set_allocated_ints(::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* ints);
  private:
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts& _internal_ints() const;
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* _internal_mutable_ints();
  public:
  void unsafe_arena_set_allocated_ints(
      ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* ints);
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* unsafe_arena_release_ints();

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedBools bools = 3;
  bool has_bools() const;
  private:
  bool _internal_has_bools() const;
  public:
  void clear_bools();
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools& bools() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* release_bools();
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* mutable_bools();
  void set_allocated_bools(::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* bools);
  private:
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools& _internal_bools() const;
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* _internal_mutable_bools();
  public:
  void unsafe_arena_set_allocated_bools(
      ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* bools);
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* unsafe_arena_release_bools();

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedStrings strings = 4;
  bool has_strings() const;
  private:
  bool _internal_has_strings() const;
  public:
  void clear_strings();
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings& strings() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* release_strings();
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* mutable_strings();
  void set_allocated_strings(::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* strings);
  private:
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings& _internal_strings() const;
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* _internal_mutable_strings();
  public:
  void unsafe_arena_set_allocated_strings(
      ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* strings);
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* unsafe_arena_release_strings();

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts longInts = 5;
  bool has_longints() const;
  private:
  bool _internal_has_longints() const;
  public:
  void clear_longints();
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts& longints() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* release_longints();
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* mutable_longints();
  void set_allocated_longints(::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* longints);
  private:
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts& _internal_longints() const;
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* _internal_mutable_longints();
  public:
  void unsafe_arena_set_allocated_longints(
      ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* longints);
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* unsafe_arena_release_longints();

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles doubles = 6;
  bool has_doubles() const;
  private:
  bool _internal_has_doubles() const;
  public:
  void clear_doubles();
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles& doubles() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* release_doubles();
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* mutable_doubles();
  void set_allocated_doubles(::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* doubles);
  private:
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles& _internal_doubles() const;
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* _internal_mutable_doubles();
  public:
  void unsafe_arena_set_allocated_doubles(
      ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* doubles);
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* unsafe_arena_release_doubles();

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedBytes bytes = 7;
  bool has_bytes() const;
  private:
  bool _internal_has_bytes() const;
  public:
  void clear_bytes();
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes& bytes() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* release_bytes();
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* mutable_bytes();
  void set_allocated_bytes(::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* bytes);
  private:
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes& _internal_bytes() const;
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* _internal_mutable_bytes();
  public:
  void unsafe_arena_set_allocated_bytes(
      ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* bytes);
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* unsafe_arena_release_bytes();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TensorValue)
 private:
  class _Internal;
  void set_has_floats();
  void set_has_ints();
  void set_has_bools();
  void set_has_strings();
  void set_has_longints();
  void set_has_doubles();
  void set_has_bytes();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* floats_;
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* ints_;
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* bools_;
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* strings_;
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* longints_;
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* doubles_;
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* bytes_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class TupleValue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TupleValue) */ {
 public:
  inline TupleValue() : TupleValue(nullptr) {}
  ~TupleValue() override;
  explicit constexpr TupleValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TupleValue(const TupleValue& from);
  TupleValue(TupleValue&& from) noexcept
    : TupleValue() {
    *this = ::std::move(from);
  }

  inline TupleValue& operator=(const TupleValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TupleValue& operator=(TupleValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TupleValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const TupleValue* internal_default_instance() {
    return reinterpret_cast<const TupleValue*>(
               &_TupleValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(TupleValue& a, TupleValue& b) {
    a.Swap(&b);
  }
  inline void Swap(TupleValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TupleValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TupleValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TupleValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TupleValue& from);
  void MergeFrom(const TupleValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TupleValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.TupleValue";
  }
  protected:
  explicit TupleValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .CoreML.Specification.MILSpec.Value values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::CoreML::Specification::MILSpec::Value* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value >*
      mutable_values();
  private:
  const ::CoreML::Specification::MILSpec::Value& _internal_values(int index) const;
  ::CoreML::Specification::MILSpec::Value* _internal_add_values();
  public:
  const ::CoreML::Specification::MILSpec::Value& values(int index) const;
  ::CoreML::Specification::MILSpec::Value* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value >&
      values() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TupleValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class ListValue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.ListValue) */ {
 public:
  inline ListValue() : ListValue(nullptr) {}
  ~ListValue() override;
  explicit constexpr ListValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListValue(const ListValue& from);
  ListValue(ListValue&& from) noexcept
    : ListValue() {
    *this = ::std::move(from);
  }

  inline ListValue& operator=(const ListValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListValue& operator=(ListValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ListValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListValue* internal_default_instance() {
    return reinterpret_cast<const ListValue*>(
               &_ListValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ListValue& a, ListValue& b) {
    a.Swap(&b);
  }
  inline void Swap(ListValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ListValue& from);
  void MergeFrom(const ListValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.ListValue";
  }
  protected:
  explicit ListValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .CoreML.Specification.MILSpec.Value values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::CoreML::Specification::MILSpec::Value* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value >*
      mutable_values();
  private:
  const ::CoreML::Specification::MILSpec::Value& _internal_values(int index) const;
  ::CoreML::Specification::MILSpec::Value* _internal_add_values();
  public:
  const ::CoreML::Specification::MILSpec::Value& values(int index) const;
  ::CoreML::Specification::MILSpec::Value* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value >&
      values() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.ListValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class DictionaryValue_KeyValuePair final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair) */ {
 public:
  inline DictionaryValue_KeyValuePair() : DictionaryValue_KeyValuePair(nullptr) {}
  ~DictionaryValue_KeyValuePair() override;
  explicit constexpr DictionaryValue_KeyValuePair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DictionaryValue_KeyValuePair(const DictionaryValue_KeyValuePair& from);
  DictionaryValue_KeyValuePair(DictionaryValue_KeyValuePair&& from) noexcept
    : DictionaryValue_KeyValuePair() {
    *this = ::std::move(from);
  }

  inline DictionaryValue_KeyValuePair& operator=(const DictionaryValue_KeyValuePair& from) {
    CopyFrom(from);
    return *this;
  }
  inline DictionaryValue_KeyValuePair& operator=(DictionaryValue_KeyValuePair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DictionaryValue_KeyValuePair& default_instance() {
    return *internal_default_instance();
  }
  static inline const DictionaryValue_KeyValuePair* internal_default_instance() {
    return reinterpret_cast<const DictionaryValue_KeyValuePair*>(
               &_DictionaryValue_KeyValuePair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(DictionaryValue_KeyValuePair& a, DictionaryValue_KeyValuePair& b) {
    a.Swap(&b);
  }
  inline void Swap(DictionaryValue_KeyValuePair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DictionaryValue_KeyValuePair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DictionaryValue_KeyValuePair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DictionaryValue_KeyValuePair>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DictionaryValue_KeyValuePair& from);
  void MergeFrom(const DictionaryValue_KeyValuePair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DictionaryValue_KeyValuePair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair";
  }
  protected:
  explicit DictionaryValue_KeyValuePair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .CoreML.Specification.MILSpec.Value key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::CoreML::Specification::MILSpec::Value& key() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::Value* release_key();
  ::CoreML::Specification::MILSpec::Value* mutable_key();
  void set_allocated_key(::CoreML::Specification::MILSpec::Value* key);
  private:
  const ::CoreML::Specification::MILSpec::Value& _internal_key() const;
  ::CoreML::Specification::MILSpec::Value* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::CoreML::Specification::MILSpec::Value* key);
  ::CoreML::Specification::MILSpec::Value* unsafe_arena_release_key();

  // .CoreML.Specification.MILSpec.Value value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::CoreML::Specification::MILSpec::Value& value() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::MILSpec::Value* release_value();
  ::CoreML::Specification::MILSpec::Value* mutable_value();
  void set_allocated_value(::CoreML::Specification::MILSpec::Value* value);
  private:
  const ::CoreML::Specification::MILSpec::Value& _internal_value() const;
  ::CoreML::Specification::MILSpec::Value* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::CoreML::Specification::MILSpec::Value* value);
  ::CoreML::Specification::MILSpec::Value* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::CoreML::Specification::MILSpec::Value* key_;
  ::CoreML::Specification::MILSpec::Value* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// -------------------------------------------------------------------

class DictionaryValue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.DictionaryValue) */ {
 public:
  inline DictionaryValue() : DictionaryValue(nullptr) {}
  ~DictionaryValue() override;
  explicit constexpr DictionaryValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DictionaryValue(const DictionaryValue& from);
  DictionaryValue(DictionaryValue&& from) noexcept
    : DictionaryValue() {
    *this = ::std::move(from);
  }

  inline DictionaryValue& operator=(const DictionaryValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline DictionaryValue& operator=(DictionaryValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DictionaryValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const DictionaryValue* internal_default_instance() {
    return reinterpret_cast<const DictionaryValue*>(
               &_DictionaryValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(DictionaryValue& a, DictionaryValue& b) {
    a.Swap(&b);
  }
  inline void Swap(DictionaryValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DictionaryValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DictionaryValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DictionaryValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DictionaryValue& from);
  void MergeFrom(const DictionaryValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DictionaryValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.MILSpec.DictionaryValue";
  }
  protected:
  explicit DictionaryValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DictionaryValue_KeyValuePair KeyValuePair;

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair >*
      mutable_values();
  private:
  const ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair& _internal_values(int index) const;
  ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair* _internal_add_values();
  public:
  const ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair& values(int index) const;
  ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair >&
      values() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.DictionaryValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MIL_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Program

// int64 version = 1;
inline void Program::clear_version() {
  version_ = int64_t{0};
}
inline int64_t Program::_internal_version() const {
  return version_;
}
inline int64_t Program::version() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Program.version)
  return _internal_version();
}
inline void Program::_internal_set_version(int64_t value) {
  
  version_ = value;
}
inline void Program::set_version(int64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Program.version)
}

// map<string, .CoreML.Specification.MILSpec.Function> functions = 2;
inline int Program::_internal_functions_size() const {
  return functions_.size();
}
inline int Program::functions_size() const {
  return _internal_functions_size();
}
inline void Program::clear_functions() {
  functions_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Function >&
Program::_internal_functions() const {
  return functions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Function >&
Program::functions() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.MILSpec.Program.functions)
  return _internal_functions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Function >*
Program::_internal_mutable_functions() {
  return functions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Function >*
Program::mutable_functions() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.MILSpec.Program.functions)
  return _internal_mutable_functions();
}

// string docString = 3;
inline void Program::clear_docstring() {
  docstring_.ClearToEmpty();
}
inline const std::string& Program::docstring() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Program.docString)
  return _internal_docstring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Program::set_docstring(ArgT0&& arg0, ArgT... args) {
 
 docstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Program.docString)
}
inline std::string* Program::mutable_docstring() {
  std::string* _s = _internal_mutable_docstring();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Program.docString)
  return _s;
}
inline const std::string& Program::_internal_docstring() const {
  return docstring_.Get();
}
inline void Program::_internal_set_docstring(const std::string& value) {
  
  docstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Program::_internal_mutable_docstring() {
  
  return docstring_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Program::release_docstring() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Program.docString)
  return docstring_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Program::set_allocated_docstring(std::string* docstring) {
  if (docstring != nullptr) {
    
  } else {
    
  }
  docstring_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), docstring,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (docstring_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    docstring_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Program.docString)
}

// map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
inline int Program::_internal_attributes_size() const {
  return attributes_.size();
}
inline int Program::attributes_size() const {
  return _internal_attributes_size();
}
inline void Program::clear_attributes() {
  attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
Program::_internal_attributes() const {
  return attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
Program::attributes() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.MILSpec.Program.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
Program::_internal_mutable_attributes() {
  return attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
Program::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.MILSpec.Program.attributes)
  return _internal_mutable_attributes();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Function

// repeated .CoreML.Specification.MILSpec.NamedValueType inputs = 1;
inline int Function::_internal_inputs_size() const {
  return inputs_.size();
}
inline int Function::inputs_size() const {
  return _internal_inputs_size();
}
inline void Function::clear_inputs() {
  inputs_.Clear();
}
inline ::CoreML::Specification::MILSpec::NamedValueType* Function::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Function.inputs)
  return inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >*
Function::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.Function.inputs)
  return &inputs_;
}
inline const ::CoreML::Specification::MILSpec::NamedValueType& Function::_internal_inputs(int index) const {
  return inputs_.Get(index);
}
inline const ::CoreML::Specification::MILSpec::NamedValueType& Function::inputs(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Function.inputs)
  return _internal_inputs(index);
}
inline ::CoreML::Specification::MILSpec::NamedValueType* Function::_internal_add_inputs() {
  return inputs_.Add();
}
inline ::CoreML::Specification::MILSpec::NamedValueType* Function::add_inputs() {
  ::CoreML::Specification::MILSpec::NamedValueType* _add = _internal_add_inputs();
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.Function.inputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >&
Function::inputs() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.Function.inputs)
  return inputs_;
}

// string opset = 2;
inline void Function::clear_opset() {
  opset_.ClearToEmpty();
}
inline const std::string& Function::opset() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Function.opset)
  return _internal_opset();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Function::set_opset(ArgT0&& arg0, ArgT... args) {
 
 opset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Function.opset)
}
inline std::string* Function::mutable_opset() {
  std::string* _s = _internal_mutable_opset();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Function.opset)
  return _s;
}
inline const std::string& Function::_internal_opset() const {
  return opset_.Get();
}
inline void Function::_internal_set_opset(const std::string& value) {
  
  opset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Function::_internal_mutable_opset() {
  
  return opset_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Function::release_opset() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Function.opset)
  return opset_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Function::set_allocated_opset(std::string* opset) {
  if (opset != nullptr) {
    
  } else {
    
  }
  opset_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), opset,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (opset_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    opset_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Function.opset)
}

// map<string, .CoreML.Specification.MILSpec.Block> block_specializations = 3;
inline int Function::_internal_block_specializations_size() const {
  return block_specializations_.size();
}
inline int Function::block_specializations_size() const {
  return _internal_block_specializations_size();
}
inline void Function::clear_block_specializations() {
  block_specializations_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Block >&
Function::_internal_block_specializations() const {
  return block_specializations_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Block >&
Function::block_specializations() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.MILSpec.Function.block_specializations)
  return _internal_block_specializations();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Block >*
Function::_internal_mutable_block_specializations() {
  return block_specializations_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Block >*
Function::mutable_block_specializations() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.MILSpec.Function.block_specializations)
  return _internal_mutable_block_specializations();
}

// map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
inline int Function::_internal_attributes_size() const {
  return attributes_.size();
}
inline int Function::attributes_size() const {
  return _internal_attributes_size();
}
inline void Function::clear_attributes() {
  attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
Function::_internal_attributes() const {
  return attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
Function::attributes() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.MILSpec.Function.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
Function::_internal_mutable_attributes() {
  return attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
Function::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.MILSpec.Function.attributes)
  return _internal_mutable_attributes();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Block

// repeated .CoreML.Specification.MILSpec.NamedValueType inputs = 1;
inline int Block::_internal_inputs_size() const {
  return inputs_.size();
}
inline int Block::inputs_size() const {
  return _internal_inputs_size();
}
inline void Block::clear_inputs() {
  inputs_.Clear();
}
inline ::CoreML::Specification::MILSpec::NamedValueType* Block::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Block.inputs)
  return inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >*
Block::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.Block.inputs)
  return &inputs_;
}
inline const ::CoreML::Specification::MILSpec::NamedValueType& Block::_internal_inputs(int index) const {
  return inputs_.Get(index);
}
inline const ::CoreML::Specification::MILSpec::NamedValueType& Block::inputs(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Block.inputs)
  return _internal_inputs(index);
}
inline ::CoreML::Specification::MILSpec::NamedValueType* Block::_internal_add_inputs() {
  return inputs_.Add();
}
inline ::CoreML::Specification::MILSpec::NamedValueType* Block::add_inputs() {
  ::CoreML::Specification::MILSpec::NamedValueType* _add = _internal_add_inputs();
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.Block.inputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >&
Block::inputs() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.Block.inputs)
  return inputs_;
}

// repeated string outputs = 2;
inline int Block::_internal_outputs_size() const {
  return outputs_.size();
}
inline int Block::outputs_size() const {
  return _internal_outputs_size();
}
inline void Block::clear_outputs() {
  outputs_.Clear();
}
inline std::string* Block::add_outputs() {
  std::string* _s = _internal_add_outputs();
  // @@protoc_insertion_point(field_add_mutable:CoreML.Specification.MILSpec.Block.outputs)
  return _s;
}
inline const std::string& Block::_internal_outputs(int index) const {
  return outputs_.Get(index);
}
inline const std::string& Block::outputs(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Block.outputs)
  return _internal_outputs(index);
}
inline std::string* Block::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Block.outputs)
  return outputs_.Mutable(index);
}
inline void Block::set_outputs(int index, const std::string& value) {
  outputs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Block.outputs)
}
inline void Block::set_outputs(int index, std::string&& value) {
  outputs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Block.outputs)
}
inline void Block::set_outputs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  outputs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.MILSpec.Block.outputs)
}
inline void Block::set_outputs(int index, const char* value, size_t size) {
  outputs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.MILSpec.Block.outputs)
}
inline std::string* Block::_internal_add_outputs() {
  return outputs_.Add();
}
inline void Block::add_outputs(const std::string& value) {
  outputs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.Block.outputs)
}
inline void Block::add_outputs(std::string&& value) {
  outputs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.Block.outputs)
}
inline void Block::add_outputs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  outputs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CoreML.Specification.MILSpec.Block.outputs)
}
inline void Block::add_outputs(const char* value, size_t size) {
  outputs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CoreML.Specification.MILSpec.Block.outputs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Block::outputs() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.Block.outputs)
  return outputs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Block::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.Block.outputs)
  return &outputs_;
}

// repeated .CoreML.Specification.MILSpec.Operation operations = 3;
inline int Block::_internal_operations_size() const {
  return operations_.size();
}
inline int Block::operations_size() const {
  return _internal_operations_size();
}
inline void Block::clear_operations() {
  operations_.Clear();
}
inline ::CoreML::Specification::MILSpec::Operation* Block::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Block.operations)
  return operations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Operation >*
Block::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.Block.operations)
  return &operations_;
}
inline const ::CoreML::Specification::MILSpec::Operation& Block::_internal_operations(int index) const {
  return operations_.Get(index);
}
inline const ::CoreML::Specification::MILSpec::Operation& Block::operations(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Block.operations)
  return _internal_operations(index);
}
inline ::CoreML::Specification::MILSpec::Operation* Block::_internal_add_operations() {
  return operations_.Add();
}
inline ::CoreML::Specification::MILSpec::Operation* Block::add_operations() {
  ::CoreML::Specification::MILSpec::Operation* _add = _internal_add_operations();
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.Block.operations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Operation >&
Block::operations() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.Block.operations)
  return operations_;
}

// map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
inline int Block::_internal_attributes_size() const {
  return attributes_.size();
}
inline int Block::attributes_size() const {
  return _internal_attributes_size();
}
inline void Block::clear_attributes() {
  attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
Block::_internal_attributes() const {
  return attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
Block::attributes() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.MILSpec.Block.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
Block::_internal_mutable_attributes() {
  return attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
Block::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.MILSpec.Block.attributes)
  return _internal_mutable_attributes();
}

// -------------------------------------------------------------------

// Argument_Binding

// string name = 1;
inline bool Argument_Binding::_internal_has_name() const {
  return binding_case() == kName;
}
inline bool Argument_Binding::has_name() const {
  return _internal_has_name();
}
inline void Argument_Binding::set_has_name() {
  _oneof_case_[0] = kName;
}
inline void Argument_Binding::clear_name() {
  if (_internal_has_name()) {
    binding_.name_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_binding();
  }
}
inline const std::string& Argument_Binding::name() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Argument.Binding.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline void Argument_Binding::set_name(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_name()) {
    clear_binding();
    set_has_name();
    binding_.name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  binding_.name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Argument.Binding.name)
}
inline std::string* Argument_Binding::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Argument.Binding.name)
  return _s;
}
inline const std::string& Argument_Binding::_internal_name() const {
  if (_internal_has_name()) {
    return binding_.name_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Argument_Binding::_internal_set_name(const std::string& value) {
  if (!_internal_has_name()) {
    clear_binding();
    set_has_name();
    binding_.name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  binding_.name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Argument_Binding::_internal_mutable_name() {
  if (!_internal_has_name()) {
    clear_binding();
    set_has_name();
    binding_.name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return binding_.name_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Argument_Binding::release_name() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Argument.Binding.name)
  if (_internal_has_name()) {
    clear_has_binding();
    return binding_.name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Argument_Binding::set_allocated_name(std::string* name) {
  if (has_binding()) {
    clear_binding();
  }
  if (name != nullptr) {
    set_has_name();
    binding_.name_.UnsafeSetDefault(name);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(name);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Argument.Binding.name)
}

// .CoreML.Specification.MILSpec.Value value = 2;
inline bool Argument_Binding::_internal_has_value() const {
  return binding_case() == kValue;
}
inline bool Argument_Binding::has_value() const {
  return _internal_has_value();
}
inline void Argument_Binding::set_has_value() {
  _oneof_case_[0] = kValue;
}
inline void Argument_Binding::clear_value() {
  if (_internal_has_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete binding_.value_;
    }
    clear_has_binding();
  }
}
inline ::CoreML::Specification::MILSpec::Value* Argument_Binding::release_value() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Argument.Binding.value)
  if (_internal_has_value()) {
    clear_has_binding();
      ::CoreML::Specification::MILSpec::Value* temp = binding_.value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    binding_.value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::Value& Argument_Binding::_internal_value() const {
  return _internal_has_value()
      ? *binding_.value_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::Value&>(::CoreML::Specification::MILSpec::_Value_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::Value& Argument_Binding::value() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Argument.Binding.value)
  return _internal_value();
}
inline ::CoreML::Specification::MILSpec::Value* Argument_Binding::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.Argument.Binding.value)
  if (_internal_has_value()) {
    clear_has_binding();
    ::CoreML::Specification::MILSpec::Value* temp = binding_.value_;
    binding_.value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Argument_Binding::unsafe_arena_set_allocated_value(::CoreML::Specification::MILSpec::Value* value) {
  clear_binding();
  if (value) {
    set_has_value();
    binding_.value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.Argument.Binding.value)
}
inline ::CoreML::Specification::MILSpec::Value* Argument_Binding::_internal_mutable_value() {
  if (!_internal_has_value()) {
    clear_binding();
    set_has_value();
    binding_.value_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::Value >(GetArenaForAllocation());
  }
  return binding_.value_;
}
inline ::CoreML::Specification::MILSpec::Value* Argument_Binding::mutable_value() {
  ::CoreML::Specification::MILSpec::Value* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Argument.Binding.value)
  return _msg;
}

inline bool Argument_Binding::has_binding() const {
  return binding_case() != BINDING_NOT_SET;
}
inline void Argument_Binding::clear_has_binding() {
  _oneof_case_[0] = BINDING_NOT_SET;
}
inline Argument_Binding::BindingCase Argument_Binding::binding_case() const {
  return Argument_Binding::BindingCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Argument

// repeated .CoreML.Specification.MILSpec.Argument.Binding arguments = 1;
inline int Argument::_internal_arguments_size() const {
  return arguments_.size();
}
inline int Argument::arguments_size() const {
  return _internal_arguments_size();
}
inline void Argument::clear_arguments() {
  arguments_.Clear();
}
inline ::CoreML::Specification::MILSpec::Argument_Binding* Argument::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Argument.arguments)
  return arguments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Argument_Binding >*
Argument::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.Argument.arguments)
  return &arguments_;
}
inline const ::CoreML::Specification::MILSpec::Argument_Binding& Argument::_internal_arguments(int index) const {
  return arguments_.Get(index);
}
inline const ::CoreML::Specification::MILSpec::Argument_Binding& Argument::arguments(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Argument.arguments)
  return _internal_arguments(index);
}
inline ::CoreML::Specification::MILSpec::Argument_Binding* Argument::_internal_add_arguments() {
  return arguments_.Add();
}
inline ::CoreML::Specification::MILSpec::Argument_Binding* Argument::add_arguments() {
  ::CoreML::Specification::MILSpec::Argument_Binding* _add = _internal_add_arguments();
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.Argument.arguments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Argument_Binding >&
Argument::arguments() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.Argument.arguments)
  return arguments_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Operation

// string type = 1;
inline void Operation::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& Operation::type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Operation.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operation::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Operation.type)
}
inline std::string* Operation::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Operation.type)
  return _s;
}
inline const std::string& Operation::_internal_type() const {
  return type_.Get();
}
inline void Operation::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Operation::release_type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Operation.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Operation::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Operation.type)
}

// map<string, .CoreML.Specification.MILSpec.Argument> inputs = 2;
inline int Operation::_internal_inputs_size() const {
  return inputs_.size();
}
inline int Operation::inputs_size() const {
  return _internal_inputs_size();
}
inline void Operation::clear_inputs() {
  inputs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Argument >&
Operation::_internal_inputs() const {
  return inputs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Argument >&
Operation::inputs() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.MILSpec.Operation.inputs)
  return _internal_inputs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Argument >*
Operation::_internal_mutable_inputs() {
  return inputs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Argument >*
Operation::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.MILSpec.Operation.inputs)
  return _internal_mutable_inputs();
}

// repeated .CoreML.Specification.MILSpec.NamedValueType outputs = 3;
inline int Operation::_internal_outputs_size() const {
  return outputs_.size();
}
inline int Operation::outputs_size() const {
  return _internal_outputs_size();
}
inline void Operation::clear_outputs() {
  outputs_.Clear();
}
inline ::CoreML::Specification::MILSpec::NamedValueType* Operation::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Operation.outputs)
  return outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >*
Operation::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.Operation.outputs)
  return &outputs_;
}
inline const ::CoreML::Specification::MILSpec::NamedValueType& Operation::_internal_outputs(int index) const {
  return outputs_.Get(index);
}
inline const ::CoreML::Specification::MILSpec::NamedValueType& Operation::outputs(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Operation.outputs)
  return _internal_outputs(index);
}
inline ::CoreML::Specification::MILSpec::NamedValueType* Operation::_internal_add_outputs() {
  return outputs_.Add();
}
inline ::CoreML::Specification::MILSpec::NamedValueType* Operation::add_outputs() {
  ::CoreML::Specification::MILSpec::NamedValueType* _add = _internal_add_outputs();
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.Operation.outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >&
Operation::outputs() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.Operation.outputs)
  return outputs_;
}

// repeated .CoreML.Specification.MILSpec.Block blocks = 4;
inline int Operation::_internal_blocks_size() const {
  return blocks_.size();
}
inline int Operation::blocks_size() const {
  return _internal_blocks_size();
}
inline void Operation::clear_blocks() {
  blocks_.Clear();
}
inline ::CoreML::Specification::MILSpec::Block* Operation::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Operation.blocks)
  return blocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Block >*
Operation::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.Operation.blocks)
  return &blocks_;
}
inline const ::CoreML::Specification::MILSpec::Block& Operation::_internal_blocks(int index) const {
  return blocks_.Get(index);
}
inline const ::CoreML::Specification::MILSpec::Block& Operation::blocks(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Operation.blocks)
  return _internal_blocks(index);
}
inline ::CoreML::Specification::MILSpec::Block* Operation::_internal_add_blocks() {
  return blocks_.Add();
}
inline ::CoreML::Specification::MILSpec::Block* Operation::add_blocks() {
  ::CoreML::Specification::MILSpec::Block* _add = _internal_add_blocks();
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.Operation.blocks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Block >&
Operation::blocks() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.Operation.blocks)
  return blocks_;
}

// map<string, .CoreML.Specification.MILSpec.Value> attributes = 5;
inline int Operation::_internal_attributes_size() const {
  return attributes_.size();
}
inline int Operation::attributes_size() const {
  return _internal_attributes_size();
}
inline void Operation::clear_attributes() {
  attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
Operation::_internal_attributes() const {
  return attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
Operation::attributes() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.MILSpec.Operation.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
Operation::_internal_mutable_attributes() {
  return attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
Operation::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.MILSpec.Operation.attributes)
  return _internal_mutable_attributes();
}

// -------------------------------------------------------------------

// NamedValueType

// string name = 1;
inline void NamedValueType::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& NamedValueType::name() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.NamedValueType.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedValueType::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.NamedValueType.name)
}
inline std::string* NamedValueType::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.NamedValueType.name)
  return _s;
}
inline const std::string& NamedValueType::_internal_name() const {
  return name_.Get();
}
inline void NamedValueType::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NamedValueType::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NamedValueType::release_name() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.NamedValueType.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NamedValueType::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.NamedValueType.name)
}

// .CoreML.Specification.MILSpec.ValueType type = 2;
inline bool NamedValueType::_internal_has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline bool NamedValueType::has_type() const {
  return _internal_has_type();
}
inline void NamedValueType::clear_type() {
  if (GetArenaForAllocation() == nullptr && type_ != nullptr) {
    delete type_;
  }
  type_ = nullptr;
}
inline const ::CoreML::Specification::MILSpec::ValueType& NamedValueType::_internal_type() const {
  const ::CoreML::Specification::MILSpec::ValueType* p = type_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::MILSpec::ValueType&>(
      ::CoreML::Specification::MILSpec::_ValueType_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::ValueType& NamedValueType::type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.NamedValueType.type)
  return _internal_type();
}
inline void NamedValueType::unsafe_arena_set_allocated_type(
    ::CoreML::Specification::MILSpec::ValueType* type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.NamedValueType.type)
}
inline ::CoreML::Specification::MILSpec::ValueType* NamedValueType::release_type() {
  
  ::CoreML::Specification::MILSpec::ValueType* temp = type_;
  type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::MILSpec::ValueType* NamedValueType::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.NamedValueType.type)
  
  ::CoreML::Specification::MILSpec::ValueType* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::MILSpec::ValueType* NamedValueType::_internal_mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::MILSpec::ValueType>(GetArenaForAllocation());
    type_ = p;
  }
  return type_;
}
inline ::CoreML::Specification::MILSpec::ValueType* NamedValueType::mutable_type() {
  ::CoreML::Specification::MILSpec::ValueType* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.NamedValueType.type)
  return _msg;
}
inline void NamedValueType::set_allocated_type(::CoreML::Specification::MILSpec::ValueType* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete type_;
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::ValueType>::GetOwningArena(type);
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.NamedValueType.type)
}

// -------------------------------------------------------------------

// ValueType

// .CoreML.Specification.MILSpec.TensorType tensorType = 1;
inline bool ValueType::_internal_has_tensortype() const {
  return type_case() == kTensorType;
}
inline bool ValueType::has_tensortype() const {
  return _internal_has_tensortype();
}
inline void ValueType::set_has_tensortype() {
  _oneof_case_[0] = kTensorType;
}
inline void ValueType::clear_tensortype() {
  if (_internal_has_tensortype()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.tensortype_;
    }
    clear_has_type();
  }
}
inline ::CoreML::Specification::MILSpec::TensorType* ValueType::release_tensortype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.ValueType.tensorType)
  if (_internal_has_tensortype()) {
    clear_has_type();
      ::CoreML::Specification::MILSpec::TensorType* temp = type_.tensortype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.tensortype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::TensorType& ValueType::_internal_tensortype() const {
  return _internal_has_tensortype()
      ? *type_.tensortype_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::TensorType&>(::CoreML::Specification::MILSpec::_TensorType_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::TensorType& ValueType::tensortype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.ValueType.tensorType)
  return _internal_tensortype();
}
inline ::CoreML::Specification::MILSpec::TensorType* ValueType::unsafe_arena_release_tensortype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.ValueType.tensorType)
  if (_internal_has_tensortype()) {
    clear_has_type();
    ::CoreML::Specification::MILSpec::TensorType* temp = type_.tensortype_;
    type_.tensortype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueType::unsafe_arena_set_allocated_tensortype(::CoreML::Specification::MILSpec::TensorType* tensortype) {
  clear_type();
  if (tensortype) {
    set_has_tensortype();
    type_.tensortype_ = tensortype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.ValueType.tensorType)
}
inline ::CoreML::Specification::MILSpec::TensorType* ValueType::_internal_mutable_tensortype() {
  if (!_internal_has_tensortype()) {
    clear_type();
    set_has_tensortype();
    type_.tensortype_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorType >(GetArenaForAllocation());
  }
  return type_.tensortype_;
}
inline ::CoreML::Specification::MILSpec::TensorType* ValueType::mutable_tensortype() {
  ::CoreML::Specification::MILSpec::TensorType* _msg = _internal_mutable_tensortype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.ValueType.tensorType)
  return _msg;
}

// .CoreML.Specification.MILSpec.ListType listType = 2;
inline bool ValueType::_internal_has_listtype() const {
  return type_case() == kListType;
}
inline bool ValueType::has_listtype() const {
  return _internal_has_listtype();
}
inline void ValueType::set_has_listtype() {
  _oneof_case_[0] = kListType;
}
inline void ValueType::clear_listtype() {
  if (_internal_has_listtype()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.listtype_;
    }
    clear_has_type();
  }
}
inline ::CoreML::Specification::MILSpec::ListType* ValueType::release_listtype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.ValueType.listType)
  if (_internal_has_listtype()) {
    clear_has_type();
      ::CoreML::Specification::MILSpec::ListType* temp = type_.listtype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.listtype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::ListType& ValueType::_internal_listtype() const {
  return _internal_has_listtype()
      ? *type_.listtype_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::ListType&>(::CoreML::Specification::MILSpec::_ListType_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::ListType& ValueType::listtype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.ValueType.listType)
  return _internal_listtype();
}
inline ::CoreML::Specification::MILSpec::ListType* ValueType::unsafe_arena_release_listtype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.ValueType.listType)
  if (_internal_has_listtype()) {
    clear_has_type();
    ::CoreML::Specification::MILSpec::ListType* temp = type_.listtype_;
    type_.listtype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueType::unsafe_arena_set_allocated_listtype(::CoreML::Specification::MILSpec::ListType* listtype) {
  clear_type();
  if (listtype) {
    set_has_listtype();
    type_.listtype_ = listtype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.ValueType.listType)
}
inline ::CoreML::Specification::MILSpec::ListType* ValueType::_internal_mutable_listtype() {
  if (!_internal_has_listtype()) {
    clear_type();
    set_has_listtype();
    type_.listtype_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::ListType >(GetArenaForAllocation());
  }
  return type_.listtype_;
}
inline ::CoreML::Specification::MILSpec::ListType* ValueType::mutable_listtype() {
  ::CoreML::Specification::MILSpec::ListType* _msg = _internal_mutable_listtype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.ValueType.listType)
  return _msg;
}

// .CoreML.Specification.MILSpec.TupleType tupleType = 3;
inline bool ValueType::_internal_has_tupletype() const {
  return type_case() == kTupleType;
}
inline bool ValueType::has_tupletype() const {
  return _internal_has_tupletype();
}
inline void ValueType::set_has_tupletype() {
  _oneof_case_[0] = kTupleType;
}
inline void ValueType::clear_tupletype() {
  if (_internal_has_tupletype()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.tupletype_;
    }
    clear_has_type();
  }
}
inline ::CoreML::Specification::MILSpec::TupleType* ValueType::release_tupletype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.ValueType.tupleType)
  if (_internal_has_tupletype()) {
    clear_has_type();
      ::CoreML::Specification::MILSpec::TupleType* temp = type_.tupletype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.tupletype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::TupleType& ValueType::_internal_tupletype() const {
  return _internal_has_tupletype()
      ? *type_.tupletype_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::TupleType&>(::CoreML::Specification::MILSpec::_TupleType_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::TupleType& ValueType::tupletype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.ValueType.tupleType)
  return _internal_tupletype();
}
inline ::CoreML::Specification::MILSpec::TupleType* ValueType::unsafe_arena_release_tupletype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.ValueType.tupleType)
  if (_internal_has_tupletype()) {
    clear_has_type();
    ::CoreML::Specification::MILSpec::TupleType* temp = type_.tupletype_;
    type_.tupletype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueType::unsafe_arena_set_allocated_tupletype(::CoreML::Specification::MILSpec::TupleType* tupletype) {
  clear_type();
  if (tupletype) {
    set_has_tupletype();
    type_.tupletype_ = tupletype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.ValueType.tupleType)
}
inline ::CoreML::Specification::MILSpec::TupleType* ValueType::_internal_mutable_tupletype() {
  if (!_internal_has_tupletype()) {
    clear_type();
    set_has_tupletype();
    type_.tupletype_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::TupleType >(GetArenaForAllocation());
  }
  return type_.tupletype_;
}
inline ::CoreML::Specification::MILSpec::TupleType* ValueType::mutable_tupletype() {
  ::CoreML::Specification::MILSpec::TupleType* _msg = _internal_mutable_tupletype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.ValueType.tupleType)
  return _msg;
}

// .CoreML.Specification.MILSpec.DictionaryType dictionaryType = 4;
inline bool ValueType::_internal_has_dictionarytype() const {
  return type_case() == kDictionaryType;
}
inline bool ValueType::has_dictionarytype() const {
  return _internal_has_dictionarytype();
}
inline void ValueType::set_has_dictionarytype() {
  _oneof_case_[0] = kDictionaryType;
}
inline void ValueType::clear_dictionarytype() {
  if (_internal_has_dictionarytype()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.dictionarytype_;
    }
    clear_has_type();
  }
}
inline ::CoreML::Specification::MILSpec::DictionaryType* ValueType::release_dictionarytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.ValueType.dictionaryType)
  if (_internal_has_dictionarytype()) {
    clear_has_type();
      ::CoreML::Specification::MILSpec::DictionaryType* temp = type_.dictionarytype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.dictionarytype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::DictionaryType& ValueType::_internal_dictionarytype() const {
  return _internal_has_dictionarytype()
      ? *type_.dictionarytype_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::DictionaryType&>(::CoreML::Specification::MILSpec::_DictionaryType_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::DictionaryType& ValueType::dictionarytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.ValueType.dictionaryType)
  return _internal_dictionarytype();
}
inline ::CoreML::Specification::MILSpec::DictionaryType* ValueType::unsafe_arena_release_dictionarytype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.ValueType.dictionaryType)
  if (_internal_has_dictionarytype()) {
    clear_has_type();
    ::CoreML::Specification::MILSpec::DictionaryType* temp = type_.dictionarytype_;
    type_.dictionarytype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueType::unsafe_arena_set_allocated_dictionarytype(::CoreML::Specification::MILSpec::DictionaryType* dictionarytype) {
  clear_type();
  if (dictionarytype) {
    set_has_dictionarytype();
    type_.dictionarytype_ = dictionarytype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.ValueType.dictionaryType)
}
inline ::CoreML::Specification::MILSpec::DictionaryType* ValueType::_internal_mutable_dictionarytype() {
  if (!_internal_has_dictionarytype()) {
    clear_type();
    set_has_dictionarytype();
    type_.dictionarytype_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::DictionaryType >(GetArenaForAllocation());
  }
  return type_.dictionarytype_;
}
inline ::CoreML::Specification::MILSpec::DictionaryType* ValueType::mutable_dictionarytype() {
  ::CoreML::Specification::MILSpec::DictionaryType* _msg = _internal_mutable_dictionarytype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.ValueType.dictionaryType)
  return _msg;
}

// .CoreML.Specification.MILSpec.StateType stateType = 5;
inline bool ValueType::_internal_has_statetype() const {
  return type_case() == kStateType;
}
inline bool ValueType::has_statetype() const {
  return _internal_has_statetype();
}
inline void ValueType::set_has_statetype() {
  _oneof_case_[0] = kStateType;
}
inline void ValueType::clear_statetype() {
  if (_internal_has_statetype()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.statetype_;
    }
    clear_has_type();
  }
}
inline ::CoreML::Specification::MILSpec::StateType* ValueType::release_statetype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.ValueType.stateType)
  if (_internal_has_statetype()) {
    clear_has_type();
      ::CoreML::Specification::MILSpec::StateType* temp = type_.statetype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.statetype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::StateType& ValueType::_internal_statetype() const {
  return _internal_has_statetype()
      ? *type_.statetype_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::StateType&>(::CoreML::Specification::MILSpec::_StateType_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::StateType& ValueType::statetype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.ValueType.stateType)
  return _internal_statetype();
}
inline ::CoreML::Specification::MILSpec::StateType* ValueType::unsafe_arena_release_statetype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.ValueType.stateType)
  if (_internal_has_statetype()) {
    clear_has_type();
    ::CoreML::Specification::MILSpec::StateType* temp = type_.statetype_;
    type_.statetype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueType::unsafe_arena_set_allocated_statetype(::CoreML::Specification::MILSpec::StateType* statetype) {
  clear_type();
  if (statetype) {
    set_has_statetype();
    type_.statetype_ = statetype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.ValueType.stateType)
}
inline ::CoreML::Specification::MILSpec::StateType* ValueType::_internal_mutable_statetype() {
  if (!_internal_has_statetype()) {
    clear_type();
    set_has_statetype();
    type_.statetype_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::StateType >(GetArenaForAllocation());
  }
  return type_.statetype_;
}
inline ::CoreML::Specification::MILSpec::StateType* ValueType::mutable_statetype() {
  ::CoreML::Specification::MILSpec::StateType* _msg = _internal_mutable_statetype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.ValueType.stateType)
  return _msg;
}

inline bool ValueType::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void ValueType::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline ValueType::TypeCase ValueType::type_case() const {
  return ValueType::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TensorType

// .CoreML.Specification.MILSpec.DataType dataType = 1;
inline void TensorType::clear_datatype() {
  datatype_ = 0;
}
inline ::CoreML::Specification::MILSpec::DataType TensorType::_internal_datatype() const {
  return static_cast< ::CoreML::Specification::MILSpec::DataType >(datatype_);
}
inline ::CoreML::Specification::MILSpec::DataType TensorType::datatype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorType.dataType)
  return _internal_datatype();
}
inline void TensorType::_internal_set_datatype(::CoreML::Specification::MILSpec::DataType value) {
  
  datatype_ = value;
}
inline void TensorType::set_datatype(::CoreML::Specification::MILSpec::DataType value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorType.dataType)
}

// int64 rank = 2;
inline void TensorType::clear_rank() {
  rank_ = int64_t{0};
}
inline int64_t TensorType::_internal_rank() const {
  return rank_;
}
inline int64_t TensorType::rank() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorType.rank)
  return _internal_rank();
}
inline void TensorType::_internal_set_rank(int64_t value) {
  
  rank_ = value;
}
inline void TensorType::set_rank(int64_t value) {
  _internal_set_rank(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorType.rank)
}

// repeated .CoreML.Specification.MILSpec.Dimension dimensions = 3;
inline int TensorType::_internal_dimensions_size() const {
  return dimensions_.size();
}
inline int TensorType::dimensions_size() const {
  return _internal_dimensions_size();
}
inline void TensorType::clear_dimensions() {
  dimensions_.Clear();
}
inline ::CoreML::Specification::MILSpec::Dimension* TensorType::mutable_dimensions(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorType.dimensions)
  return dimensions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Dimension >*
TensorType::mutable_dimensions() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.TensorType.dimensions)
  return &dimensions_;
}
inline const ::CoreML::Specification::MILSpec::Dimension& TensorType::_internal_dimensions(int index) const {
  return dimensions_.Get(index);
}
inline const ::CoreML::Specification::MILSpec::Dimension& TensorType::dimensions(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorType.dimensions)
  return _internal_dimensions(index);
}
inline ::CoreML::Specification::MILSpec::Dimension* TensorType::_internal_add_dimensions() {
  return dimensions_.Add();
}
inline ::CoreML::Specification::MILSpec::Dimension* TensorType::add_dimensions() {
  ::CoreML::Specification::MILSpec::Dimension* _add = _internal_add_dimensions();
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TensorType.dimensions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Dimension >&
TensorType::dimensions() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.TensorType.dimensions)
  return dimensions_;
}

// map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
inline int TensorType::_internal_attributes_size() const {
  return attributes_.size();
}
inline int TensorType::attributes_size() const {
  return _internal_attributes_size();
}
inline void TensorType::clear_attributes() {
  attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
TensorType::_internal_attributes() const {
  return attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >&
TensorType::attributes() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.MILSpec.TensorType.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
TensorType::_internal_mutable_attributes() {
  return attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >*
TensorType::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.MILSpec.TensorType.attributes)
  return _internal_mutable_attributes();
}

// -------------------------------------------------------------------

// TupleType

// repeated .CoreML.Specification.MILSpec.ValueType types = 1;
inline int TupleType::_internal_types_size() const {
  return types_.size();
}
inline int TupleType::types_size() const {
  return _internal_types_size();
}
inline void TupleType::clear_types() {
  types_.Clear();
}
inline ::CoreML::Specification::MILSpec::ValueType* TupleType::mutable_types(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TupleType.types)
  return types_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::ValueType >*
TupleType::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.TupleType.types)
  return &types_;
}
inline const ::CoreML::Specification::MILSpec::ValueType& TupleType::_internal_types(int index) const {
  return types_.Get(index);
}
inline const ::CoreML::Specification::MILSpec::ValueType& TupleType::types(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TupleType.types)
  return _internal_types(index);
}
inline ::CoreML::Specification::MILSpec::ValueType* TupleType::_internal_add_types() {
  return types_.Add();
}
inline ::CoreML::Specification::MILSpec::ValueType* TupleType::add_types() {
  ::CoreML::Specification::MILSpec::ValueType* _add = _internal_add_types();
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TupleType.types)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::ValueType >&
TupleType::types() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.TupleType.types)
  return types_;
}

// -------------------------------------------------------------------

// ListType

// .CoreML.Specification.MILSpec.ValueType type = 1;
inline bool ListType::_internal_has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline bool ListType::has_type() const {
  return _internal_has_type();
}
inline void ListType::clear_type() {
  if (GetArenaForAllocation() == nullptr && type_ != nullptr) {
    delete type_;
  }
  type_ = nullptr;
}
inline const ::CoreML::Specification::MILSpec::ValueType& ListType::_internal_type() const {
  const ::CoreML::Specification::MILSpec::ValueType* p = type_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::MILSpec::ValueType&>(
      ::CoreML::Specification::MILSpec::_ValueType_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::ValueType& ListType::type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.ListType.type)
  return _internal_type();
}
inline void ListType::unsafe_arena_set_allocated_type(
    ::CoreML::Specification::MILSpec::ValueType* type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.ListType.type)
}
inline ::CoreML::Specification::MILSpec::ValueType* ListType::release_type() {
  
  ::CoreML::Specification::MILSpec::ValueType* temp = type_;
  type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::MILSpec::ValueType* ListType::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.ListType.type)
  
  ::CoreML::Specification::MILSpec::ValueType* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::MILSpec::ValueType* ListType::_internal_mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::MILSpec::ValueType>(GetArenaForAllocation());
    type_ = p;
  }
  return type_;
}
inline ::CoreML::Specification::MILSpec::ValueType* ListType::mutable_type() {
  ::CoreML::Specification::MILSpec::ValueType* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.ListType.type)
  return _msg;
}
inline void ListType::set_allocated_type(::CoreML::Specification::MILSpec::ValueType* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete type_;
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::ValueType>::GetOwningArena(type);
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.ListType.type)
}

// .CoreML.Specification.MILSpec.Dimension length = 2;
inline bool ListType::_internal_has_length() const {
  return this != internal_default_instance() && length_ != nullptr;
}
inline bool ListType::has_length() const {
  return _internal_has_length();
}
inline void ListType::clear_length() {
  if (GetArenaForAllocation() == nullptr && length_ != nullptr) {
    delete length_;
  }
  length_ = nullptr;
}
inline const ::CoreML::Specification::MILSpec::Dimension& ListType::_internal_length() const {
  const ::CoreML::Specification::MILSpec::Dimension* p = length_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::MILSpec::Dimension&>(
      ::CoreML::Specification::MILSpec::_Dimension_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::Dimension& ListType::length() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.ListType.length)
  return _internal_length();
}
inline void ListType::unsafe_arena_set_allocated_length(
    ::CoreML::Specification::MILSpec::Dimension* length) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(length_);
  }
  length_ = length;
  if (length) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.ListType.length)
}
inline ::CoreML::Specification::MILSpec::Dimension* ListType::release_length() {
  
  ::CoreML::Specification::MILSpec::Dimension* temp = length_;
  length_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::MILSpec::Dimension* ListType::unsafe_arena_release_length() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.ListType.length)
  
  ::CoreML::Specification::MILSpec::Dimension* temp = length_;
  length_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::MILSpec::Dimension* ListType::_internal_mutable_length() {
  
  if (length_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::MILSpec::Dimension>(GetArenaForAllocation());
    length_ = p;
  }
  return length_;
}
inline ::CoreML::Specification::MILSpec::Dimension* ListType::mutable_length() {
  ::CoreML::Specification::MILSpec::Dimension* _msg = _internal_mutable_length();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.ListType.length)
  return _msg;
}
inline void ListType::set_allocated_length(::CoreML::Specification::MILSpec::Dimension* length) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete length_;
  }
  if (length) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::Dimension>::GetOwningArena(length);
    if (message_arena != submessage_arena) {
      length = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, length, submessage_arena);
    }
    
  } else {
    
  }
  length_ = length;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.ListType.length)
}

// -------------------------------------------------------------------

// DictionaryType

// .CoreML.Specification.MILSpec.ValueType keyType = 1;
inline bool DictionaryType::_internal_has_keytype() const {
  return this != internal_default_instance() && keytype_ != nullptr;
}
inline bool DictionaryType::has_keytype() const {
  return _internal_has_keytype();
}
inline void DictionaryType::clear_keytype() {
  if (GetArenaForAllocation() == nullptr && keytype_ != nullptr) {
    delete keytype_;
  }
  keytype_ = nullptr;
}
inline const ::CoreML::Specification::MILSpec::ValueType& DictionaryType::_internal_keytype() const {
  const ::CoreML::Specification::MILSpec::ValueType* p = keytype_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::MILSpec::ValueType&>(
      ::CoreML::Specification::MILSpec::_ValueType_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::ValueType& DictionaryType::keytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.DictionaryType.keyType)
  return _internal_keytype();
}
inline void DictionaryType::unsafe_arena_set_allocated_keytype(
    ::CoreML::Specification::MILSpec::ValueType* keytype) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(keytype_);
  }
  keytype_ = keytype;
  if (keytype) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.DictionaryType.keyType)
}
inline ::CoreML::Specification::MILSpec::ValueType* DictionaryType::release_keytype() {
  
  ::CoreML::Specification::MILSpec::ValueType* temp = keytype_;
  keytype_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::MILSpec::ValueType* DictionaryType::unsafe_arena_release_keytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.DictionaryType.keyType)
  
  ::CoreML::Specification::MILSpec::ValueType* temp = keytype_;
  keytype_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::MILSpec::ValueType* DictionaryType::_internal_mutable_keytype() {
  
  if (keytype_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::MILSpec::ValueType>(GetArenaForAllocation());
    keytype_ = p;
  }
  return keytype_;
}
inline ::CoreML::Specification::MILSpec::ValueType* DictionaryType::mutable_keytype() {
  ::CoreML::Specification::MILSpec::ValueType* _msg = _internal_mutable_keytype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.DictionaryType.keyType)
  return _msg;
}
inline void DictionaryType::set_allocated_keytype(::CoreML::Specification::MILSpec::ValueType* keytype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete keytype_;
  }
  if (keytype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::ValueType>::GetOwningArena(keytype);
    if (message_arena != submessage_arena) {
      keytype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keytype, submessage_arena);
    }
    
  } else {
    
  }
  keytype_ = keytype;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.DictionaryType.keyType)
}

// .CoreML.Specification.MILSpec.ValueType valueType = 2;
inline bool DictionaryType::_internal_has_valuetype() const {
  return this != internal_default_instance() && valuetype_ != nullptr;
}
inline bool DictionaryType::has_valuetype() const {
  return _internal_has_valuetype();
}
inline void DictionaryType::clear_valuetype() {
  if (GetArenaForAllocation() == nullptr && valuetype_ != nullptr) {
    delete valuetype_;
  }
  valuetype_ = nullptr;
}
inline const ::CoreML::Specification::MILSpec::ValueType& DictionaryType::_internal_valuetype() const {
  const ::CoreML::Specification::MILSpec::ValueType* p = valuetype_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::MILSpec::ValueType&>(
      ::CoreML::Specification::MILSpec::_ValueType_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::ValueType& DictionaryType::valuetype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.DictionaryType.valueType)
  return _internal_valuetype();
}
inline void DictionaryType::unsafe_arena_set_allocated_valuetype(
    ::CoreML::Specification::MILSpec::ValueType* valuetype) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(valuetype_);
  }
  valuetype_ = valuetype;
  if (valuetype) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.DictionaryType.valueType)
}
inline ::CoreML::Specification::MILSpec::ValueType* DictionaryType::release_valuetype() {
  
  ::CoreML::Specification::MILSpec::ValueType* temp = valuetype_;
  valuetype_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::MILSpec::ValueType* DictionaryType::unsafe_arena_release_valuetype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.DictionaryType.valueType)
  
  ::CoreML::Specification::MILSpec::ValueType* temp = valuetype_;
  valuetype_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::MILSpec::ValueType* DictionaryType::_internal_mutable_valuetype() {
  
  if (valuetype_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::MILSpec::ValueType>(GetArenaForAllocation());
    valuetype_ = p;
  }
  return valuetype_;
}
inline ::CoreML::Specification::MILSpec::ValueType* DictionaryType::mutable_valuetype() {
  ::CoreML::Specification::MILSpec::ValueType* _msg = _internal_mutable_valuetype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.DictionaryType.valueType)
  return _msg;
}
inline void DictionaryType::set_allocated_valuetype(::CoreML::Specification::MILSpec::ValueType* valuetype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete valuetype_;
  }
  if (valuetype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::ValueType>::GetOwningArena(valuetype);
    if (message_arena != submessage_arena) {
      valuetype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, valuetype, submessage_arena);
    }
    
  } else {
    
  }
  valuetype_ = valuetype;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.DictionaryType.valueType)
}

// -------------------------------------------------------------------

// StateType

// .CoreML.Specification.MILSpec.ValueType wrappedType = 1;
inline bool StateType::_internal_has_wrappedtype() const {
  return this != internal_default_instance() && wrappedtype_ != nullptr;
}
inline bool StateType::has_wrappedtype() const {
  return _internal_has_wrappedtype();
}
inline void StateType::clear_wrappedtype() {
  if (GetArenaForAllocation() == nullptr && wrappedtype_ != nullptr) {
    delete wrappedtype_;
  }
  wrappedtype_ = nullptr;
}
inline const ::CoreML::Specification::MILSpec::ValueType& StateType::_internal_wrappedtype() const {
  const ::CoreML::Specification::MILSpec::ValueType* p = wrappedtype_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::MILSpec::ValueType&>(
      ::CoreML::Specification::MILSpec::_ValueType_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::ValueType& StateType::wrappedtype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.StateType.wrappedType)
  return _internal_wrappedtype();
}
inline void StateType::unsafe_arena_set_allocated_wrappedtype(
    ::CoreML::Specification::MILSpec::ValueType* wrappedtype) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wrappedtype_);
  }
  wrappedtype_ = wrappedtype;
  if (wrappedtype) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.StateType.wrappedType)
}
inline ::CoreML::Specification::MILSpec::ValueType* StateType::release_wrappedtype() {
  
  ::CoreML::Specification::MILSpec::ValueType* temp = wrappedtype_;
  wrappedtype_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::MILSpec::ValueType* StateType::unsafe_arena_release_wrappedtype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.StateType.wrappedType)
  
  ::CoreML::Specification::MILSpec::ValueType* temp = wrappedtype_;
  wrappedtype_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::MILSpec::ValueType* StateType::_internal_mutable_wrappedtype() {
  
  if (wrappedtype_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::MILSpec::ValueType>(GetArenaForAllocation());
    wrappedtype_ = p;
  }
  return wrappedtype_;
}
inline ::CoreML::Specification::MILSpec::ValueType* StateType::mutable_wrappedtype() {
  ::CoreML::Specification::MILSpec::ValueType* _msg = _internal_mutable_wrappedtype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.StateType.wrappedType)
  return _msg;
}
inline void StateType::set_allocated_wrappedtype(::CoreML::Specification::MILSpec::ValueType* wrappedtype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete wrappedtype_;
  }
  if (wrappedtype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::ValueType>::GetOwningArena(wrappedtype);
    if (message_arena != submessage_arena) {
      wrappedtype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wrappedtype, submessage_arena);
    }
    
  } else {
    
  }
  wrappedtype_ = wrappedtype;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.StateType.wrappedType)
}

// -------------------------------------------------------------------

// Dimension_ConstantDimension

// uint64 size = 1;
inline void Dimension_ConstantDimension::clear_size() {
  size_ = uint64_t{0u};
}
inline uint64_t Dimension_ConstantDimension::_internal_size() const {
  return size_;
}
inline uint64_t Dimension_ConstantDimension::size() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Dimension.ConstantDimension.size)
  return _internal_size();
}
inline void Dimension_ConstantDimension::_internal_set_size(uint64_t value) {
  
  size_ = value;
}
inline void Dimension_ConstantDimension::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Dimension.ConstantDimension.size)
}

// -------------------------------------------------------------------

// Dimension_UnknownDimension

// bool variadic = 1;
inline void Dimension_UnknownDimension::clear_variadic() {
  variadic_ = false;
}
inline bool Dimension_UnknownDimension::_internal_variadic() const {
  return variadic_;
}
inline bool Dimension_UnknownDimension::variadic() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Dimension.UnknownDimension.variadic)
  return _internal_variadic();
}
inline void Dimension_UnknownDimension::_internal_set_variadic(bool value) {
  
  variadic_ = value;
}
inline void Dimension_UnknownDimension::set_variadic(bool value) {
  _internal_set_variadic(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Dimension.UnknownDimension.variadic)
}

// -------------------------------------------------------------------

// Dimension

// .CoreML.Specification.MILSpec.Dimension.ConstantDimension constant = 1;
inline bool Dimension::_internal_has_constant() const {
  return dimension_case() == kConstant;
}
inline bool Dimension::has_constant() const {
  return _internal_has_constant();
}
inline void Dimension::set_has_constant() {
  _oneof_case_[0] = kConstant;
}
inline void Dimension::clear_constant() {
  if (_internal_has_constant()) {
    if (GetArenaForAllocation() == nullptr) {
      delete dimension_.constant_;
    }
    clear_has_dimension();
  }
}
inline ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* Dimension::release_constant() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Dimension.constant)
  if (_internal_has_constant()) {
    clear_has_dimension();
      ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* temp = dimension_.constant_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    dimension_.constant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::Dimension_ConstantDimension& Dimension::_internal_constant() const {
  return _internal_has_constant()
      ? *dimension_.constant_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::Dimension_ConstantDimension&>(::CoreML::Specification::MILSpec::_Dimension_ConstantDimension_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::Dimension_ConstantDimension& Dimension::constant() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Dimension.constant)
  return _internal_constant();
}
inline ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* Dimension::unsafe_arena_release_constant() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.Dimension.constant)
  if (_internal_has_constant()) {
    clear_has_dimension();
    ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* temp = dimension_.constant_;
    dimension_.constant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Dimension::unsafe_arena_set_allocated_constant(::CoreML::Specification::MILSpec::Dimension_ConstantDimension* constant) {
  clear_dimension();
  if (constant) {
    set_has_constant();
    dimension_.constant_ = constant;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.Dimension.constant)
}
inline ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* Dimension::_internal_mutable_constant() {
  if (!_internal_has_constant()) {
    clear_dimension();
    set_has_constant();
    dimension_.constant_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::Dimension_ConstantDimension >(GetArenaForAllocation());
  }
  return dimension_.constant_;
}
inline ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* Dimension::mutable_constant() {
  ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* _msg = _internal_mutable_constant();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Dimension.constant)
  return _msg;
}

// .CoreML.Specification.MILSpec.Dimension.UnknownDimension unknown = 2;
inline bool Dimension::_internal_has_unknown() const {
  return dimension_case() == kUnknown;
}
inline bool Dimension::has_unknown() const {
  return _internal_has_unknown();
}
inline void Dimension::set_has_unknown() {
  _oneof_case_[0] = kUnknown;
}
inline void Dimension::clear_unknown() {
  if (_internal_has_unknown()) {
    if (GetArenaForAllocation() == nullptr) {
      delete dimension_.unknown_;
    }
    clear_has_dimension();
  }
}
inline ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* Dimension::release_unknown() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Dimension.unknown)
  if (_internal_has_unknown()) {
    clear_has_dimension();
      ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* temp = dimension_.unknown_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    dimension_.unknown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::Dimension_UnknownDimension& Dimension::_internal_unknown() const {
  return _internal_has_unknown()
      ? *dimension_.unknown_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::Dimension_UnknownDimension&>(::CoreML::Specification::MILSpec::_Dimension_UnknownDimension_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::Dimension_UnknownDimension& Dimension::unknown() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Dimension.unknown)
  return _internal_unknown();
}
inline ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* Dimension::unsafe_arena_release_unknown() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.Dimension.unknown)
  if (_internal_has_unknown()) {
    clear_has_dimension();
    ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* temp = dimension_.unknown_;
    dimension_.unknown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Dimension::unsafe_arena_set_allocated_unknown(::CoreML::Specification::MILSpec::Dimension_UnknownDimension* unknown) {
  clear_dimension();
  if (unknown) {
    set_has_unknown();
    dimension_.unknown_ = unknown;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.Dimension.unknown)
}
inline ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* Dimension::_internal_mutable_unknown() {
  if (!_internal_has_unknown()) {
    clear_dimension();
    set_has_unknown();
    dimension_.unknown_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::Dimension_UnknownDimension >(GetArenaForAllocation());
  }
  return dimension_.unknown_;
}
inline ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* Dimension::mutable_unknown() {
  ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* _msg = _internal_mutable_unknown();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Dimension.unknown)
  return _msg;
}

inline bool Dimension::has_dimension() const {
  return dimension_case() != DIMENSION_NOT_SET;
}
inline void Dimension::clear_has_dimension() {
  _oneof_case_[0] = DIMENSION_NOT_SET;
}
inline Dimension::DimensionCase Dimension::dimension_case() const {
  return Dimension::DimensionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Value_ImmediateValue

// .CoreML.Specification.MILSpec.TensorValue tensor = 1;
inline bool Value_ImmediateValue::_internal_has_tensor() const {
  return value_case() == kTensor;
}
inline bool Value_ImmediateValue::has_tensor() const {
  return _internal_has_tensor();
}
inline void Value_ImmediateValue::set_has_tensor() {
  _oneof_case_[0] = kTensor;
}
inline void Value_ImmediateValue::clear_tensor() {
  if (_internal_has_tensor()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.tensor_;
    }
    clear_has_value();
  }
}
inline ::CoreML::Specification::MILSpec::TensorValue* Value_ImmediateValue::release_tensor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Value.ImmediateValue.tensor)
  if (_internal_has_tensor()) {
    clear_has_value();
      ::CoreML::Specification::MILSpec::TensorValue* temp = value_.tensor_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.tensor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::TensorValue& Value_ImmediateValue::_internal_tensor() const {
  return _internal_has_tensor()
      ? *value_.tensor_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::TensorValue&>(::CoreML::Specification::MILSpec::_TensorValue_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::TensorValue& Value_ImmediateValue::tensor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.ImmediateValue.tensor)
  return _internal_tensor();
}
inline ::CoreML::Specification::MILSpec::TensorValue* Value_ImmediateValue::unsafe_arena_release_tensor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.Value.ImmediateValue.tensor)
  if (_internal_has_tensor()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::TensorValue* temp = value_.tensor_;
    value_.tensor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value_ImmediateValue::unsafe_arena_set_allocated_tensor(::CoreML::Specification::MILSpec::TensorValue* tensor) {
  clear_value();
  if (tensor) {
    set_has_tensor();
    value_.tensor_ = tensor;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.Value.ImmediateValue.tensor)
}
inline ::CoreML::Specification::MILSpec::TensorValue* Value_ImmediateValue::_internal_mutable_tensor() {
  if (!_internal_has_tensor()) {
    clear_value();
    set_has_tensor();
    value_.tensor_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorValue >(GetArenaForAllocation());
  }
  return value_.tensor_;
}
inline ::CoreML::Specification::MILSpec::TensorValue* Value_ImmediateValue::mutable_tensor() {
  ::CoreML::Specification::MILSpec::TensorValue* _msg = _internal_mutable_tensor();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Value.ImmediateValue.tensor)
  return _msg;
}

// .CoreML.Specification.MILSpec.TupleValue tuple = 2;
inline bool Value_ImmediateValue::_internal_has_tuple() const {
  return value_case() == kTuple;
}
inline bool Value_ImmediateValue::has_tuple() const {
  return _internal_has_tuple();
}
inline void Value_ImmediateValue::set_has_tuple() {
  _oneof_case_[0] = kTuple;
}
inline void Value_ImmediateValue::clear_tuple() {
  if (_internal_has_tuple()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.tuple_;
    }
    clear_has_value();
  }
}
inline ::CoreML::Specification::MILSpec::TupleValue* Value_ImmediateValue::release_tuple() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Value.ImmediateValue.tuple)
  if (_internal_has_tuple()) {
    clear_has_value();
      ::CoreML::Specification::MILSpec::TupleValue* temp = value_.tuple_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.tuple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::TupleValue& Value_ImmediateValue::_internal_tuple() const {
  return _internal_has_tuple()
      ? *value_.tuple_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::TupleValue&>(::CoreML::Specification::MILSpec::_TupleValue_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::TupleValue& Value_ImmediateValue::tuple() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.ImmediateValue.tuple)
  return _internal_tuple();
}
inline ::CoreML::Specification::MILSpec::TupleValue* Value_ImmediateValue::unsafe_arena_release_tuple() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.Value.ImmediateValue.tuple)
  if (_internal_has_tuple()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::TupleValue* temp = value_.tuple_;
    value_.tuple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value_ImmediateValue::unsafe_arena_set_allocated_tuple(::CoreML::Specification::MILSpec::TupleValue* tuple) {
  clear_value();
  if (tuple) {
    set_has_tuple();
    value_.tuple_ = tuple;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.Value.ImmediateValue.tuple)
}
inline ::CoreML::Specification::MILSpec::TupleValue* Value_ImmediateValue::_internal_mutable_tuple() {
  if (!_internal_has_tuple()) {
    clear_value();
    set_has_tuple();
    value_.tuple_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::TupleValue >(GetArenaForAllocation());
  }
  return value_.tuple_;
}
inline ::CoreML::Specification::MILSpec::TupleValue* Value_ImmediateValue::mutable_tuple() {
  ::CoreML::Specification::MILSpec::TupleValue* _msg = _internal_mutable_tuple();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Value.ImmediateValue.tuple)
  return _msg;
}

// .CoreML.Specification.MILSpec.ListValue list = 3;
inline bool Value_ImmediateValue::_internal_has_list() const {
  return value_case() == kList;
}
inline bool Value_ImmediateValue::has_list() const {
  return _internal_has_list();
}
inline void Value_ImmediateValue::set_has_list() {
  _oneof_case_[0] = kList;
}
inline void Value_ImmediateValue::clear_list() {
  if (_internal_has_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.list_;
    }
    clear_has_value();
  }
}
inline ::CoreML::Specification::MILSpec::ListValue* Value_ImmediateValue::release_list() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Value.ImmediateValue.list)
  if (_internal_has_list()) {
    clear_has_value();
      ::CoreML::Specification::MILSpec::ListValue* temp = value_.list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::ListValue& Value_ImmediateValue::_internal_list() const {
  return _internal_has_list()
      ? *value_.list_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::ListValue&>(::CoreML::Specification::MILSpec::_ListValue_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::ListValue& Value_ImmediateValue::list() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.ImmediateValue.list)
  return _internal_list();
}
inline ::CoreML::Specification::MILSpec::ListValue* Value_ImmediateValue::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.Value.ImmediateValue.list)
  if (_internal_has_list()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::ListValue* temp = value_.list_;
    value_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value_ImmediateValue::unsafe_arena_set_allocated_list(::CoreML::Specification::MILSpec::ListValue* list) {
  clear_value();
  if (list) {
    set_has_list();
    value_.list_ = list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.Value.ImmediateValue.list)
}
inline ::CoreML::Specification::MILSpec::ListValue* Value_ImmediateValue::_internal_mutable_list() {
  if (!_internal_has_list()) {
    clear_value();
    set_has_list();
    value_.list_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::ListValue >(GetArenaForAllocation());
  }
  return value_.list_;
}
inline ::CoreML::Specification::MILSpec::ListValue* Value_ImmediateValue::mutable_list() {
  ::CoreML::Specification::MILSpec::ListValue* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Value.ImmediateValue.list)
  return _msg;
}

// .CoreML.Specification.MILSpec.DictionaryValue dictionary = 4;
inline bool Value_ImmediateValue::_internal_has_dictionary() const {
  return value_case() == kDictionary;
}
inline bool Value_ImmediateValue::has_dictionary() const {
  return _internal_has_dictionary();
}
inline void Value_ImmediateValue::set_has_dictionary() {
  _oneof_case_[0] = kDictionary;
}
inline void Value_ImmediateValue::clear_dictionary() {
  if (_internal_has_dictionary()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.dictionary_;
    }
    clear_has_value();
  }
}
inline ::CoreML::Specification::MILSpec::DictionaryValue* Value_ImmediateValue::release_dictionary() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Value.ImmediateValue.dictionary)
  if (_internal_has_dictionary()) {
    clear_has_value();
      ::CoreML::Specification::MILSpec::DictionaryValue* temp = value_.dictionary_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.dictionary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::DictionaryValue& Value_ImmediateValue::_internal_dictionary() const {
  return _internal_has_dictionary()
      ? *value_.dictionary_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::DictionaryValue&>(::CoreML::Specification::MILSpec::_DictionaryValue_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::DictionaryValue& Value_ImmediateValue::dictionary() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.ImmediateValue.dictionary)
  return _internal_dictionary();
}
inline ::CoreML::Specification::MILSpec::DictionaryValue* Value_ImmediateValue::unsafe_arena_release_dictionary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.Value.ImmediateValue.dictionary)
  if (_internal_has_dictionary()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::DictionaryValue* temp = value_.dictionary_;
    value_.dictionary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value_ImmediateValue::unsafe_arena_set_allocated_dictionary(::CoreML::Specification::MILSpec::DictionaryValue* dictionary) {
  clear_value();
  if (dictionary) {
    set_has_dictionary();
    value_.dictionary_ = dictionary;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.Value.ImmediateValue.dictionary)
}
inline ::CoreML::Specification::MILSpec::DictionaryValue* Value_ImmediateValue::_internal_mutable_dictionary() {
  if (!_internal_has_dictionary()) {
    clear_value();
    set_has_dictionary();
    value_.dictionary_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::DictionaryValue >(GetArenaForAllocation());
  }
  return value_.dictionary_;
}
inline ::CoreML::Specification::MILSpec::DictionaryValue* Value_ImmediateValue::mutable_dictionary() {
  ::CoreML::Specification::MILSpec::DictionaryValue* _msg = _internal_mutable_dictionary();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Value.ImmediateValue.dictionary)
  return _msg;
}

inline bool Value_ImmediateValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Value_ImmediateValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Value_ImmediateValue::ValueCase Value_ImmediateValue::value_case() const {
  return Value_ImmediateValue::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Value_BlobFileValue

// string fileName = 1;
inline void Value_BlobFileValue::clear_filename() {
  filename_.ClearToEmpty();
}
inline const std::string& Value_BlobFileValue::filename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.BlobFileValue.fileName)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Value_BlobFileValue::set_filename(ArgT0&& arg0, ArgT... args) {
 
 filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Value.BlobFileValue.fileName)
}
inline std::string* Value_BlobFileValue::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Value.BlobFileValue.fileName)
  return _s;
}
inline const std::string& Value_BlobFileValue::_internal_filename() const {
  return filename_.Get();
}
inline void Value_BlobFileValue::_internal_set_filename(const std::string& value) {
  
  filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Value_BlobFileValue::_internal_mutable_filename() {
  
  return filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Value_BlobFileValue::release_filename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Value.BlobFileValue.fileName)
  return filename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Value_BlobFileValue::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Value.BlobFileValue.fileName)
}

// uint64 offset = 2;
inline void Value_BlobFileValue::clear_offset() {
  offset_ = uint64_t{0u};
}
inline uint64_t Value_BlobFileValue::_internal_offset() const {
  return offset_;
}
inline uint64_t Value_BlobFileValue::offset() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.BlobFileValue.offset)
  return _internal_offset();
}
inline void Value_BlobFileValue::_internal_set_offset(uint64_t value) {
  
  offset_ = value;
}
inline void Value_BlobFileValue::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Value.BlobFileValue.offset)
}

// -------------------------------------------------------------------

// Value

// string docString = 1;
inline void Value::clear_docstring() {
  docstring_.ClearToEmpty();
}
inline const std::string& Value::docstring() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.docString)
  return _internal_docstring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Value::set_docstring(ArgT0&& arg0, ArgT... args) {
 
 docstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Value.docString)
}
inline std::string* Value::mutable_docstring() {
  std::string* _s = _internal_mutable_docstring();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Value.docString)
  return _s;
}
inline const std::string& Value::_internal_docstring() const {
  return docstring_.Get();
}
inline void Value::_internal_set_docstring(const std::string& value) {
  
  docstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_docstring() {
  
  return docstring_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Value::release_docstring() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Value.docString)
  return docstring_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Value::set_allocated_docstring(std::string* docstring) {
  if (docstring != nullptr) {
    
  } else {
    
  }
  docstring_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), docstring,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (docstring_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    docstring_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Value.docString)
}

// .CoreML.Specification.MILSpec.ValueType type = 2;
inline bool Value::_internal_has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline bool Value::has_type() const {
  return _internal_has_type();
}
inline void Value::clear_type() {
  if (GetArenaForAllocation() == nullptr && type_ != nullptr) {
    delete type_;
  }
  type_ = nullptr;
}
inline const ::CoreML::Specification::MILSpec::ValueType& Value::_internal_type() const {
  const ::CoreML::Specification::MILSpec::ValueType* p = type_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::MILSpec::ValueType&>(
      ::CoreML::Specification::MILSpec::_ValueType_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::ValueType& Value::type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.type)
  return _internal_type();
}
inline void Value::unsafe_arena_set_allocated_type(
    ::CoreML::Specification::MILSpec::ValueType* type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.Value.type)
}
inline ::CoreML::Specification::MILSpec::ValueType* Value::release_type() {
  
  ::CoreML::Specification::MILSpec::ValueType* temp = type_;
  type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::MILSpec::ValueType* Value::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Value.type)
  
  ::CoreML::Specification::MILSpec::ValueType* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::MILSpec::ValueType* Value::_internal_mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::MILSpec::ValueType>(GetArenaForAllocation());
    type_ = p;
  }
  return type_;
}
inline ::CoreML::Specification::MILSpec::ValueType* Value::mutable_type() {
  ::CoreML::Specification::MILSpec::ValueType* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Value.type)
  return _msg;
}
inline void Value::set_allocated_type(::CoreML::Specification::MILSpec::ValueType* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete type_;
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::ValueType>::GetOwningArena(type);
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Value.type)
}

// .CoreML.Specification.MILSpec.Value.ImmediateValue immediateValue = 3;
inline bool Value::_internal_has_immediatevalue() const {
  return value_case() == kImmediateValue;
}
inline bool Value::has_immediatevalue() const {
  return _internal_has_immediatevalue();
}
inline void Value::set_has_immediatevalue() {
  _oneof_case_[0] = kImmediateValue;
}
inline void Value::clear_immediatevalue() {
  if (_internal_has_immediatevalue()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.immediatevalue_;
    }
    clear_has_value();
  }
}
inline ::CoreML::Specification::MILSpec::Value_ImmediateValue* Value::release_immediatevalue() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Value.immediateValue)
  if (_internal_has_immediatevalue()) {
    clear_has_value();
      ::CoreML::Specification::MILSpec::Value_ImmediateValue* temp = value_.immediatevalue_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.immediatevalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::Value_ImmediateValue& Value::_internal_immediatevalue() const {
  return _internal_has_immediatevalue()
      ? *value_.immediatevalue_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::Value_ImmediateValue&>(::CoreML::Specification::MILSpec::_Value_ImmediateValue_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::Value_ImmediateValue& Value::immediatevalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.immediateValue)
  return _internal_immediatevalue();
}
inline ::CoreML::Specification::MILSpec::Value_ImmediateValue* Value::unsafe_arena_release_immediatevalue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.Value.immediateValue)
  if (_internal_has_immediatevalue()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::Value_ImmediateValue* temp = value_.immediatevalue_;
    value_.immediatevalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_immediatevalue(::CoreML::Specification::MILSpec::Value_ImmediateValue* immediatevalue) {
  clear_value();
  if (immediatevalue) {
    set_has_immediatevalue();
    value_.immediatevalue_ = immediatevalue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.Value.immediateValue)
}
inline ::CoreML::Specification::MILSpec::Value_ImmediateValue* Value::_internal_mutable_immediatevalue() {
  if (!_internal_has_immediatevalue()) {
    clear_value();
    set_has_immediatevalue();
    value_.immediatevalue_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::Value_ImmediateValue >(GetArenaForAllocation());
  }
  return value_.immediatevalue_;
}
inline ::CoreML::Specification::MILSpec::Value_ImmediateValue* Value::mutable_immediatevalue() {
  ::CoreML::Specification::MILSpec::Value_ImmediateValue* _msg = _internal_mutable_immediatevalue();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Value.immediateValue)
  return _msg;
}

// .CoreML.Specification.MILSpec.Value.BlobFileValue blobFileValue = 5;
inline bool Value::_internal_has_blobfilevalue() const {
  return value_case() == kBlobFileValue;
}
inline bool Value::has_blobfilevalue() const {
  return _internal_has_blobfilevalue();
}
inline void Value::set_has_blobfilevalue() {
  _oneof_case_[0] = kBlobFileValue;
}
inline void Value::clear_blobfilevalue() {
  if (_internal_has_blobfilevalue()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.blobfilevalue_;
    }
    clear_has_value();
  }
}
inline ::CoreML::Specification::MILSpec::Value_BlobFileValue* Value::release_blobfilevalue() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Value.blobFileValue)
  if (_internal_has_blobfilevalue()) {
    clear_has_value();
      ::CoreML::Specification::MILSpec::Value_BlobFileValue* temp = value_.blobfilevalue_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.blobfilevalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::Value_BlobFileValue& Value::_internal_blobfilevalue() const {
  return _internal_has_blobfilevalue()
      ? *value_.blobfilevalue_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::Value_BlobFileValue&>(::CoreML::Specification::MILSpec::_Value_BlobFileValue_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::Value_BlobFileValue& Value::blobfilevalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.blobFileValue)
  return _internal_blobfilevalue();
}
inline ::CoreML::Specification::MILSpec::Value_BlobFileValue* Value::unsafe_arena_release_blobfilevalue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.Value.blobFileValue)
  if (_internal_has_blobfilevalue()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::Value_BlobFileValue* temp = value_.blobfilevalue_;
    value_.blobfilevalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_blobfilevalue(::CoreML::Specification::MILSpec::Value_BlobFileValue* blobfilevalue) {
  clear_value();
  if (blobfilevalue) {
    set_has_blobfilevalue();
    value_.blobfilevalue_ = blobfilevalue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.Value.blobFileValue)
}
inline ::CoreML::Specification::MILSpec::Value_BlobFileValue* Value::_internal_mutable_blobfilevalue() {
  if (!_internal_has_blobfilevalue()) {
    clear_value();
    set_has_blobfilevalue();
    value_.blobfilevalue_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::Value_BlobFileValue >(GetArenaForAllocation());
  }
  return value_.blobfilevalue_;
}
inline ::CoreML::Specification::MILSpec::Value_BlobFileValue* Value::mutable_blobfilevalue() {
  ::CoreML::Specification::MILSpec::Value_BlobFileValue* _msg = _internal_mutable_blobfilevalue();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Value.blobFileValue)
  return _msg;
}

inline bool Value::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Value::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Value::ValueCase Value::value_case() const {
  return Value::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TensorValue_RepeatedFloats

// repeated float values = 1 [packed = true];
inline int TensorValue_RepeatedFloats::_internal_values_size() const {
  return values_.size();
}
inline int TensorValue_RepeatedFloats::values_size() const {
  return _internal_values_size();
}
inline void TensorValue_RepeatedFloats::clear_values() {
  values_.Clear();
}
inline float TensorValue_RepeatedFloats::_internal_values(int index) const {
  return values_.Get(index);
}
inline float TensorValue_RepeatedFloats::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats.values)
  return _internal_values(index);
}
inline void TensorValue_RepeatedFloats::set_values(int index, float value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats.values)
}
inline void TensorValue_RepeatedFloats::_internal_add_values(float value) {
  values_.Add(value);
}
inline void TensorValue_RepeatedFloats::add_values(float value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TensorValue_RepeatedFloats::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TensorValue_RepeatedFloats::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TensorValue_RepeatedFloats::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TensorValue_RepeatedFloats::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// TensorValue_RepeatedDoubles

// repeated double values = 1 [packed = true];
inline int TensorValue_RepeatedDoubles::_internal_values_size() const {
  return values_.size();
}
inline int TensorValue_RepeatedDoubles::values_size() const {
  return _internal_values_size();
}
inline void TensorValue_RepeatedDoubles::clear_values() {
  values_.Clear();
}
inline double TensorValue_RepeatedDoubles::_internal_values(int index) const {
  return values_.Get(index);
}
inline double TensorValue_RepeatedDoubles::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles.values)
  return _internal_values(index);
}
inline void TensorValue_RepeatedDoubles::set_values(int index, double value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles.values)
}
inline void TensorValue_RepeatedDoubles::_internal_add_values(double value) {
  values_.Add(value);
}
inline void TensorValue_RepeatedDoubles::add_values(double value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TensorValue_RepeatedDoubles::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TensorValue_RepeatedDoubles::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TensorValue_RepeatedDoubles::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TensorValue_RepeatedDoubles::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// TensorValue_RepeatedInts

// repeated int32 values = 1 [packed = true];
inline int TensorValue_RepeatedInts::_internal_values_size() const {
  return values_.size();
}
inline int TensorValue_RepeatedInts::values_size() const {
  return _internal_values_size();
}
inline void TensorValue_RepeatedInts::clear_values() {
  values_.Clear();
}
inline int32_t TensorValue_RepeatedInts::_internal_values(int index) const {
  return values_.Get(index);
}
inline int32_t TensorValue_RepeatedInts::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.RepeatedInts.values)
  return _internal_values(index);
}
inline void TensorValue_RepeatedInts::set_values(int index, int32_t value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorValue.RepeatedInts.values)
}
inline void TensorValue_RepeatedInts::_internal_add_values(int32_t value) {
  values_.Add(value);
}
inline void TensorValue_RepeatedInts::add_values(int32_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TensorValue.RepeatedInts.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TensorValue_RepeatedInts::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TensorValue_RepeatedInts::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.TensorValue.RepeatedInts.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TensorValue_RepeatedInts::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TensorValue_RepeatedInts::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.TensorValue.RepeatedInts.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// TensorValue_RepeatedLongInts

// repeated int64 values = 1 [packed = true];
inline int TensorValue_RepeatedLongInts::_internal_values_size() const {
  return values_.size();
}
inline int TensorValue_RepeatedLongInts::values_size() const {
  return _internal_values_size();
}
inline void TensorValue_RepeatedLongInts::clear_values() {
  values_.Clear();
}
inline int64_t TensorValue_RepeatedLongInts::_internal_values(int index) const {
  return values_.Get(index);
}
inline int64_t TensorValue_RepeatedLongInts::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts.values)
  return _internal_values(index);
}
inline void TensorValue_RepeatedLongInts::set_values(int index, int64_t value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts.values)
}
inline void TensorValue_RepeatedLongInts::_internal_add_values(int64_t value) {
  values_.Add(value);
}
inline void TensorValue_RepeatedLongInts::add_values(int64_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TensorValue_RepeatedLongInts::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TensorValue_RepeatedLongInts::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TensorValue_RepeatedLongInts::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TensorValue_RepeatedLongInts::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// TensorValue_RepeatedBools

// repeated bool values = 1 [packed = true];
inline int TensorValue_RepeatedBools::_internal_values_size() const {
  return values_.size();
}
inline int TensorValue_RepeatedBools::values_size() const {
  return _internal_values_size();
}
inline void TensorValue_RepeatedBools::clear_values() {
  values_.Clear();
}
inline bool TensorValue_RepeatedBools::_internal_values(int index) const {
  return values_.Get(index);
}
inline bool TensorValue_RepeatedBools::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.RepeatedBools.values)
  return _internal_values(index);
}
inline void TensorValue_RepeatedBools::set_values(int index, bool value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorValue.RepeatedBools.values)
}
inline void TensorValue_RepeatedBools::_internal_add_values(bool value) {
  values_.Add(value);
}
inline void TensorValue_RepeatedBools::add_values(bool value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TensorValue.RepeatedBools.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
TensorValue_RepeatedBools::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
TensorValue_RepeatedBools::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.TensorValue.RepeatedBools.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
TensorValue_RepeatedBools::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
TensorValue_RepeatedBools::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.TensorValue.RepeatedBools.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// TensorValue_RepeatedStrings

// repeated string values = 1;
inline int TensorValue_RepeatedStrings::_internal_values_size() const {
  return values_.size();
}
inline int TensorValue_RepeatedStrings::values_size() const {
  return _internal_values_size();
}
inline void TensorValue_RepeatedStrings::clear_values() {
  values_.Clear();
}
inline std::string* TensorValue_RepeatedStrings::add_values() {
  std::string* _s = _internal_add_values();
  // @@protoc_insertion_point(field_add_mutable:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
  return _s;
}
inline const std::string& TensorValue_RepeatedStrings::_internal_values(int index) const {
  return values_.Get(index);
}
inline const std::string& TensorValue_RepeatedStrings::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
  return _internal_values(index);
}
inline std::string* TensorValue_RepeatedStrings::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
  return values_.Mutable(index);
}
inline void TensorValue_RepeatedStrings::set_values(int index, const std::string& value) {
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
}
inline void TensorValue_RepeatedStrings::set_values(int index, std::string&& value) {
  values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
}
inline void TensorValue_RepeatedStrings::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
}
inline void TensorValue_RepeatedStrings::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
}
inline std::string* TensorValue_RepeatedStrings::_internal_add_values() {
  return values_.Add();
}
inline void TensorValue_RepeatedStrings::add_values(const std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
}
inline void TensorValue_RepeatedStrings::add_values(std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
}
inline void TensorValue_RepeatedStrings::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
}
inline void TensorValue_RepeatedStrings::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TensorValue_RepeatedStrings::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
  return values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TensorValue_RepeatedStrings::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
  return &values_;
}

// -------------------------------------------------------------------

// TensorValue_RepeatedBytes

// bytes values = 1;
inline void TensorValue_RepeatedBytes::clear_values() {
  values_.ClearToEmpty();
}
inline const std::string& TensorValue_RepeatedBytes::values() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes.values)
  return _internal_values();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TensorValue_RepeatedBytes::set_values(ArgT0&& arg0, ArgT... args) {
 
 values_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes.values)
}
inline std::string* TensorValue_RepeatedBytes::mutable_values() {
  std::string* _s = _internal_mutable_values();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes.values)
  return _s;
}
inline const std::string& TensorValue_RepeatedBytes::_internal_values() const {
  return values_.Get();
}
inline void TensorValue_RepeatedBytes::_internal_set_values(const std::string& value) {
  
  values_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TensorValue_RepeatedBytes::_internal_mutable_values() {
  
  return values_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TensorValue_RepeatedBytes::release_values() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes.values)
  return values_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TensorValue_RepeatedBytes::set_allocated_values(std::string* values) {
  if (values != nullptr) {
    
  } else {
    
  }
  values_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), values,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (values_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    values_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes.values)
}

// -------------------------------------------------------------------

// TensorValue

// .CoreML.Specification.MILSpec.TensorValue.RepeatedFloats floats = 1;
inline bool TensorValue::_internal_has_floats() const {
  return value_case() == kFloats;
}
inline bool TensorValue::has_floats() const {
  return _internal_has_floats();
}
inline void TensorValue::set_has_floats() {
  _oneof_case_[0] = kFloats;
}
inline void TensorValue::clear_floats() {
  if (_internal_has_floats()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.floats_;
    }
    clear_has_value();
  }
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* TensorValue::release_floats() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.TensorValue.floats)
  if (_internal_has_floats()) {
    clear_has_value();
      ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* temp = value_.floats_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.floats_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats& TensorValue::_internal_floats() const {
  return _internal_has_floats()
      ? *value_.floats_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats&>(::CoreML::Specification::MILSpec::_TensorValue_RepeatedFloats_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats& TensorValue::floats() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.floats)
  return _internal_floats();
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* TensorValue::unsafe_arena_release_floats() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.TensorValue.floats)
  if (_internal_has_floats()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* temp = value_.floats_;
    value_.floats_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TensorValue::unsafe_arena_set_allocated_floats(::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* floats) {
  clear_value();
  if (floats) {
    set_has_floats();
    value_.floats_ = floats;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.TensorValue.floats)
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* TensorValue::_internal_mutable_floats() {
  if (!_internal_has_floats()) {
    clear_value();
    set_has_floats();
    value_.floats_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats >(GetArenaForAllocation());
  }
  return value_.floats_;
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* TensorValue::mutable_floats() {
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* _msg = _internal_mutable_floats();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorValue.floats)
  return _msg;
}

// .CoreML.Specification.MILSpec.TensorValue.RepeatedInts ints = 2;
inline bool TensorValue::_internal_has_ints() const {
  return value_case() == kInts;
}
inline bool TensorValue::has_ints() const {
  return _internal_has_ints();
}
inline void TensorValue::set_has_ints() {
  _oneof_case_[0] = kInts;
}
inline void TensorValue::clear_ints() {
  if (_internal_has_ints()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.ints_;
    }
    clear_has_value();
  }
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* TensorValue::release_ints() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.TensorValue.ints)
  if (_internal_has_ints()) {
    clear_has_value();
      ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* temp = value_.ints_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.ints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts& TensorValue::_internal_ints() const {
  return _internal_has_ints()
      ? *value_.ints_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts&>(::CoreML::Specification::MILSpec::_TensorValue_RepeatedInts_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts& TensorValue::ints() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.ints)
  return _internal_ints();
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* TensorValue::unsafe_arena_release_ints() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.TensorValue.ints)
  if (_internal_has_ints()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* temp = value_.ints_;
    value_.ints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TensorValue::unsafe_arena_set_allocated_ints(::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* ints) {
  clear_value();
  if (ints) {
    set_has_ints();
    value_.ints_ = ints;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.TensorValue.ints)
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* TensorValue::_internal_mutable_ints() {
  if (!_internal_has_ints()) {
    clear_value();
    set_has_ints();
    value_.ints_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts >(GetArenaForAllocation());
  }
  return value_.ints_;
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* TensorValue::mutable_ints() {
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* _msg = _internal_mutable_ints();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorValue.ints)
  return _msg;
}

// .CoreML.Specification.MILSpec.TensorValue.RepeatedBools bools = 3;
inline bool TensorValue::_internal_has_bools() const {
  return value_case() == kBools;
}
inline bool TensorValue::has_bools() const {
  return _internal_has_bools();
}
inline void TensorValue::set_has_bools() {
  _oneof_case_[0] = kBools;
}
inline void TensorValue::clear_bools() {
  if (_internal_has_bools()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.bools_;
    }
    clear_has_value();
  }
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* TensorValue::release_bools() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.TensorValue.bools)
  if (_internal_has_bools()) {
    clear_has_value();
      ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* temp = value_.bools_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.bools_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools& TensorValue::_internal_bools() const {
  return _internal_has_bools()
      ? *value_.bools_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools&>(::CoreML::Specification::MILSpec::_TensorValue_RepeatedBools_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools& TensorValue::bools() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.bools)
  return _internal_bools();
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* TensorValue::unsafe_arena_release_bools() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.TensorValue.bools)
  if (_internal_has_bools()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* temp = value_.bools_;
    value_.bools_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TensorValue::unsafe_arena_set_allocated_bools(::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* bools) {
  clear_value();
  if (bools) {
    set_has_bools();
    value_.bools_ = bools;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.TensorValue.bools)
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* TensorValue::_internal_mutable_bools() {
  if (!_internal_has_bools()) {
    clear_value();
    set_has_bools();
    value_.bools_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools >(GetArenaForAllocation());
  }
  return value_.bools_;
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* TensorValue::mutable_bools() {
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* _msg = _internal_mutable_bools();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorValue.bools)
  return _msg;
}

// .CoreML.Specification.MILSpec.TensorValue.RepeatedStrings strings = 4;
inline bool TensorValue::_internal_has_strings() const {
  return value_case() == kStrings;
}
inline bool TensorValue::has_strings() const {
  return _internal_has_strings();
}
inline void TensorValue::set_has_strings() {
  _oneof_case_[0] = kStrings;
}
inline void TensorValue::clear_strings() {
  if (_internal_has_strings()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.strings_;
    }
    clear_has_value();
  }
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* TensorValue::release_strings() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.TensorValue.strings)
  if (_internal_has_strings()) {
    clear_has_value();
      ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* temp = value_.strings_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.strings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings& TensorValue::_internal_strings() const {
  return _internal_has_strings()
      ? *value_.strings_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings&>(::CoreML::Specification::MILSpec::_TensorValue_RepeatedStrings_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings& TensorValue::strings() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.strings)
  return _internal_strings();
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* TensorValue::unsafe_arena_release_strings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.TensorValue.strings)
  if (_internal_has_strings()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* temp = value_.strings_;
    value_.strings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TensorValue::unsafe_arena_set_allocated_strings(::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* strings) {
  clear_value();
  if (strings) {
    set_has_strings();
    value_.strings_ = strings;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.TensorValue.strings)
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* TensorValue::_internal_mutable_strings() {
  if (!_internal_has_strings()) {
    clear_value();
    set_has_strings();
    value_.strings_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings >(GetArenaForAllocation());
  }
  return value_.strings_;
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* TensorValue::mutable_strings() {
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* _msg = _internal_mutable_strings();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorValue.strings)
  return _msg;
}

// .CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts longInts = 5;
inline bool TensorValue::_internal_has_longints() const {
  return value_case() == kLongInts;
}
inline bool TensorValue::has_longints() const {
  return _internal_has_longints();
}
inline void TensorValue::set_has_longints() {
  _oneof_case_[0] = kLongInts;
}
inline void TensorValue::clear_longints() {
  if (_internal_has_longints()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.longints_;
    }
    clear_has_value();
  }
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* TensorValue::release_longints() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.TensorValue.longInts)
  if (_internal_has_longints()) {
    clear_has_value();
      ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* temp = value_.longints_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.longints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts& TensorValue::_internal_longints() const {
  return _internal_has_longints()
      ? *value_.longints_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts&>(::CoreML::Specification::MILSpec::_TensorValue_RepeatedLongInts_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts& TensorValue::longints() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.longInts)
  return _internal_longints();
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* TensorValue::unsafe_arena_release_longints() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.TensorValue.longInts)
  if (_internal_has_longints()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* temp = value_.longints_;
    value_.longints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TensorValue::unsafe_arena_set_allocated_longints(::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* longints) {
  clear_value();
  if (longints) {
    set_has_longints();
    value_.longints_ = longints;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.TensorValue.longInts)
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* TensorValue::_internal_mutable_longints() {
  if (!_internal_has_longints()) {
    clear_value();
    set_has_longints();
    value_.longints_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts >(GetArenaForAllocation());
  }
  return value_.longints_;
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* TensorValue::mutable_longints() {
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* _msg = _internal_mutable_longints();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorValue.longInts)
  return _msg;
}

// .CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles doubles = 6;
inline bool TensorValue::_internal_has_doubles() const {
  return value_case() == kDoubles;
}
inline bool TensorValue::has_doubles() const {
  return _internal_has_doubles();
}
inline void TensorValue::set_has_doubles() {
  _oneof_case_[0] = kDoubles;
}
inline void TensorValue::clear_doubles() {
  if (_internal_has_doubles()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.doubles_;
    }
    clear_has_value();
  }
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* TensorValue::release_doubles() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.TensorValue.doubles)
  if (_internal_has_doubles()) {
    clear_has_value();
      ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* temp = value_.doubles_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.doubles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles& TensorValue::_internal_doubles() const {
  return _internal_has_doubles()
      ? *value_.doubles_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles&>(::CoreML::Specification::MILSpec::_TensorValue_RepeatedDoubles_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles& TensorValue::doubles() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.doubles)
  return _internal_doubles();
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* TensorValue::unsafe_arena_release_doubles() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.TensorValue.doubles)
  if (_internal_has_doubles()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* temp = value_.doubles_;
    value_.doubles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TensorValue::unsafe_arena_set_allocated_doubles(::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* doubles) {
  clear_value();
  if (doubles) {
    set_has_doubles();
    value_.doubles_ = doubles;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.TensorValue.doubles)
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* TensorValue::_internal_mutable_doubles() {
  if (!_internal_has_doubles()) {
    clear_value();
    set_has_doubles();
    value_.doubles_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles >(GetArenaForAllocation());
  }
  return value_.doubles_;
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* TensorValue::mutable_doubles() {
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* _msg = _internal_mutable_doubles();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorValue.doubles)
  return _msg;
}

// .CoreML.Specification.MILSpec.TensorValue.RepeatedBytes bytes = 7;
inline bool TensorValue::_internal_has_bytes() const {
  return value_case() == kBytes;
}
inline bool TensorValue::has_bytes() const {
  return _internal_has_bytes();
}
inline void TensorValue::set_has_bytes() {
  _oneof_case_[0] = kBytes;
}
inline void TensorValue::clear_bytes() {
  if (_internal_has_bytes()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.bytes_;
    }
    clear_has_value();
  }
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* TensorValue::release_bytes() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.TensorValue.bytes)
  if (_internal_has_bytes()) {
    clear_has_value();
      ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* temp = value_.bytes_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.bytes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes& TensorValue::_internal_bytes() const {
  return _internal_has_bytes()
      ? *value_.bytes_
      : reinterpret_cast< ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes&>(::CoreML::Specification::MILSpec::_TensorValue_RepeatedBytes_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes& TensorValue::bytes() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.bytes)
  return _internal_bytes();
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* TensorValue::unsafe_arena_release_bytes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.MILSpec.TensorValue.bytes)
  if (_internal_has_bytes()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* temp = value_.bytes_;
    value_.bytes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TensorValue::unsafe_arena_set_allocated_bytes(::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* bytes) {
  clear_value();
  if (bytes) {
    set_has_bytes();
    value_.bytes_ = bytes;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.TensorValue.bytes)
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* TensorValue::_internal_mutable_bytes() {
  if (!_internal_has_bytes()) {
    clear_value();
    set_has_bytes();
    value_.bytes_ = CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes >(GetArenaForAllocation());
  }
  return value_.bytes_;
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* TensorValue::mutable_bytes() {
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* _msg = _internal_mutable_bytes();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorValue.bytes)
  return _msg;
}

inline bool TensorValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void TensorValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline TensorValue::ValueCase TensorValue::value_case() const {
  return TensorValue::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TupleValue

// repeated .CoreML.Specification.MILSpec.Value values = 1;
inline int TupleValue::_internal_values_size() const {
  return values_.size();
}
inline int TupleValue::values_size() const {
  return _internal_values_size();
}
inline void TupleValue::clear_values() {
  values_.Clear();
}
inline ::CoreML::Specification::MILSpec::Value* TupleValue::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TupleValue.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value >*
TupleValue::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.TupleValue.values)
  return &values_;
}
inline const ::CoreML::Specification::MILSpec::Value& TupleValue::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::CoreML::Specification::MILSpec::Value& TupleValue::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TupleValue.values)
  return _internal_values(index);
}
inline ::CoreML::Specification::MILSpec::Value* TupleValue::_internal_add_values() {
  return values_.Add();
}
inline ::CoreML::Specification::MILSpec::Value* TupleValue::add_values() {
  ::CoreML::Specification::MILSpec::Value* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TupleValue.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value >&
TupleValue::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.TupleValue.values)
  return values_;
}

// -------------------------------------------------------------------

// ListValue

// repeated .CoreML.Specification.MILSpec.Value values = 1;
inline int ListValue::_internal_values_size() const {
  return values_.size();
}
inline int ListValue::values_size() const {
  return _internal_values_size();
}
inline void ListValue::clear_values() {
  values_.Clear();
}
inline ::CoreML::Specification::MILSpec::Value* ListValue::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.ListValue.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value >*
ListValue::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.ListValue.values)
  return &values_;
}
inline const ::CoreML::Specification::MILSpec::Value& ListValue::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::CoreML::Specification::MILSpec::Value& ListValue::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.ListValue.values)
  return _internal_values(index);
}
inline ::CoreML::Specification::MILSpec::Value* ListValue::_internal_add_values() {
  return values_.Add();
}
inline ::CoreML::Specification::MILSpec::Value* ListValue::add_values() {
  ::CoreML::Specification::MILSpec::Value* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.ListValue.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value >&
ListValue::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.ListValue.values)
  return values_;
}

// -------------------------------------------------------------------

// DictionaryValue_KeyValuePair

// .CoreML.Specification.MILSpec.Value key = 1;
inline bool DictionaryValue_KeyValuePair::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool DictionaryValue_KeyValuePair::has_key() const {
  return _internal_has_key();
}
inline void DictionaryValue_KeyValuePair::clear_key() {
  if (GetArenaForAllocation() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::CoreML::Specification::MILSpec::Value& DictionaryValue_KeyValuePair::_internal_key() const {
  const ::CoreML::Specification::MILSpec::Value* p = key_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::MILSpec::Value&>(
      ::CoreML::Specification::MILSpec::_Value_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::Value& DictionaryValue_KeyValuePair::key() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair.key)
  return _internal_key();
}
inline void DictionaryValue_KeyValuePair::unsafe_arena_set_allocated_key(
    ::CoreML::Specification::MILSpec::Value* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair.key)
}
inline ::CoreML::Specification::MILSpec::Value* DictionaryValue_KeyValuePair::release_key() {
  
  ::CoreML::Specification::MILSpec::Value* temp = key_;
  key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::MILSpec::Value* DictionaryValue_KeyValuePair::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair.key)
  
  ::CoreML::Specification::MILSpec::Value* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::MILSpec::Value* DictionaryValue_KeyValuePair::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::MILSpec::Value>(GetArenaForAllocation());
    key_ = p;
  }
  return key_;
}
inline ::CoreML::Specification::MILSpec::Value* DictionaryValue_KeyValuePair::mutable_key() {
  ::CoreML::Specification::MILSpec::Value* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair.key)
  return _msg;
}
inline void DictionaryValue_KeyValuePair::set_allocated_key(::CoreML::Specification::MILSpec::Value* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::Value>::GetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair.key)
}

// .CoreML.Specification.MILSpec.Value value = 2;
inline bool DictionaryValue_KeyValuePair::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool DictionaryValue_KeyValuePair::has_value() const {
  return _internal_has_value();
}
inline void DictionaryValue_KeyValuePair::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::CoreML::Specification::MILSpec::Value& DictionaryValue_KeyValuePair::_internal_value() const {
  const ::CoreML::Specification::MILSpec::Value* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::MILSpec::Value&>(
      ::CoreML::Specification::MILSpec::_Value_default_instance_);
}
inline const ::CoreML::Specification::MILSpec::Value& DictionaryValue_KeyValuePair::value() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair.value)
  return _internal_value();
}
inline void DictionaryValue_KeyValuePair::unsafe_arena_set_allocated_value(
    ::CoreML::Specification::MILSpec::Value* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair.value)
}
inline ::CoreML::Specification::MILSpec::Value* DictionaryValue_KeyValuePair::release_value() {
  
  ::CoreML::Specification::MILSpec::Value* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::MILSpec::Value* DictionaryValue_KeyValuePair::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair.value)
  
  ::CoreML::Specification::MILSpec::Value* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::MILSpec::Value* DictionaryValue_KeyValuePair::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::MILSpec::Value>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::CoreML::Specification::MILSpec::Value* DictionaryValue_KeyValuePair::mutable_value() {
  ::CoreML::Specification::MILSpec::Value* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair.value)
  return _msg;
}
inline void DictionaryValue_KeyValuePair::set_allocated_value(::CoreML::Specification::MILSpec::Value* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::Value>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair.value)
}

// -------------------------------------------------------------------

// DictionaryValue

// repeated .CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair values = 1;
inline int DictionaryValue::_internal_values_size() const {
  return values_.size();
}
inline int DictionaryValue::values_size() const {
  return _internal_values_size();
}
inline void DictionaryValue::clear_values() {
  values_.Clear();
}
inline ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair* DictionaryValue::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.DictionaryValue.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair >*
DictionaryValue::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.DictionaryValue.values)
  return &values_;
}
inline const ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair& DictionaryValue::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair& DictionaryValue::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.DictionaryValue.values)
  return _internal_values(index);
}
inline ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair* DictionaryValue::_internal_add_values() {
  return values_.Add();
}
inline ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair* DictionaryValue::add_values() {
  ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.DictionaryValue.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair >&
DictionaryValue::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.DictionaryValue.values)
  return values_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace MILSpec
}  // namespace Specification
}  // namespace CoreML

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CoreML::Specification::MILSpec::DataType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_MIL_2eproto
