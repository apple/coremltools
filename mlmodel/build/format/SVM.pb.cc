// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SVM.proto

#include "SVM.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace CoreML {
namespace Specification {
constexpr LinearKernel::LinearKernel(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct LinearKernelDefaultTypeInternal {
  constexpr LinearKernelDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LinearKernelDefaultTypeInternal() {}
  union {
    LinearKernel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LinearKernelDefaultTypeInternal _LinearKernel_default_instance_;
constexpr RBFKernel::RBFKernel(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gamma_(0){}
struct RBFKernelDefaultTypeInternal {
  constexpr RBFKernelDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RBFKernelDefaultTypeInternal() {}
  union {
    RBFKernel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RBFKernelDefaultTypeInternal _RBFKernel_default_instance_;
constexpr PolyKernel::PolyKernel(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : c_(0)
  , gamma_(0)
  , degree_(0){}
struct PolyKernelDefaultTypeInternal {
  constexpr PolyKernelDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PolyKernelDefaultTypeInternal() {}
  union {
    PolyKernel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PolyKernelDefaultTypeInternal _PolyKernel_default_instance_;
constexpr SigmoidKernel::SigmoidKernel(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gamma_(0)
  , c_(0){}
struct SigmoidKernelDefaultTypeInternal {
  constexpr SigmoidKernelDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SigmoidKernelDefaultTypeInternal() {}
  union {
    SigmoidKernel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SigmoidKernelDefaultTypeInternal _SigmoidKernel_default_instance_;
constexpr Kernel::Kernel(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct KernelDefaultTypeInternal {
  constexpr KernelDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KernelDefaultTypeInternal() {}
  union {
    Kernel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KernelDefaultTypeInternal _Kernel_default_instance_;
constexpr SparseNode::SparseNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : value_(0)
  , index_(0){}
struct SparseNodeDefaultTypeInternal {
  constexpr SparseNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SparseNodeDefaultTypeInternal() {}
  union {
    SparseNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SparseNodeDefaultTypeInternal _SparseNode_default_instance_;
constexpr SparseVector::SparseVector(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nodes_(){}
struct SparseVectorDefaultTypeInternal {
  constexpr SparseVectorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SparseVectorDefaultTypeInternal() {}
  union {
    SparseVector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SparseVectorDefaultTypeInternal _SparseVector_default_instance_;
constexpr SparseSupportVectors::SparseSupportVectors(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : vectors_(){}
struct SparseSupportVectorsDefaultTypeInternal {
  constexpr SparseSupportVectorsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SparseSupportVectorsDefaultTypeInternal() {}
  union {
    SparseSupportVectors _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SparseSupportVectorsDefaultTypeInternal _SparseSupportVectors_default_instance_;
constexpr DenseVector::DenseVector(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : values_(){}
struct DenseVectorDefaultTypeInternal {
  constexpr DenseVectorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DenseVectorDefaultTypeInternal() {}
  union {
    DenseVector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DenseVectorDefaultTypeInternal _DenseVector_default_instance_;
constexpr DenseSupportVectors::DenseSupportVectors(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : vectors_(){}
struct DenseSupportVectorsDefaultTypeInternal {
  constexpr DenseSupportVectorsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DenseSupportVectorsDefaultTypeInternal() {}
  union {
    DenseSupportVectors _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DenseSupportVectorsDefaultTypeInternal _DenseSupportVectors_default_instance_;
constexpr Coefficients::Coefficients(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(){}
struct CoefficientsDefaultTypeInternal {
  constexpr CoefficientsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CoefficientsDefaultTypeInternal() {}
  union {
    Coefficients _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CoefficientsDefaultTypeInternal _Coefficients_default_instance_;
constexpr SupportVectorRegressor::SupportVectorRegressor(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : kernel_(nullptr)
  , coefficients_(nullptr)
  , rho_(0)
  , _oneof_case_{}{}
struct SupportVectorRegressorDefaultTypeInternal {
  constexpr SupportVectorRegressorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SupportVectorRegressorDefaultTypeInternal() {}
  union {
    SupportVectorRegressor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SupportVectorRegressorDefaultTypeInternal _SupportVectorRegressor_default_instance_;
constexpr SupportVectorClassifier::SupportVectorClassifier(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : numberofsupportvectorsperclass_()
  , _numberofsupportvectorsperclass_cached_byte_size_(0)
  , coefficients_()
  , rho_()
  , proba_()
  , probb_()
  , kernel_(nullptr)
  , _oneof_case_{}{}
struct SupportVectorClassifierDefaultTypeInternal {
  constexpr SupportVectorClassifierDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SupportVectorClassifierDefaultTypeInternal() {}
  union {
    SupportVectorClassifier _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SupportVectorClassifierDefaultTypeInternal _SupportVectorClassifier_default_instance_;
}  // namespace Specification
}  // namespace CoreML
namespace CoreML {
namespace Specification {

// ===================================================================

class LinearKernel::_Internal {
 public:
};

LinearKernel::LinearKernel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LinearKernel)
}
LinearKernel::LinearKernel(const LinearKernel& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LinearKernel)
}

inline void LinearKernel::SharedCtor() {
}

LinearKernel::~LinearKernel() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LinearKernel)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LinearKernel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LinearKernel::ArenaDtor(void* object) {
  LinearKernel* _this = reinterpret_cast< LinearKernel* >(object);
  (void)_this;
}
void LinearKernel::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LinearKernel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LinearKernel::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LinearKernel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* LinearKernel::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LinearKernel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LinearKernel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LinearKernel)
  return target;
}

size_t LinearKernel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LinearKernel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LinearKernel::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LinearKernel*>(
      &from));
}

void LinearKernel::MergeFrom(const LinearKernel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LinearKernel)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LinearKernel::CopyFrom(const LinearKernel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LinearKernel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinearKernel::IsInitialized() const {
  return true;
}

void LinearKernel::InternalSwap(LinearKernel* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string LinearKernel::GetTypeName() const {
  return "CoreML.Specification.LinearKernel";
}


// ===================================================================

class RBFKernel::_Internal {
 public:
};

RBFKernel::RBFKernel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.RBFKernel)
}
RBFKernel::RBFKernel(const RBFKernel& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  gamma_ = from.gamma_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.RBFKernel)
}

inline void RBFKernel::SharedCtor() {
gamma_ = 0;
}

RBFKernel::~RBFKernel() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.RBFKernel)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RBFKernel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RBFKernel::ArenaDtor(void* object) {
  RBFKernel* _this = reinterpret_cast< RBFKernel* >(object);
  (void)_this;
}
void RBFKernel::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RBFKernel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RBFKernel::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.RBFKernel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  gamma_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* RBFKernel::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double gamma = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          gamma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RBFKernel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.RBFKernel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double gamma = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gamma = this->_internal_gamma();
  uint64_t raw_gamma;
  memcpy(&raw_gamma, &tmp_gamma, sizeof(tmp_gamma));
  if (raw_gamma != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_gamma(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.RBFKernel)
  return target;
}

size_t RBFKernel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.RBFKernel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double gamma = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gamma = this->_internal_gamma();
  uint64_t raw_gamma;
  memcpy(&raw_gamma, &tmp_gamma, sizeof(tmp_gamma));
  if (raw_gamma != 0) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RBFKernel::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RBFKernel*>(
      &from));
}

void RBFKernel::MergeFrom(const RBFKernel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.RBFKernel)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gamma = from._internal_gamma();
  uint64_t raw_gamma;
  memcpy(&raw_gamma, &tmp_gamma, sizeof(tmp_gamma));
  if (raw_gamma != 0) {
    _internal_set_gamma(from._internal_gamma());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RBFKernel::CopyFrom(const RBFKernel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.RBFKernel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RBFKernel::IsInitialized() const {
  return true;
}

void RBFKernel::InternalSwap(RBFKernel* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(gamma_, other->gamma_);
}

std::string RBFKernel::GetTypeName() const {
  return "CoreML.Specification.RBFKernel";
}


// ===================================================================

class PolyKernel::_Internal {
 public:
};

PolyKernel::PolyKernel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.PolyKernel)
}
PolyKernel::PolyKernel(const PolyKernel& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&c_, &from.c_,
    static_cast<size_t>(reinterpret_cast<char*>(&degree_) -
    reinterpret_cast<char*>(&c_)) + sizeof(degree_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.PolyKernel)
}

inline void PolyKernel::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&c_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&degree_) -
    reinterpret_cast<char*>(&c_)) + sizeof(degree_));
}

PolyKernel::~PolyKernel() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.PolyKernel)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PolyKernel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PolyKernel::ArenaDtor(void* object) {
  PolyKernel* _this = reinterpret_cast< PolyKernel* >(object);
  (void)_this;
}
void PolyKernel::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PolyKernel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PolyKernel::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.PolyKernel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&c_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&degree_) -
      reinterpret_cast<char*>(&c_)) + sizeof(degree_));
  _internal_metadata_.Clear<std::string>();
}

const char* PolyKernel::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 degree = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          degree_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double c = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          c_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double gamma = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          gamma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PolyKernel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.PolyKernel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 degree = 1;
  if (this->_internal_degree() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_degree(), target);
  }

  // double c = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_c = this->_internal_c();
  uint64_t raw_c;
  memcpy(&raw_c, &tmp_c, sizeof(tmp_c));
  if (raw_c != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_c(), target);
  }

  // double gamma = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gamma = this->_internal_gamma();
  uint64_t raw_gamma;
  memcpy(&raw_gamma, &tmp_gamma, sizeof(tmp_gamma));
  if (raw_gamma != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_gamma(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.PolyKernel)
  return target;
}

size_t PolyKernel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.PolyKernel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double c = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_c = this->_internal_c();
  uint64_t raw_c;
  memcpy(&raw_c, &tmp_c, sizeof(tmp_c));
  if (raw_c != 0) {
    total_size += 1 + 8;
  }

  // double gamma = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gamma = this->_internal_gamma();
  uint64_t raw_gamma;
  memcpy(&raw_gamma, &tmp_gamma, sizeof(tmp_gamma));
  if (raw_gamma != 0) {
    total_size += 1 + 8;
  }

  // int32 degree = 1;
  if (this->_internal_degree() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_degree());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PolyKernel::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PolyKernel*>(
      &from));
}

void PolyKernel::MergeFrom(const PolyKernel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.PolyKernel)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_c = from._internal_c();
  uint64_t raw_c;
  memcpy(&raw_c, &tmp_c, sizeof(tmp_c));
  if (raw_c != 0) {
    _internal_set_c(from._internal_c());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gamma = from._internal_gamma();
  uint64_t raw_gamma;
  memcpy(&raw_gamma, &tmp_gamma, sizeof(tmp_gamma));
  if (raw_gamma != 0) {
    _internal_set_gamma(from._internal_gamma());
  }
  if (from._internal_degree() != 0) {
    _internal_set_degree(from._internal_degree());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PolyKernel::CopyFrom(const PolyKernel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.PolyKernel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PolyKernel::IsInitialized() const {
  return true;
}

void PolyKernel::InternalSwap(PolyKernel* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PolyKernel, degree_)
      + sizeof(PolyKernel::degree_)
      - PROTOBUF_FIELD_OFFSET(PolyKernel, c_)>(
          reinterpret_cast<char*>(&c_),
          reinterpret_cast<char*>(&other->c_));
}

std::string PolyKernel::GetTypeName() const {
  return "CoreML.Specification.PolyKernel";
}


// ===================================================================

class SigmoidKernel::_Internal {
 public:
};

SigmoidKernel::SigmoidKernel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SigmoidKernel)
}
SigmoidKernel::SigmoidKernel(const SigmoidKernel& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gamma_, &from.gamma_,
    static_cast<size_t>(reinterpret_cast<char*>(&c_) -
    reinterpret_cast<char*>(&gamma_)) + sizeof(c_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SigmoidKernel)
}

inline void SigmoidKernel::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gamma_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&c_) -
    reinterpret_cast<char*>(&gamma_)) + sizeof(c_));
}

SigmoidKernel::~SigmoidKernel() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SigmoidKernel)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SigmoidKernel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SigmoidKernel::ArenaDtor(void* object) {
  SigmoidKernel* _this = reinterpret_cast< SigmoidKernel* >(object);
  (void)_this;
}
void SigmoidKernel::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SigmoidKernel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SigmoidKernel::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SigmoidKernel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&gamma_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&c_) -
      reinterpret_cast<char*>(&gamma_)) + sizeof(c_));
  _internal_metadata_.Clear<std::string>();
}

const char* SigmoidKernel::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double gamma = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          gamma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double c = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          c_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SigmoidKernel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SigmoidKernel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double gamma = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gamma = this->_internal_gamma();
  uint64_t raw_gamma;
  memcpy(&raw_gamma, &tmp_gamma, sizeof(tmp_gamma));
  if (raw_gamma != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_gamma(), target);
  }

  // double c = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_c = this->_internal_c();
  uint64_t raw_c;
  memcpy(&raw_c, &tmp_c, sizeof(tmp_c));
  if (raw_c != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_c(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SigmoidKernel)
  return target;
}

size_t SigmoidKernel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SigmoidKernel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double gamma = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gamma = this->_internal_gamma();
  uint64_t raw_gamma;
  memcpy(&raw_gamma, &tmp_gamma, sizeof(tmp_gamma));
  if (raw_gamma != 0) {
    total_size += 1 + 8;
  }

  // double c = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_c = this->_internal_c();
  uint64_t raw_c;
  memcpy(&raw_c, &tmp_c, sizeof(tmp_c));
  if (raw_c != 0) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SigmoidKernel::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SigmoidKernel*>(
      &from));
}

void SigmoidKernel::MergeFrom(const SigmoidKernel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SigmoidKernel)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gamma = from._internal_gamma();
  uint64_t raw_gamma;
  memcpy(&raw_gamma, &tmp_gamma, sizeof(tmp_gamma));
  if (raw_gamma != 0) {
    _internal_set_gamma(from._internal_gamma());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_c = from._internal_c();
  uint64_t raw_c;
  memcpy(&raw_c, &tmp_c, sizeof(tmp_c));
  if (raw_c != 0) {
    _internal_set_c(from._internal_c());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SigmoidKernel::CopyFrom(const SigmoidKernel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SigmoidKernel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SigmoidKernel::IsInitialized() const {
  return true;
}

void SigmoidKernel::InternalSwap(SigmoidKernel* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SigmoidKernel, c_)
      + sizeof(SigmoidKernel::c_)
      - PROTOBUF_FIELD_OFFSET(SigmoidKernel, gamma_)>(
          reinterpret_cast<char*>(&gamma_),
          reinterpret_cast<char*>(&other->gamma_));
}

std::string SigmoidKernel::GetTypeName() const {
  return "CoreML.Specification.SigmoidKernel";
}


// ===================================================================

class Kernel::_Internal {
 public:
  static const ::CoreML::Specification::LinearKernel& linearkernel(const Kernel* msg);
  static const ::CoreML::Specification::RBFKernel& rbfkernel(const Kernel* msg);
  static const ::CoreML::Specification::PolyKernel& polykernel(const Kernel* msg);
  static const ::CoreML::Specification::SigmoidKernel& sigmoidkernel(const Kernel* msg);
};

const ::CoreML::Specification::LinearKernel&
Kernel::_Internal::linearkernel(const Kernel* msg) {
  return *msg->kernel_.linearkernel_;
}
const ::CoreML::Specification::RBFKernel&
Kernel::_Internal::rbfkernel(const Kernel* msg) {
  return *msg->kernel_.rbfkernel_;
}
const ::CoreML::Specification::PolyKernel&
Kernel::_Internal::polykernel(const Kernel* msg) {
  return *msg->kernel_.polykernel_;
}
const ::CoreML::Specification::SigmoidKernel&
Kernel::_Internal::sigmoidkernel(const Kernel* msg) {
  return *msg->kernel_.sigmoidkernel_;
}
void Kernel::set_allocated_linearkernel(::CoreML::Specification::LinearKernel* linearkernel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kernel();
  if (linearkernel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::LinearKernel>::GetOwningArena(linearkernel);
    if (message_arena != submessage_arena) {
      linearkernel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linearkernel, submessage_arena);
    }
    set_has_linearkernel();
    kernel_.linearkernel_ = linearkernel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Kernel.linearKernel)
}
void Kernel::set_allocated_rbfkernel(::CoreML::Specification::RBFKernel* rbfkernel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kernel();
  if (rbfkernel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::RBFKernel>::GetOwningArena(rbfkernel);
    if (message_arena != submessage_arena) {
      rbfkernel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rbfkernel, submessage_arena);
    }
    set_has_rbfkernel();
    kernel_.rbfkernel_ = rbfkernel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Kernel.rbfKernel)
}
void Kernel::set_allocated_polykernel(::CoreML::Specification::PolyKernel* polykernel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kernel();
  if (polykernel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::PolyKernel>::GetOwningArena(polykernel);
    if (message_arena != submessage_arena) {
      polykernel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, polykernel, submessage_arena);
    }
    set_has_polykernel();
    kernel_.polykernel_ = polykernel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Kernel.polyKernel)
}
void Kernel::set_allocated_sigmoidkernel(::CoreML::Specification::SigmoidKernel* sigmoidkernel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kernel();
  if (sigmoidkernel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SigmoidKernel>::GetOwningArena(sigmoidkernel);
    if (message_arena != submessage_arena) {
      sigmoidkernel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sigmoidkernel, submessage_arena);
    }
    set_has_sigmoidkernel();
    kernel_.sigmoidkernel_ = sigmoidkernel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Kernel.sigmoidKernel)
}
Kernel::Kernel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.Kernel)
}
Kernel::Kernel(const Kernel& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_kernel();
  switch (from.kernel_case()) {
    case kLinearKernel: {
      _internal_mutable_linearkernel()->::CoreML::Specification::LinearKernel::MergeFrom(from._internal_linearkernel());
      break;
    }
    case kRbfKernel: {
      _internal_mutable_rbfkernel()->::CoreML::Specification::RBFKernel::MergeFrom(from._internal_rbfkernel());
      break;
    }
    case kPolyKernel: {
      _internal_mutable_polykernel()->::CoreML::Specification::PolyKernel::MergeFrom(from._internal_polykernel());
      break;
    }
    case kSigmoidKernel: {
      _internal_mutable_sigmoidkernel()->::CoreML::Specification::SigmoidKernel::MergeFrom(from._internal_sigmoidkernel());
      break;
    }
    case KERNEL_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Kernel)
}

inline void Kernel::SharedCtor() {
clear_has_kernel();
}

Kernel::~Kernel() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Kernel)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Kernel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_kernel()) {
    clear_kernel();
  }
}

void Kernel::ArenaDtor(void* object) {
  Kernel* _this = reinterpret_cast< Kernel* >(object);
  (void)_this;
}
void Kernel::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Kernel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Kernel::clear_kernel() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.Kernel)
  switch (kernel_case()) {
    case kLinearKernel: {
      if (GetArenaForAllocation() == nullptr) {
        delete kernel_.linearkernel_;
      }
      break;
    }
    case kRbfKernel: {
      if (GetArenaForAllocation() == nullptr) {
        delete kernel_.rbfkernel_;
      }
      break;
    }
    case kPolyKernel: {
      if (GetArenaForAllocation() == nullptr) {
        delete kernel_.polykernel_;
      }
      break;
    }
    case kSigmoidKernel: {
      if (GetArenaForAllocation() == nullptr) {
        delete kernel_.sigmoidkernel_;
      }
      break;
    }
    case KERNEL_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = KERNEL_NOT_SET;
}


void Kernel::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Kernel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_kernel();
  _internal_metadata_.Clear<std::string>();
}

const char* Kernel::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.LinearKernel linearKernel = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_linearkernel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.RBFKernel rbfKernel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rbfkernel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.PolyKernel polyKernel = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_polykernel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SigmoidKernel sigmoidKernel = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_sigmoidkernel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Kernel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.Kernel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.LinearKernel linearKernel = 1;
  if (_internal_has_linearkernel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::linearkernel(this), target, stream);
  }

  // .CoreML.Specification.RBFKernel rbfKernel = 2;
  if (_internal_has_rbfkernel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::rbfkernel(this), target, stream);
  }

  // .CoreML.Specification.PolyKernel polyKernel = 3;
  if (_internal_has_polykernel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::polykernel(this), target, stream);
  }

  // .CoreML.Specification.SigmoidKernel sigmoidKernel = 4;
  if (_internal_has_sigmoidkernel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::sigmoidkernel(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.Kernel)
  return target;
}

size_t Kernel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Kernel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (kernel_case()) {
    // .CoreML.Specification.LinearKernel linearKernel = 1;
    case kLinearKernel: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kernel_.linearkernel_);
      break;
    }
    // .CoreML.Specification.RBFKernel rbfKernel = 2;
    case kRbfKernel: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kernel_.rbfkernel_);
      break;
    }
    // .CoreML.Specification.PolyKernel polyKernel = 3;
    case kPolyKernel: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kernel_.polykernel_);
      break;
    }
    // .CoreML.Specification.SigmoidKernel sigmoidKernel = 4;
    case kSigmoidKernel: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kernel_.sigmoidkernel_);
      break;
    }
    case KERNEL_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Kernel::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Kernel*>(
      &from));
}

void Kernel::MergeFrom(const Kernel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Kernel)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.kernel_case()) {
    case kLinearKernel: {
      _internal_mutable_linearkernel()->::CoreML::Specification::LinearKernel::MergeFrom(from._internal_linearkernel());
      break;
    }
    case kRbfKernel: {
      _internal_mutable_rbfkernel()->::CoreML::Specification::RBFKernel::MergeFrom(from._internal_rbfkernel());
      break;
    }
    case kPolyKernel: {
      _internal_mutable_polykernel()->::CoreML::Specification::PolyKernel::MergeFrom(from._internal_polykernel());
      break;
    }
    case kSigmoidKernel: {
      _internal_mutable_sigmoidkernel()->::CoreML::Specification::SigmoidKernel::MergeFrom(from._internal_sigmoidkernel());
      break;
    }
    case KERNEL_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Kernel::CopyFrom(const Kernel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Kernel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Kernel::IsInitialized() const {
  return true;
}

void Kernel::InternalSwap(Kernel* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(kernel_, other->kernel_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string Kernel::GetTypeName() const {
  return "CoreML.Specification.Kernel";
}


// ===================================================================

class SparseNode::_Internal {
 public:
};

SparseNode::SparseNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SparseNode)
}
SparseNode::SparseNode(const SparseNode& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&value_, &from.value_,
    static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&value_)) + sizeof(index_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SparseNode)
}

inline void SparseNode::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&value_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&value_)) + sizeof(index_));
}

SparseNode::~SparseNode() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SparseNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SparseNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SparseNode::ArenaDtor(void* object) {
  SparseNode* _this = reinterpret_cast< SparseNode* >(object);
  (void)_this;
}
void SparseNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SparseNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SparseNode::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SparseNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&value_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&index_) -
      reinterpret_cast<char*>(&value_)) + sizeof(index_));
  _internal_metadata_.Clear<std::string>();
}

const char* SparseNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SparseNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SparseNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 index = 1;
  if (this->_internal_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_index(), target);
  }

  // double value = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_value = this->_internal_value();
  uint64_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SparseNode)
  return target;
}

size_t SparseNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SparseNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double value = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_value = this->_internal_value();
  uint64_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    total_size += 1 + 8;
  }

  // int32 index = 1;
  if (this->_internal_index() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_index());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SparseNode::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SparseNode*>(
      &from));
}

void SparseNode::MergeFrom(const SparseNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SparseNode)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_value = from._internal_value();
  uint64_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    _internal_set_value(from._internal_value());
  }
  if (from._internal_index() != 0) {
    _internal_set_index(from._internal_index());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SparseNode::CopyFrom(const SparseNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SparseNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SparseNode::IsInitialized() const {
  return true;
}

void SparseNode::InternalSwap(SparseNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SparseNode, index_)
      + sizeof(SparseNode::index_)
      - PROTOBUF_FIELD_OFFSET(SparseNode, value_)>(
          reinterpret_cast<char*>(&value_),
          reinterpret_cast<char*>(&other->value_));
}

std::string SparseNode::GetTypeName() const {
  return "CoreML.Specification.SparseNode";
}


// ===================================================================

class SparseVector::_Internal {
 public:
};

SparseVector::SparseVector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  nodes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SparseVector)
}
SparseVector::SparseVector(const SparseVector& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      nodes_(from.nodes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SparseVector)
}

inline void SparseVector::SharedCtor() {
}

SparseVector::~SparseVector() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SparseVector)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SparseVector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SparseVector::ArenaDtor(void* object) {
  SparseVector* _this = reinterpret_cast< SparseVector* >(object);
  (void)_this;
}
void SparseVector::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SparseVector::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SparseVector::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SparseVector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nodes_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SparseVector::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.SparseNode nodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SparseVector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SparseVector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.SparseNode nodes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_nodes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_nodes(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SparseVector)
  return target;
}

size_t SparseVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SparseVector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.SparseNode nodes = 1;
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SparseVector::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SparseVector*>(
      &from));
}

void SparseVector::MergeFrom(const SparseVector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SparseVector)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  nodes_.MergeFrom(from.nodes_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SparseVector::CopyFrom(const SparseVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SparseVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SparseVector::IsInitialized() const {
  return true;
}

void SparseVector::InternalSwap(SparseVector* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  nodes_.InternalSwap(&other->nodes_);
}

std::string SparseVector::GetTypeName() const {
  return "CoreML.Specification.SparseVector";
}


// ===================================================================

class SparseSupportVectors::_Internal {
 public:
};

SparseSupportVectors::SparseSupportVectors(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  vectors_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SparseSupportVectors)
}
SparseSupportVectors::SparseSupportVectors(const SparseSupportVectors& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      vectors_(from.vectors_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SparseSupportVectors)
}

inline void SparseSupportVectors::SharedCtor() {
}

SparseSupportVectors::~SparseSupportVectors() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SparseSupportVectors)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SparseSupportVectors::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SparseSupportVectors::ArenaDtor(void* object) {
  SparseSupportVectors* _this = reinterpret_cast< SparseSupportVectors* >(object);
  (void)_this;
}
void SparseSupportVectors::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SparseSupportVectors::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SparseSupportVectors::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SparseSupportVectors)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vectors_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SparseSupportVectors::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.SparseVector vectors = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_vectors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SparseSupportVectors::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SparseSupportVectors)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.SparseVector vectors = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_vectors_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_vectors(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SparseSupportVectors)
  return target;
}

size_t SparseSupportVectors::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SparseSupportVectors)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.SparseVector vectors = 1;
  total_size += 1UL * this->_internal_vectors_size();
  for (const auto& msg : this->vectors_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SparseSupportVectors::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SparseSupportVectors*>(
      &from));
}

void SparseSupportVectors::MergeFrom(const SparseSupportVectors& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SparseSupportVectors)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  vectors_.MergeFrom(from.vectors_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SparseSupportVectors::CopyFrom(const SparseSupportVectors& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SparseSupportVectors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SparseSupportVectors::IsInitialized() const {
  return true;
}

void SparseSupportVectors::InternalSwap(SparseSupportVectors* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  vectors_.InternalSwap(&other->vectors_);
}

std::string SparseSupportVectors::GetTypeName() const {
  return "CoreML.Specification.SparseSupportVectors";
}


// ===================================================================

class DenseVector::_Internal {
 public:
};

DenseVector::DenseVector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.DenseVector)
}
DenseVector::DenseVector(const DenseVector& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DenseVector)
}

inline void DenseVector::SharedCtor() {
}

DenseVector::~DenseVector() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DenseVector)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void DenseVector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DenseVector::ArenaDtor(void* object) {
  DenseVector* _this = reinterpret_cast< DenseVector* >(object);
  (void)_this;
}
void DenseVector::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DenseVector::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DenseVector::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DenseVector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DenseVector::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated double values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_values(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 9) {
          _internal_add_values(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DenseVector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.DenseVector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double values = 1;
  if (this->_internal_values_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_values(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.DenseVector)
  return target;
}

size_t DenseVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DenseVector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double values = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_values_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DenseVector::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DenseVector*>(
      &from));
}

void DenseVector::MergeFrom(const DenseVector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DenseVector)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DenseVector::CopyFrom(const DenseVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DenseVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DenseVector::IsInitialized() const {
  return true;
}

void DenseVector::InternalSwap(DenseVector* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string DenseVector::GetTypeName() const {
  return "CoreML.Specification.DenseVector";
}


// ===================================================================

class DenseSupportVectors::_Internal {
 public:
};

DenseSupportVectors::DenseSupportVectors(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  vectors_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.DenseSupportVectors)
}
DenseSupportVectors::DenseSupportVectors(const DenseSupportVectors& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      vectors_(from.vectors_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DenseSupportVectors)
}

inline void DenseSupportVectors::SharedCtor() {
}

DenseSupportVectors::~DenseSupportVectors() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DenseSupportVectors)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void DenseSupportVectors::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DenseSupportVectors::ArenaDtor(void* object) {
  DenseSupportVectors* _this = reinterpret_cast< DenseSupportVectors* >(object);
  (void)_this;
}
void DenseSupportVectors::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DenseSupportVectors::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DenseSupportVectors::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DenseSupportVectors)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vectors_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DenseSupportVectors::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.DenseVector vectors = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_vectors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DenseSupportVectors::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.DenseSupportVectors)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.DenseVector vectors = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_vectors_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_vectors(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.DenseSupportVectors)
  return target;
}

size_t DenseSupportVectors::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DenseSupportVectors)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.DenseVector vectors = 1;
  total_size += 1UL * this->_internal_vectors_size();
  for (const auto& msg : this->vectors_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DenseSupportVectors::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DenseSupportVectors*>(
      &from));
}

void DenseSupportVectors::MergeFrom(const DenseSupportVectors& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DenseSupportVectors)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  vectors_.MergeFrom(from.vectors_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DenseSupportVectors::CopyFrom(const DenseSupportVectors& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DenseSupportVectors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DenseSupportVectors::IsInitialized() const {
  return true;
}

void DenseSupportVectors::InternalSwap(DenseSupportVectors* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  vectors_.InternalSwap(&other->vectors_);
}

std::string DenseSupportVectors::GetTypeName() const {
  return "CoreML.Specification.DenseSupportVectors";
}


// ===================================================================

class Coefficients::_Internal {
 public:
};

Coefficients::Coefficients(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  alpha_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.Coefficients)
}
Coefficients::Coefficients(const Coefficients& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      alpha_(from.alpha_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Coefficients)
}

inline void Coefficients::SharedCtor() {
}

Coefficients::~Coefficients() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Coefficients)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Coefficients::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Coefficients::ArenaDtor(void* object) {
  Coefficients* _this = reinterpret_cast< Coefficients* >(object);
  (void)_this;
}
void Coefficients::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Coefficients::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Coefficients::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Coefficients)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  alpha_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Coefficients::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated double alpha = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_alpha(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 9) {
          _internal_add_alpha(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Coefficients::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.Coefficients)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double alpha = 1;
  if (this->_internal_alpha_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_alpha(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.Coefficients)
  return target;
}

size_t Coefficients::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Coefficients)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double alpha = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_alpha_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Coefficients::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Coefficients*>(
      &from));
}

void Coefficients::MergeFrom(const Coefficients& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Coefficients)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  alpha_.MergeFrom(from.alpha_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Coefficients::CopyFrom(const Coefficients& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Coefficients)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Coefficients::IsInitialized() const {
  return true;
}

void Coefficients::InternalSwap(Coefficients* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  alpha_.InternalSwap(&other->alpha_);
}

std::string Coefficients::GetTypeName() const {
  return "CoreML.Specification.Coefficients";
}


// ===================================================================

class SupportVectorRegressor::_Internal {
 public:
  static const ::CoreML::Specification::Kernel& kernel(const SupportVectorRegressor* msg);
  static const ::CoreML::Specification::SparseSupportVectors& sparsesupportvectors(const SupportVectorRegressor* msg);
  static const ::CoreML::Specification::DenseSupportVectors& densesupportvectors(const SupportVectorRegressor* msg);
  static const ::CoreML::Specification::Coefficients& coefficients(const SupportVectorRegressor* msg);
};

const ::CoreML::Specification::Kernel&
SupportVectorRegressor::_Internal::kernel(const SupportVectorRegressor* msg) {
  return *msg->kernel_;
}
const ::CoreML::Specification::SparseSupportVectors&
SupportVectorRegressor::_Internal::sparsesupportvectors(const SupportVectorRegressor* msg) {
  return *msg->supportVectors_.sparsesupportvectors_;
}
const ::CoreML::Specification::DenseSupportVectors&
SupportVectorRegressor::_Internal::densesupportvectors(const SupportVectorRegressor* msg) {
  return *msg->supportVectors_.densesupportvectors_;
}
const ::CoreML::Specification::Coefficients&
SupportVectorRegressor::_Internal::coefficients(const SupportVectorRegressor* msg) {
  return *msg->coefficients_;
}
void SupportVectorRegressor::set_allocated_sparsesupportvectors(::CoreML::Specification::SparseSupportVectors* sparsesupportvectors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_supportVectors();
  if (sparsesupportvectors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SparseSupportVectors>::GetOwningArena(sparsesupportvectors);
    if (message_arena != submessage_arena) {
      sparsesupportvectors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sparsesupportvectors, submessage_arena);
    }
    set_has_sparsesupportvectors();
    supportVectors_.sparsesupportvectors_ = sparsesupportvectors;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorRegressor.sparseSupportVectors)
}
void SupportVectorRegressor::set_allocated_densesupportvectors(::CoreML::Specification::DenseSupportVectors* densesupportvectors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_supportVectors();
  if (densesupportvectors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::DenseSupportVectors>::GetOwningArena(densesupportvectors);
    if (message_arena != submessage_arena) {
      densesupportvectors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, densesupportvectors, submessage_arena);
    }
    set_has_densesupportvectors();
    supportVectors_.densesupportvectors_ = densesupportvectors;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorRegressor.denseSupportVectors)
}
SupportVectorRegressor::SupportVectorRegressor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SupportVectorRegressor)
}
SupportVectorRegressor::SupportVectorRegressor(const SupportVectorRegressor& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_kernel()) {
    kernel_ = new ::CoreML::Specification::Kernel(*from.kernel_);
  } else {
    kernel_ = nullptr;
  }
  if (from._internal_has_coefficients()) {
    coefficients_ = new ::CoreML::Specification::Coefficients(*from.coefficients_);
  } else {
    coefficients_ = nullptr;
  }
  rho_ = from.rho_;
  clear_has_supportVectors();
  switch (from.supportVectors_case()) {
    case kSparseSupportVectors: {
      _internal_mutable_sparsesupportvectors()->::CoreML::Specification::SparseSupportVectors::MergeFrom(from._internal_sparsesupportvectors());
      break;
    }
    case kDenseSupportVectors: {
      _internal_mutable_densesupportvectors()->::CoreML::Specification::DenseSupportVectors::MergeFrom(from._internal_densesupportvectors());
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SupportVectorRegressor)
}

inline void SupportVectorRegressor::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&kernel_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rho_) -
    reinterpret_cast<char*>(&kernel_)) + sizeof(rho_));
clear_has_supportVectors();
}

SupportVectorRegressor::~SupportVectorRegressor() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SupportVectorRegressor)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SupportVectorRegressor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete kernel_;
  if (this != internal_default_instance()) delete coefficients_;
  if (has_supportVectors()) {
    clear_supportVectors();
  }
}

void SupportVectorRegressor::ArenaDtor(void* object) {
  SupportVectorRegressor* _this = reinterpret_cast< SupportVectorRegressor* >(object);
  (void)_this;
}
void SupportVectorRegressor::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SupportVectorRegressor::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SupportVectorRegressor::clear_supportVectors() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.SupportVectorRegressor)
  switch (supportVectors_case()) {
    case kSparseSupportVectors: {
      if (GetArenaForAllocation() == nullptr) {
        delete supportVectors_.sparsesupportvectors_;
      }
      break;
    }
    case kDenseSupportVectors: {
      if (GetArenaForAllocation() == nullptr) {
        delete supportVectors_.densesupportvectors_;
      }
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SUPPORTVECTORS_NOT_SET;
}


void SupportVectorRegressor::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SupportVectorRegressor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && kernel_ != nullptr) {
    delete kernel_;
  }
  kernel_ = nullptr;
  if (GetArenaForAllocation() == nullptr && coefficients_ != nullptr) {
    delete coefficients_;
  }
  coefficients_ = nullptr;
  rho_ = 0;
  clear_supportVectors();
  _internal_metadata_.Clear<std::string>();
}

const char* SupportVectorRegressor::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.Kernel kernel = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_kernel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_sparsesupportvectors(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.DenseSupportVectors denseSupportVectors = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_densesupportvectors(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Coefficients coefficients = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_coefficients(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double rho = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          rho_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SupportVectorRegressor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SupportVectorRegressor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.Kernel kernel = 1;
  if (this->_internal_has_kernel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::kernel(this), target, stream);
  }

  // .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 2;
  if (_internal_has_sparsesupportvectors()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::sparsesupportvectors(this), target, stream);
  }

  // .CoreML.Specification.DenseSupportVectors denseSupportVectors = 3;
  if (_internal_has_densesupportvectors()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::densesupportvectors(this), target, stream);
  }

  // .CoreML.Specification.Coefficients coefficients = 4;
  if (this->_internal_has_coefficients()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::coefficients(this), target, stream);
  }

  // double rho = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rho = this->_internal_rho();
  uint64_t raw_rho;
  memcpy(&raw_rho, &tmp_rho, sizeof(tmp_rho));
  if (raw_rho != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_rho(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SupportVectorRegressor)
  return target;
}

size_t SupportVectorRegressor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SupportVectorRegressor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.Kernel kernel = 1;
  if (this->_internal_has_kernel()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *kernel_);
  }

  // .CoreML.Specification.Coefficients coefficients = 4;
  if (this->_internal_has_coefficients()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *coefficients_);
  }

  // double rho = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rho = this->_internal_rho();
  uint64_t raw_rho;
  memcpy(&raw_rho, &tmp_rho, sizeof(tmp_rho));
  if (raw_rho != 0) {
    total_size += 1 + 8;
  }

  switch (supportVectors_case()) {
    // .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 2;
    case kSparseSupportVectors: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *supportVectors_.sparsesupportvectors_);
      break;
    }
    // .CoreML.Specification.DenseSupportVectors denseSupportVectors = 3;
    case kDenseSupportVectors: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *supportVectors_.densesupportvectors_);
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SupportVectorRegressor::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SupportVectorRegressor*>(
      &from));
}

void SupportVectorRegressor::MergeFrom(const SupportVectorRegressor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SupportVectorRegressor)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_kernel()) {
    _internal_mutable_kernel()->::CoreML::Specification::Kernel::MergeFrom(from._internal_kernel());
  }
  if (from._internal_has_coefficients()) {
    _internal_mutable_coefficients()->::CoreML::Specification::Coefficients::MergeFrom(from._internal_coefficients());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rho = from._internal_rho();
  uint64_t raw_rho;
  memcpy(&raw_rho, &tmp_rho, sizeof(tmp_rho));
  if (raw_rho != 0) {
    _internal_set_rho(from._internal_rho());
  }
  switch (from.supportVectors_case()) {
    case kSparseSupportVectors: {
      _internal_mutable_sparsesupportvectors()->::CoreML::Specification::SparseSupportVectors::MergeFrom(from._internal_sparsesupportvectors());
      break;
    }
    case kDenseSupportVectors: {
      _internal_mutable_densesupportvectors()->::CoreML::Specification::DenseSupportVectors::MergeFrom(from._internal_densesupportvectors());
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SupportVectorRegressor::CopyFrom(const SupportVectorRegressor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SupportVectorRegressor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SupportVectorRegressor::IsInitialized() const {
  return true;
}

void SupportVectorRegressor::InternalSwap(SupportVectorRegressor* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SupportVectorRegressor, rho_)
      + sizeof(SupportVectorRegressor::rho_)
      - PROTOBUF_FIELD_OFFSET(SupportVectorRegressor, kernel_)>(
          reinterpret_cast<char*>(&kernel_),
          reinterpret_cast<char*>(&other->kernel_));
  swap(supportVectors_, other->supportVectors_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string SupportVectorRegressor::GetTypeName() const {
  return "CoreML.Specification.SupportVectorRegressor";
}


// ===================================================================

class SupportVectorClassifier::_Internal {
 public:
  static const ::CoreML::Specification::Kernel& kernel(const SupportVectorClassifier* msg);
  static const ::CoreML::Specification::SparseSupportVectors& sparsesupportvectors(const SupportVectorClassifier* msg);
  static const ::CoreML::Specification::DenseSupportVectors& densesupportvectors(const SupportVectorClassifier* msg);
  static const ::CoreML::Specification::StringVector& stringclasslabels(const SupportVectorClassifier* msg);
  static const ::CoreML::Specification::Int64Vector& int64classlabels(const SupportVectorClassifier* msg);
};

const ::CoreML::Specification::Kernel&
SupportVectorClassifier::_Internal::kernel(const SupportVectorClassifier* msg) {
  return *msg->kernel_;
}
const ::CoreML::Specification::SparseSupportVectors&
SupportVectorClassifier::_Internal::sparsesupportvectors(const SupportVectorClassifier* msg) {
  return *msg->supportVectors_.sparsesupportvectors_;
}
const ::CoreML::Specification::DenseSupportVectors&
SupportVectorClassifier::_Internal::densesupportvectors(const SupportVectorClassifier* msg) {
  return *msg->supportVectors_.densesupportvectors_;
}
const ::CoreML::Specification::StringVector&
SupportVectorClassifier::_Internal::stringclasslabels(const SupportVectorClassifier* msg) {
  return *msg->ClassLabels_.stringclasslabels_;
}
const ::CoreML::Specification::Int64Vector&
SupportVectorClassifier::_Internal::int64classlabels(const SupportVectorClassifier* msg) {
  return *msg->ClassLabels_.int64classlabels_;
}
void SupportVectorClassifier::set_allocated_sparsesupportvectors(::CoreML::Specification::SparseSupportVectors* sparsesupportvectors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_supportVectors();
  if (sparsesupportvectors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SparseSupportVectors>::GetOwningArena(sparsesupportvectors);
    if (message_arena != submessage_arena) {
      sparsesupportvectors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sparsesupportvectors, submessage_arena);
    }
    set_has_sparsesupportvectors();
    supportVectors_.sparsesupportvectors_ = sparsesupportvectors;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorClassifier.sparseSupportVectors)
}
void SupportVectorClassifier::set_allocated_densesupportvectors(::CoreML::Specification::DenseSupportVectors* densesupportvectors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_supportVectors();
  if (densesupportvectors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::DenseSupportVectors>::GetOwningArena(densesupportvectors);
    if (message_arena != submessage_arena) {
      densesupportvectors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, densesupportvectors, submessage_arena);
    }
    set_has_densesupportvectors();
    supportVectors_.densesupportvectors_ = densesupportvectors;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorClassifier.denseSupportVectors)
}
void SupportVectorClassifier::set_allocated_stringclasslabels(::CoreML::Specification::StringVector* stringclasslabels) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ClassLabels();
  if (stringclasslabels) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stringclasslabels));
    if (message_arena != submessage_arena) {
      stringclasslabels = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stringclasslabels, submessage_arena);
    }
    set_has_stringclasslabels();
    ClassLabels_.stringclasslabels_ = stringclasslabels;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorClassifier.stringClassLabels)
}
void SupportVectorClassifier::clear_stringclasslabels() {
  if (_internal_has_stringclasslabels()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ClassLabels_.stringclasslabels_;
    }
    clear_has_ClassLabels();
  }
}
void SupportVectorClassifier::set_allocated_int64classlabels(::CoreML::Specification::Int64Vector* int64classlabels) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ClassLabels();
  if (int64classlabels) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(int64classlabels));
    if (message_arena != submessage_arena) {
      int64classlabels = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, int64classlabels, submessage_arena);
    }
    set_has_int64classlabels();
    ClassLabels_.int64classlabels_ = int64classlabels;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorClassifier.int64ClassLabels)
}
void SupportVectorClassifier::clear_int64classlabels() {
  if (_internal_has_int64classlabels()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ClassLabels_.int64classlabels_;
    }
    clear_has_ClassLabels();
  }
}
SupportVectorClassifier::SupportVectorClassifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  numberofsupportvectorsperclass_(arena),
  coefficients_(arena),
  rho_(arena),
  proba_(arena),
  probb_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SupportVectorClassifier)
}
SupportVectorClassifier::SupportVectorClassifier(const SupportVectorClassifier& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      numberofsupportvectorsperclass_(from.numberofsupportvectorsperclass_),
      coefficients_(from.coefficients_),
      rho_(from.rho_),
      proba_(from.proba_),
      probb_(from.probb_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_kernel()) {
    kernel_ = new ::CoreML::Specification::Kernel(*from.kernel_);
  } else {
    kernel_ = nullptr;
  }
  clear_has_supportVectors();
  switch (from.supportVectors_case()) {
    case kSparseSupportVectors: {
      _internal_mutable_sparsesupportvectors()->::CoreML::Specification::SparseSupportVectors::MergeFrom(from._internal_sparsesupportvectors());
      break;
    }
    case kDenseSupportVectors: {
      _internal_mutable_densesupportvectors()->::CoreML::Specification::DenseSupportVectors::MergeFrom(from._internal_densesupportvectors());
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  clear_has_ClassLabels();
  switch (from.ClassLabels_case()) {
    case kStringClassLabels: {
      _internal_mutable_stringclasslabels()->::CoreML::Specification::StringVector::MergeFrom(from._internal_stringclasslabels());
      break;
    }
    case kInt64ClassLabels: {
      _internal_mutable_int64classlabels()->::CoreML::Specification::Int64Vector::MergeFrom(from._internal_int64classlabels());
      break;
    }
    case CLASSLABELS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SupportVectorClassifier)
}

inline void SupportVectorClassifier::SharedCtor() {
kernel_ = nullptr;
clear_has_supportVectors();
clear_has_ClassLabels();
}

SupportVectorClassifier::~SupportVectorClassifier() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SupportVectorClassifier)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SupportVectorClassifier::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete kernel_;
  if (has_supportVectors()) {
    clear_supportVectors();
  }
  if (has_ClassLabels()) {
    clear_ClassLabels();
  }
}

void SupportVectorClassifier::ArenaDtor(void* object) {
  SupportVectorClassifier* _this = reinterpret_cast< SupportVectorClassifier* >(object);
  (void)_this;
}
void SupportVectorClassifier::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SupportVectorClassifier::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SupportVectorClassifier::clear_supportVectors() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.SupportVectorClassifier)
  switch (supportVectors_case()) {
    case kSparseSupportVectors: {
      if (GetArenaForAllocation() == nullptr) {
        delete supportVectors_.sparsesupportvectors_;
      }
      break;
    }
    case kDenseSupportVectors: {
      if (GetArenaForAllocation() == nullptr) {
        delete supportVectors_.densesupportvectors_;
      }
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SUPPORTVECTORS_NOT_SET;
}

void SupportVectorClassifier::clear_ClassLabels() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.SupportVectorClassifier)
  switch (ClassLabels_case()) {
    case kStringClassLabels: {
      if (GetArenaForAllocation() == nullptr) {
        delete ClassLabels_.stringclasslabels_;
      }
      break;
    }
    case kInt64ClassLabels: {
      if (GetArenaForAllocation() == nullptr) {
        delete ClassLabels_.int64classlabels_;
      }
      break;
    }
    case CLASSLABELS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = CLASSLABELS_NOT_SET;
}


void SupportVectorClassifier::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SupportVectorClassifier)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  numberofsupportvectorsperclass_.Clear();
  coefficients_.Clear();
  rho_.Clear();
  proba_.Clear();
  probb_.Clear();
  if (GetArenaForAllocation() == nullptr && kernel_ != nullptr) {
    delete kernel_;
  }
  kernel_ = nullptr;
  clear_supportVectors();
  clear_ClassLabels();
  _internal_metadata_.Clear<std::string>();
}

const char* SupportVectorClassifier::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.Kernel kernel = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_kernel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 numberOfSupportVectorsPerClass = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_numberofsupportvectorsperclass(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_numberofsupportvectorsperclass(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sparsesupportvectors(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.DenseSupportVectors denseSupportVectors = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_densesupportvectors(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.Coefficients coefficients = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_coefficients(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated double rho = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_rho(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 49) {
          _internal_add_rho(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated double probA = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_proba(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 57) {
          _internal_add_proba(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated double probB = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_probb(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 65) {
          _internal_add_probb(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.StringVector stringClassLabels = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_stringclasslabels(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Int64Vector int64ClassLabels = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_int64classlabels(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SupportVectorClassifier::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SupportVectorClassifier)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.Kernel kernel = 1;
  if (this->_internal_has_kernel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::kernel(this), target, stream);
  }

  // repeated int32 numberOfSupportVectorsPerClass = 2;
  {
    int byte_size = _numberofsupportvectorsperclass_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          2, _internal_numberofsupportvectorsperclass(), byte_size, target);
    }
  }

  // .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 3;
  if (_internal_has_sparsesupportvectors()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::sparsesupportvectors(this), target, stream);
  }

  // .CoreML.Specification.DenseSupportVectors denseSupportVectors = 4;
  if (_internal_has_densesupportvectors()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::densesupportvectors(this), target, stream);
  }

  // repeated .CoreML.Specification.Coefficients coefficients = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_coefficients_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_coefficients(i), target, stream);
  }

  // repeated double rho = 6;
  if (this->_internal_rho_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_rho(), target);
  }

  // repeated double probA = 7;
  if (this->_internal_proba_size() > 0) {
    target = stream->WriteFixedPacked(7, _internal_proba(), target);
  }

  // repeated double probB = 8;
  if (this->_internal_probb_size() > 0) {
    target = stream->WriteFixedPacked(8, _internal_probb(), target);
  }

  // .CoreML.Specification.StringVector stringClassLabels = 100;
  if (_internal_has_stringclasslabels()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        100, _Internal::stringclasslabels(this), target, stream);
  }

  // .CoreML.Specification.Int64Vector int64ClassLabels = 101;
  if (_internal_has_int64classlabels()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        101, _Internal::int64classlabels(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SupportVectorClassifier)
  return target;
}

size_t SupportVectorClassifier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SupportVectorClassifier)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 numberOfSupportVectorsPerClass = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->numberofsupportvectorsperclass_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _numberofsupportvectorsperclass_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .CoreML.Specification.Coefficients coefficients = 5;
  total_size += 1UL * this->_internal_coefficients_size();
  for (const auto& msg : this->coefficients_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated double rho = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_rho_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated double probA = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_proba_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated double probB = 8;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_probb_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // .CoreML.Specification.Kernel kernel = 1;
  if (this->_internal_has_kernel()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *kernel_);
  }

  switch (supportVectors_case()) {
    // .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 3;
    case kSparseSupportVectors: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *supportVectors_.sparsesupportvectors_);
      break;
    }
    // .CoreML.Specification.DenseSupportVectors denseSupportVectors = 4;
    case kDenseSupportVectors: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *supportVectors_.densesupportvectors_);
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  switch (ClassLabels_case()) {
    // .CoreML.Specification.StringVector stringClassLabels = 100;
    case kStringClassLabels: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ClassLabels_.stringclasslabels_);
      break;
    }
    // .CoreML.Specification.Int64Vector int64ClassLabels = 101;
    case kInt64ClassLabels: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ClassLabels_.int64classlabels_);
      break;
    }
    case CLASSLABELS_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SupportVectorClassifier::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SupportVectorClassifier*>(
      &from));
}

void SupportVectorClassifier::MergeFrom(const SupportVectorClassifier& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SupportVectorClassifier)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  numberofsupportvectorsperclass_.MergeFrom(from.numberofsupportvectorsperclass_);
  coefficients_.MergeFrom(from.coefficients_);
  rho_.MergeFrom(from.rho_);
  proba_.MergeFrom(from.proba_);
  probb_.MergeFrom(from.probb_);
  if (from._internal_has_kernel()) {
    _internal_mutable_kernel()->::CoreML::Specification::Kernel::MergeFrom(from._internal_kernel());
  }
  switch (from.supportVectors_case()) {
    case kSparseSupportVectors: {
      _internal_mutable_sparsesupportvectors()->::CoreML::Specification::SparseSupportVectors::MergeFrom(from._internal_sparsesupportvectors());
      break;
    }
    case kDenseSupportVectors: {
      _internal_mutable_densesupportvectors()->::CoreML::Specification::DenseSupportVectors::MergeFrom(from._internal_densesupportvectors());
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  switch (from.ClassLabels_case()) {
    case kStringClassLabels: {
      _internal_mutable_stringclasslabels()->::CoreML::Specification::StringVector::MergeFrom(from._internal_stringclasslabels());
      break;
    }
    case kInt64ClassLabels: {
      _internal_mutable_int64classlabels()->::CoreML::Specification::Int64Vector::MergeFrom(from._internal_int64classlabels());
      break;
    }
    case CLASSLABELS_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SupportVectorClassifier::CopyFrom(const SupportVectorClassifier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SupportVectorClassifier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SupportVectorClassifier::IsInitialized() const {
  return true;
}

void SupportVectorClassifier::InternalSwap(SupportVectorClassifier* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  numberofsupportvectorsperclass_.InternalSwap(&other->numberofsupportvectorsperclass_);
  coefficients_.InternalSwap(&other->coefficients_);
  rho_.InternalSwap(&other->rho_);
  proba_.InternalSwap(&other->proba_);
  probb_.InternalSwap(&other->probb_);
  swap(kernel_, other->kernel_);
  swap(supportVectors_, other->supportVectors_);
  swap(ClassLabels_, other->ClassLabels_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

std::string SupportVectorClassifier::GetTypeName() const {
  return "CoreML.Specification.SupportVectorClassifier";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace Specification
}  // namespace CoreML
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LinearKernel* Arena::CreateMaybeMessage< ::CoreML::Specification::LinearKernel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LinearKernel >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::RBFKernel* Arena::CreateMaybeMessage< ::CoreML::Specification::RBFKernel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::RBFKernel >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::PolyKernel* Arena::CreateMaybeMessage< ::CoreML::Specification::PolyKernel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::PolyKernel >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SigmoidKernel* Arena::CreateMaybeMessage< ::CoreML::Specification::SigmoidKernel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SigmoidKernel >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Kernel* Arena::CreateMaybeMessage< ::CoreML::Specification::Kernel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Kernel >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SparseNode* Arena::CreateMaybeMessage< ::CoreML::Specification::SparseNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SparseNode >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SparseVector* Arena::CreateMaybeMessage< ::CoreML::Specification::SparseVector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SparseVector >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SparseSupportVectors* Arena::CreateMaybeMessage< ::CoreML::Specification::SparseSupportVectors >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SparseSupportVectors >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::DenseVector* Arena::CreateMaybeMessage< ::CoreML::Specification::DenseVector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::DenseVector >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::DenseSupportVectors* Arena::CreateMaybeMessage< ::CoreML::Specification::DenseSupportVectors >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::DenseSupportVectors >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Coefficients* Arena::CreateMaybeMessage< ::CoreML::Specification::Coefficients >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Coefficients >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SupportVectorRegressor* Arena::CreateMaybeMessage< ::CoreML::Specification::SupportVectorRegressor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SupportVectorRegressor >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SupportVectorClassifier* Arena::CreateMaybeMessage< ::CoreML::Specification::SupportVectorClassifier >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SupportVectorClassifier >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
