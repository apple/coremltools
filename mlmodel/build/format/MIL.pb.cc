// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MIL.proto

#include "MIL.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace CoreML {
namespace Specification {
namespace MILSpec {
constexpr Program_FunctionsEntry_DoNotUse::Program_FunctionsEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct Program_FunctionsEntry_DoNotUseDefaultTypeInternal {
  constexpr Program_FunctionsEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Program_FunctionsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Program_FunctionsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Program_FunctionsEntry_DoNotUseDefaultTypeInternal _Program_FunctionsEntry_DoNotUse_default_instance_;
constexpr Program_AttributesEntry_DoNotUse::Program_AttributesEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct Program_AttributesEntry_DoNotUseDefaultTypeInternal {
  constexpr Program_AttributesEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Program_AttributesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Program_AttributesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Program_AttributesEntry_DoNotUseDefaultTypeInternal _Program_AttributesEntry_DoNotUse_default_instance_;
constexpr Program::Program(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : functions_()
  , attributes_()
  , docstring_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , version_(int64_t{0}){}
struct ProgramDefaultTypeInternal {
  constexpr ProgramDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ProgramDefaultTypeInternal() {}
  union {
    Program _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ProgramDefaultTypeInternal _Program_default_instance_;
constexpr Function_BlockSpecializationsEntry_DoNotUse::Function_BlockSpecializationsEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct Function_BlockSpecializationsEntry_DoNotUseDefaultTypeInternal {
  constexpr Function_BlockSpecializationsEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Function_BlockSpecializationsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Function_BlockSpecializationsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Function_BlockSpecializationsEntry_DoNotUseDefaultTypeInternal _Function_BlockSpecializationsEntry_DoNotUse_default_instance_;
constexpr Function_AttributesEntry_DoNotUse::Function_AttributesEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct Function_AttributesEntry_DoNotUseDefaultTypeInternal {
  constexpr Function_AttributesEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Function_AttributesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Function_AttributesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Function_AttributesEntry_DoNotUseDefaultTypeInternal _Function_AttributesEntry_DoNotUse_default_instance_;
constexpr Function::Function(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : inputs_()
  , block_specializations_()
  , attributes_()
  , opset_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct FunctionDefaultTypeInternal {
  constexpr FunctionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FunctionDefaultTypeInternal() {}
  union {
    Function _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FunctionDefaultTypeInternal _Function_default_instance_;
constexpr Block_AttributesEntry_DoNotUse::Block_AttributesEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct Block_AttributesEntry_DoNotUseDefaultTypeInternal {
  constexpr Block_AttributesEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Block_AttributesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Block_AttributesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Block_AttributesEntry_DoNotUseDefaultTypeInternal _Block_AttributesEntry_DoNotUse_default_instance_;
constexpr Block::Block(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : inputs_()
  , outputs_()
  , operations_()
  , attributes_(){}
struct BlockDefaultTypeInternal {
  constexpr BlockDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BlockDefaultTypeInternal() {}
  union {
    Block _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BlockDefaultTypeInternal _Block_default_instance_;
constexpr Argument_Binding::Argument_Binding(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct Argument_BindingDefaultTypeInternal {
  constexpr Argument_BindingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Argument_BindingDefaultTypeInternal() {}
  union {
    Argument_Binding _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Argument_BindingDefaultTypeInternal _Argument_Binding_default_instance_;
constexpr Argument::Argument(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : arguments_(){}
struct ArgumentDefaultTypeInternal {
  constexpr ArgumentDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ArgumentDefaultTypeInternal() {}
  union {
    Argument _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ArgumentDefaultTypeInternal _Argument_default_instance_;
constexpr Operation_InputsEntry_DoNotUse::Operation_InputsEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct Operation_InputsEntry_DoNotUseDefaultTypeInternal {
  constexpr Operation_InputsEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Operation_InputsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Operation_InputsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Operation_InputsEntry_DoNotUseDefaultTypeInternal _Operation_InputsEntry_DoNotUse_default_instance_;
constexpr Operation_AttributesEntry_DoNotUse::Operation_AttributesEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct Operation_AttributesEntry_DoNotUseDefaultTypeInternal {
  constexpr Operation_AttributesEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Operation_AttributesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Operation_AttributesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Operation_AttributesEntry_DoNotUseDefaultTypeInternal _Operation_AttributesEntry_DoNotUse_default_instance_;
constexpr Operation::Operation(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : inputs_()
  , outputs_()
  , blocks_()
  , attributes_()
  , type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct OperationDefaultTypeInternal {
  constexpr OperationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~OperationDefaultTypeInternal() {}
  union {
    Operation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OperationDefaultTypeInternal _Operation_default_instance_;
constexpr NamedValueType::NamedValueType(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , type_(nullptr){}
struct NamedValueTypeDefaultTypeInternal {
  constexpr NamedValueTypeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NamedValueTypeDefaultTypeInternal() {}
  union {
    NamedValueType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NamedValueTypeDefaultTypeInternal _NamedValueType_default_instance_;
constexpr ValueType::ValueType(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct ValueTypeDefaultTypeInternal {
  constexpr ValueTypeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ValueTypeDefaultTypeInternal() {}
  union {
    ValueType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ValueTypeDefaultTypeInternal _ValueType_default_instance_;
constexpr TensorType_AttributesEntry_DoNotUse::TensorType_AttributesEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct TensorType_AttributesEntry_DoNotUseDefaultTypeInternal {
  constexpr TensorType_AttributesEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TensorType_AttributesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    TensorType_AttributesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TensorType_AttributesEntry_DoNotUseDefaultTypeInternal _TensorType_AttributesEntry_DoNotUse_default_instance_;
constexpr TensorType::TensorType(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dimensions_()
  , attributes_()
  , rank_(int64_t{0})
  , datatype_(0)
{}
struct TensorTypeDefaultTypeInternal {
  constexpr TensorTypeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TensorTypeDefaultTypeInternal() {}
  union {
    TensorType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TensorTypeDefaultTypeInternal _TensorType_default_instance_;
constexpr TupleType::TupleType(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : types_(){}
struct TupleTypeDefaultTypeInternal {
  constexpr TupleTypeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TupleTypeDefaultTypeInternal() {}
  union {
    TupleType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TupleTypeDefaultTypeInternal _TupleType_default_instance_;
constexpr ListType::ListType(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : type_(nullptr)
  , length_(nullptr){}
struct ListTypeDefaultTypeInternal {
  constexpr ListTypeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ListTypeDefaultTypeInternal() {}
  union {
    ListType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ListTypeDefaultTypeInternal _ListType_default_instance_;
constexpr DictionaryType::DictionaryType(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : keytype_(nullptr)
  , valuetype_(nullptr){}
struct DictionaryTypeDefaultTypeInternal {
  constexpr DictionaryTypeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DictionaryTypeDefaultTypeInternal() {}
  union {
    DictionaryType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DictionaryTypeDefaultTypeInternal _DictionaryType_default_instance_;
constexpr StateType::StateType(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : wrappedtype_(nullptr){}
struct StateTypeDefaultTypeInternal {
  constexpr StateTypeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StateTypeDefaultTypeInternal() {}
  union {
    StateType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StateTypeDefaultTypeInternal _StateType_default_instance_;
constexpr Dimension_ConstantDimension::Dimension_ConstantDimension(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : size_(uint64_t{0u}){}
struct Dimension_ConstantDimensionDefaultTypeInternal {
  constexpr Dimension_ConstantDimensionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Dimension_ConstantDimensionDefaultTypeInternal() {}
  union {
    Dimension_ConstantDimension _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Dimension_ConstantDimensionDefaultTypeInternal _Dimension_ConstantDimension_default_instance_;
constexpr Dimension_UnknownDimension::Dimension_UnknownDimension(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : variadic_(false){}
struct Dimension_UnknownDimensionDefaultTypeInternal {
  constexpr Dimension_UnknownDimensionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Dimension_UnknownDimensionDefaultTypeInternal() {}
  union {
    Dimension_UnknownDimension _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Dimension_UnknownDimensionDefaultTypeInternal _Dimension_UnknownDimension_default_instance_;
constexpr Dimension::Dimension(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct DimensionDefaultTypeInternal {
  constexpr DimensionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DimensionDefaultTypeInternal() {}
  union {
    Dimension _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DimensionDefaultTypeInternal _Dimension_default_instance_;
constexpr Value_ImmediateValue::Value_ImmediateValue(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct Value_ImmediateValueDefaultTypeInternal {
  constexpr Value_ImmediateValueDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Value_ImmediateValueDefaultTypeInternal() {}
  union {
    Value_ImmediateValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Value_ImmediateValueDefaultTypeInternal _Value_ImmediateValue_default_instance_;
constexpr Value_BlobFileValue::Value_BlobFileValue(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : filename_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , offset_(uint64_t{0u}){}
struct Value_BlobFileValueDefaultTypeInternal {
  constexpr Value_BlobFileValueDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Value_BlobFileValueDefaultTypeInternal() {}
  union {
    Value_BlobFileValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Value_BlobFileValueDefaultTypeInternal _Value_BlobFileValue_default_instance_;
constexpr Value::Value(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : docstring_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , type_(nullptr)
  , _oneof_case_{}{}
struct ValueDefaultTypeInternal {
  constexpr ValueDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ValueDefaultTypeInternal() {}
  union {
    Value _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ValueDefaultTypeInternal _Value_default_instance_;
constexpr TensorValue_RepeatedFloats::TensorValue_RepeatedFloats(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : values_(){}
struct TensorValue_RepeatedFloatsDefaultTypeInternal {
  constexpr TensorValue_RepeatedFloatsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TensorValue_RepeatedFloatsDefaultTypeInternal() {}
  union {
    TensorValue_RepeatedFloats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TensorValue_RepeatedFloatsDefaultTypeInternal _TensorValue_RepeatedFloats_default_instance_;
constexpr TensorValue_RepeatedDoubles::TensorValue_RepeatedDoubles(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : values_(){}
struct TensorValue_RepeatedDoublesDefaultTypeInternal {
  constexpr TensorValue_RepeatedDoublesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TensorValue_RepeatedDoublesDefaultTypeInternal() {}
  union {
    TensorValue_RepeatedDoubles _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TensorValue_RepeatedDoublesDefaultTypeInternal _TensorValue_RepeatedDoubles_default_instance_;
constexpr TensorValue_RepeatedInts::TensorValue_RepeatedInts(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : values_()
  , _values_cached_byte_size_(0){}
struct TensorValue_RepeatedIntsDefaultTypeInternal {
  constexpr TensorValue_RepeatedIntsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TensorValue_RepeatedIntsDefaultTypeInternal() {}
  union {
    TensorValue_RepeatedInts _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TensorValue_RepeatedIntsDefaultTypeInternal _TensorValue_RepeatedInts_default_instance_;
constexpr TensorValue_RepeatedLongInts::TensorValue_RepeatedLongInts(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : values_()
  , _values_cached_byte_size_(0){}
struct TensorValue_RepeatedLongIntsDefaultTypeInternal {
  constexpr TensorValue_RepeatedLongIntsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TensorValue_RepeatedLongIntsDefaultTypeInternal() {}
  union {
    TensorValue_RepeatedLongInts _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TensorValue_RepeatedLongIntsDefaultTypeInternal _TensorValue_RepeatedLongInts_default_instance_;
constexpr TensorValue_RepeatedBools::TensorValue_RepeatedBools(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : values_(){}
struct TensorValue_RepeatedBoolsDefaultTypeInternal {
  constexpr TensorValue_RepeatedBoolsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TensorValue_RepeatedBoolsDefaultTypeInternal() {}
  union {
    TensorValue_RepeatedBools _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TensorValue_RepeatedBoolsDefaultTypeInternal _TensorValue_RepeatedBools_default_instance_;
constexpr TensorValue_RepeatedStrings::TensorValue_RepeatedStrings(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : values_(){}
struct TensorValue_RepeatedStringsDefaultTypeInternal {
  constexpr TensorValue_RepeatedStringsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TensorValue_RepeatedStringsDefaultTypeInternal() {}
  union {
    TensorValue_RepeatedStrings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TensorValue_RepeatedStringsDefaultTypeInternal _TensorValue_RepeatedStrings_default_instance_;
constexpr TensorValue_RepeatedBytes::TensorValue_RepeatedBytes(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : values_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct TensorValue_RepeatedBytesDefaultTypeInternal {
  constexpr TensorValue_RepeatedBytesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TensorValue_RepeatedBytesDefaultTypeInternal() {}
  union {
    TensorValue_RepeatedBytes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TensorValue_RepeatedBytesDefaultTypeInternal _TensorValue_RepeatedBytes_default_instance_;
constexpr TensorValue::TensorValue(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct TensorValueDefaultTypeInternal {
  constexpr TensorValueDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TensorValueDefaultTypeInternal() {}
  union {
    TensorValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TensorValueDefaultTypeInternal _TensorValue_default_instance_;
constexpr TupleValue::TupleValue(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : values_(){}
struct TupleValueDefaultTypeInternal {
  constexpr TupleValueDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TupleValueDefaultTypeInternal() {}
  union {
    TupleValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TupleValueDefaultTypeInternal _TupleValue_default_instance_;
constexpr ListValue::ListValue(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : values_(){}
struct ListValueDefaultTypeInternal {
  constexpr ListValueDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ListValueDefaultTypeInternal() {}
  union {
    ListValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ListValueDefaultTypeInternal _ListValue_default_instance_;
constexpr DictionaryValue_KeyValuePair::DictionaryValue_KeyValuePair(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : key_(nullptr)
  , value_(nullptr){}
struct DictionaryValue_KeyValuePairDefaultTypeInternal {
  constexpr DictionaryValue_KeyValuePairDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DictionaryValue_KeyValuePairDefaultTypeInternal() {}
  union {
    DictionaryValue_KeyValuePair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DictionaryValue_KeyValuePairDefaultTypeInternal _DictionaryValue_KeyValuePair_default_instance_;
constexpr DictionaryValue::DictionaryValue(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : values_(){}
struct DictionaryValueDefaultTypeInternal {
  constexpr DictionaryValueDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DictionaryValueDefaultTypeInternal() {}
  union {
    DictionaryValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DictionaryValueDefaultTypeInternal _DictionaryValue_default_instance_;
}  // namespace MILSpec
}  // namespace Specification
}  // namespace CoreML
namespace CoreML {
namespace Specification {
namespace MILSpec {
bool DataType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 10:
    case 11:
    case 12:
    case 13:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DataType_strings[23] = {};

static const char DataType_names[] =
  "BFLOAT16"
  "BOOL"
  "FLOAT16"
  "FLOAT32"
  "FLOAT64"
  "FLOAT8E4M3FN"
  "FLOAT8E5M2"
  "INT16"
  "INT32"
  "INT4"
  "INT64"
  "INT8"
  "STRING"
  "UINT1"
  "UINT16"
  "UINT2"
  "UINT3"
  "UINT32"
  "UINT4"
  "UINT6"
  "UINT64"
  "UINT8"
  "UNUSED_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DataType_entries[] = {
  { {DataType_names + 0, 8}, 13 },
  { {DataType_names + 8, 4}, 1 },
  { {DataType_names + 12, 7}, 10 },
  { {DataType_names + 19, 7}, 11 },
  { {DataType_names + 26, 7}, 12 },
  { {DataType_names + 33, 12}, 40 },
  { {DataType_names + 45, 10}, 41 },
  { {DataType_names + 55, 5}, 22 },
  { {DataType_names + 60, 5}, 23 },
  { {DataType_names + 65, 4}, 25 },
  { {DataType_names + 69, 5}, 24 },
  { {DataType_names + 74, 4}, 21 },
  { {DataType_names + 78, 6}, 2 },
  { {DataType_names + 84, 5}, 37 },
  { {DataType_names + 89, 6}, 32 },
  { {DataType_names + 95, 5}, 36 },
  { {DataType_names + 100, 5}, 39 },
  { {DataType_names + 105, 6}, 33 },
  { {DataType_names + 111, 5}, 35 },
  { {DataType_names + 116, 5}, 38 },
  { {DataType_names + 121, 6}, 34 },
  { {DataType_names + 127, 5}, 31 },
  { {DataType_names + 132, 11}, 0 },
};

static const int DataType_entries_by_number[] = {
  22, // 0 -> UNUSED_TYPE
  1, // 1 -> BOOL
  12, // 2 -> STRING
  2, // 10 -> FLOAT16
  3, // 11 -> FLOAT32
  4, // 12 -> FLOAT64
  0, // 13 -> BFLOAT16
  11, // 21 -> INT8
  7, // 22 -> INT16
  8, // 23 -> INT32
  10, // 24 -> INT64
  9, // 25 -> INT4
  21, // 31 -> UINT8
  14, // 32 -> UINT16
  17, // 33 -> UINT32
  20, // 34 -> UINT64
  18, // 35 -> UINT4
  15, // 36 -> UINT2
  13, // 37 -> UINT1
  19, // 38 -> UINT6
  16, // 39 -> UINT3
  5, // 40 -> FLOAT8E4M3FN
  6, // 41 -> FLOAT8E5M2
};

const std::string& DataType_Name(
    DataType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DataType_entries,
          DataType_entries_by_number,
          23, DataType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DataType_entries,
      DataType_entries_by_number,
      23, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DataType_strings[idx].get();
}
bool DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DataType_entries, 23, name, &int_value);
  if (success) {
    *value = static_cast<DataType>(int_value);
  }
  return success;
}

// ===================================================================

Program_FunctionsEntry_DoNotUse::Program_FunctionsEntry_DoNotUse() {}
Program_FunctionsEntry_DoNotUse::Program_FunctionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Program_FunctionsEntry_DoNotUse::MergeFrom(const Program_FunctionsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

Program_AttributesEntry_DoNotUse::Program_AttributesEntry_DoNotUse() {}
Program_AttributesEntry_DoNotUse::Program_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Program_AttributesEntry_DoNotUse::MergeFrom(const Program_AttributesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class Program::_Internal {
 public:
};

Program::Program(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  functions_(arena),
  attributes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.Program)
}
Program::Program(const Program& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  functions_.MergeFrom(from.functions_);
  attributes_.MergeFrom(from.attributes_);
  docstring_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    docstring_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_docstring().empty()) {
    docstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_docstring(), 
      GetArenaForAllocation());
  }
  version_ = from.version_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.Program)
}

inline void Program::SharedCtor() {
docstring_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  docstring_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
version_ = int64_t{0};
}

Program::~Program() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.Program)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Program::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  docstring_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Program::ArenaDtor(void* object) {
  Program* _this = reinterpret_cast< Program* >(object);
  (void)_this;
}
void Program::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Program::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Program::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.Program)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  functions_.Clear();
  attributes_.Clear();
  docstring_.ClearToEmpty();
  version_ = int64_t{0};
  _internal_metadata_.Clear<std::string>();
}

const char* Program::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .CoreML.Specification.MILSpec.Function> functions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&functions_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string docString = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_docstring();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&attributes_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Program::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.Program)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 version = 1;
  if (this->_internal_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_version(), target);
  }

  // map<string, .CoreML.Specification.MILSpec.Function> functions = 2;
  if (!this->_internal_functions().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Function >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.MILSpec.Program.FunctionsEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_functions().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_functions().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Function >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Function >::const_iterator
          it = this->_internal_functions().begin();
          it != this->_internal_functions().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = Program_FunctionsEntry_DoNotUse::Funcs::InternalSerialize(2, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Function >::const_iterator
          it = this->_internal_functions().begin();
          it != this->_internal_functions().end(); ++it) {
        target = Program_FunctionsEntry_DoNotUse::Funcs::InternalSerialize(2, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  // string docString = 3;
  if (!this->_internal_docstring().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_docstring().data(), static_cast<int>(this->_internal_docstring().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.MILSpec.Program.docString");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_docstring(), target);
  }

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
  if (!this->_internal_attributes().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.MILSpec.Program.AttributesEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_attributes().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_attributes().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_iterator
          it = this->_internal_attributes().begin();
          it != this->_internal_attributes().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = Program_AttributesEntry_DoNotUse::Funcs::InternalSerialize(4, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_iterator
          it = this->_internal_attributes().begin();
          it != this->_internal_attributes().end(); ++it) {
        target = Program_AttributesEntry_DoNotUse::Funcs::InternalSerialize(4, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.Program)
  return target;
}

size_t Program::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.Program)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .CoreML.Specification.MILSpec.Function> functions = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_functions_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Function >::const_iterator
      it = this->_internal_functions().begin();
      it != this->_internal_functions().end(); ++it) {
    total_size += Program_FunctionsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_attributes_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_iterator
      it = this->_internal_attributes().begin();
      it != this->_internal_attributes().end(); ++it) {
    total_size += Program_AttributesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string docString = 3;
  if (!this->_internal_docstring().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_docstring());
  }

  // int64 version = 1;
  if (this->_internal_version() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_version());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Program::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Program*>(
      &from));
}

void Program::MergeFrom(const Program& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.Program)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  functions_.MergeFrom(from.functions_);
  attributes_.MergeFrom(from.attributes_);
  if (!from._internal_docstring().empty()) {
    _internal_set_docstring(from._internal_docstring());
  }
  if (from._internal_version() != 0) {
    _internal_set_version(from._internal_version());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Program::CopyFrom(const Program& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.Program)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Program::IsInitialized() const {
  return true;
}

void Program::InternalSwap(Program* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  functions_.InternalSwap(&other->functions_);
  attributes_.InternalSwap(&other->attributes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &docstring_, lhs_arena,
      &other->docstring_, rhs_arena
  );
  swap(version_, other->version_);
}

std::string Program::GetTypeName() const {
  return "CoreML.Specification.MILSpec.Program";
}


// ===================================================================

Function_BlockSpecializationsEntry_DoNotUse::Function_BlockSpecializationsEntry_DoNotUse() {}
Function_BlockSpecializationsEntry_DoNotUse::Function_BlockSpecializationsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Function_BlockSpecializationsEntry_DoNotUse::MergeFrom(const Function_BlockSpecializationsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

Function_AttributesEntry_DoNotUse::Function_AttributesEntry_DoNotUse() {}
Function_AttributesEntry_DoNotUse::Function_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Function_AttributesEntry_DoNotUse::MergeFrom(const Function_AttributesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class Function::_Internal {
 public:
};

Function::Function(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  inputs_(arena),
  block_specializations_(arena),
  attributes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.Function)
}
Function::Function(const Function& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      inputs_(from.inputs_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  block_specializations_.MergeFrom(from.block_specializations_);
  attributes_.MergeFrom(from.attributes_);
  opset_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    opset_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_opset().empty()) {
    opset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_opset(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.Function)
}

inline void Function::SharedCtor() {
opset_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  opset_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Function::~Function() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.Function)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Function::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  opset_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Function::ArenaDtor(void* object) {
  Function* _this = reinterpret_cast< Function* >(object);
  (void)_this;
}
void Function::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Function::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Function::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.Function)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  inputs_.Clear();
  block_specializations_.Clear();
  attributes_.Clear();
  opset_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* Function::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.MILSpec.NamedValueType inputs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_inputs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string opset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_opset();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .CoreML.Specification.MILSpec.Block> block_specializations = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&block_specializations_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&attributes_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Function::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.Function)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.MILSpec.NamedValueType inputs = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_inputs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_inputs(i), target, stream);
  }

  // string opset = 2;
  if (!this->_internal_opset().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_opset().data(), static_cast<int>(this->_internal_opset().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.MILSpec.Function.opset");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_opset(), target);
  }

  // map<string, .CoreML.Specification.MILSpec.Block> block_specializations = 3;
  if (!this->_internal_block_specializations().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Block >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.MILSpec.Function.BlockSpecializationsEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_block_specializations().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_block_specializations().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Block >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Block >::const_iterator
          it = this->_internal_block_specializations().begin();
          it != this->_internal_block_specializations().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = Function_BlockSpecializationsEntry_DoNotUse::Funcs::InternalSerialize(3, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Block >::const_iterator
          it = this->_internal_block_specializations().begin();
          it != this->_internal_block_specializations().end(); ++it) {
        target = Function_BlockSpecializationsEntry_DoNotUse::Funcs::InternalSerialize(3, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
  if (!this->_internal_attributes().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.MILSpec.Function.AttributesEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_attributes().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_attributes().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_iterator
          it = this->_internal_attributes().begin();
          it != this->_internal_attributes().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = Function_AttributesEntry_DoNotUse::Funcs::InternalSerialize(4, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_iterator
          it = this->_internal_attributes().begin();
          it != this->_internal_attributes().end(); ++it) {
        target = Function_AttributesEntry_DoNotUse::Funcs::InternalSerialize(4, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.Function)
  return target;
}

size_t Function::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.Function)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.MILSpec.NamedValueType inputs = 1;
  total_size += 1UL * this->_internal_inputs_size();
  for (const auto& msg : this->inputs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, .CoreML.Specification.MILSpec.Block> block_specializations = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_block_specializations_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Block >::const_iterator
      it = this->_internal_block_specializations().begin();
      it != this->_internal_block_specializations().end(); ++it) {
    total_size += Function_BlockSpecializationsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_attributes_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_iterator
      it = this->_internal_attributes().begin();
      it != this->_internal_attributes().end(); ++it) {
    total_size += Function_AttributesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string opset = 2;
  if (!this->_internal_opset().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_opset());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Function::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Function*>(
      &from));
}

void Function::MergeFrom(const Function& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.Function)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  inputs_.MergeFrom(from.inputs_);
  block_specializations_.MergeFrom(from.block_specializations_);
  attributes_.MergeFrom(from.attributes_);
  if (!from._internal_opset().empty()) {
    _internal_set_opset(from._internal_opset());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Function::CopyFrom(const Function& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.Function)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Function::IsInitialized() const {
  return true;
}

void Function::InternalSwap(Function* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  inputs_.InternalSwap(&other->inputs_);
  block_specializations_.InternalSwap(&other->block_specializations_);
  attributes_.InternalSwap(&other->attributes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &opset_, lhs_arena,
      &other->opset_, rhs_arena
  );
}

std::string Function::GetTypeName() const {
  return "CoreML.Specification.MILSpec.Function";
}


// ===================================================================

Block_AttributesEntry_DoNotUse::Block_AttributesEntry_DoNotUse() {}
Block_AttributesEntry_DoNotUse::Block_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Block_AttributesEntry_DoNotUse::MergeFrom(const Block_AttributesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class Block::_Internal {
 public:
};

Block::Block(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  inputs_(arena),
  outputs_(arena),
  operations_(arena),
  attributes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.Block)
}
Block::Block(const Block& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      inputs_(from.inputs_),
      outputs_(from.outputs_),
      operations_(from.operations_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  attributes_.MergeFrom(from.attributes_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.Block)
}

inline void Block::SharedCtor() {
}

Block::~Block() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.Block)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Block::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Block::ArenaDtor(void* object) {
  Block* _this = reinterpret_cast< Block* >(object);
  (void)_this;
}
void Block::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Block::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Block::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.Block)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  inputs_.Clear();
  outputs_.Clear();
  operations_.Clear();
  attributes_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Block::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.MILSpec.NamedValueType inputs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_inputs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string outputs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_outputs();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.MILSpec.Operation operations = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_operations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&attributes_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Block::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.Block)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.MILSpec.NamedValueType inputs = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_inputs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_inputs(i), target, stream);
  }

  // repeated string outputs = 2;
  for (int i = 0, n = this->_internal_outputs_size(); i < n; i++) {
    const auto& s = this->_internal_outputs(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.MILSpec.Block.outputs");
    target = stream->WriteString(2, s, target);
  }

  // repeated .CoreML.Specification.MILSpec.Operation operations = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_operations_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_operations(i), target, stream);
  }

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
  if (!this->_internal_attributes().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.MILSpec.Block.AttributesEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_attributes().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_attributes().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_iterator
          it = this->_internal_attributes().begin();
          it != this->_internal_attributes().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = Block_AttributesEntry_DoNotUse::Funcs::InternalSerialize(4, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_iterator
          it = this->_internal_attributes().begin();
          it != this->_internal_attributes().end(); ++it) {
        target = Block_AttributesEntry_DoNotUse::Funcs::InternalSerialize(4, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.Block)
  return target;
}

size_t Block::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.Block)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.MILSpec.NamedValueType inputs = 1;
  total_size += 1UL * this->_internal_inputs_size();
  for (const auto& msg : this->inputs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string outputs = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(outputs_.size());
  for (int i = 0, n = outputs_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      outputs_.Get(i));
  }

  // repeated .CoreML.Specification.MILSpec.Operation operations = 3;
  total_size += 1UL * this->_internal_operations_size();
  for (const auto& msg : this->operations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_attributes_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_iterator
      it = this->_internal_attributes().begin();
      it != this->_internal_attributes().end(); ++it) {
    total_size += Block_AttributesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Block::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Block*>(
      &from));
}

void Block::MergeFrom(const Block& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.Block)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  inputs_.MergeFrom(from.inputs_);
  outputs_.MergeFrom(from.outputs_);
  operations_.MergeFrom(from.operations_);
  attributes_.MergeFrom(from.attributes_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Block::CopyFrom(const Block& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.Block)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Block::IsInitialized() const {
  return true;
}

void Block::InternalSwap(Block* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  inputs_.InternalSwap(&other->inputs_);
  outputs_.InternalSwap(&other->outputs_);
  operations_.InternalSwap(&other->operations_);
  attributes_.InternalSwap(&other->attributes_);
}

std::string Block::GetTypeName() const {
  return "CoreML.Specification.MILSpec.Block";
}


// ===================================================================

class Argument_Binding::_Internal {
 public:
  static const ::CoreML::Specification::MILSpec::Value& value(const Argument_Binding* msg);
};

const ::CoreML::Specification::MILSpec::Value&
Argument_Binding::_Internal::value(const Argument_Binding* msg) {
  return *msg->binding_.value_;
}
void Argument_Binding::set_allocated_value(::CoreML::Specification::MILSpec::Value* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_binding();
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::Value>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    set_has_value();
    binding_.value_ = value;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Argument.Binding.value)
}
Argument_Binding::Argument_Binding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.Argument.Binding)
}
Argument_Binding::Argument_Binding(const Argument_Binding& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_binding();
  switch (from.binding_case()) {
    case kName: {
      _internal_set_name(from._internal_name());
      break;
    }
    case kValue: {
      _internal_mutable_value()->::CoreML::Specification::MILSpec::Value::MergeFrom(from._internal_value());
      break;
    }
    case BINDING_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.Argument.Binding)
}

inline void Argument_Binding::SharedCtor() {
clear_has_binding();
}

Argument_Binding::~Argument_Binding() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.Argument.Binding)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Argument_Binding::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_binding()) {
    clear_binding();
  }
}

void Argument_Binding::ArenaDtor(void* object) {
  Argument_Binding* _this = reinterpret_cast< Argument_Binding* >(object);
  (void)_this;
}
void Argument_Binding::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Argument_Binding::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Argument_Binding::clear_binding() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.MILSpec.Argument.Binding)
  switch (binding_case()) {
    case kName: {
      binding_.name_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
      break;
    }
    case kValue: {
      if (GetArenaForAllocation() == nullptr) {
        delete binding_.value_;
      }
      break;
    }
    case BINDING_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = BINDING_NOT_SET;
}


void Argument_Binding::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.Argument.Binding)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_binding();
  _internal_metadata_.Clear<std::string>();
}

const char* Argument_Binding::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.Value value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Argument_Binding::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.Argument.Binding)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (_internal_has_name()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.MILSpec.Argument.Binding.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .CoreML.Specification.MILSpec.Value value = 2;
  if (_internal_has_value()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::value(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.Argument.Binding)
  return target;
}

size_t Argument_Binding::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.Argument.Binding)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (binding_case()) {
    // string name = 1;
    case kName: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
      break;
    }
    // .CoreML.Specification.MILSpec.Value value = 2;
    case kValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *binding_.value_);
      break;
    }
    case BINDING_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Argument_Binding::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Argument_Binding*>(
      &from));
}

void Argument_Binding::MergeFrom(const Argument_Binding& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.Argument.Binding)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.binding_case()) {
    case kName: {
      _internal_set_name(from._internal_name());
      break;
    }
    case kValue: {
      _internal_mutable_value()->::CoreML::Specification::MILSpec::Value::MergeFrom(from._internal_value());
      break;
    }
    case BINDING_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Argument_Binding::CopyFrom(const Argument_Binding& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.Argument.Binding)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Argument_Binding::IsInitialized() const {
  return true;
}

void Argument_Binding::InternalSwap(Argument_Binding* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(binding_, other->binding_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string Argument_Binding::GetTypeName() const {
  return "CoreML.Specification.MILSpec.Argument.Binding";
}


// ===================================================================

class Argument::_Internal {
 public:
};

Argument::Argument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  arguments_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.Argument)
}
Argument::Argument(const Argument& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      arguments_(from.arguments_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.Argument)
}

inline void Argument::SharedCtor() {
}

Argument::~Argument() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.Argument)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Argument::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Argument::ArenaDtor(void* object) {
  Argument* _this = reinterpret_cast< Argument* >(object);
  (void)_this;
}
void Argument::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Argument::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Argument::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.Argument)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  arguments_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Argument::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.MILSpec.Argument.Binding arguments = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_arguments(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Argument::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.Argument)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.MILSpec.Argument.Binding arguments = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_arguments_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_arguments(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.Argument)
  return target;
}

size_t Argument::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.Argument)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.MILSpec.Argument.Binding arguments = 1;
  total_size += 1UL * this->_internal_arguments_size();
  for (const auto& msg : this->arguments_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Argument::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Argument*>(
      &from));
}

void Argument::MergeFrom(const Argument& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.Argument)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  arguments_.MergeFrom(from.arguments_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Argument::CopyFrom(const Argument& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.Argument)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Argument::IsInitialized() const {
  return true;
}

void Argument::InternalSwap(Argument* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  arguments_.InternalSwap(&other->arguments_);
}

std::string Argument::GetTypeName() const {
  return "CoreML.Specification.MILSpec.Argument";
}


// ===================================================================

Operation_InputsEntry_DoNotUse::Operation_InputsEntry_DoNotUse() {}
Operation_InputsEntry_DoNotUse::Operation_InputsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Operation_InputsEntry_DoNotUse::MergeFrom(const Operation_InputsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

Operation_AttributesEntry_DoNotUse::Operation_AttributesEntry_DoNotUse() {}
Operation_AttributesEntry_DoNotUse::Operation_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Operation_AttributesEntry_DoNotUse::MergeFrom(const Operation_AttributesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class Operation::_Internal {
 public:
};

Operation::Operation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  inputs_(arena),
  outputs_(arena),
  blocks_(arena),
  attributes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.Operation)
}
Operation::Operation(const Operation& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      outputs_(from.outputs_),
      blocks_(from.blocks_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  inputs_.MergeFrom(from.inputs_);
  attributes_.MergeFrom(from.attributes_);
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_type(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.Operation)
}

inline void Operation::SharedCtor() {
type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Operation::~Operation() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.Operation)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Operation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Operation::ArenaDtor(void* object) {
  Operation* _this = reinterpret_cast< Operation* >(object);
  (void)_this;
}
void Operation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Operation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Operation::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.Operation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  inputs_.Clear();
  outputs_.Clear();
  blocks_.Clear();
  attributes_.Clear();
  type_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* Operation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .CoreML.Specification.MILSpec.Argument> inputs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&inputs_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.MILSpec.NamedValueType outputs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_outputs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.MILSpec.Block blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_blocks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, .CoreML.Specification.MILSpec.Value> attributes = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&attributes_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Operation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.Operation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type = 1;
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.MILSpec.Operation.type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type(), target);
  }

  // map<string, .CoreML.Specification.MILSpec.Argument> inputs = 2;
  if (!this->_internal_inputs().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Argument >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.MILSpec.Operation.InputsEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_inputs().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_inputs().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Argument >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Argument >::const_iterator
          it = this->_internal_inputs().begin();
          it != this->_internal_inputs().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = Operation_InputsEntry_DoNotUse::Funcs::InternalSerialize(2, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Argument >::const_iterator
          it = this->_internal_inputs().begin();
          it != this->_internal_inputs().end(); ++it) {
        target = Operation_InputsEntry_DoNotUse::Funcs::InternalSerialize(2, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  // repeated .CoreML.Specification.MILSpec.NamedValueType outputs = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_outputs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_outputs(i), target, stream);
  }

  // repeated .CoreML.Specification.MILSpec.Block blocks = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_blocks_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_blocks(i), target, stream);
  }

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 5;
  if (!this->_internal_attributes().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.MILSpec.Operation.AttributesEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_attributes().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_attributes().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_iterator
          it = this->_internal_attributes().begin();
          it != this->_internal_attributes().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = Operation_AttributesEntry_DoNotUse::Funcs::InternalSerialize(5, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_iterator
          it = this->_internal_attributes().begin();
          it != this->_internal_attributes().end(); ++it) {
        target = Operation_AttributesEntry_DoNotUse::Funcs::InternalSerialize(5, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.Operation)
  return target;
}

size_t Operation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.Operation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .CoreML.Specification.MILSpec.Argument> inputs = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_inputs_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Argument >::const_iterator
      it = this->_internal_inputs().begin();
      it != this->_internal_inputs().end(); ++it) {
    total_size += Operation_InputsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .CoreML.Specification.MILSpec.NamedValueType outputs = 3;
  total_size += 1UL * this->_internal_outputs_size();
  for (const auto& msg : this->outputs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CoreML.Specification.MILSpec.Block blocks = 4;
  total_size += 1UL * this->_internal_blocks_size();
  for (const auto& msg : this->blocks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_attributes_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_iterator
      it = this->_internal_attributes().begin();
      it != this->_internal_attributes().end(); ++it) {
    total_size += Operation_AttributesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string type = 1;
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Operation::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Operation*>(
      &from));
}

void Operation::MergeFrom(const Operation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.Operation)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  inputs_.MergeFrom(from.inputs_);
  outputs_.MergeFrom(from.outputs_);
  blocks_.MergeFrom(from.blocks_);
  attributes_.MergeFrom(from.attributes_);
  if (!from._internal_type().empty()) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Operation::CopyFrom(const Operation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.Operation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Operation::IsInitialized() const {
  return true;
}

void Operation::InternalSwap(Operation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  inputs_.InternalSwap(&other->inputs_);
  outputs_.InternalSwap(&other->outputs_);
  blocks_.InternalSwap(&other->blocks_);
  attributes_.InternalSwap(&other->attributes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &type_, lhs_arena,
      &other->type_, rhs_arena
  );
}

std::string Operation::GetTypeName() const {
  return "CoreML.Specification.MILSpec.Operation";
}


// ===================================================================

class NamedValueType::_Internal {
 public:
  static const ::CoreML::Specification::MILSpec::ValueType& type(const NamedValueType* msg);
};

const ::CoreML::Specification::MILSpec::ValueType&
NamedValueType::_Internal::type(const NamedValueType* msg) {
  return *msg->type_;
}
NamedValueType::NamedValueType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.NamedValueType)
}
NamedValueType::NamedValueType(const NamedValueType& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_type()) {
    type_ = new ::CoreML::Specification::MILSpec::ValueType(*from.type_);
  } else {
    type_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.NamedValueType)
}

inline void NamedValueType::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
type_ = nullptr;
}

NamedValueType::~NamedValueType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.NamedValueType)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void NamedValueType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete type_;
}

void NamedValueType::ArenaDtor(void* object) {
  NamedValueType* _this = reinterpret_cast< NamedValueType* >(object);
  (void)_this;
}
void NamedValueType::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NamedValueType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NamedValueType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.NamedValueType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && type_ != nullptr) {
    delete type_;
  }
  type_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* NamedValueType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.ValueType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamedValueType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.NamedValueType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.MILSpec.NamedValueType.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .CoreML.Specification.MILSpec.ValueType type = 2;
  if (this->_internal_has_type()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::type(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.NamedValueType)
  return target;
}

size_t NamedValueType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.NamedValueType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .CoreML.Specification.MILSpec.ValueType type = 2;
  if (this->_internal_has_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *type_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NamedValueType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const NamedValueType*>(
      &from));
}

void NamedValueType::MergeFrom(const NamedValueType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.NamedValueType)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_has_type()) {
    _internal_mutable_type()->::CoreML::Specification::MILSpec::ValueType::MergeFrom(from._internal_type());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NamedValueType::CopyFrom(const NamedValueType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.NamedValueType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedValueType::IsInitialized() const {
  return true;
}

void NamedValueType::InternalSwap(NamedValueType* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(type_, other->type_);
}

std::string NamedValueType::GetTypeName() const {
  return "CoreML.Specification.MILSpec.NamedValueType";
}


// ===================================================================

class ValueType::_Internal {
 public:
  static const ::CoreML::Specification::MILSpec::TensorType& tensortype(const ValueType* msg);
  static const ::CoreML::Specification::MILSpec::ListType& listtype(const ValueType* msg);
  static const ::CoreML::Specification::MILSpec::TupleType& tupletype(const ValueType* msg);
  static const ::CoreML::Specification::MILSpec::DictionaryType& dictionarytype(const ValueType* msg);
  static const ::CoreML::Specification::MILSpec::StateType& statetype(const ValueType* msg);
};

const ::CoreML::Specification::MILSpec::TensorType&
ValueType::_Internal::tensortype(const ValueType* msg) {
  return *msg->type_.tensortype_;
}
const ::CoreML::Specification::MILSpec::ListType&
ValueType::_Internal::listtype(const ValueType* msg) {
  return *msg->type_.listtype_;
}
const ::CoreML::Specification::MILSpec::TupleType&
ValueType::_Internal::tupletype(const ValueType* msg) {
  return *msg->type_.tupletype_;
}
const ::CoreML::Specification::MILSpec::DictionaryType&
ValueType::_Internal::dictionarytype(const ValueType* msg) {
  return *msg->type_.dictionarytype_;
}
const ::CoreML::Specification::MILSpec::StateType&
ValueType::_Internal::statetype(const ValueType* msg) {
  return *msg->type_.statetype_;
}
void ValueType::set_allocated_tensortype(::CoreML::Specification::MILSpec::TensorType* tensortype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (tensortype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::TensorType>::GetOwningArena(tensortype);
    if (message_arena != submessage_arena) {
      tensortype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tensortype, submessage_arena);
    }
    set_has_tensortype();
    type_.tensortype_ = tensortype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.ValueType.tensorType)
}
void ValueType::set_allocated_listtype(::CoreML::Specification::MILSpec::ListType* listtype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (listtype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::ListType>::GetOwningArena(listtype);
    if (message_arena != submessage_arena) {
      listtype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, listtype, submessage_arena);
    }
    set_has_listtype();
    type_.listtype_ = listtype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.ValueType.listType)
}
void ValueType::set_allocated_tupletype(::CoreML::Specification::MILSpec::TupleType* tupletype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (tupletype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::TupleType>::GetOwningArena(tupletype);
    if (message_arena != submessage_arena) {
      tupletype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tupletype, submessage_arena);
    }
    set_has_tupletype();
    type_.tupletype_ = tupletype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.ValueType.tupleType)
}
void ValueType::set_allocated_dictionarytype(::CoreML::Specification::MILSpec::DictionaryType* dictionarytype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (dictionarytype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::DictionaryType>::GetOwningArena(dictionarytype);
    if (message_arena != submessage_arena) {
      dictionarytype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dictionarytype, submessage_arena);
    }
    set_has_dictionarytype();
    type_.dictionarytype_ = dictionarytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.ValueType.dictionaryType)
}
void ValueType::set_allocated_statetype(::CoreML::Specification::MILSpec::StateType* statetype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (statetype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::StateType>::GetOwningArena(statetype);
    if (message_arena != submessage_arena) {
      statetype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statetype, submessage_arena);
    }
    set_has_statetype();
    type_.statetype_ = statetype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.ValueType.stateType)
}
ValueType::ValueType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.ValueType)
}
ValueType::ValueType(const ValueType& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_type();
  switch (from.type_case()) {
    case kTensorType: {
      _internal_mutable_tensortype()->::CoreML::Specification::MILSpec::TensorType::MergeFrom(from._internal_tensortype());
      break;
    }
    case kListType: {
      _internal_mutable_listtype()->::CoreML::Specification::MILSpec::ListType::MergeFrom(from._internal_listtype());
      break;
    }
    case kTupleType: {
      _internal_mutable_tupletype()->::CoreML::Specification::MILSpec::TupleType::MergeFrom(from._internal_tupletype());
      break;
    }
    case kDictionaryType: {
      _internal_mutable_dictionarytype()->::CoreML::Specification::MILSpec::DictionaryType::MergeFrom(from._internal_dictionarytype());
      break;
    }
    case kStateType: {
      _internal_mutable_statetype()->::CoreML::Specification::MILSpec::StateType::MergeFrom(from._internal_statetype());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.ValueType)
}

inline void ValueType::SharedCtor() {
clear_has_type();
}

ValueType::~ValueType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.ValueType)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ValueType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_type()) {
    clear_type();
  }
}

void ValueType::ArenaDtor(void* object) {
  ValueType* _this = reinterpret_cast< ValueType* >(object);
  (void)_this;
}
void ValueType::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ValueType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ValueType::clear_type() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.MILSpec.ValueType)
  switch (type_case()) {
    case kTensorType: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.tensortype_;
      }
      break;
    }
    case kListType: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.listtype_;
      }
      break;
    }
    case kTupleType: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.tupletype_;
      }
      break;
    }
    case kDictionaryType: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.dictionarytype_;
      }
      break;
    }
    case kStateType: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.statetype_;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TYPE_NOT_SET;
}


void ValueType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.ValueType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_type();
  _internal_metadata_.Clear<std::string>();
}

const char* ValueType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.MILSpec.TensorType tensorType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tensortype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.ListType listType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_listtype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.TupleType tupleType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tupletype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.DictionaryType dictionaryType = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_dictionarytype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.StateType stateType = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_statetype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ValueType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.ValueType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.MILSpec.TensorType tensorType = 1;
  if (_internal_has_tensortype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::tensortype(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.ListType listType = 2;
  if (_internal_has_listtype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::listtype(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.TupleType tupleType = 3;
  if (_internal_has_tupletype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::tupletype(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.DictionaryType dictionaryType = 4;
  if (_internal_has_dictionarytype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::dictionarytype(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.StateType stateType = 5;
  if (_internal_has_statetype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::statetype(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.ValueType)
  return target;
}

size_t ValueType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.ValueType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (type_case()) {
    // .CoreML.Specification.MILSpec.TensorType tensorType = 1;
    case kTensorType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.tensortype_);
      break;
    }
    // .CoreML.Specification.MILSpec.ListType listType = 2;
    case kListType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.listtype_);
      break;
    }
    // .CoreML.Specification.MILSpec.TupleType tupleType = 3;
    case kTupleType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.tupletype_);
      break;
    }
    // .CoreML.Specification.MILSpec.DictionaryType dictionaryType = 4;
    case kDictionaryType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.dictionarytype_);
      break;
    }
    // .CoreML.Specification.MILSpec.StateType stateType = 5;
    case kStateType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.statetype_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ValueType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ValueType*>(
      &from));
}

void ValueType::MergeFrom(const ValueType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.ValueType)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.type_case()) {
    case kTensorType: {
      _internal_mutable_tensortype()->::CoreML::Specification::MILSpec::TensorType::MergeFrom(from._internal_tensortype());
      break;
    }
    case kListType: {
      _internal_mutable_listtype()->::CoreML::Specification::MILSpec::ListType::MergeFrom(from._internal_listtype());
      break;
    }
    case kTupleType: {
      _internal_mutable_tupletype()->::CoreML::Specification::MILSpec::TupleType::MergeFrom(from._internal_tupletype());
      break;
    }
    case kDictionaryType: {
      _internal_mutable_dictionarytype()->::CoreML::Specification::MILSpec::DictionaryType::MergeFrom(from._internal_dictionarytype());
      break;
    }
    case kStateType: {
      _internal_mutable_statetype()->::CoreML::Specification::MILSpec::StateType::MergeFrom(from._internal_statetype());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ValueType::CopyFrom(const ValueType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.ValueType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ValueType::IsInitialized() const {
  return true;
}

void ValueType::InternalSwap(ValueType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(type_, other->type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ValueType::GetTypeName() const {
  return "CoreML.Specification.MILSpec.ValueType";
}


// ===================================================================

TensorType_AttributesEntry_DoNotUse::TensorType_AttributesEntry_DoNotUse() {}
TensorType_AttributesEntry_DoNotUse::TensorType_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void TensorType_AttributesEntry_DoNotUse::MergeFrom(const TensorType_AttributesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class TensorType::_Internal {
 public:
};

TensorType::TensorType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  dimensions_(arena),
  attributes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.TensorType)
}
TensorType::TensorType(const TensorType& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      dimensions_(from.dimensions_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  attributes_.MergeFrom(from.attributes_);
  ::memcpy(&rank_, &from.rank_,
    static_cast<size_t>(reinterpret_cast<char*>(&datatype_) -
    reinterpret_cast<char*>(&rank_)) + sizeof(datatype_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.TensorType)
}

inline void TensorType::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rank_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&datatype_) -
    reinterpret_cast<char*>(&rank_)) + sizeof(datatype_));
}

TensorType::~TensorType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.TensorType)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TensorType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TensorType::ArenaDtor(void* object) {
  TensorType* _this = reinterpret_cast< TensorType* >(object);
  (void)_this;
}
void TensorType::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TensorType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TensorType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.TensorType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dimensions_.Clear();
  attributes_.Clear();
  ::memset(&rank_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&datatype_) -
      reinterpret_cast<char*>(&rank_)) + sizeof(datatype_));
  _internal_metadata_.Clear<std::string>();
}

const char* TensorType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.MILSpec.DataType dataType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_datatype(static_cast<::CoreML::Specification::MILSpec::DataType>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 rank = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          rank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.MILSpec.Dimension dimensions = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_dimensions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&attributes_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TensorType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.TensorType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.MILSpec.DataType dataType = 1;
  if (this->_internal_datatype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_datatype(), target);
  }

  // int64 rank = 2;
  if (this->_internal_rank() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_rank(), target);
  }

  // repeated .CoreML.Specification.MILSpec.Dimension dimensions = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_dimensions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_dimensions(i), target, stream);
  }

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
  if (!this->_internal_attributes().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.MILSpec.TensorType.AttributesEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_attributes().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_attributes().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_iterator
          it = this->_internal_attributes().begin();
          it != this->_internal_attributes().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = TensorType_AttributesEntry_DoNotUse::Funcs::InternalSerialize(4, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_iterator
          it = this->_internal_attributes().begin();
          it != this->_internal_attributes().end(); ++it) {
        target = TensorType_AttributesEntry_DoNotUse::Funcs::InternalSerialize(4, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.TensorType)
  return target;
}

size_t TensorType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.TensorType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.MILSpec.Dimension dimensions = 3;
  total_size += 1UL * this->_internal_dimensions_size();
  for (const auto& msg : this->dimensions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_attributes_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::MILSpec::Value >::const_iterator
      it = this->_internal_attributes().begin();
      it != this->_internal_attributes().end(); ++it) {
    total_size += TensorType_AttributesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // int64 rank = 2;
  if (this->_internal_rank() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_rank());
  }

  // .CoreML.Specification.MILSpec.DataType dataType = 1;
  if (this->_internal_datatype() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_datatype());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TensorType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TensorType*>(
      &from));
}

void TensorType::MergeFrom(const TensorType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.TensorType)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  dimensions_.MergeFrom(from.dimensions_);
  attributes_.MergeFrom(from.attributes_);
  if (from._internal_rank() != 0) {
    _internal_set_rank(from._internal_rank());
  }
  if (from._internal_datatype() != 0) {
    _internal_set_datatype(from._internal_datatype());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TensorType::CopyFrom(const TensorType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.TensorType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TensorType::IsInitialized() const {
  return true;
}

void TensorType::InternalSwap(TensorType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  dimensions_.InternalSwap(&other->dimensions_);
  attributes_.InternalSwap(&other->attributes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TensorType, datatype_)
      + sizeof(TensorType::datatype_)
      - PROTOBUF_FIELD_OFFSET(TensorType, rank_)>(
          reinterpret_cast<char*>(&rank_),
          reinterpret_cast<char*>(&other->rank_));
}

std::string TensorType::GetTypeName() const {
  return "CoreML.Specification.MILSpec.TensorType";
}


// ===================================================================

class TupleType::_Internal {
 public:
};

TupleType::TupleType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  types_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.TupleType)
}
TupleType::TupleType(const TupleType& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      types_(from.types_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.TupleType)
}

inline void TupleType::SharedCtor() {
}

TupleType::~TupleType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.TupleType)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TupleType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TupleType::ArenaDtor(void* object) {
  TupleType* _this = reinterpret_cast< TupleType* >(object);
  (void)_this;
}
void TupleType::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TupleType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TupleType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.TupleType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  types_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TupleType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.MILSpec.ValueType types = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_types(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TupleType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.TupleType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.MILSpec.ValueType types = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_types_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_types(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.TupleType)
  return target;
}

size_t TupleType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.TupleType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.MILSpec.ValueType types = 1;
  total_size += 1UL * this->_internal_types_size();
  for (const auto& msg : this->types_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TupleType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TupleType*>(
      &from));
}

void TupleType::MergeFrom(const TupleType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.TupleType)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  types_.MergeFrom(from.types_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TupleType::CopyFrom(const TupleType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.TupleType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TupleType::IsInitialized() const {
  return true;
}

void TupleType::InternalSwap(TupleType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  types_.InternalSwap(&other->types_);
}

std::string TupleType::GetTypeName() const {
  return "CoreML.Specification.MILSpec.TupleType";
}


// ===================================================================

class ListType::_Internal {
 public:
  static const ::CoreML::Specification::MILSpec::ValueType& type(const ListType* msg);
  static const ::CoreML::Specification::MILSpec::Dimension& length(const ListType* msg);
};

const ::CoreML::Specification::MILSpec::ValueType&
ListType::_Internal::type(const ListType* msg) {
  return *msg->type_;
}
const ::CoreML::Specification::MILSpec::Dimension&
ListType::_Internal::length(const ListType* msg) {
  return *msg->length_;
}
ListType::ListType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.ListType)
}
ListType::ListType(const ListType& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_type()) {
    type_ = new ::CoreML::Specification::MILSpec::ValueType(*from.type_);
  } else {
    type_ = nullptr;
  }
  if (from._internal_has_length()) {
    length_ = new ::CoreML::Specification::MILSpec::Dimension(*from.length_);
  } else {
    length_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.ListType)
}

inline void ListType::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&type_)) + sizeof(length_));
}

ListType::~ListType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.ListType)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ListType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete type_;
  if (this != internal_default_instance()) delete length_;
}

void ListType::ArenaDtor(void* object) {
  ListType* _this = reinterpret_cast< ListType* >(object);
  (void)_this;
}
void ListType::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ListType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ListType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.ListType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && type_ != nullptr) {
    delete type_;
  }
  type_ = nullptr;
  if (GetArenaForAllocation() == nullptr && length_ != nullptr) {
    delete length_;
  }
  length_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* ListType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.MILSpec.ValueType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.Dimension length = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_length(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.ListType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.MILSpec.ValueType type = 1;
  if (this->_internal_has_type()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::type(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.Dimension length = 2;
  if (this->_internal_has_length()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::length(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.ListType)
  return target;
}

size_t ListType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.ListType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.MILSpec.ValueType type = 1;
  if (this->_internal_has_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *type_);
  }

  // .CoreML.Specification.MILSpec.Dimension length = 2;
  if (this->_internal_has_length()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *length_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ListType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ListType*>(
      &from));
}

void ListType::MergeFrom(const ListType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.ListType)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_type()) {
    _internal_mutable_type()->::CoreML::Specification::MILSpec::ValueType::MergeFrom(from._internal_type());
  }
  if (from._internal_has_length()) {
    _internal_mutable_length()->::CoreML::Specification::MILSpec::Dimension::MergeFrom(from._internal_length());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ListType::CopyFrom(const ListType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.ListType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListType::IsInitialized() const {
  return true;
}

void ListType::InternalSwap(ListType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ListType, length_)
      + sizeof(ListType::length_)
      - PROTOBUF_FIELD_OFFSET(ListType, type_)>(
          reinterpret_cast<char*>(&type_),
          reinterpret_cast<char*>(&other->type_));
}

std::string ListType::GetTypeName() const {
  return "CoreML.Specification.MILSpec.ListType";
}


// ===================================================================

class DictionaryType::_Internal {
 public:
  static const ::CoreML::Specification::MILSpec::ValueType& keytype(const DictionaryType* msg);
  static const ::CoreML::Specification::MILSpec::ValueType& valuetype(const DictionaryType* msg);
};

const ::CoreML::Specification::MILSpec::ValueType&
DictionaryType::_Internal::keytype(const DictionaryType* msg) {
  return *msg->keytype_;
}
const ::CoreML::Specification::MILSpec::ValueType&
DictionaryType::_Internal::valuetype(const DictionaryType* msg) {
  return *msg->valuetype_;
}
DictionaryType::DictionaryType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.DictionaryType)
}
DictionaryType::DictionaryType(const DictionaryType& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_keytype()) {
    keytype_ = new ::CoreML::Specification::MILSpec::ValueType(*from.keytype_);
  } else {
    keytype_ = nullptr;
  }
  if (from._internal_has_valuetype()) {
    valuetype_ = new ::CoreML::Specification::MILSpec::ValueType(*from.valuetype_);
  } else {
    valuetype_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.DictionaryType)
}

inline void DictionaryType::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&keytype_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&valuetype_) -
    reinterpret_cast<char*>(&keytype_)) + sizeof(valuetype_));
}

DictionaryType::~DictionaryType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.DictionaryType)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void DictionaryType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete keytype_;
  if (this != internal_default_instance()) delete valuetype_;
}

void DictionaryType::ArenaDtor(void* object) {
  DictionaryType* _this = reinterpret_cast< DictionaryType* >(object);
  (void)_this;
}
void DictionaryType::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DictionaryType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DictionaryType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.DictionaryType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && keytype_ != nullptr) {
    delete keytype_;
  }
  keytype_ = nullptr;
  if (GetArenaForAllocation() == nullptr && valuetype_ != nullptr) {
    delete valuetype_;
  }
  valuetype_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* DictionaryType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.MILSpec.ValueType keyType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_keytype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.ValueType valueType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_valuetype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DictionaryType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.DictionaryType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.MILSpec.ValueType keyType = 1;
  if (this->_internal_has_keytype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::keytype(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.ValueType valueType = 2;
  if (this->_internal_has_valuetype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::valuetype(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.DictionaryType)
  return target;
}

size_t DictionaryType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.DictionaryType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.MILSpec.ValueType keyType = 1;
  if (this->_internal_has_keytype()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *keytype_);
  }

  // .CoreML.Specification.MILSpec.ValueType valueType = 2;
  if (this->_internal_has_valuetype()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *valuetype_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DictionaryType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DictionaryType*>(
      &from));
}

void DictionaryType::MergeFrom(const DictionaryType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.DictionaryType)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_keytype()) {
    _internal_mutable_keytype()->::CoreML::Specification::MILSpec::ValueType::MergeFrom(from._internal_keytype());
  }
  if (from._internal_has_valuetype()) {
    _internal_mutable_valuetype()->::CoreML::Specification::MILSpec::ValueType::MergeFrom(from._internal_valuetype());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DictionaryType::CopyFrom(const DictionaryType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.DictionaryType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DictionaryType::IsInitialized() const {
  return true;
}

void DictionaryType::InternalSwap(DictionaryType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DictionaryType, valuetype_)
      + sizeof(DictionaryType::valuetype_)
      - PROTOBUF_FIELD_OFFSET(DictionaryType, keytype_)>(
          reinterpret_cast<char*>(&keytype_),
          reinterpret_cast<char*>(&other->keytype_));
}

std::string DictionaryType::GetTypeName() const {
  return "CoreML.Specification.MILSpec.DictionaryType";
}


// ===================================================================

class StateType::_Internal {
 public:
  static const ::CoreML::Specification::MILSpec::ValueType& wrappedtype(const StateType* msg);
};

const ::CoreML::Specification::MILSpec::ValueType&
StateType::_Internal::wrappedtype(const StateType* msg) {
  return *msg->wrappedtype_;
}
StateType::StateType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.StateType)
}
StateType::StateType(const StateType& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_wrappedtype()) {
    wrappedtype_ = new ::CoreML::Specification::MILSpec::ValueType(*from.wrappedtype_);
  } else {
    wrappedtype_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.StateType)
}

inline void StateType::SharedCtor() {
wrappedtype_ = nullptr;
}

StateType::~StateType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.StateType)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void StateType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete wrappedtype_;
}

void StateType::ArenaDtor(void* object) {
  StateType* _this = reinterpret_cast< StateType* >(object);
  (void)_this;
}
void StateType::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StateType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StateType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.StateType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && wrappedtype_ != nullptr) {
    delete wrappedtype_;
  }
  wrappedtype_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* StateType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.MILSpec.ValueType wrappedType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_wrappedtype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StateType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.StateType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.MILSpec.ValueType wrappedType = 1;
  if (this->_internal_has_wrappedtype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::wrappedtype(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.StateType)
  return target;
}

size_t StateType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.StateType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.MILSpec.ValueType wrappedType = 1;
  if (this->_internal_has_wrappedtype()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *wrappedtype_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StateType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StateType*>(
      &from));
}

void StateType::MergeFrom(const StateType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.StateType)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_wrappedtype()) {
    _internal_mutable_wrappedtype()->::CoreML::Specification::MILSpec::ValueType::MergeFrom(from._internal_wrappedtype());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StateType::CopyFrom(const StateType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.StateType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StateType::IsInitialized() const {
  return true;
}

void StateType::InternalSwap(StateType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(wrappedtype_, other->wrappedtype_);
}

std::string StateType::GetTypeName() const {
  return "CoreML.Specification.MILSpec.StateType";
}


// ===================================================================

class Dimension_ConstantDimension::_Internal {
 public:
};

Dimension_ConstantDimension::Dimension_ConstantDimension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.Dimension.ConstantDimension)
}
Dimension_ConstantDimension::Dimension_ConstantDimension(const Dimension_ConstantDimension& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  size_ = from.size_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.Dimension.ConstantDimension)
}

inline void Dimension_ConstantDimension::SharedCtor() {
size_ = uint64_t{0u};
}

Dimension_ConstantDimension::~Dimension_ConstantDimension() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.Dimension.ConstantDimension)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Dimension_ConstantDimension::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Dimension_ConstantDimension::ArenaDtor(void* object) {
  Dimension_ConstantDimension* _this = reinterpret_cast< Dimension_ConstantDimension* >(object);
  (void)_this;
}
void Dimension_ConstantDimension::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Dimension_ConstantDimension::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Dimension_ConstantDimension::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.Dimension.ConstantDimension)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  size_ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* Dimension_ConstantDimension::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Dimension_ConstantDimension::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.Dimension.ConstantDimension)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 size = 1;
  if (this->_internal_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.Dimension.ConstantDimension)
  return target;
}

size_t Dimension_ConstantDimension::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.Dimension.ConstantDimension)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 size = 1;
  if (this->_internal_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_size());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Dimension_ConstantDimension::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Dimension_ConstantDimension*>(
      &from));
}

void Dimension_ConstantDimension::MergeFrom(const Dimension_ConstantDimension& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.Dimension.ConstantDimension)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_size() != 0) {
    _internal_set_size(from._internal_size());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Dimension_ConstantDimension::CopyFrom(const Dimension_ConstantDimension& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.Dimension.ConstantDimension)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Dimension_ConstantDimension::IsInitialized() const {
  return true;
}

void Dimension_ConstantDimension::InternalSwap(Dimension_ConstantDimension* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(size_, other->size_);
}

std::string Dimension_ConstantDimension::GetTypeName() const {
  return "CoreML.Specification.MILSpec.Dimension.ConstantDimension";
}


// ===================================================================

class Dimension_UnknownDimension::_Internal {
 public:
};

Dimension_UnknownDimension::Dimension_UnknownDimension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.Dimension.UnknownDimension)
}
Dimension_UnknownDimension::Dimension_UnknownDimension(const Dimension_UnknownDimension& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  variadic_ = from.variadic_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.Dimension.UnknownDimension)
}

inline void Dimension_UnknownDimension::SharedCtor() {
variadic_ = false;
}

Dimension_UnknownDimension::~Dimension_UnknownDimension() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.Dimension.UnknownDimension)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Dimension_UnknownDimension::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Dimension_UnknownDimension::ArenaDtor(void* object) {
  Dimension_UnknownDimension* _this = reinterpret_cast< Dimension_UnknownDimension* >(object);
  (void)_this;
}
void Dimension_UnknownDimension::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Dimension_UnknownDimension::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Dimension_UnknownDimension::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.Dimension.UnknownDimension)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  variadic_ = false;
  _internal_metadata_.Clear<std::string>();
}

const char* Dimension_UnknownDimension::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool variadic = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          variadic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Dimension_UnknownDimension::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.Dimension.UnknownDimension)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool variadic = 1;
  if (this->_internal_variadic() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_variadic(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.Dimension.UnknownDimension)
  return target;
}

size_t Dimension_UnknownDimension::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.Dimension.UnknownDimension)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool variadic = 1;
  if (this->_internal_variadic() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Dimension_UnknownDimension::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Dimension_UnknownDimension*>(
      &from));
}

void Dimension_UnknownDimension::MergeFrom(const Dimension_UnknownDimension& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.Dimension.UnknownDimension)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_variadic() != 0) {
    _internal_set_variadic(from._internal_variadic());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Dimension_UnknownDimension::CopyFrom(const Dimension_UnknownDimension& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.Dimension.UnknownDimension)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Dimension_UnknownDimension::IsInitialized() const {
  return true;
}

void Dimension_UnknownDimension::InternalSwap(Dimension_UnknownDimension* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(variadic_, other->variadic_);
}

std::string Dimension_UnknownDimension::GetTypeName() const {
  return "CoreML.Specification.MILSpec.Dimension.UnknownDimension";
}


// ===================================================================

class Dimension::_Internal {
 public:
  static const ::CoreML::Specification::MILSpec::Dimension_ConstantDimension& constant(const Dimension* msg);
  static const ::CoreML::Specification::MILSpec::Dimension_UnknownDimension& unknown(const Dimension* msg);
};

const ::CoreML::Specification::MILSpec::Dimension_ConstantDimension&
Dimension::_Internal::constant(const Dimension* msg) {
  return *msg->dimension_.constant_;
}
const ::CoreML::Specification::MILSpec::Dimension_UnknownDimension&
Dimension::_Internal::unknown(const Dimension* msg) {
  return *msg->dimension_.unknown_;
}
void Dimension::set_allocated_constant(::CoreML::Specification::MILSpec::Dimension_ConstantDimension* constant) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dimension();
  if (constant) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::Dimension_ConstantDimension>::GetOwningArena(constant);
    if (message_arena != submessage_arena) {
      constant = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, constant, submessage_arena);
    }
    set_has_constant();
    dimension_.constant_ = constant;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Dimension.constant)
}
void Dimension::set_allocated_unknown(::CoreML::Specification::MILSpec::Dimension_UnknownDimension* unknown) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dimension();
  if (unknown) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::Dimension_UnknownDimension>::GetOwningArena(unknown);
    if (message_arena != submessage_arena) {
      unknown = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unknown, submessage_arena);
    }
    set_has_unknown();
    dimension_.unknown_ = unknown;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Dimension.unknown)
}
Dimension::Dimension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.Dimension)
}
Dimension::Dimension(const Dimension& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_dimension();
  switch (from.dimension_case()) {
    case kConstant: {
      _internal_mutable_constant()->::CoreML::Specification::MILSpec::Dimension_ConstantDimension::MergeFrom(from._internal_constant());
      break;
    }
    case kUnknown: {
      _internal_mutable_unknown()->::CoreML::Specification::MILSpec::Dimension_UnknownDimension::MergeFrom(from._internal_unknown());
      break;
    }
    case DIMENSION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.Dimension)
}

inline void Dimension::SharedCtor() {
clear_has_dimension();
}

Dimension::~Dimension() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.Dimension)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Dimension::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_dimension()) {
    clear_dimension();
  }
}

void Dimension::ArenaDtor(void* object) {
  Dimension* _this = reinterpret_cast< Dimension* >(object);
  (void)_this;
}
void Dimension::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Dimension::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Dimension::clear_dimension() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.MILSpec.Dimension)
  switch (dimension_case()) {
    case kConstant: {
      if (GetArenaForAllocation() == nullptr) {
        delete dimension_.constant_;
      }
      break;
    }
    case kUnknown: {
      if (GetArenaForAllocation() == nullptr) {
        delete dimension_.unknown_;
      }
      break;
    }
    case DIMENSION_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = DIMENSION_NOT_SET;
}


void Dimension::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.Dimension)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_dimension();
  _internal_metadata_.Clear<std::string>();
}

const char* Dimension::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.MILSpec.Dimension.ConstantDimension constant = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_constant(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.Dimension.UnknownDimension unknown = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_unknown(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Dimension::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.Dimension)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.MILSpec.Dimension.ConstantDimension constant = 1;
  if (_internal_has_constant()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::constant(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.Dimension.UnknownDimension unknown = 2;
  if (_internal_has_unknown()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::unknown(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.Dimension)
  return target;
}

size_t Dimension::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.Dimension)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (dimension_case()) {
    // .CoreML.Specification.MILSpec.Dimension.ConstantDimension constant = 1;
    case kConstant: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dimension_.constant_);
      break;
    }
    // .CoreML.Specification.MILSpec.Dimension.UnknownDimension unknown = 2;
    case kUnknown: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dimension_.unknown_);
      break;
    }
    case DIMENSION_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Dimension::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Dimension*>(
      &from));
}

void Dimension::MergeFrom(const Dimension& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.Dimension)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.dimension_case()) {
    case kConstant: {
      _internal_mutable_constant()->::CoreML::Specification::MILSpec::Dimension_ConstantDimension::MergeFrom(from._internal_constant());
      break;
    }
    case kUnknown: {
      _internal_mutable_unknown()->::CoreML::Specification::MILSpec::Dimension_UnknownDimension::MergeFrom(from._internal_unknown());
      break;
    }
    case DIMENSION_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Dimension::CopyFrom(const Dimension& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.Dimension)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Dimension::IsInitialized() const {
  return true;
}

void Dimension::InternalSwap(Dimension* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(dimension_, other->dimension_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string Dimension::GetTypeName() const {
  return "CoreML.Specification.MILSpec.Dimension";
}


// ===================================================================

class Value_ImmediateValue::_Internal {
 public:
  static const ::CoreML::Specification::MILSpec::TensorValue& tensor(const Value_ImmediateValue* msg);
  static const ::CoreML::Specification::MILSpec::TupleValue& tuple(const Value_ImmediateValue* msg);
  static const ::CoreML::Specification::MILSpec::ListValue& list(const Value_ImmediateValue* msg);
  static const ::CoreML::Specification::MILSpec::DictionaryValue& dictionary(const Value_ImmediateValue* msg);
};

const ::CoreML::Specification::MILSpec::TensorValue&
Value_ImmediateValue::_Internal::tensor(const Value_ImmediateValue* msg) {
  return *msg->value_.tensor_;
}
const ::CoreML::Specification::MILSpec::TupleValue&
Value_ImmediateValue::_Internal::tuple(const Value_ImmediateValue* msg) {
  return *msg->value_.tuple_;
}
const ::CoreML::Specification::MILSpec::ListValue&
Value_ImmediateValue::_Internal::list(const Value_ImmediateValue* msg) {
  return *msg->value_.list_;
}
const ::CoreML::Specification::MILSpec::DictionaryValue&
Value_ImmediateValue::_Internal::dictionary(const Value_ImmediateValue* msg) {
  return *msg->value_.dictionary_;
}
void Value_ImmediateValue::set_allocated_tensor(::CoreML::Specification::MILSpec::TensorValue* tensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (tensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::TensorValue>::GetOwningArena(tensor);
    if (message_arena != submessage_arena) {
      tensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tensor, submessage_arena);
    }
    set_has_tensor();
    value_.tensor_ = tensor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Value.ImmediateValue.tensor)
}
void Value_ImmediateValue::set_allocated_tuple(::CoreML::Specification::MILSpec::TupleValue* tuple) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (tuple) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::TupleValue>::GetOwningArena(tuple);
    if (message_arena != submessage_arena) {
      tuple = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tuple, submessage_arena);
    }
    set_has_tuple();
    value_.tuple_ = tuple;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Value.ImmediateValue.tuple)
}
void Value_ImmediateValue::set_allocated_list(::CoreML::Specification::MILSpec::ListValue* list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::ListValue>::GetOwningArena(list);
    if (message_arena != submessage_arena) {
      list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, list, submessage_arena);
    }
    set_has_list();
    value_.list_ = list;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Value.ImmediateValue.list)
}
void Value_ImmediateValue::set_allocated_dictionary(::CoreML::Specification::MILSpec::DictionaryValue* dictionary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (dictionary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::DictionaryValue>::GetOwningArena(dictionary);
    if (message_arena != submessage_arena) {
      dictionary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dictionary, submessage_arena);
    }
    set_has_dictionary();
    value_.dictionary_ = dictionary;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Value.ImmediateValue.dictionary)
}
Value_ImmediateValue::Value_ImmediateValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.Value.ImmediateValue)
}
Value_ImmediateValue::Value_ImmediateValue(const Value_ImmediateValue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_value();
  switch (from.value_case()) {
    case kTensor: {
      _internal_mutable_tensor()->::CoreML::Specification::MILSpec::TensorValue::MergeFrom(from._internal_tensor());
      break;
    }
    case kTuple: {
      _internal_mutable_tuple()->::CoreML::Specification::MILSpec::TupleValue::MergeFrom(from._internal_tuple());
      break;
    }
    case kList: {
      _internal_mutable_list()->::CoreML::Specification::MILSpec::ListValue::MergeFrom(from._internal_list());
      break;
    }
    case kDictionary: {
      _internal_mutable_dictionary()->::CoreML::Specification::MILSpec::DictionaryValue::MergeFrom(from._internal_dictionary());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.Value.ImmediateValue)
}

inline void Value_ImmediateValue::SharedCtor() {
clear_has_value();
}

Value_ImmediateValue::~Value_ImmediateValue() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.Value.ImmediateValue)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Value_ImmediateValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_value()) {
    clear_value();
  }
}

void Value_ImmediateValue::ArenaDtor(void* object) {
  Value_ImmediateValue* _this = reinterpret_cast< Value_ImmediateValue* >(object);
  (void)_this;
}
void Value_ImmediateValue::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Value_ImmediateValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Value_ImmediateValue::clear_value() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.MILSpec.Value.ImmediateValue)
  switch (value_case()) {
    case kTensor: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.tensor_;
      }
      break;
    }
    case kTuple: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.tuple_;
      }
      break;
    }
    case kList: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.list_;
      }
      break;
    }
    case kDictionary: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.dictionary_;
      }
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = VALUE_NOT_SET;
}


void Value_ImmediateValue::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.Value.ImmediateValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_value();
  _internal_metadata_.Clear<std::string>();
}

const char* Value_ImmediateValue::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.MILSpec.TensorValue tensor = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tensor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.TupleValue tuple = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tuple(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.ListValue list = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_list(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.DictionaryValue dictionary = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_dictionary(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Value_ImmediateValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.Value.ImmediateValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.MILSpec.TensorValue tensor = 1;
  if (_internal_has_tensor()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::tensor(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.TupleValue tuple = 2;
  if (_internal_has_tuple()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::tuple(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.ListValue list = 3;
  if (_internal_has_list()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::list(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.DictionaryValue dictionary = 4;
  if (_internal_has_dictionary()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::dictionary(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.Value.ImmediateValue)
  return target;
}

size_t Value_ImmediateValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.Value.ImmediateValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (value_case()) {
    // .CoreML.Specification.MILSpec.TensorValue tensor = 1;
    case kTensor: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.tensor_);
      break;
    }
    // .CoreML.Specification.MILSpec.TupleValue tuple = 2;
    case kTuple: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.tuple_);
      break;
    }
    // .CoreML.Specification.MILSpec.ListValue list = 3;
    case kList: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.list_);
      break;
    }
    // .CoreML.Specification.MILSpec.DictionaryValue dictionary = 4;
    case kDictionary: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.dictionary_);
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Value_ImmediateValue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Value_ImmediateValue*>(
      &from));
}

void Value_ImmediateValue::MergeFrom(const Value_ImmediateValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.Value.ImmediateValue)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.value_case()) {
    case kTensor: {
      _internal_mutable_tensor()->::CoreML::Specification::MILSpec::TensorValue::MergeFrom(from._internal_tensor());
      break;
    }
    case kTuple: {
      _internal_mutable_tuple()->::CoreML::Specification::MILSpec::TupleValue::MergeFrom(from._internal_tuple());
      break;
    }
    case kList: {
      _internal_mutable_list()->::CoreML::Specification::MILSpec::ListValue::MergeFrom(from._internal_list());
      break;
    }
    case kDictionary: {
      _internal_mutable_dictionary()->::CoreML::Specification::MILSpec::DictionaryValue::MergeFrom(from._internal_dictionary());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Value_ImmediateValue::CopyFrom(const Value_ImmediateValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.Value.ImmediateValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value_ImmediateValue::IsInitialized() const {
  return true;
}

void Value_ImmediateValue::InternalSwap(Value_ImmediateValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(value_, other->value_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string Value_ImmediateValue::GetTypeName() const {
  return "CoreML.Specification.MILSpec.Value.ImmediateValue";
}


// ===================================================================

class Value_BlobFileValue::_Internal {
 public:
};

Value_BlobFileValue::Value_BlobFileValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.Value.BlobFileValue)
}
Value_BlobFileValue::Value_BlobFileValue(const Value_BlobFileValue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_filename().empty()) {
    filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_filename(), 
      GetArenaForAllocation());
  }
  offset_ = from.offset_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.Value.BlobFileValue)
}

inline void Value_BlobFileValue::SharedCtor() {
filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
offset_ = uint64_t{0u};
}

Value_BlobFileValue::~Value_BlobFileValue() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.Value.BlobFileValue)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Value_BlobFileValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  filename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Value_BlobFileValue::ArenaDtor(void* object) {
  Value_BlobFileValue* _this = reinterpret_cast< Value_BlobFileValue* >(object);
  (void)_this;
}
void Value_BlobFileValue::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Value_BlobFileValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Value_BlobFileValue::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.Value.BlobFileValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  filename_.ClearToEmpty();
  offset_ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* Value_BlobFileValue::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string fileName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_filename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Value_BlobFileValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.Value.BlobFileValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string fileName = 1;
  if (!this->_internal_filename().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.MILSpec.Value.BlobFileValue.fileName");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_filename(), target);
  }

  // uint64 offset = 2;
  if (this->_internal_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.Value.BlobFileValue)
  return target;
}

size_t Value_BlobFileValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.Value.BlobFileValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string fileName = 1;
  if (!this->_internal_filename().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_filename());
  }

  // uint64 offset = 2;
  if (this->_internal_offset() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_offset());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Value_BlobFileValue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Value_BlobFileValue*>(
      &from));
}

void Value_BlobFileValue::MergeFrom(const Value_BlobFileValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.Value.BlobFileValue)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_filename().empty()) {
    _internal_set_filename(from._internal_filename());
  }
  if (from._internal_offset() != 0) {
    _internal_set_offset(from._internal_offset());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Value_BlobFileValue::CopyFrom(const Value_BlobFileValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.Value.BlobFileValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value_BlobFileValue::IsInitialized() const {
  return true;
}

void Value_BlobFileValue::InternalSwap(Value_BlobFileValue* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &filename_, lhs_arena,
      &other->filename_, rhs_arena
  );
  swap(offset_, other->offset_);
}

std::string Value_BlobFileValue::GetTypeName() const {
  return "CoreML.Specification.MILSpec.Value.BlobFileValue";
}


// ===================================================================

class Value::_Internal {
 public:
  static const ::CoreML::Specification::MILSpec::ValueType& type(const Value* msg);
  static const ::CoreML::Specification::MILSpec::Value_ImmediateValue& immediatevalue(const Value* msg);
  static const ::CoreML::Specification::MILSpec::Value_BlobFileValue& blobfilevalue(const Value* msg);
};

const ::CoreML::Specification::MILSpec::ValueType&
Value::_Internal::type(const Value* msg) {
  return *msg->type_;
}
const ::CoreML::Specification::MILSpec::Value_ImmediateValue&
Value::_Internal::immediatevalue(const Value* msg) {
  return *msg->value_.immediatevalue_;
}
const ::CoreML::Specification::MILSpec::Value_BlobFileValue&
Value::_Internal::blobfilevalue(const Value* msg) {
  return *msg->value_.blobfilevalue_;
}
void Value::set_allocated_immediatevalue(::CoreML::Specification::MILSpec::Value_ImmediateValue* immediatevalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (immediatevalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::Value_ImmediateValue>::GetOwningArena(immediatevalue);
    if (message_arena != submessage_arena) {
      immediatevalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, immediatevalue, submessage_arena);
    }
    set_has_immediatevalue();
    value_.immediatevalue_ = immediatevalue;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Value.immediateValue)
}
void Value::set_allocated_blobfilevalue(::CoreML::Specification::MILSpec::Value_BlobFileValue* blobfilevalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (blobfilevalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::Value_BlobFileValue>::GetOwningArena(blobfilevalue);
    if (message_arena != submessage_arena) {
      blobfilevalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blobfilevalue, submessage_arena);
    }
    set_has_blobfilevalue();
    value_.blobfilevalue_ = blobfilevalue;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Value.blobFileValue)
}
Value::Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.Value)
}
Value::Value(const Value& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  docstring_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    docstring_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_docstring().empty()) {
    docstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_docstring(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_type()) {
    type_ = new ::CoreML::Specification::MILSpec::ValueType(*from.type_);
  } else {
    type_ = nullptr;
  }
  clear_has_value();
  switch (from.value_case()) {
    case kImmediateValue: {
      _internal_mutable_immediatevalue()->::CoreML::Specification::MILSpec::Value_ImmediateValue::MergeFrom(from._internal_immediatevalue());
      break;
    }
    case kBlobFileValue: {
      _internal_mutable_blobfilevalue()->::CoreML::Specification::MILSpec::Value_BlobFileValue::MergeFrom(from._internal_blobfilevalue());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.Value)
}

inline void Value::SharedCtor() {
docstring_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  docstring_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
type_ = nullptr;
clear_has_value();
}

Value::~Value() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.Value)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Value::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  docstring_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete type_;
  if (has_value()) {
    clear_value();
  }
}

void Value::ArenaDtor(void* object) {
  Value* _this = reinterpret_cast< Value* >(object);
  (void)_this;
}
void Value::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Value::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Value::clear_value() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.MILSpec.Value)
  switch (value_case()) {
    case kImmediateValue: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.immediatevalue_;
      }
      break;
    }
    case kBlobFileValue: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.blobfilevalue_;
      }
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = VALUE_NOT_SET;
}


void Value::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.Value)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  docstring_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && type_ != nullptr) {
    delete type_;
  }
  type_ = nullptr;
  clear_value();
  _internal_metadata_.Clear<std::string>();
}

const char* Value::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string docString = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_docstring();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.ValueType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.Value.ImmediateValue immediateValue = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_immediatevalue(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.Value.BlobFileValue blobFileValue = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_blobfilevalue(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Value::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.Value)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string docString = 1;
  if (!this->_internal_docstring().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_docstring().data(), static_cast<int>(this->_internal_docstring().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.MILSpec.Value.docString");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_docstring(), target);
  }

  // .CoreML.Specification.MILSpec.ValueType type = 2;
  if (this->_internal_has_type()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::type(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.Value.ImmediateValue immediateValue = 3;
  if (_internal_has_immediatevalue()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::immediatevalue(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.Value.BlobFileValue blobFileValue = 5;
  if (_internal_has_blobfilevalue()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::blobfilevalue(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.Value)
  return target;
}

size_t Value::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.Value)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string docString = 1;
  if (!this->_internal_docstring().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_docstring());
  }

  // .CoreML.Specification.MILSpec.ValueType type = 2;
  if (this->_internal_has_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *type_);
  }

  switch (value_case()) {
    // .CoreML.Specification.MILSpec.Value.ImmediateValue immediateValue = 3;
    case kImmediateValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.immediatevalue_);
      break;
    }
    // .CoreML.Specification.MILSpec.Value.BlobFileValue blobFileValue = 5;
    case kBlobFileValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.blobfilevalue_);
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Value::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Value*>(
      &from));
}

void Value::MergeFrom(const Value& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.Value)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_docstring().empty()) {
    _internal_set_docstring(from._internal_docstring());
  }
  if (from._internal_has_type()) {
    _internal_mutable_type()->::CoreML::Specification::MILSpec::ValueType::MergeFrom(from._internal_type());
  }
  switch (from.value_case()) {
    case kImmediateValue: {
      _internal_mutable_immediatevalue()->::CoreML::Specification::MILSpec::Value_ImmediateValue::MergeFrom(from._internal_immediatevalue());
      break;
    }
    case kBlobFileValue: {
      _internal_mutable_blobfilevalue()->::CoreML::Specification::MILSpec::Value_BlobFileValue::MergeFrom(from._internal_blobfilevalue());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Value::CopyFrom(const Value& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.Value)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value::IsInitialized() const {
  return true;
}

void Value::InternalSwap(Value* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &docstring_, lhs_arena,
      &other->docstring_, rhs_arena
  );
  swap(type_, other->type_);
  swap(value_, other->value_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string Value::GetTypeName() const {
  return "CoreML.Specification.MILSpec.Value";
}


// ===================================================================

class TensorValue_RepeatedFloats::_Internal {
 public:
};

TensorValue_RepeatedFloats::TensorValue_RepeatedFloats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats)
}
TensorValue_RepeatedFloats::TensorValue_RepeatedFloats(const TensorValue_RepeatedFloats& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats)
}

inline void TensorValue_RepeatedFloats::SharedCtor() {
}

TensorValue_RepeatedFloats::~TensorValue_RepeatedFloats() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TensorValue_RepeatedFloats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TensorValue_RepeatedFloats::ArenaDtor(void* object) {
  TensorValue_RepeatedFloats* _this = reinterpret_cast< TensorValue_RepeatedFloats* >(object);
  (void)_this;
}
void TensorValue_RepeatedFloats::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TensorValue_RepeatedFloats::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TensorValue_RepeatedFloats::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TensorValue_RepeatedFloats::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float values = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_values(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 13) {
          _internal_add_values(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TensorValue_RepeatedFloats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float values = 1 [packed = true];
  if (this->_internal_values_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_values(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats)
  return target;
}

size_t TensorValue_RepeatedFloats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float values = 1 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_values_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TensorValue_RepeatedFloats::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TensorValue_RepeatedFloats*>(
      &from));
}

void TensorValue_RepeatedFloats::MergeFrom(const TensorValue_RepeatedFloats& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TensorValue_RepeatedFloats::CopyFrom(const TensorValue_RepeatedFloats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TensorValue_RepeatedFloats::IsInitialized() const {
  return true;
}

void TensorValue_RepeatedFloats::InternalSwap(TensorValue_RepeatedFloats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string TensorValue_RepeatedFloats::GetTypeName() const {
  return "CoreML.Specification.MILSpec.TensorValue.RepeatedFloats";
}


// ===================================================================

class TensorValue_RepeatedDoubles::_Internal {
 public:
};

TensorValue_RepeatedDoubles::TensorValue_RepeatedDoubles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles)
}
TensorValue_RepeatedDoubles::TensorValue_RepeatedDoubles(const TensorValue_RepeatedDoubles& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles)
}

inline void TensorValue_RepeatedDoubles::SharedCtor() {
}

TensorValue_RepeatedDoubles::~TensorValue_RepeatedDoubles() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TensorValue_RepeatedDoubles::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TensorValue_RepeatedDoubles::ArenaDtor(void* object) {
  TensorValue_RepeatedDoubles* _this = reinterpret_cast< TensorValue_RepeatedDoubles* >(object);
  (void)_this;
}
void TensorValue_RepeatedDoubles::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TensorValue_RepeatedDoubles::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TensorValue_RepeatedDoubles::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TensorValue_RepeatedDoubles::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated double values = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_values(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 9) {
          _internal_add_values(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TensorValue_RepeatedDoubles::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double values = 1 [packed = true];
  if (this->_internal_values_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_values(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles)
  return target;
}

size_t TensorValue_RepeatedDoubles::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double values = 1 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_values_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TensorValue_RepeatedDoubles::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TensorValue_RepeatedDoubles*>(
      &from));
}

void TensorValue_RepeatedDoubles::MergeFrom(const TensorValue_RepeatedDoubles& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TensorValue_RepeatedDoubles::CopyFrom(const TensorValue_RepeatedDoubles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TensorValue_RepeatedDoubles::IsInitialized() const {
  return true;
}

void TensorValue_RepeatedDoubles::InternalSwap(TensorValue_RepeatedDoubles* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string TensorValue_RepeatedDoubles::GetTypeName() const {
  return "CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles";
}


// ===================================================================

class TensorValue_RepeatedInts::_Internal {
 public:
};

TensorValue_RepeatedInts::TensorValue_RepeatedInts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.TensorValue.RepeatedInts)
}
TensorValue_RepeatedInts::TensorValue_RepeatedInts(const TensorValue_RepeatedInts& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.TensorValue.RepeatedInts)
}

inline void TensorValue_RepeatedInts::SharedCtor() {
}

TensorValue_RepeatedInts::~TensorValue_RepeatedInts() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.TensorValue.RepeatedInts)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TensorValue_RepeatedInts::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TensorValue_RepeatedInts::ArenaDtor(void* object) {
  TensorValue_RepeatedInts* _this = reinterpret_cast< TensorValue_RepeatedInts* >(object);
  (void)_this;
}
void TensorValue_RepeatedInts::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TensorValue_RepeatedInts::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TensorValue_RepeatedInts::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.TensorValue.RepeatedInts)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TensorValue_RepeatedInts::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 values = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_values(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_values(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TensorValue_RepeatedInts::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.TensorValue.RepeatedInts)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 values = 1 [packed = true];
  {
    int byte_size = _values_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_values(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.TensorValue.RepeatedInts)
  return target;
}

size_t TensorValue_RepeatedInts::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.TensorValue.RepeatedInts)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 values = 1 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->values_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _values_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TensorValue_RepeatedInts::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TensorValue_RepeatedInts*>(
      &from));
}

void TensorValue_RepeatedInts::MergeFrom(const TensorValue_RepeatedInts& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.TensorValue.RepeatedInts)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TensorValue_RepeatedInts::CopyFrom(const TensorValue_RepeatedInts& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.TensorValue.RepeatedInts)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TensorValue_RepeatedInts::IsInitialized() const {
  return true;
}

void TensorValue_RepeatedInts::InternalSwap(TensorValue_RepeatedInts* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string TensorValue_RepeatedInts::GetTypeName() const {
  return "CoreML.Specification.MILSpec.TensorValue.RepeatedInts";
}


// ===================================================================

class TensorValue_RepeatedLongInts::_Internal {
 public:
};

TensorValue_RepeatedLongInts::TensorValue_RepeatedLongInts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts)
}
TensorValue_RepeatedLongInts::TensorValue_RepeatedLongInts(const TensorValue_RepeatedLongInts& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts)
}

inline void TensorValue_RepeatedLongInts::SharedCtor() {
}

TensorValue_RepeatedLongInts::~TensorValue_RepeatedLongInts() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TensorValue_RepeatedLongInts::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TensorValue_RepeatedLongInts::ArenaDtor(void* object) {
  TensorValue_RepeatedLongInts* _this = reinterpret_cast< TensorValue_RepeatedLongInts* >(object);
  (void)_this;
}
void TensorValue_RepeatedLongInts::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TensorValue_RepeatedLongInts::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TensorValue_RepeatedLongInts::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TensorValue_RepeatedLongInts::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 values = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_values(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_values(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TensorValue_RepeatedLongInts::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 values = 1 [packed = true];
  {
    int byte_size = _values_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_values(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts)
  return target;
}

size_t TensorValue_RepeatedLongInts::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 values = 1 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->values_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _values_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TensorValue_RepeatedLongInts::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TensorValue_RepeatedLongInts*>(
      &from));
}

void TensorValue_RepeatedLongInts::MergeFrom(const TensorValue_RepeatedLongInts& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TensorValue_RepeatedLongInts::CopyFrom(const TensorValue_RepeatedLongInts& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TensorValue_RepeatedLongInts::IsInitialized() const {
  return true;
}

void TensorValue_RepeatedLongInts::InternalSwap(TensorValue_RepeatedLongInts* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string TensorValue_RepeatedLongInts::GetTypeName() const {
  return "CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts";
}


// ===================================================================

class TensorValue_RepeatedBools::_Internal {
 public:
};

TensorValue_RepeatedBools::TensorValue_RepeatedBools(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.TensorValue.RepeatedBools)
}
TensorValue_RepeatedBools::TensorValue_RepeatedBools(const TensorValue_RepeatedBools& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.TensorValue.RepeatedBools)
}

inline void TensorValue_RepeatedBools::SharedCtor() {
}

TensorValue_RepeatedBools::~TensorValue_RepeatedBools() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.TensorValue.RepeatedBools)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TensorValue_RepeatedBools::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TensorValue_RepeatedBools::ArenaDtor(void* object) {
  TensorValue_RepeatedBools* _this = reinterpret_cast< TensorValue_RepeatedBools* >(object);
  (void)_this;
}
void TensorValue_RepeatedBools::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TensorValue_RepeatedBools::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TensorValue_RepeatedBools::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.TensorValue.RepeatedBools)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TensorValue_RepeatedBools::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bool values = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_values(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_values(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TensorValue_RepeatedBools::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.TensorValue.RepeatedBools)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bool values = 1 [packed = true];
  if (this->_internal_values_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_values(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.TensorValue.RepeatedBools)
  return target;
}

size_t TensorValue_RepeatedBools::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.TensorValue.RepeatedBools)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bool values = 1 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_values_size());
    size_t data_size = 1UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TensorValue_RepeatedBools::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TensorValue_RepeatedBools*>(
      &from));
}

void TensorValue_RepeatedBools::MergeFrom(const TensorValue_RepeatedBools& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.TensorValue.RepeatedBools)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TensorValue_RepeatedBools::CopyFrom(const TensorValue_RepeatedBools& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.TensorValue.RepeatedBools)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TensorValue_RepeatedBools::IsInitialized() const {
  return true;
}

void TensorValue_RepeatedBools::InternalSwap(TensorValue_RepeatedBools* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string TensorValue_RepeatedBools::GetTypeName() const {
  return "CoreML.Specification.MILSpec.TensorValue.RepeatedBools";
}


// ===================================================================

class TensorValue_RepeatedStrings::_Internal {
 public:
};

TensorValue_RepeatedStrings::TensorValue_RepeatedStrings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings)
}
TensorValue_RepeatedStrings::TensorValue_RepeatedStrings(const TensorValue_RepeatedStrings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings)
}

inline void TensorValue_RepeatedStrings::SharedCtor() {
}

TensorValue_RepeatedStrings::~TensorValue_RepeatedStrings() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TensorValue_RepeatedStrings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TensorValue_RepeatedStrings::ArenaDtor(void* object) {
  TensorValue_RepeatedStrings* _this = reinterpret_cast< TensorValue_RepeatedStrings* >(object);
  (void)_this;
}
void TensorValue_RepeatedStrings::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TensorValue_RepeatedStrings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TensorValue_RepeatedStrings::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TensorValue_RepeatedStrings::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_values();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TensorValue_RepeatedStrings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string values = 1;
  for (int i = 0, n = this->_internal_values_size(); i < n; i++) {
    const auto& s = this->_internal_values(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings)
  return target;
}

size_t TensorValue_RepeatedStrings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string values = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(values_.size());
  for (int i = 0, n = values_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      values_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TensorValue_RepeatedStrings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TensorValue_RepeatedStrings*>(
      &from));
}

void TensorValue_RepeatedStrings::MergeFrom(const TensorValue_RepeatedStrings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TensorValue_RepeatedStrings::CopyFrom(const TensorValue_RepeatedStrings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TensorValue_RepeatedStrings::IsInitialized() const {
  return true;
}

void TensorValue_RepeatedStrings::InternalSwap(TensorValue_RepeatedStrings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string TensorValue_RepeatedStrings::GetTypeName() const {
  return "CoreML.Specification.MILSpec.TensorValue.RepeatedStrings";
}


// ===================================================================

class TensorValue_RepeatedBytes::_Internal {
 public:
};

TensorValue_RepeatedBytes::TensorValue_RepeatedBytes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes)
}
TensorValue_RepeatedBytes::TensorValue_RepeatedBytes(const TensorValue_RepeatedBytes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  values_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    values_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_values().empty()) {
    values_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_values(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes)
}

inline void TensorValue_RepeatedBytes::SharedCtor() {
values_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  values_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TensorValue_RepeatedBytes::~TensorValue_RepeatedBytes() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TensorValue_RepeatedBytes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  values_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TensorValue_RepeatedBytes::ArenaDtor(void* object) {
  TensorValue_RepeatedBytes* _this = reinterpret_cast< TensorValue_RepeatedBytes* >(object);
  (void)_this;
}
void TensorValue_RepeatedBytes::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TensorValue_RepeatedBytes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TensorValue_RepeatedBytes::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* TensorValue_RepeatedBytes::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_values();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TensorValue_RepeatedBytes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes values = 1;
  if (!this->_internal_values().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_values(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes)
  return target;
}

size_t TensorValue_RepeatedBytes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes values = 1;
  if (!this->_internal_values().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_values());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TensorValue_RepeatedBytes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TensorValue_RepeatedBytes*>(
      &from));
}

void TensorValue_RepeatedBytes::MergeFrom(const TensorValue_RepeatedBytes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_values().empty()) {
    _internal_set_values(from._internal_values());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TensorValue_RepeatedBytes::CopyFrom(const TensorValue_RepeatedBytes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TensorValue_RepeatedBytes::IsInitialized() const {
  return true;
}

void TensorValue_RepeatedBytes::InternalSwap(TensorValue_RepeatedBytes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &values_, lhs_arena,
      &other->values_, rhs_arena
  );
}

std::string TensorValue_RepeatedBytes::GetTypeName() const {
  return "CoreML.Specification.MILSpec.TensorValue.RepeatedBytes";
}


// ===================================================================

class TensorValue::_Internal {
 public:
  static const ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats& floats(const TensorValue* msg);
  static const ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts& ints(const TensorValue* msg);
  static const ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools& bools(const TensorValue* msg);
  static const ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings& strings(const TensorValue* msg);
  static const ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts& longints(const TensorValue* msg);
  static const ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles& doubles(const TensorValue* msg);
  static const ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes& bytes(const TensorValue* msg);
};

const ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats&
TensorValue::_Internal::floats(const TensorValue* msg) {
  return *msg->value_.floats_;
}
const ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts&
TensorValue::_Internal::ints(const TensorValue* msg) {
  return *msg->value_.ints_;
}
const ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools&
TensorValue::_Internal::bools(const TensorValue* msg) {
  return *msg->value_.bools_;
}
const ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings&
TensorValue::_Internal::strings(const TensorValue* msg) {
  return *msg->value_.strings_;
}
const ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts&
TensorValue::_Internal::longints(const TensorValue* msg) {
  return *msg->value_.longints_;
}
const ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles&
TensorValue::_Internal::doubles(const TensorValue* msg) {
  return *msg->value_.doubles_;
}
const ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes&
TensorValue::_Internal::bytes(const TensorValue* msg) {
  return *msg->value_.bytes_;
}
void TensorValue::set_allocated_floats(::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* floats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (floats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats>::GetOwningArena(floats);
    if (message_arena != submessage_arena) {
      floats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, floats, submessage_arena);
    }
    set_has_floats();
    value_.floats_ = floats;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.TensorValue.floats)
}
void TensorValue::set_allocated_ints(::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* ints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (ints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::TensorValue_RepeatedInts>::GetOwningArena(ints);
    if (message_arena != submessage_arena) {
      ints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ints, submessage_arena);
    }
    set_has_ints();
    value_.ints_ = ints;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.TensorValue.ints)
}
void TensorValue::set_allocated_bools(::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* bools) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (bools) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::TensorValue_RepeatedBools>::GetOwningArena(bools);
    if (message_arena != submessage_arena) {
      bools = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bools, submessage_arena);
    }
    set_has_bools();
    value_.bools_ = bools;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.TensorValue.bools)
}
void TensorValue::set_allocated_strings(::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* strings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (strings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings>::GetOwningArena(strings);
    if (message_arena != submessage_arena) {
      strings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, strings, submessage_arena);
    }
    set_has_strings();
    value_.strings_ = strings;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.TensorValue.strings)
}
void TensorValue::set_allocated_longints(::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* longints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (longints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts>::GetOwningArena(longints);
    if (message_arena != submessage_arena) {
      longints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, longints, submessage_arena);
    }
    set_has_longints();
    value_.longints_ = longints;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.TensorValue.longInts)
}
void TensorValue::set_allocated_doubles(::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* doubles) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (doubles) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles>::GetOwningArena(doubles);
    if (message_arena != submessage_arena) {
      doubles = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, doubles, submessage_arena);
    }
    set_has_doubles();
    value_.doubles_ = doubles;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.TensorValue.doubles)
}
void TensorValue::set_allocated_bytes(::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* bytes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (bytes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes>::GetOwningArena(bytes);
    if (message_arena != submessage_arena) {
      bytes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bytes, submessage_arena);
    }
    set_has_bytes();
    value_.bytes_ = bytes;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.TensorValue.bytes)
}
TensorValue::TensorValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.TensorValue)
}
TensorValue::TensorValue(const TensorValue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_value();
  switch (from.value_case()) {
    case kFloats: {
      _internal_mutable_floats()->::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats::MergeFrom(from._internal_floats());
      break;
    }
    case kInts: {
      _internal_mutable_ints()->::CoreML::Specification::MILSpec::TensorValue_RepeatedInts::MergeFrom(from._internal_ints());
      break;
    }
    case kBools: {
      _internal_mutable_bools()->::CoreML::Specification::MILSpec::TensorValue_RepeatedBools::MergeFrom(from._internal_bools());
      break;
    }
    case kStrings: {
      _internal_mutable_strings()->::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings::MergeFrom(from._internal_strings());
      break;
    }
    case kLongInts: {
      _internal_mutable_longints()->::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts::MergeFrom(from._internal_longints());
      break;
    }
    case kDoubles: {
      _internal_mutable_doubles()->::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles::MergeFrom(from._internal_doubles());
      break;
    }
    case kBytes: {
      _internal_mutable_bytes()->::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes::MergeFrom(from._internal_bytes());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.TensorValue)
}

inline void TensorValue::SharedCtor() {
clear_has_value();
}

TensorValue::~TensorValue() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.TensorValue)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TensorValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_value()) {
    clear_value();
  }
}

void TensorValue::ArenaDtor(void* object) {
  TensorValue* _this = reinterpret_cast< TensorValue* >(object);
  (void)_this;
}
void TensorValue::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TensorValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TensorValue::clear_value() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.MILSpec.TensorValue)
  switch (value_case()) {
    case kFloats: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.floats_;
      }
      break;
    }
    case kInts: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.ints_;
      }
      break;
    }
    case kBools: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.bools_;
      }
      break;
    }
    case kStrings: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.strings_;
      }
      break;
    }
    case kLongInts: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.longints_;
      }
      break;
    }
    case kDoubles: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.doubles_;
      }
      break;
    }
    case kBytes: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.bytes_;
      }
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = VALUE_NOT_SET;
}


void TensorValue::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.TensorValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_value();
  _internal_metadata_.Clear<std::string>();
}

const char* TensorValue::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.MILSpec.TensorValue.RepeatedFloats floats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_floats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.TensorValue.RepeatedInts ints = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ints(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.TensorValue.RepeatedBools bools = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_bools(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.TensorValue.RepeatedStrings strings = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_strings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts longInts = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_longints(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles doubles = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_doubles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.TensorValue.RepeatedBytes bytes = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_bytes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TensorValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.TensorValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedFloats floats = 1;
  if (_internal_has_floats()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::floats(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedInts ints = 2;
  if (_internal_has_ints()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::ints(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedBools bools = 3;
  if (_internal_has_bools()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::bools(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedStrings strings = 4;
  if (_internal_has_strings()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::strings(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts longInts = 5;
  if (_internal_has_longints()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::longints(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles doubles = 6;
  if (_internal_has_doubles()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::doubles(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedBytes bytes = 7;
  if (_internal_has_bytes()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::bytes(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.TensorValue)
  return target;
}

size_t TensorValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.TensorValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (value_case()) {
    // .CoreML.Specification.MILSpec.TensorValue.RepeatedFloats floats = 1;
    case kFloats: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.floats_);
      break;
    }
    // .CoreML.Specification.MILSpec.TensorValue.RepeatedInts ints = 2;
    case kInts: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.ints_);
      break;
    }
    // .CoreML.Specification.MILSpec.TensorValue.RepeatedBools bools = 3;
    case kBools: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.bools_);
      break;
    }
    // .CoreML.Specification.MILSpec.TensorValue.RepeatedStrings strings = 4;
    case kStrings: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.strings_);
      break;
    }
    // .CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts longInts = 5;
    case kLongInts: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.longints_);
      break;
    }
    // .CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles doubles = 6;
    case kDoubles: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.doubles_);
      break;
    }
    // .CoreML.Specification.MILSpec.TensorValue.RepeatedBytes bytes = 7;
    case kBytes: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.bytes_);
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TensorValue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TensorValue*>(
      &from));
}

void TensorValue::MergeFrom(const TensorValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.TensorValue)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.value_case()) {
    case kFloats: {
      _internal_mutable_floats()->::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats::MergeFrom(from._internal_floats());
      break;
    }
    case kInts: {
      _internal_mutable_ints()->::CoreML::Specification::MILSpec::TensorValue_RepeatedInts::MergeFrom(from._internal_ints());
      break;
    }
    case kBools: {
      _internal_mutable_bools()->::CoreML::Specification::MILSpec::TensorValue_RepeatedBools::MergeFrom(from._internal_bools());
      break;
    }
    case kStrings: {
      _internal_mutable_strings()->::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings::MergeFrom(from._internal_strings());
      break;
    }
    case kLongInts: {
      _internal_mutable_longints()->::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts::MergeFrom(from._internal_longints());
      break;
    }
    case kDoubles: {
      _internal_mutable_doubles()->::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles::MergeFrom(from._internal_doubles());
      break;
    }
    case kBytes: {
      _internal_mutable_bytes()->::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes::MergeFrom(from._internal_bytes());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TensorValue::CopyFrom(const TensorValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.TensorValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TensorValue::IsInitialized() const {
  return true;
}

void TensorValue::InternalSwap(TensorValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(value_, other->value_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string TensorValue::GetTypeName() const {
  return "CoreML.Specification.MILSpec.TensorValue";
}


// ===================================================================

class TupleValue::_Internal {
 public:
};

TupleValue::TupleValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.TupleValue)
}
TupleValue::TupleValue(const TupleValue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.TupleValue)
}

inline void TupleValue::SharedCtor() {
}

TupleValue::~TupleValue() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.TupleValue)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TupleValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TupleValue::ArenaDtor(void* object) {
  TupleValue* _this = reinterpret_cast< TupleValue* >(object);
  (void)_this;
}
void TupleValue::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TupleValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TupleValue::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.TupleValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TupleValue::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.MILSpec.Value values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TupleValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.TupleValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.MILSpec.Value values = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_values_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_values(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.TupleValue)
  return target;
}

size_t TupleValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.TupleValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.MILSpec.Value values = 1;
  total_size += 1UL * this->_internal_values_size();
  for (const auto& msg : this->values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TupleValue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TupleValue*>(
      &from));
}

void TupleValue::MergeFrom(const TupleValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.TupleValue)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TupleValue::CopyFrom(const TupleValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.TupleValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TupleValue::IsInitialized() const {
  return true;
}

void TupleValue::InternalSwap(TupleValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string TupleValue::GetTypeName() const {
  return "CoreML.Specification.MILSpec.TupleValue";
}


// ===================================================================

class ListValue::_Internal {
 public:
};

ListValue::ListValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.ListValue)
}
ListValue::ListValue(const ListValue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.ListValue)
}

inline void ListValue::SharedCtor() {
}

ListValue::~ListValue() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.ListValue)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ListValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ListValue::ArenaDtor(void* object) {
  ListValue* _this = reinterpret_cast< ListValue* >(object);
  (void)_this;
}
void ListValue::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ListValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ListValue::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.ListValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ListValue::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.MILSpec.Value values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.ListValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.MILSpec.Value values = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_values_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_values(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.ListValue)
  return target;
}

size_t ListValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.ListValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.MILSpec.Value values = 1;
  total_size += 1UL * this->_internal_values_size();
  for (const auto& msg : this->values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ListValue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ListValue*>(
      &from));
}

void ListValue::MergeFrom(const ListValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.ListValue)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ListValue::CopyFrom(const ListValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.ListValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListValue::IsInitialized() const {
  return true;
}

void ListValue::InternalSwap(ListValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string ListValue::GetTypeName() const {
  return "CoreML.Specification.MILSpec.ListValue";
}


// ===================================================================

class DictionaryValue_KeyValuePair::_Internal {
 public:
  static const ::CoreML::Specification::MILSpec::Value& key(const DictionaryValue_KeyValuePair* msg);
  static const ::CoreML::Specification::MILSpec::Value& value(const DictionaryValue_KeyValuePair* msg);
};

const ::CoreML::Specification::MILSpec::Value&
DictionaryValue_KeyValuePair::_Internal::key(const DictionaryValue_KeyValuePair* msg) {
  return *msg->key_;
}
const ::CoreML::Specification::MILSpec::Value&
DictionaryValue_KeyValuePair::_Internal::value(const DictionaryValue_KeyValuePair* msg) {
  return *msg->value_;
}
DictionaryValue_KeyValuePair::DictionaryValue_KeyValuePair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair)
}
DictionaryValue_KeyValuePair::DictionaryValue_KeyValuePair(const DictionaryValue_KeyValuePair& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_key()) {
    key_ = new ::CoreML::Specification::MILSpec::Value(*from.key_);
  } else {
    key_ = nullptr;
  }
  if (from._internal_has_value()) {
    value_ = new ::CoreML::Specification::MILSpec::Value(*from.value_);
  } else {
    value_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair)
}

inline void DictionaryValue_KeyValuePair::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&key_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&value_) -
    reinterpret_cast<char*>(&key_)) + sizeof(value_));
}

DictionaryValue_KeyValuePair::~DictionaryValue_KeyValuePair() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void DictionaryValue_KeyValuePair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete key_;
  if (this != internal_default_instance()) delete value_;
}

void DictionaryValue_KeyValuePair::ArenaDtor(void* object) {
  DictionaryValue_KeyValuePair* _this = reinterpret_cast< DictionaryValue_KeyValuePair* >(object);
  (void)_this;
}
void DictionaryValue_KeyValuePair::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DictionaryValue_KeyValuePair::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DictionaryValue_KeyValuePair::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* DictionaryValue_KeyValuePair::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.MILSpec.Value key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MILSpec.Value value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DictionaryValue_KeyValuePair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.MILSpec.Value key = 1;
  if (this->_internal_has_key()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::key(this), target, stream);
  }

  // .CoreML.Specification.MILSpec.Value value = 2;
  if (this->_internal_has_value()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::value(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair)
  return target;
}

size_t DictionaryValue_KeyValuePair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.MILSpec.Value key = 1;
  if (this->_internal_has_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *key_);
  }

  // .CoreML.Specification.MILSpec.Value value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *value_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DictionaryValue_KeyValuePair::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DictionaryValue_KeyValuePair*>(
      &from));
}

void DictionaryValue_KeyValuePair::MergeFrom(const DictionaryValue_KeyValuePair& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_key()) {
    _internal_mutable_key()->::CoreML::Specification::MILSpec::Value::MergeFrom(from._internal_key());
  }
  if (from._internal_has_value()) {
    _internal_mutable_value()->::CoreML::Specification::MILSpec::Value::MergeFrom(from._internal_value());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DictionaryValue_KeyValuePair::CopyFrom(const DictionaryValue_KeyValuePair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DictionaryValue_KeyValuePair::IsInitialized() const {
  return true;
}

void DictionaryValue_KeyValuePair::InternalSwap(DictionaryValue_KeyValuePair* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DictionaryValue_KeyValuePair, value_)
      + sizeof(DictionaryValue_KeyValuePair::value_)
      - PROTOBUF_FIELD_OFFSET(DictionaryValue_KeyValuePair, key_)>(
          reinterpret_cast<char*>(&key_),
          reinterpret_cast<char*>(&other->key_));
}

std::string DictionaryValue_KeyValuePair::GetTypeName() const {
  return "CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair";
}


// ===================================================================

class DictionaryValue::_Internal {
 public:
};

DictionaryValue::DictionaryValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MILSpec.DictionaryValue)
}
DictionaryValue::DictionaryValue(const DictionaryValue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MILSpec.DictionaryValue)
}

inline void DictionaryValue::SharedCtor() {
}

DictionaryValue::~DictionaryValue() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MILSpec.DictionaryValue)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void DictionaryValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DictionaryValue::ArenaDtor(void* object) {
  DictionaryValue* _this = reinterpret_cast< DictionaryValue* >(object);
  (void)_this;
}
void DictionaryValue::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DictionaryValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DictionaryValue::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MILSpec.DictionaryValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DictionaryValue::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DictionaryValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MILSpec.DictionaryValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair values = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_values_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_values(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MILSpec.DictionaryValue)
  return target;
}

size_t DictionaryValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MILSpec.DictionaryValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair values = 1;
  total_size += 1UL * this->_internal_values_size();
  for (const auto& msg : this->values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DictionaryValue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DictionaryValue*>(
      &from));
}

void DictionaryValue::MergeFrom(const DictionaryValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MILSpec.DictionaryValue)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DictionaryValue::CopyFrom(const DictionaryValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MILSpec.DictionaryValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DictionaryValue::IsInitialized() const {
  return true;
}

void DictionaryValue::InternalSwap(DictionaryValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string DictionaryValue::GetTypeName() const {
  return "CoreML.Specification.MILSpec.DictionaryValue";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace MILSpec
}  // namespace Specification
}  // namespace CoreML
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Program_FunctionsEntry_DoNotUse* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Program_FunctionsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Program_FunctionsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Program_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Program_AttributesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Program_AttributesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Program* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Program >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Program >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Function_BlockSpecializationsEntry_DoNotUse* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Function_BlockSpecializationsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Function_BlockSpecializationsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Function_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Function_AttributesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Function_AttributesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Function* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Function >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Function >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Block_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Block_AttributesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Block_AttributesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Block* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Block >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Block >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Argument_Binding* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Argument_Binding >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Argument_Binding >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Argument* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Argument >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Argument >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Operation_InputsEntry_DoNotUse* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Operation_InputsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Operation_InputsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Operation_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Operation_AttributesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Operation_AttributesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Operation* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Operation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Operation >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::NamedValueType* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::NamedValueType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::NamedValueType >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::ValueType* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::ValueType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::ValueType >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::TensorType_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorType_AttributesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::TensorType_AttributesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::TensorType* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::TensorType >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::TupleType* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::TupleType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::TupleType >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::ListType* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::ListType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::ListType >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::DictionaryType* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::DictionaryType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::DictionaryType >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::StateType* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::StateType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::StateType >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Dimension_ConstantDimension >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Dimension_ConstantDimension >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Dimension_UnknownDimension >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Dimension_UnknownDimension >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Dimension* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Dimension >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Dimension >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Value_ImmediateValue* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Value_ImmediateValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Value_ImmediateValue >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Value_BlobFileValue* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Value_BlobFileValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Value_BlobFileValue >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::Value* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::Value >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::Value >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::TensorValue* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::TensorValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::TensorValue >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::TupleValue* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::TupleValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::TupleValue >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::ListValue* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::ListValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::ListValue >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MILSpec::DictionaryValue* Arena::CreateMaybeMessage< ::CoreML::Specification::MILSpec::DictionaryValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MILSpec::DictionaryValue >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
