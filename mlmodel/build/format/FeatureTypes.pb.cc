// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FeatureTypes.proto

#include "FeatureTypes.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace CoreML {
namespace Specification {
constexpr Int64FeatureType::Int64FeatureType(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct Int64FeatureTypeDefaultTypeInternal {
  constexpr Int64FeatureTypeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Int64FeatureTypeDefaultTypeInternal() {}
  union {
    Int64FeatureType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Int64FeatureTypeDefaultTypeInternal _Int64FeatureType_default_instance_;
constexpr DoubleFeatureType::DoubleFeatureType(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct DoubleFeatureTypeDefaultTypeInternal {
  constexpr DoubleFeatureTypeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DoubleFeatureTypeDefaultTypeInternal() {}
  union {
    DoubleFeatureType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DoubleFeatureTypeDefaultTypeInternal _DoubleFeatureType_default_instance_;
constexpr StringFeatureType::StringFeatureType(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct StringFeatureTypeDefaultTypeInternal {
  constexpr StringFeatureTypeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StringFeatureTypeDefaultTypeInternal() {}
  union {
    StringFeatureType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StringFeatureTypeDefaultTypeInternal _StringFeatureType_default_instance_;
constexpr SizeRange::SizeRange(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : lowerbound_(uint64_t{0u})
  , upperbound_(int64_t{0}){}
struct SizeRangeDefaultTypeInternal {
  constexpr SizeRangeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SizeRangeDefaultTypeInternal() {}
  union {
    SizeRange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SizeRangeDefaultTypeInternal _SizeRange_default_instance_;
constexpr ImageFeatureType_ImageSize::ImageFeatureType_ImageSize(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : width_(uint64_t{0u})
  , height_(uint64_t{0u}){}
struct ImageFeatureType_ImageSizeDefaultTypeInternal {
  constexpr ImageFeatureType_ImageSizeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ImageFeatureType_ImageSizeDefaultTypeInternal() {}
  union {
    ImageFeatureType_ImageSize _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ImageFeatureType_ImageSizeDefaultTypeInternal _ImageFeatureType_ImageSize_default_instance_;
constexpr ImageFeatureType_EnumeratedImageSizes::ImageFeatureType_EnumeratedImageSizes(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sizes_(){}
struct ImageFeatureType_EnumeratedImageSizesDefaultTypeInternal {
  constexpr ImageFeatureType_EnumeratedImageSizesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ImageFeatureType_EnumeratedImageSizesDefaultTypeInternal() {}
  union {
    ImageFeatureType_EnumeratedImageSizes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ImageFeatureType_EnumeratedImageSizesDefaultTypeInternal _ImageFeatureType_EnumeratedImageSizes_default_instance_;
constexpr ImageFeatureType_ImageSizeRange::ImageFeatureType_ImageSizeRange(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : widthrange_(nullptr)
  , heightrange_(nullptr){}
struct ImageFeatureType_ImageSizeRangeDefaultTypeInternal {
  constexpr ImageFeatureType_ImageSizeRangeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ImageFeatureType_ImageSizeRangeDefaultTypeInternal() {}
  union {
    ImageFeatureType_ImageSizeRange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ImageFeatureType_ImageSizeRangeDefaultTypeInternal _ImageFeatureType_ImageSizeRange_default_instance_;
constexpr ImageFeatureType::ImageFeatureType(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : width_(int64_t{0})
  , height_(int64_t{0})
  , colorspace_(0)

  , _oneof_case_{}{}
struct ImageFeatureTypeDefaultTypeInternal {
  constexpr ImageFeatureTypeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ImageFeatureTypeDefaultTypeInternal() {}
  union {
    ImageFeatureType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ImageFeatureTypeDefaultTypeInternal _ImageFeatureType_default_instance_;
constexpr ArrayFeatureType_Shape::ArrayFeatureType_Shape(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : shape_()
  , _shape_cached_byte_size_(0){}
struct ArrayFeatureType_ShapeDefaultTypeInternal {
  constexpr ArrayFeatureType_ShapeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ArrayFeatureType_ShapeDefaultTypeInternal() {}
  union {
    ArrayFeatureType_Shape _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ArrayFeatureType_ShapeDefaultTypeInternal _ArrayFeatureType_Shape_default_instance_;
constexpr ArrayFeatureType_EnumeratedShapes::ArrayFeatureType_EnumeratedShapes(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : shapes_(){}
struct ArrayFeatureType_EnumeratedShapesDefaultTypeInternal {
  constexpr ArrayFeatureType_EnumeratedShapesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ArrayFeatureType_EnumeratedShapesDefaultTypeInternal() {}
  union {
    ArrayFeatureType_EnumeratedShapes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ArrayFeatureType_EnumeratedShapesDefaultTypeInternal _ArrayFeatureType_EnumeratedShapes_default_instance_;
constexpr ArrayFeatureType_ShapeRange::ArrayFeatureType_ShapeRange(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sizeranges_(){}
struct ArrayFeatureType_ShapeRangeDefaultTypeInternal {
  constexpr ArrayFeatureType_ShapeRangeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ArrayFeatureType_ShapeRangeDefaultTypeInternal() {}
  union {
    ArrayFeatureType_ShapeRange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ArrayFeatureType_ShapeRangeDefaultTypeInternal _ArrayFeatureType_ShapeRange_default_instance_;
constexpr ArrayFeatureType::ArrayFeatureType(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : shape_()
  , _shape_cached_byte_size_(0)
  , datatype_(0)

  , _oneof_case_{}{}
struct ArrayFeatureTypeDefaultTypeInternal {
  constexpr ArrayFeatureTypeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ArrayFeatureTypeDefaultTypeInternal() {}
  union {
    ArrayFeatureType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ArrayFeatureTypeDefaultTypeInternal _ArrayFeatureType_default_instance_;
constexpr DictionaryFeatureType::DictionaryFeatureType(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct DictionaryFeatureTypeDefaultTypeInternal {
  constexpr DictionaryFeatureTypeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DictionaryFeatureTypeDefaultTypeInternal() {}
  union {
    DictionaryFeatureType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DictionaryFeatureTypeDefaultTypeInternal _DictionaryFeatureType_default_instance_;
constexpr SequenceFeatureType::SequenceFeatureType(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sizerange_(nullptr)
  , _oneof_case_{}{}
struct SequenceFeatureTypeDefaultTypeInternal {
  constexpr SequenceFeatureTypeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SequenceFeatureTypeDefaultTypeInternal() {}
  union {
    SequenceFeatureType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SequenceFeatureTypeDefaultTypeInternal _SequenceFeatureType_default_instance_;
constexpr StateFeatureType::StateFeatureType(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct StateFeatureTypeDefaultTypeInternal {
  constexpr StateFeatureTypeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StateFeatureTypeDefaultTypeInternal() {}
  union {
    StateFeatureType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StateFeatureTypeDefaultTypeInternal _StateFeatureType_default_instance_;
constexpr FeatureType::FeatureType(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : isoptional_(false)
  , _oneof_case_{}{}
struct FeatureTypeDefaultTypeInternal {
  constexpr FeatureTypeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FeatureTypeDefaultTypeInternal() {}
  union {
    FeatureType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FeatureTypeDefaultTypeInternal _FeatureType_default_instance_;
}  // namespace Specification
}  // namespace CoreML
namespace CoreML {
namespace Specification {
bool ImageFeatureType_ColorSpace_IsValid(int value) {
  switch (value) {
    case 0:
    case 10:
    case 20:
    case 30:
    case 40:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ImageFeatureType_ColorSpace_strings[5] = {};

static const char ImageFeatureType_ColorSpace_names[] =
  "BGR"
  "GRAYSCALE"
  "GRAYSCALE_FLOAT16"
  "INVALID_COLOR_SPACE"
  "RGB";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ImageFeatureType_ColorSpace_entries[] = {
  { {ImageFeatureType_ColorSpace_names + 0, 3}, 30 },
  { {ImageFeatureType_ColorSpace_names + 3, 9}, 10 },
  { {ImageFeatureType_ColorSpace_names + 12, 17}, 40 },
  { {ImageFeatureType_ColorSpace_names + 29, 19}, 0 },
  { {ImageFeatureType_ColorSpace_names + 48, 3}, 20 },
};

static const int ImageFeatureType_ColorSpace_entries_by_number[] = {
  3, // 0 -> INVALID_COLOR_SPACE
  1, // 10 -> GRAYSCALE
  4, // 20 -> RGB
  0, // 30 -> BGR
  2, // 40 -> GRAYSCALE_FLOAT16
};

const std::string& ImageFeatureType_ColorSpace_Name(
    ImageFeatureType_ColorSpace value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ImageFeatureType_ColorSpace_entries,
          ImageFeatureType_ColorSpace_entries_by_number,
          5, ImageFeatureType_ColorSpace_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ImageFeatureType_ColorSpace_entries,
      ImageFeatureType_ColorSpace_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ImageFeatureType_ColorSpace_strings[idx].get();
}
bool ImageFeatureType_ColorSpace_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImageFeatureType_ColorSpace* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ImageFeatureType_ColorSpace_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ImageFeatureType_ColorSpace>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ImageFeatureType_ColorSpace ImageFeatureType::INVALID_COLOR_SPACE;
constexpr ImageFeatureType_ColorSpace ImageFeatureType::GRAYSCALE;
constexpr ImageFeatureType_ColorSpace ImageFeatureType::RGB;
constexpr ImageFeatureType_ColorSpace ImageFeatureType::BGR;
constexpr ImageFeatureType_ColorSpace ImageFeatureType::GRAYSCALE_FLOAT16;
constexpr ImageFeatureType_ColorSpace ImageFeatureType::ColorSpace_MIN;
constexpr ImageFeatureType_ColorSpace ImageFeatureType::ColorSpace_MAX;
constexpr int ImageFeatureType::ColorSpace_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ArrayFeatureType_ArrayDataType_IsValid(int value) {
  switch (value) {
    case 0:
    case 65552:
    case 65568:
    case 65600:
    case 131104:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ArrayFeatureType_ArrayDataType_strings[5] = {};

static const char ArrayFeatureType_ArrayDataType_names[] =
  "DOUBLE"
  "FLOAT16"
  "FLOAT32"
  "INT32"
  "INVALID_ARRAY_DATA_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ArrayFeatureType_ArrayDataType_entries[] = {
  { {ArrayFeatureType_ArrayDataType_names + 0, 6}, 65600 },
  { {ArrayFeatureType_ArrayDataType_names + 6, 7}, 65552 },
  { {ArrayFeatureType_ArrayDataType_names + 13, 7}, 65568 },
  { {ArrayFeatureType_ArrayDataType_names + 20, 5}, 131104 },
  { {ArrayFeatureType_ArrayDataType_names + 25, 23}, 0 },
};

static const int ArrayFeatureType_ArrayDataType_entries_by_number[] = {
  4, // 0 -> INVALID_ARRAY_DATA_TYPE
  1, // 65552 -> FLOAT16
  2, // 65568 -> FLOAT32
  0, // 65600 -> DOUBLE
  3, // 131104 -> INT32
};

const std::string& ArrayFeatureType_ArrayDataType_Name(
    ArrayFeatureType_ArrayDataType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ArrayFeatureType_ArrayDataType_entries,
          ArrayFeatureType_ArrayDataType_entries_by_number,
          5, ArrayFeatureType_ArrayDataType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ArrayFeatureType_ArrayDataType_entries,
      ArrayFeatureType_ArrayDataType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ArrayFeatureType_ArrayDataType_strings[idx].get();
}
bool ArrayFeatureType_ArrayDataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ArrayFeatureType_ArrayDataType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ArrayFeatureType_ArrayDataType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ArrayFeatureType_ArrayDataType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ArrayFeatureType_ArrayDataType ArrayFeatureType::INVALID_ARRAY_DATA_TYPE;
constexpr ArrayFeatureType_ArrayDataType ArrayFeatureType::FLOAT32;
constexpr ArrayFeatureType_ArrayDataType ArrayFeatureType::DOUBLE;
constexpr ArrayFeatureType_ArrayDataType ArrayFeatureType::INT32;
constexpr ArrayFeatureType_ArrayDataType ArrayFeatureType::FLOAT16;
constexpr ArrayFeatureType_ArrayDataType ArrayFeatureType::ArrayDataType_MIN;
constexpr ArrayFeatureType_ArrayDataType ArrayFeatureType::ArrayDataType_MAX;
constexpr int ArrayFeatureType::ArrayDataType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Int64FeatureType::_Internal {
 public:
};

Int64FeatureType::Int64FeatureType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.Int64FeatureType)
}
Int64FeatureType::Int64FeatureType(const Int64FeatureType& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Int64FeatureType)
}

inline void Int64FeatureType::SharedCtor() {
}

Int64FeatureType::~Int64FeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Int64FeatureType)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Int64FeatureType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Int64FeatureType::ArenaDtor(void* object) {
  Int64FeatureType* _this = reinterpret_cast< Int64FeatureType* >(object);
  (void)_this;
}
void Int64FeatureType::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Int64FeatureType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Int64FeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Int64FeatureType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* Int64FeatureType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Int64FeatureType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.Int64FeatureType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.Int64FeatureType)
  return target;
}

size_t Int64FeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Int64FeatureType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Int64FeatureType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Int64FeatureType*>(
      &from));
}

void Int64FeatureType::MergeFrom(const Int64FeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Int64FeatureType)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Int64FeatureType::CopyFrom(const Int64FeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Int64FeatureType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int64FeatureType::IsInitialized() const {
  return true;
}

void Int64FeatureType::InternalSwap(Int64FeatureType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string Int64FeatureType::GetTypeName() const {
  return "CoreML.Specification.Int64FeatureType";
}


// ===================================================================

class DoubleFeatureType::_Internal {
 public:
};

DoubleFeatureType::DoubleFeatureType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.DoubleFeatureType)
}
DoubleFeatureType::DoubleFeatureType(const DoubleFeatureType& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DoubleFeatureType)
}

inline void DoubleFeatureType::SharedCtor() {
}

DoubleFeatureType::~DoubleFeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DoubleFeatureType)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void DoubleFeatureType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DoubleFeatureType::ArenaDtor(void* object) {
  DoubleFeatureType* _this = reinterpret_cast< DoubleFeatureType* >(object);
  (void)_this;
}
void DoubleFeatureType::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DoubleFeatureType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DoubleFeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DoubleFeatureType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* DoubleFeatureType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DoubleFeatureType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.DoubleFeatureType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.DoubleFeatureType)
  return target;
}

size_t DoubleFeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DoubleFeatureType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DoubleFeatureType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DoubleFeatureType*>(
      &from));
}

void DoubleFeatureType::MergeFrom(const DoubleFeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DoubleFeatureType)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DoubleFeatureType::CopyFrom(const DoubleFeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DoubleFeatureType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoubleFeatureType::IsInitialized() const {
  return true;
}

void DoubleFeatureType::InternalSwap(DoubleFeatureType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string DoubleFeatureType::GetTypeName() const {
  return "CoreML.Specification.DoubleFeatureType";
}


// ===================================================================

class StringFeatureType::_Internal {
 public:
};

StringFeatureType::StringFeatureType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.StringFeatureType)
}
StringFeatureType::StringFeatureType(const StringFeatureType& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.StringFeatureType)
}

inline void StringFeatureType::SharedCtor() {
}

StringFeatureType::~StringFeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.StringFeatureType)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void StringFeatureType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StringFeatureType::ArenaDtor(void* object) {
  StringFeatureType* _this = reinterpret_cast< StringFeatureType* >(object);
  (void)_this;
}
void StringFeatureType::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StringFeatureType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StringFeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.StringFeatureType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* StringFeatureType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StringFeatureType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.StringFeatureType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.StringFeatureType)
  return target;
}

size_t StringFeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.StringFeatureType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StringFeatureType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StringFeatureType*>(
      &from));
}

void StringFeatureType::MergeFrom(const StringFeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.StringFeatureType)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StringFeatureType::CopyFrom(const StringFeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.StringFeatureType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringFeatureType::IsInitialized() const {
  return true;
}

void StringFeatureType::InternalSwap(StringFeatureType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string StringFeatureType::GetTypeName() const {
  return "CoreML.Specification.StringFeatureType";
}


// ===================================================================

class SizeRange::_Internal {
 public:
};

SizeRange::SizeRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SizeRange)
}
SizeRange::SizeRange(const SizeRange& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&lowerbound_, &from.lowerbound_,
    static_cast<size_t>(reinterpret_cast<char*>(&upperbound_) -
    reinterpret_cast<char*>(&lowerbound_)) + sizeof(upperbound_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SizeRange)
}

inline void SizeRange::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&lowerbound_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&upperbound_) -
    reinterpret_cast<char*>(&lowerbound_)) + sizeof(upperbound_));
}

SizeRange::~SizeRange() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SizeRange)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SizeRange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SizeRange::ArenaDtor(void* object) {
  SizeRange* _this = reinterpret_cast< SizeRange* >(object);
  (void)_this;
}
void SizeRange::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SizeRange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SizeRange::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SizeRange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&lowerbound_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&upperbound_) -
      reinterpret_cast<char*>(&lowerbound_)) + sizeof(upperbound_));
  _internal_metadata_.Clear<std::string>();
}

const char* SizeRange::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 lowerBound = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          lowerbound_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 upperBound = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          upperbound_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SizeRange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SizeRange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 lowerBound = 1;
  if (this->_internal_lowerbound() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_lowerbound(), target);
  }

  // int64 upperBound = 2;
  if (this->_internal_upperbound() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_upperbound(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SizeRange)
  return target;
}

size_t SizeRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SizeRange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 lowerBound = 1;
  if (this->_internal_lowerbound() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_lowerbound());
  }

  // int64 upperBound = 2;
  if (this->_internal_upperbound() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_upperbound());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SizeRange::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SizeRange*>(
      &from));
}

void SizeRange::MergeFrom(const SizeRange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SizeRange)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_lowerbound() != 0) {
    _internal_set_lowerbound(from._internal_lowerbound());
  }
  if (from._internal_upperbound() != 0) {
    _internal_set_upperbound(from._internal_upperbound());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SizeRange::CopyFrom(const SizeRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SizeRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SizeRange::IsInitialized() const {
  return true;
}

void SizeRange::InternalSwap(SizeRange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SizeRange, upperbound_)
      + sizeof(SizeRange::upperbound_)
      - PROTOBUF_FIELD_OFFSET(SizeRange, lowerbound_)>(
          reinterpret_cast<char*>(&lowerbound_),
          reinterpret_cast<char*>(&other->lowerbound_));
}

std::string SizeRange::GetTypeName() const {
  return "CoreML.Specification.SizeRange";
}


// ===================================================================

class ImageFeatureType_ImageSize::_Internal {
 public:
};

ImageFeatureType_ImageSize::ImageFeatureType_ImageSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ImageFeatureType.ImageSize)
}
ImageFeatureType_ImageSize::ImageFeatureType_ImageSize(const ImageFeatureType_ImageSize& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&width_, &from.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_)) + sizeof(height_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ImageFeatureType.ImageSize)
}

inline void ImageFeatureType_ImageSize::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&width_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_)) + sizeof(height_));
}

ImageFeatureType_ImageSize::~ImageFeatureType_ImageSize() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ImageFeatureType.ImageSize)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ImageFeatureType_ImageSize::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ImageFeatureType_ImageSize::ArenaDtor(void* object) {
  ImageFeatureType_ImageSize* _this = reinterpret_cast< ImageFeatureType_ImageSize* >(object);
  (void)_this;
}
void ImageFeatureType_ImageSize::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ImageFeatureType_ImageSize::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ImageFeatureType_ImageSize::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ImageFeatureType.ImageSize)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&width_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&height_) -
      reinterpret_cast<char*>(&width_)) + sizeof(height_));
  _internal_metadata_.Clear<std::string>();
}

const char* ImageFeatureType_ImageSize::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageFeatureType_ImageSize::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ImageFeatureType.ImageSize)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 width = 1;
  if (this->_internal_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_width(), target);
  }

  // uint64 height = 2;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ImageFeatureType.ImageSize)
  return target;
}

size_t ImageFeatureType_ImageSize::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ImageFeatureType.ImageSize)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 width = 1;
  if (this->_internal_width() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_width());
  }

  // uint64 height = 2;
  if (this->_internal_height() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_height());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ImageFeatureType_ImageSize::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ImageFeatureType_ImageSize*>(
      &from));
}

void ImageFeatureType_ImageSize::MergeFrom(const ImageFeatureType_ImageSize& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ImageFeatureType.ImageSize)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_width() != 0) {
    _internal_set_width(from._internal_width());
  }
  if (from._internal_height() != 0) {
    _internal_set_height(from._internal_height());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ImageFeatureType_ImageSize::CopyFrom(const ImageFeatureType_ImageSize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ImageFeatureType.ImageSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageFeatureType_ImageSize::IsInitialized() const {
  return true;
}

void ImageFeatureType_ImageSize::InternalSwap(ImageFeatureType_ImageSize* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImageFeatureType_ImageSize, height_)
      + sizeof(ImageFeatureType_ImageSize::height_)
      - PROTOBUF_FIELD_OFFSET(ImageFeatureType_ImageSize, width_)>(
          reinterpret_cast<char*>(&width_),
          reinterpret_cast<char*>(&other->width_));
}

std::string ImageFeatureType_ImageSize::GetTypeName() const {
  return "CoreML.Specification.ImageFeatureType.ImageSize";
}


// ===================================================================

class ImageFeatureType_EnumeratedImageSizes::_Internal {
 public:
};

ImageFeatureType_EnumeratedImageSizes::ImageFeatureType_EnumeratedImageSizes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  sizes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
}
ImageFeatureType_EnumeratedImageSizes::ImageFeatureType_EnumeratedImageSizes(const ImageFeatureType_EnumeratedImageSizes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      sizes_(from.sizes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
}

inline void ImageFeatureType_EnumeratedImageSizes::SharedCtor() {
}

ImageFeatureType_EnumeratedImageSizes::~ImageFeatureType_EnumeratedImageSizes() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ImageFeatureType_EnumeratedImageSizes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ImageFeatureType_EnumeratedImageSizes::ArenaDtor(void* object) {
  ImageFeatureType_EnumeratedImageSizes* _this = reinterpret_cast< ImageFeatureType_EnumeratedImageSizes* >(object);
  (void)_this;
}
void ImageFeatureType_EnumeratedImageSizes::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ImageFeatureType_EnumeratedImageSizes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ImageFeatureType_EnumeratedImageSizes::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sizes_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ImageFeatureType_EnumeratedImageSizes::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.ImageFeatureType.ImageSize sizes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sizes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageFeatureType_EnumeratedImageSizes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.ImageFeatureType.ImageSize sizes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_sizes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_sizes(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
  return target;
}

size_t ImageFeatureType_EnumeratedImageSizes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.ImageFeatureType.ImageSize sizes = 1;
  total_size += 1UL * this->_internal_sizes_size();
  for (const auto& msg : this->sizes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ImageFeatureType_EnumeratedImageSizes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ImageFeatureType_EnumeratedImageSizes*>(
      &from));
}

void ImageFeatureType_EnumeratedImageSizes::MergeFrom(const ImageFeatureType_EnumeratedImageSizes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  sizes_.MergeFrom(from.sizes_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ImageFeatureType_EnumeratedImageSizes::CopyFrom(const ImageFeatureType_EnumeratedImageSizes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageFeatureType_EnumeratedImageSizes::IsInitialized() const {
  return true;
}

void ImageFeatureType_EnumeratedImageSizes::InternalSwap(ImageFeatureType_EnumeratedImageSizes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  sizes_.InternalSwap(&other->sizes_);
}

std::string ImageFeatureType_EnumeratedImageSizes::GetTypeName() const {
  return "CoreML.Specification.ImageFeatureType.EnumeratedImageSizes";
}


// ===================================================================

class ImageFeatureType_ImageSizeRange::_Internal {
 public:
  static const ::CoreML::Specification::SizeRange& widthrange(const ImageFeatureType_ImageSizeRange* msg);
  static const ::CoreML::Specification::SizeRange& heightrange(const ImageFeatureType_ImageSizeRange* msg);
};

const ::CoreML::Specification::SizeRange&
ImageFeatureType_ImageSizeRange::_Internal::widthrange(const ImageFeatureType_ImageSizeRange* msg) {
  return *msg->widthrange_;
}
const ::CoreML::Specification::SizeRange&
ImageFeatureType_ImageSizeRange::_Internal::heightrange(const ImageFeatureType_ImageSizeRange* msg) {
  return *msg->heightrange_;
}
ImageFeatureType_ImageSizeRange::ImageFeatureType_ImageSizeRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ImageFeatureType.ImageSizeRange)
}
ImageFeatureType_ImageSizeRange::ImageFeatureType_ImageSizeRange(const ImageFeatureType_ImageSizeRange& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_widthrange()) {
    widthrange_ = new ::CoreML::Specification::SizeRange(*from.widthrange_);
  } else {
    widthrange_ = nullptr;
  }
  if (from._internal_has_heightrange()) {
    heightrange_ = new ::CoreML::Specification::SizeRange(*from.heightrange_);
  } else {
    heightrange_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ImageFeatureType.ImageSizeRange)
}

inline void ImageFeatureType_ImageSizeRange::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&widthrange_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&heightrange_) -
    reinterpret_cast<char*>(&widthrange_)) + sizeof(heightrange_));
}

ImageFeatureType_ImageSizeRange::~ImageFeatureType_ImageSizeRange() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ImageFeatureType.ImageSizeRange)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ImageFeatureType_ImageSizeRange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete widthrange_;
  if (this != internal_default_instance()) delete heightrange_;
}

void ImageFeatureType_ImageSizeRange::ArenaDtor(void* object) {
  ImageFeatureType_ImageSizeRange* _this = reinterpret_cast< ImageFeatureType_ImageSizeRange* >(object);
  (void)_this;
}
void ImageFeatureType_ImageSizeRange::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ImageFeatureType_ImageSizeRange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ImageFeatureType_ImageSizeRange::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ImageFeatureType.ImageSizeRange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && widthrange_ != nullptr) {
    delete widthrange_;
  }
  widthrange_ = nullptr;
  if (GetArenaForAllocation() == nullptr && heightrange_ != nullptr) {
    delete heightrange_;
  }
  heightrange_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* ImageFeatureType_ImageSizeRange::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.SizeRange widthRange = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_widthrange(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SizeRange heightRange = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_heightrange(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageFeatureType_ImageSizeRange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ImageFeatureType.ImageSizeRange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.SizeRange widthRange = 1;
  if (this->_internal_has_widthrange()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::widthrange(this), target, stream);
  }

  // .CoreML.Specification.SizeRange heightRange = 2;
  if (this->_internal_has_heightrange()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::heightrange(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ImageFeatureType.ImageSizeRange)
  return target;
}

size_t ImageFeatureType_ImageSizeRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ImageFeatureType.ImageSizeRange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.SizeRange widthRange = 1;
  if (this->_internal_has_widthrange()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *widthrange_);
  }

  // .CoreML.Specification.SizeRange heightRange = 2;
  if (this->_internal_has_heightrange()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *heightrange_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ImageFeatureType_ImageSizeRange::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ImageFeatureType_ImageSizeRange*>(
      &from));
}

void ImageFeatureType_ImageSizeRange::MergeFrom(const ImageFeatureType_ImageSizeRange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ImageFeatureType.ImageSizeRange)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_widthrange()) {
    _internal_mutable_widthrange()->::CoreML::Specification::SizeRange::MergeFrom(from._internal_widthrange());
  }
  if (from._internal_has_heightrange()) {
    _internal_mutable_heightrange()->::CoreML::Specification::SizeRange::MergeFrom(from._internal_heightrange());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ImageFeatureType_ImageSizeRange::CopyFrom(const ImageFeatureType_ImageSizeRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ImageFeatureType.ImageSizeRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageFeatureType_ImageSizeRange::IsInitialized() const {
  return true;
}

void ImageFeatureType_ImageSizeRange::InternalSwap(ImageFeatureType_ImageSizeRange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImageFeatureType_ImageSizeRange, heightrange_)
      + sizeof(ImageFeatureType_ImageSizeRange::heightrange_)
      - PROTOBUF_FIELD_OFFSET(ImageFeatureType_ImageSizeRange, widthrange_)>(
          reinterpret_cast<char*>(&widthrange_),
          reinterpret_cast<char*>(&other->widthrange_));
}

std::string ImageFeatureType_ImageSizeRange::GetTypeName() const {
  return "CoreML.Specification.ImageFeatureType.ImageSizeRange";
}


// ===================================================================

class ImageFeatureType::_Internal {
 public:
  static const ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes& enumeratedsizes(const ImageFeatureType* msg);
  static const ::CoreML::Specification::ImageFeatureType_ImageSizeRange& imagesizerange(const ImageFeatureType* msg);
};

const ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes&
ImageFeatureType::_Internal::enumeratedsizes(const ImageFeatureType* msg) {
  return *msg->SizeFlexibility_.enumeratedsizes_;
}
const ::CoreML::Specification::ImageFeatureType_ImageSizeRange&
ImageFeatureType::_Internal::imagesizerange(const ImageFeatureType* msg) {
  return *msg->SizeFlexibility_.imagesizerange_;
}
void ImageFeatureType::set_allocated_enumeratedsizes(::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* enumeratedsizes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_SizeFlexibility();
  if (enumeratedsizes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes>::GetOwningArena(enumeratedsizes);
    if (message_arena != submessage_arena) {
      enumeratedsizes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enumeratedsizes, submessage_arena);
    }
    set_has_enumeratedsizes();
    SizeFlexibility_.enumeratedsizes_ = enumeratedsizes;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ImageFeatureType.enumeratedSizes)
}
void ImageFeatureType::set_allocated_imagesizerange(::CoreML::Specification::ImageFeatureType_ImageSizeRange* imagesizerange) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_SizeFlexibility();
  if (imagesizerange) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ImageFeatureType_ImageSizeRange>::GetOwningArena(imagesizerange);
    if (message_arena != submessage_arena) {
      imagesizerange = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imagesizerange, submessage_arena);
    }
    set_has_imagesizerange();
    SizeFlexibility_.imagesizerange_ = imagesizerange;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ImageFeatureType.imageSizeRange)
}
ImageFeatureType::ImageFeatureType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ImageFeatureType)
}
ImageFeatureType::ImageFeatureType(const ImageFeatureType& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&width_, &from.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&colorspace_) -
    reinterpret_cast<char*>(&width_)) + sizeof(colorspace_));
  clear_has_SizeFlexibility();
  switch (from.SizeFlexibility_case()) {
    case kEnumeratedSizes: {
      _internal_mutable_enumeratedsizes()->::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes::MergeFrom(from._internal_enumeratedsizes());
      break;
    }
    case kImageSizeRange: {
      _internal_mutable_imagesizerange()->::CoreML::Specification::ImageFeatureType_ImageSizeRange::MergeFrom(from._internal_imagesizerange());
      break;
    }
    case SIZEFLEXIBILITY_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ImageFeatureType)
}

inline void ImageFeatureType::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&width_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&colorspace_) -
    reinterpret_cast<char*>(&width_)) + sizeof(colorspace_));
clear_has_SizeFlexibility();
}

ImageFeatureType::~ImageFeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ImageFeatureType)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ImageFeatureType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_SizeFlexibility()) {
    clear_SizeFlexibility();
  }
}

void ImageFeatureType::ArenaDtor(void* object) {
  ImageFeatureType* _this = reinterpret_cast< ImageFeatureType* >(object);
  (void)_this;
}
void ImageFeatureType::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ImageFeatureType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ImageFeatureType::clear_SizeFlexibility() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.ImageFeatureType)
  switch (SizeFlexibility_case()) {
    case kEnumeratedSizes: {
      if (GetArenaForAllocation() == nullptr) {
        delete SizeFlexibility_.enumeratedsizes_;
      }
      break;
    }
    case kImageSizeRange: {
      if (GetArenaForAllocation() == nullptr) {
        delete SizeFlexibility_.imagesizerange_;
      }
      break;
    }
    case SIZEFLEXIBILITY_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SIZEFLEXIBILITY_NOT_SET;
}


void ImageFeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ImageFeatureType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&width_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&colorspace_) -
      reinterpret_cast<char*>(&width_)) + sizeof(colorspace_));
  clear_SizeFlexibility();
  _internal_metadata_.Clear<std::string>();
}

const char* ImageFeatureType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ImageFeatureType.ColorSpace colorSpace = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_colorspace(static_cast<::CoreML::Specification::ImageFeatureType_ColorSpace>(val));
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ImageFeatureType.EnumeratedImageSizes enumeratedSizes = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_enumeratedsizes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ImageFeatureType.ImageSizeRange imageSizeRange = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_imagesizerange(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageFeatureType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ImageFeatureType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 width = 1;
  if (this->_internal_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_width(), target);
  }

  // int64 height = 2;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_height(), target);
  }

  // .CoreML.Specification.ImageFeatureType.ColorSpace colorSpace = 3;
  if (this->_internal_colorspace() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_colorspace(), target);
  }

  // .CoreML.Specification.ImageFeatureType.EnumeratedImageSizes enumeratedSizes = 21;
  if (_internal_has_enumeratedsizes()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        21, _Internal::enumeratedsizes(this), target, stream);
  }

  // .CoreML.Specification.ImageFeatureType.ImageSizeRange imageSizeRange = 31;
  if (_internal_has_imagesizerange()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        31, _Internal::imagesizerange(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ImageFeatureType)
  return target;
}

size_t ImageFeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ImageFeatureType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 width = 1;
  if (this->_internal_width() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_width());
  }

  // int64 height = 2;
  if (this->_internal_height() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_height());
  }

  // .CoreML.Specification.ImageFeatureType.ColorSpace colorSpace = 3;
  if (this->_internal_colorspace() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_colorspace());
  }

  switch (SizeFlexibility_case()) {
    // .CoreML.Specification.ImageFeatureType.EnumeratedImageSizes enumeratedSizes = 21;
    case kEnumeratedSizes: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *SizeFlexibility_.enumeratedsizes_);
      break;
    }
    // .CoreML.Specification.ImageFeatureType.ImageSizeRange imageSizeRange = 31;
    case kImageSizeRange: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *SizeFlexibility_.imagesizerange_);
      break;
    }
    case SIZEFLEXIBILITY_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ImageFeatureType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ImageFeatureType*>(
      &from));
}

void ImageFeatureType::MergeFrom(const ImageFeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ImageFeatureType)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_width() != 0) {
    _internal_set_width(from._internal_width());
  }
  if (from._internal_height() != 0) {
    _internal_set_height(from._internal_height());
  }
  if (from._internal_colorspace() != 0) {
    _internal_set_colorspace(from._internal_colorspace());
  }
  switch (from.SizeFlexibility_case()) {
    case kEnumeratedSizes: {
      _internal_mutable_enumeratedsizes()->::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes::MergeFrom(from._internal_enumeratedsizes());
      break;
    }
    case kImageSizeRange: {
      _internal_mutable_imagesizerange()->::CoreML::Specification::ImageFeatureType_ImageSizeRange::MergeFrom(from._internal_imagesizerange());
      break;
    }
    case SIZEFLEXIBILITY_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ImageFeatureType::CopyFrom(const ImageFeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ImageFeatureType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageFeatureType::IsInitialized() const {
  return true;
}

void ImageFeatureType::InternalSwap(ImageFeatureType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImageFeatureType, colorspace_)
      + sizeof(ImageFeatureType::colorspace_)
      - PROTOBUF_FIELD_OFFSET(ImageFeatureType, width_)>(
          reinterpret_cast<char*>(&width_),
          reinterpret_cast<char*>(&other->width_));
  swap(SizeFlexibility_, other->SizeFlexibility_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ImageFeatureType::GetTypeName() const {
  return "CoreML.Specification.ImageFeatureType";
}


// ===================================================================

class ArrayFeatureType_Shape::_Internal {
 public:
};

ArrayFeatureType_Shape::ArrayFeatureType_Shape(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  shape_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ArrayFeatureType.Shape)
}
ArrayFeatureType_Shape::ArrayFeatureType_Shape(const ArrayFeatureType_Shape& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      shape_(from.shape_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ArrayFeatureType.Shape)
}

inline void ArrayFeatureType_Shape::SharedCtor() {
}

ArrayFeatureType_Shape::~ArrayFeatureType_Shape() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ArrayFeatureType.Shape)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ArrayFeatureType_Shape::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ArrayFeatureType_Shape::ArenaDtor(void* object) {
  ArrayFeatureType_Shape* _this = reinterpret_cast< ArrayFeatureType_Shape* >(object);
  (void)_this;
}
void ArrayFeatureType_Shape::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ArrayFeatureType_Shape::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArrayFeatureType_Shape::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ArrayFeatureType.Shape)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  shape_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ArrayFeatureType_Shape::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 shape = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_shape(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_shape(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArrayFeatureType_Shape::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ArrayFeatureType.Shape)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 shape = 1;
  {
    int byte_size = _shape_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_shape(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ArrayFeatureType.Shape)
  return target;
}

size_t ArrayFeatureType_Shape::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ArrayFeatureType.Shape)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 shape = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->shape_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _shape_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ArrayFeatureType_Shape::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ArrayFeatureType_Shape*>(
      &from));
}

void ArrayFeatureType_Shape::MergeFrom(const ArrayFeatureType_Shape& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ArrayFeatureType.Shape)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  shape_.MergeFrom(from.shape_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ArrayFeatureType_Shape::CopyFrom(const ArrayFeatureType_Shape& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ArrayFeatureType.Shape)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArrayFeatureType_Shape::IsInitialized() const {
  return true;
}

void ArrayFeatureType_Shape::InternalSwap(ArrayFeatureType_Shape* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  shape_.InternalSwap(&other->shape_);
}

std::string ArrayFeatureType_Shape::GetTypeName() const {
  return "CoreML.Specification.ArrayFeatureType.Shape";
}


// ===================================================================

class ArrayFeatureType_EnumeratedShapes::_Internal {
 public:
};

ArrayFeatureType_EnumeratedShapes::ArrayFeatureType_EnumeratedShapes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  shapes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
}
ArrayFeatureType_EnumeratedShapes::ArrayFeatureType_EnumeratedShapes(const ArrayFeatureType_EnumeratedShapes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      shapes_(from.shapes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
}

inline void ArrayFeatureType_EnumeratedShapes::SharedCtor() {
}

ArrayFeatureType_EnumeratedShapes::~ArrayFeatureType_EnumeratedShapes() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ArrayFeatureType_EnumeratedShapes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ArrayFeatureType_EnumeratedShapes::ArenaDtor(void* object) {
  ArrayFeatureType_EnumeratedShapes* _this = reinterpret_cast< ArrayFeatureType_EnumeratedShapes* >(object);
  (void)_this;
}
void ArrayFeatureType_EnumeratedShapes::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ArrayFeatureType_EnumeratedShapes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArrayFeatureType_EnumeratedShapes::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  shapes_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ArrayFeatureType_EnumeratedShapes::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.ArrayFeatureType.Shape shapes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shapes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArrayFeatureType_EnumeratedShapes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.ArrayFeatureType.Shape shapes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_shapes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_shapes(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
  return target;
}

size_t ArrayFeatureType_EnumeratedShapes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.ArrayFeatureType.Shape shapes = 1;
  total_size += 1UL * this->_internal_shapes_size();
  for (const auto& msg : this->shapes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ArrayFeatureType_EnumeratedShapes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ArrayFeatureType_EnumeratedShapes*>(
      &from));
}

void ArrayFeatureType_EnumeratedShapes::MergeFrom(const ArrayFeatureType_EnumeratedShapes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  shapes_.MergeFrom(from.shapes_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ArrayFeatureType_EnumeratedShapes::CopyFrom(const ArrayFeatureType_EnumeratedShapes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArrayFeatureType_EnumeratedShapes::IsInitialized() const {
  return true;
}

void ArrayFeatureType_EnumeratedShapes::InternalSwap(ArrayFeatureType_EnumeratedShapes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  shapes_.InternalSwap(&other->shapes_);
}

std::string ArrayFeatureType_EnumeratedShapes::GetTypeName() const {
  return "CoreML.Specification.ArrayFeatureType.EnumeratedShapes";
}


// ===================================================================

class ArrayFeatureType_ShapeRange::_Internal {
 public:
};

ArrayFeatureType_ShapeRange::ArrayFeatureType_ShapeRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  sizeranges_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ArrayFeatureType.ShapeRange)
}
ArrayFeatureType_ShapeRange::ArrayFeatureType_ShapeRange(const ArrayFeatureType_ShapeRange& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      sizeranges_(from.sizeranges_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ArrayFeatureType.ShapeRange)
}

inline void ArrayFeatureType_ShapeRange::SharedCtor() {
}

ArrayFeatureType_ShapeRange::~ArrayFeatureType_ShapeRange() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ArrayFeatureType.ShapeRange)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ArrayFeatureType_ShapeRange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ArrayFeatureType_ShapeRange::ArenaDtor(void* object) {
  ArrayFeatureType_ShapeRange* _this = reinterpret_cast< ArrayFeatureType_ShapeRange* >(object);
  (void)_this;
}
void ArrayFeatureType_ShapeRange::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ArrayFeatureType_ShapeRange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArrayFeatureType_ShapeRange::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ArrayFeatureType.ShapeRange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sizeranges_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ArrayFeatureType_ShapeRange::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.SizeRange sizeRanges = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sizeranges(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArrayFeatureType_ShapeRange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ArrayFeatureType.ShapeRange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.SizeRange sizeRanges = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_sizeranges_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_sizeranges(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ArrayFeatureType.ShapeRange)
  return target;
}

size_t ArrayFeatureType_ShapeRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ArrayFeatureType.ShapeRange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.SizeRange sizeRanges = 1;
  total_size += 1UL * this->_internal_sizeranges_size();
  for (const auto& msg : this->sizeranges_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ArrayFeatureType_ShapeRange::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ArrayFeatureType_ShapeRange*>(
      &from));
}

void ArrayFeatureType_ShapeRange::MergeFrom(const ArrayFeatureType_ShapeRange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ArrayFeatureType.ShapeRange)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  sizeranges_.MergeFrom(from.sizeranges_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ArrayFeatureType_ShapeRange::CopyFrom(const ArrayFeatureType_ShapeRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ArrayFeatureType.ShapeRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArrayFeatureType_ShapeRange::IsInitialized() const {
  return true;
}

void ArrayFeatureType_ShapeRange::InternalSwap(ArrayFeatureType_ShapeRange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  sizeranges_.InternalSwap(&other->sizeranges_);
}

std::string ArrayFeatureType_ShapeRange::GetTypeName() const {
  return "CoreML.Specification.ArrayFeatureType.ShapeRange";
}


// ===================================================================

class ArrayFeatureType::_Internal {
 public:
  static const ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes& enumeratedshapes(const ArrayFeatureType* msg);
  static const ::CoreML::Specification::ArrayFeatureType_ShapeRange& shaperange(const ArrayFeatureType* msg);
};

const ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes&
ArrayFeatureType::_Internal::enumeratedshapes(const ArrayFeatureType* msg) {
  return *msg->ShapeFlexibility_.enumeratedshapes_;
}
const ::CoreML::Specification::ArrayFeatureType_ShapeRange&
ArrayFeatureType::_Internal::shaperange(const ArrayFeatureType* msg) {
  return *msg->ShapeFlexibility_.shaperange_;
}
void ArrayFeatureType::set_allocated_enumeratedshapes(::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* enumeratedshapes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ShapeFlexibility();
  if (enumeratedshapes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ArrayFeatureType_EnumeratedShapes>::GetOwningArena(enumeratedshapes);
    if (message_arena != submessage_arena) {
      enumeratedshapes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enumeratedshapes, submessage_arena);
    }
    set_has_enumeratedshapes();
    ShapeFlexibility_.enumeratedshapes_ = enumeratedshapes;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ArrayFeatureType.enumeratedShapes)
}
void ArrayFeatureType::set_allocated_shaperange(::CoreML::Specification::ArrayFeatureType_ShapeRange* shaperange) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ShapeFlexibility();
  if (shaperange) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ArrayFeatureType_ShapeRange>::GetOwningArena(shaperange);
    if (message_arena != submessage_arena) {
      shaperange = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shaperange, submessage_arena);
    }
    set_has_shaperange();
    ShapeFlexibility_.shaperange_ = shaperange;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ArrayFeatureType.shapeRange)
}
ArrayFeatureType::ArrayFeatureType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  shape_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ArrayFeatureType)
}
ArrayFeatureType::ArrayFeatureType(const ArrayFeatureType& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      shape_(from.shape_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  datatype_ = from.datatype_;
  clear_has_ShapeFlexibility();
  switch (from.ShapeFlexibility_case()) {
    case kEnumeratedShapes: {
      _internal_mutable_enumeratedshapes()->::CoreML::Specification::ArrayFeatureType_EnumeratedShapes::MergeFrom(from._internal_enumeratedshapes());
      break;
    }
    case kShapeRange: {
      _internal_mutable_shaperange()->::CoreML::Specification::ArrayFeatureType_ShapeRange::MergeFrom(from._internal_shaperange());
      break;
    }
    case SHAPEFLEXIBILITY_NOT_SET: {
      break;
    }
  }
  clear_has_defaultOptionalValue();
  switch (from.defaultOptionalValue_case()) {
    case kIntDefaultValue: {
      _internal_set_intdefaultvalue(from._internal_intdefaultvalue());
      break;
    }
    case kFloatDefaultValue: {
      _internal_set_floatdefaultvalue(from._internal_floatdefaultvalue());
      break;
    }
    case kDoubleDefaultValue: {
      _internal_set_doubledefaultvalue(from._internal_doubledefaultvalue());
      break;
    }
    case DEFAULTOPTIONALVALUE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ArrayFeatureType)
}

inline void ArrayFeatureType::SharedCtor() {
datatype_ = 0;
clear_has_ShapeFlexibility();
clear_has_defaultOptionalValue();
}

ArrayFeatureType::~ArrayFeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ArrayFeatureType)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ArrayFeatureType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_ShapeFlexibility()) {
    clear_ShapeFlexibility();
  }
  if (has_defaultOptionalValue()) {
    clear_defaultOptionalValue();
  }
}

void ArrayFeatureType::ArenaDtor(void* object) {
  ArrayFeatureType* _this = reinterpret_cast< ArrayFeatureType* >(object);
  (void)_this;
}
void ArrayFeatureType::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ArrayFeatureType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArrayFeatureType::clear_ShapeFlexibility() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.ArrayFeatureType)
  switch (ShapeFlexibility_case()) {
    case kEnumeratedShapes: {
      if (GetArenaForAllocation() == nullptr) {
        delete ShapeFlexibility_.enumeratedshapes_;
      }
      break;
    }
    case kShapeRange: {
      if (GetArenaForAllocation() == nullptr) {
        delete ShapeFlexibility_.shaperange_;
      }
      break;
    }
    case SHAPEFLEXIBILITY_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SHAPEFLEXIBILITY_NOT_SET;
}

void ArrayFeatureType::clear_defaultOptionalValue() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.ArrayFeatureType)
  switch (defaultOptionalValue_case()) {
    case kIntDefaultValue: {
      // No need to clear
      break;
    }
    case kFloatDefaultValue: {
      // No need to clear
      break;
    }
    case kDoubleDefaultValue: {
      // No need to clear
      break;
    }
    case DEFAULTOPTIONALVALUE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = DEFAULTOPTIONALVALUE_NOT_SET;
}


void ArrayFeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ArrayFeatureType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  shape_.Clear();
  datatype_ = 0;
  clear_ShapeFlexibility();
  clear_defaultOptionalValue();
  _internal_metadata_.Clear<std::string>();
}

const char* ArrayFeatureType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 shape = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_shape(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_shape(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ArrayFeatureType.ArrayDataType dataType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_datatype(static_cast<::CoreML::Specification::ArrayFeatureType_ArrayDataType>(val));
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ArrayFeatureType.EnumeratedShapes enumeratedShapes = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_enumeratedshapes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ArrayFeatureType.ShapeRange shapeRange = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_shaperange(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 intDefaultValue = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _internal_set_intdefaultvalue(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float floatDefaultValue = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 157)) {
          _internal_set_floatdefaultvalue(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // double doubleDefaultValue = 61;
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 233)) {
          _internal_set_doubledefaultvalue(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArrayFeatureType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ArrayFeatureType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 shape = 1;
  {
    int byte_size = _shape_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_shape(), byte_size, target);
    }
  }

  // .CoreML.Specification.ArrayFeatureType.ArrayDataType dataType = 2;
  if (this->_internal_datatype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_datatype(), target);
  }

  // .CoreML.Specification.ArrayFeatureType.EnumeratedShapes enumeratedShapes = 21;
  if (_internal_has_enumeratedshapes()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        21, _Internal::enumeratedshapes(this), target, stream);
  }

  // .CoreML.Specification.ArrayFeatureType.ShapeRange shapeRange = 31;
  if (_internal_has_shaperange()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        31, _Internal::shaperange(this), target, stream);
  }

  // int32 intDefaultValue = 41;
  if (_internal_has_intdefaultvalue()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(41, this->_internal_intdefaultvalue(), target);
  }

  // float floatDefaultValue = 51;
  if (_internal_has_floatdefaultvalue()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(51, this->_internal_floatdefaultvalue(), target);
  }

  // double doubleDefaultValue = 61;
  if (_internal_has_doubledefaultvalue()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(61, this->_internal_doubledefaultvalue(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ArrayFeatureType)
  return target;
}

size_t ArrayFeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ArrayFeatureType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 shape = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->shape_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _shape_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .CoreML.Specification.ArrayFeatureType.ArrayDataType dataType = 2;
  if (this->_internal_datatype() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_datatype());
  }

  switch (ShapeFlexibility_case()) {
    // .CoreML.Specification.ArrayFeatureType.EnumeratedShapes enumeratedShapes = 21;
    case kEnumeratedShapes: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ShapeFlexibility_.enumeratedshapes_);
      break;
    }
    // .CoreML.Specification.ArrayFeatureType.ShapeRange shapeRange = 31;
    case kShapeRange: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ShapeFlexibility_.shaperange_);
      break;
    }
    case SHAPEFLEXIBILITY_NOT_SET: {
      break;
    }
  }
  switch (defaultOptionalValue_case()) {
    // int32 intDefaultValue = 41;
    case kIntDefaultValue: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_intdefaultvalue());
      break;
    }
    // float floatDefaultValue = 51;
    case kFloatDefaultValue: {
      total_size += 2 + 4;
      break;
    }
    // double doubleDefaultValue = 61;
    case kDoubleDefaultValue: {
      total_size += 2 + 8;
      break;
    }
    case DEFAULTOPTIONALVALUE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ArrayFeatureType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ArrayFeatureType*>(
      &from));
}

void ArrayFeatureType::MergeFrom(const ArrayFeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ArrayFeatureType)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  shape_.MergeFrom(from.shape_);
  if (from._internal_datatype() != 0) {
    _internal_set_datatype(from._internal_datatype());
  }
  switch (from.ShapeFlexibility_case()) {
    case kEnumeratedShapes: {
      _internal_mutable_enumeratedshapes()->::CoreML::Specification::ArrayFeatureType_EnumeratedShapes::MergeFrom(from._internal_enumeratedshapes());
      break;
    }
    case kShapeRange: {
      _internal_mutable_shaperange()->::CoreML::Specification::ArrayFeatureType_ShapeRange::MergeFrom(from._internal_shaperange());
      break;
    }
    case SHAPEFLEXIBILITY_NOT_SET: {
      break;
    }
  }
  switch (from.defaultOptionalValue_case()) {
    case kIntDefaultValue: {
      _internal_set_intdefaultvalue(from._internal_intdefaultvalue());
      break;
    }
    case kFloatDefaultValue: {
      _internal_set_floatdefaultvalue(from._internal_floatdefaultvalue());
      break;
    }
    case kDoubleDefaultValue: {
      _internal_set_doubledefaultvalue(from._internal_doubledefaultvalue());
      break;
    }
    case DEFAULTOPTIONALVALUE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ArrayFeatureType::CopyFrom(const ArrayFeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ArrayFeatureType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArrayFeatureType::IsInitialized() const {
  return true;
}

void ArrayFeatureType::InternalSwap(ArrayFeatureType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  shape_.InternalSwap(&other->shape_);
  swap(datatype_, other->datatype_);
  swap(ShapeFlexibility_, other->ShapeFlexibility_);
  swap(defaultOptionalValue_, other->defaultOptionalValue_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

std::string ArrayFeatureType::GetTypeName() const {
  return "CoreML.Specification.ArrayFeatureType";
}


// ===================================================================

class DictionaryFeatureType::_Internal {
 public:
  static const ::CoreML::Specification::Int64FeatureType& int64keytype(const DictionaryFeatureType* msg);
  static const ::CoreML::Specification::StringFeatureType& stringkeytype(const DictionaryFeatureType* msg);
};

const ::CoreML::Specification::Int64FeatureType&
DictionaryFeatureType::_Internal::int64keytype(const DictionaryFeatureType* msg) {
  return *msg->KeyType_.int64keytype_;
}
const ::CoreML::Specification::StringFeatureType&
DictionaryFeatureType::_Internal::stringkeytype(const DictionaryFeatureType* msg) {
  return *msg->KeyType_.stringkeytype_;
}
void DictionaryFeatureType::set_allocated_int64keytype(::CoreML::Specification::Int64FeatureType* int64keytype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_KeyType();
  if (int64keytype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::Int64FeatureType>::GetOwningArena(int64keytype);
    if (message_arena != submessage_arena) {
      int64keytype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, int64keytype, submessage_arena);
    }
    set_has_int64keytype();
    KeyType_.int64keytype_ = int64keytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.DictionaryFeatureType.int64KeyType)
}
void DictionaryFeatureType::set_allocated_stringkeytype(::CoreML::Specification::StringFeatureType* stringkeytype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_KeyType();
  if (stringkeytype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::StringFeatureType>::GetOwningArena(stringkeytype);
    if (message_arena != submessage_arena) {
      stringkeytype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stringkeytype, submessage_arena);
    }
    set_has_stringkeytype();
    KeyType_.stringkeytype_ = stringkeytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.DictionaryFeatureType.stringKeyType)
}
DictionaryFeatureType::DictionaryFeatureType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.DictionaryFeatureType)
}
DictionaryFeatureType::DictionaryFeatureType(const DictionaryFeatureType& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_KeyType();
  switch (from.KeyType_case()) {
    case kInt64KeyType: {
      _internal_mutable_int64keytype()->::CoreML::Specification::Int64FeatureType::MergeFrom(from._internal_int64keytype());
      break;
    }
    case kStringKeyType: {
      _internal_mutable_stringkeytype()->::CoreML::Specification::StringFeatureType::MergeFrom(from._internal_stringkeytype());
      break;
    }
    case KEYTYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DictionaryFeatureType)
}

inline void DictionaryFeatureType::SharedCtor() {
clear_has_KeyType();
}

DictionaryFeatureType::~DictionaryFeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DictionaryFeatureType)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void DictionaryFeatureType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_KeyType()) {
    clear_KeyType();
  }
}

void DictionaryFeatureType::ArenaDtor(void* object) {
  DictionaryFeatureType* _this = reinterpret_cast< DictionaryFeatureType* >(object);
  (void)_this;
}
void DictionaryFeatureType::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DictionaryFeatureType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DictionaryFeatureType::clear_KeyType() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.DictionaryFeatureType)
  switch (KeyType_case()) {
    case kInt64KeyType: {
      if (GetArenaForAllocation() == nullptr) {
        delete KeyType_.int64keytype_;
      }
      break;
    }
    case kStringKeyType: {
      if (GetArenaForAllocation() == nullptr) {
        delete KeyType_.stringkeytype_;
      }
      break;
    }
    case KEYTYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = KEYTYPE_NOT_SET;
}


void DictionaryFeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DictionaryFeatureType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_KeyType();
  _internal_metadata_.Clear<std::string>();
}

const char* DictionaryFeatureType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.Int64FeatureType int64KeyType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_int64keytype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.StringFeatureType stringKeyType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_stringkeytype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DictionaryFeatureType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.DictionaryFeatureType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.Int64FeatureType int64KeyType = 1;
  if (_internal_has_int64keytype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::int64keytype(this), target, stream);
  }

  // .CoreML.Specification.StringFeatureType stringKeyType = 2;
  if (_internal_has_stringkeytype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::stringkeytype(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.DictionaryFeatureType)
  return target;
}

size_t DictionaryFeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DictionaryFeatureType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (KeyType_case()) {
    // .CoreML.Specification.Int64FeatureType int64KeyType = 1;
    case kInt64KeyType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *KeyType_.int64keytype_);
      break;
    }
    // .CoreML.Specification.StringFeatureType stringKeyType = 2;
    case kStringKeyType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *KeyType_.stringkeytype_);
      break;
    }
    case KEYTYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DictionaryFeatureType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DictionaryFeatureType*>(
      &from));
}

void DictionaryFeatureType::MergeFrom(const DictionaryFeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DictionaryFeatureType)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.KeyType_case()) {
    case kInt64KeyType: {
      _internal_mutable_int64keytype()->::CoreML::Specification::Int64FeatureType::MergeFrom(from._internal_int64keytype());
      break;
    }
    case kStringKeyType: {
      _internal_mutable_stringkeytype()->::CoreML::Specification::StringFeatureType::MergeFrom(from._internal_stringkeytype());
      break;
    }
    case KEYTYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DictionaryFeatureType::CopyFrom(const DictionaryFeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DictionaryFeatureType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DictionaryFeatureType::IsInitialized() const {
  return true;
}

void DictionaryFeatureType::InternalSwap(DictionaryFeatureType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(KeyType_, other->KeyType_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string DictionaryFeatureType::GetTypeName() const {
  return "CoreML.Specification.DictionaryFeatureType";
}


// ===================================================================

class SequenceFeatureType::_Internal {
 public:
  static const ::CoreML::Specification::Int64FeatureType& int64type(const SequenceFeatureType* msg);
  static const ::CoreML::Specification::StringFeatureType& stringtype(const SequenceFeatureType* msg);
  static const ::CoreML::Specification::SizeRange& sizerange(const SequenceFeatureType* msg);
};

const ::CoreML::Specification::Int64FeatureType&
SequenceFeatureType::_Internal::int64type(const SequenceFeatureType* msg) {
  return *msg->Type_.int64type_;
}
const ::CoreML::Specification::StringFeatureType&
SequenceFeatureType::_Internal::stringtype(const SequenceFeatureType* msg) {
  return *msg->Type_.stringtype_;
}
const ::CoreML::Specification::SizeRange&
SequenceFeatureType::_Internal::sizerange(const SequenceFeatureType* msg) {
  return *msg->sizerange_;
}
void SequenceFeatureType::set_allocated_int64type(::CoreML::Specification::Int64FeatureType* int64type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (int64type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::Int64FeatureType>::GetOwningArena(int64type);
    if (message_arena != submessage_arena) {
      int64type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, int64type, submessage_arena);
    }
    set_has_int64type();
    Type_.int64type_ = int64type;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SequenceFeatureType.int64Type)
}
void SequenceFeatureType::set_allocated_stringtype(::CoreML::Specification::StringFeatureType* stringtype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (stringtype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::StringFeatureType>::GetOwningArena(stringtype);
    if (message_arena != submessage_arena) {
      stringtype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stringtype, submessage_arena);
    }
    set_has_stringtype();
    Type_.stringtype_ = stringtype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SequenceFeatureType.stringType)
}
SequenceFeatureType::SequenceFeatureType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SequenceFeatureType)
}
SequenceFeatureType::SequenceFeatureType(const SequenceFeatureType& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_sizerange()) {
    sizerange_ = new ::CoreML::Specification::SizeRange(*from.sizerange_);
  } else {
    sizerange_ = nullptr;
  }
  clear_has_Type();
  switch (from.Type_case()) {
    case kInt64Type: {
      _internal_mutable_int64type()->::CoreML::Specification::Int64FeatureType::MergeFrom(from._internal_int64type());
      break;
    }
    case kStringType: {
      _internal_mutable_stringtype()->::CoreML::Specification::StringFeatureType::MergeFrom(from._internal_stringtype());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SequenceFeatureType)
}

inline void SequenceFeatureType::SharedCtor() {
sizerange_ = nullptr;
clear_has_Type();
}

SequenceFeatureType::~SequenceFeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SequenceFeatureType)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SequenceFeatureType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sizerange_;
  if (has_Type()) {
    clear_Type();
  }
}

void SequenceFeatureType::ArenaDtor(void* object) {
  SequenceFeatureType* _this = reinterpret_cast< SequenceFeatureType* >(object);
  (void)_this;
}
void SequenceFeatureType::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SequenceFeatureType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SequenceFeatureType::clear_Type() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.SequenceFeatureType)
  switch (Type_case()) {
    case kInt64Type: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.int64type_;
      }
      break;
    }
    case kStringType: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.stringtype_;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TYPE_NOT_SET;
}


void SequenceFeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SequenceFeatureType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && sizerange_ != nullptr) {
    delete sizerange_;
  }
  sizerange_ = nullptr;
  clear_Type();
  _internal_metadata_.Clear<std::string>();
}

const char* SequenceFeatureType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.Int64FeatureType int64Type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_int64type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.StringFeatureType stringType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_stringtype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SizeRange sizeRange = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_sizerange(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SequenceFeatureType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SequenceFeatureType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.Int64FeatureType int64Type = 1;
  if (_internal_has_int64type()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::int64type(this), target, stream);
  }

  // .CoreML.Specification.StringFeatureType stringType = 3;
  if (_internal_has_stringtype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::stringtype(this), target, stream);
  }

  // .CoreML.Specification.SizeRange sizeRange = 101;
  if (this->_internal_has_sizerange()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        101, _Internal::sizerange(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SequenceFeatureType)
  return target;
}

size_t SequenceFeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SequenceFeatureType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.SizeRange sizeRange = 101;
  if (this->_internal_has_sizerange()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sizerange_);
  }

  switch (Type_case()) {
    // .CoreML.Specification.Int64FeatureType int64Type = 1;
    case kInt64Type: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.int64type_);
      break;
    }
    // .CoreML.Specification.StringFeatureType stringType = 3;
    case kStringType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.stringtype_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SequenceFeatureType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SequenceFeatureType*>(
      &from));
}

void SequenceFeatureType::MergeFrom(const SequenceFeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SequenceFeatureType)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_sizerange()) {
    _internal_mutable_sizerange()->::CoreML::Specification::SizeRange::MergeFrom(from._internal_sizerange());
  }
  switch (from.Type_case()) {
    case kInt64Type: {
      _internal_mutable_int64type()->::CoreML::Specification::Int64FeatureType::MergeFrom(from._internal_int64type());
      break;
    }
    case kStringType: {
      _internal_mutable_stringtype()->::CoreML::Specification::StringFeatureType::MergeFrom(from._internal_stringtype());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SequenceFeatureType::CopyFrom(const SequenceFeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SequenceFeatureType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SequenceFeatureType::IsInitialized() const {
  return true;
}

void SequenceFeatureType::InternalSwap(SequenceFeatureType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(sizerange_, other->sizerange_);
  swap(Type_, other->Type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string SequenceFeatureType::GetTypeName() const {
  return "CoreML.Specification.SequenceFeatureType";
}


// ===================================================================

class StateFeatureType::_Internal {
 public:
  static const ::CoreML::Specification::ArrayFeatureType& arraytype(const StateFeatureType* msg);
};

const ::CoreML::Specification::ArrayFeatureType&
StateFeatureType::_Internal::arraytype(const StateFeatureType* msg) {
  return *msg->Type_.arraytype_;
}
void StateFeatureType::set_allocated_arraytype(::CoreML::Specification::ArrayFeatureType* arraytype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (arraytype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ArrayFeatureType>::GetOwningArena(arraytype);
    if (message_arena != submessage_arena) {
      arraytype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arraytype, submessage_arena);
    }
    set_has_arraytype();
    Type_.arraytype_ = arraytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.StateFeatureType.arrayType)
}
StateFeatureType::StateFeatureType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.StateFeatureType)
}
StateFeatureType::StateFeatureType(const StateFeatureType& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_Type();
  switch (from.Type_case()) {
    case kArrayType: {
      _internal_mutable_arraytype()->::CoreML::Specification::ArrayFeatureType::MergeFrom(from._internal_arraytype());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.StateFeatureType)
}

inline void StateFeatureType::SharedCtor() {
clear_has_Type();
}

StateFeatureType::~StateFeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.StateFeatureType)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void StateFeatureType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_Type()) {
    clear_Type();
  }
}

void StateFeatureType::ArenaDtor(void* object) {
  StateFeatureType* _this = reinterpret_cast< StateFeatureType* >(object);
  (void)_this;
}
void StateFeatureType::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StateFeatureType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StateFeatureType::clear_Type() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.StateFeatureType)
  switch (Type_case()) {
    case kArrayType: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.arraytype_;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TYPE_NOT_SET;
}


void StateFeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.StateFeatureType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_Type();
  _internal_metadata_.Clear<std::string>();
}

const char* StateFeatureType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.ArrayFeatureType arrayType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_arraytype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StateFeatureType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.StateFeatureType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.ArrayFeatureType arrayType = 1;
  if (_internal_has_arraytype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::arraytype(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.StateFeatureType)
  return target;
}

size_t StateFeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.StateFeatureType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (Type_case()) {
    // .CoreML.Specification.ArrayFeatureType arrayType = 1;
    case kArrayType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.arraytype_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StateFeatureType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StateFeatureType*>(
      &from));
}

void StateFeatureType::MergeFrom(const StateFeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.StateFeatureType)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.Type_case()) {
    case kArrayType: {
      _internal_mutable_arraytype()->::CoreML::Specification::ArrayFeatureType::MergeFrom(from._internal_arraytype());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StateFeatureType::CopyFrom(const StateFeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.StateFeatureType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StateFeatureType::IsInitialized() const {
  return true;
}

void StateFeatureType::InternalSwap(StateFeatureType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(Type_, other->Type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string StateFeatureType::GetTypeName() const {
  return "CoreML.Specification.StateFeatureType";
}


// ===================================================================

class FeatureType::_Internal {
 public:
  static const ::CoreML::Specification::Int64FeatureType& int64type(const FeatureType* msg);
  static const ::CoreML::Specification::DoubleFeatureType& doubletype(const FeatureType* msg);
  static const ::CoreML::Specification::StringFeatureType& stringtype(const FeatureType* msg);
  static const ::CoreML::Specification::ImageFeatureType& imagetype(const FeatureType* msg);
  static const ::CoreML::Specification::ArrayFeatureType& multiarraytype(const FeatureType* msg);
  static const ::CoreML::Specification::DictionaryFeatureType& dictionarytype(const FeatureType* msg);
  static const ::CoreML::Specification::SequenceFeatureType& sequencetype(const FeatureType* msg);
  static const ::CoreML::Specification::StateFeatureType& statetype(const FeatureType* msg);
};

const ::CoreML::Specification::Int64FeatureType&
FeatureType::_Internal::int64type(const FeatureType* msg) {
  return *msg->Type_.int64type_;
}
const ::CoreML::Specification::DoubleFeatureType&
FeatureType::_Internal::doubletype(const FeatureType* msg) {
  return *msg->Type_.doubletype_;
}
const ::CoreML::Specification::StringFeatureType&
FeatureType::_Internal::stringtype(const FeatureType* msg) {
  return *msg->Type_.stringtype_;
}
const ::CoreML::Specification::ImageFeatureType&
FeatureType::_Internal::imagetype(const FeatureType* msg) {
  return *msg->Type_.imagetype_;
}
const ::CoreML::Specification::ArrayFeatureType&
FeatureType::_Internal::multiarraytype(const FeatureType* msg) {
  return *msg->Type_.multiarraytype_;
}
const ::CoreML::Specification::DictionaryFeatureType&
FeatureType::_Internal::dictionarytype(const FeatureType* msg) {
  return *msg->Type_.dictionarytype_;
}
const ::CoreML::Specification::SequenceFeatureType&
FeatureType::_Internal::sequencetype(const FeatureType* msg) {
  return *msg->Type_.sequencetype_;
}
const ::CoreML::Specification::StateFeatureType&
FeatureType::_Internal::statetype(const FeatureType* msg) {
  return *msg->Type_.statetype_;
}
void FeatureType::set_allocated_int64type(::CoreML::Specification::Int64FeatureType* int64type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (int64type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::Int64FeatureType>::GetOwningArena(int64type);
    if (message_arena != submessage_arena) {
      int64type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, int64type, submessage_arena);
    }
    set_has_int64type();
    Type_.int64type_ = int64type;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.int64Type)
}
void FeatureType::set_allocated_doubletype(::CoreML::Specification::DoubleFeatureType* doubletype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (doubletype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::DoubleFeatureType>::GetOwningArena(doubletype);
    if (message_arena != submessage_arena) {
      doubletype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, doubletype, submessage_arena);
    }
    set_has_doubletype();
    Type_.doubletype_ = doubletype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.doubleType)
}
void FeatureType::set_allocated_stringtype(::CoreML::Specification::StringFeatureType* stringtype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (stringtype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::StringFeatureType>::GetOwningArena(stringtype);
    if (message_arena != submessage_arena) {
      stringtype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stringtype, submessage_arena);
    }
    set_has_stringtype();
    Type_.stringtype_ = stringtype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.stringType)
}
void FeatureType::set_allocated_imagetype(::CoreML::Specification::ImageFeatureType* imagetype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (imagetype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ImageFeatureType>::GetOwningArena(imagetype);
    if (message_arena != submessage_arena) {
      imagetype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imagetype, submessage_arena);
    }
    set_has_imagetype();
    Type_.imagetype_ = imagetype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.imageType)
}
void FeatureType::set_allocated_multiarraytype(::CoreML::Specification::ArrayFeatureType* multiarraytype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (multiarraytype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ArrayFeatureType>::GetOwningArena(multiarraytype);
    if (message_arena != submessage_arena) {
      multiarraytype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multiarraytype, submessage_arena);
    }
    set_has_multiarraytype();
    Type_.multiarraytype_ = multiarraytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.multiArrayType)
}
void FeatureType::set_allocated_dictionarytype(::CoreML::Specification::DictionaryFeatureType* dictionarytype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (dictionarytype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::DictionaryFeatureType>::GetOwningArena(dictionarytype);
    if (message_arena != submessage_arena) {
      dictionarytype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dictionarytype, submessage_arena);
    }
    set_has_dictionarytype();
    Type_.dictionarytype_ = dictionarytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.dictionaryType)
}
void FeatureType::set_allocated_sequencetype(::CoreML::Specification::SequenceFeatureType* sequencetype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (sequencetype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SequenceFeatureType>::GetOwningArena(sequencetype);
    if (message_arena != submessage_arena) {
      sequencetype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sequencetype, submessage_arena);
    }
    set_has_sequencetype();
    Type_.sequencetype_ = sequencetype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.sequenceType)
}
void FeatureType::set_allocated_statetype(::CoreML::Specification::StateFeatureType* statetype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (statetype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::StateFeatureType>::GetOwningArena(statetype);
    if (message_arena != submessage_arena) {
      statetype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statetype, submessage_arena);
    }
    set_has_statetype();
    Type_.statetype_ = statetype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.stateType)
}
FeatureType::FeatureType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.FeatureType)
}
FeatureType::FeatureType(const FeatureType& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  isoptional_ = from.isoptional_;
  clear_has_Type();
  switch (from.Type_case()) {
    case kInt64Type: {
      _internal_mutable_int64type()->::CoreML::Specification::Int64FeatureType::MergeFrom(from._internal_int64type());
      break;
    }
    case kDoubleType: {
      _internal_mutable_doubletype()->::CoreML::Specification::DoubleFeatureType::MergeFrom(from._internal_doubletype());
      break;
    }
    case kStringType: {
      _internal_mutable_stringtype()->::CoreML::Specification::StringFeatureType::MergeFrom(from._internal_stringtype());
      break;
    }
    case kImageType: {
      _internal_mutable_imagetype()->::CoreML::Specification::ImageFeatureType::MergeFrom(from._internal_imagetype());
      break;
    }
    case kMultiArrayType: {
      _internal_mutable_multiarraytype()->::CoreML::Specification::ArrayFeatureType::MergeFrom(from._internal_multiarraytype());
      break;
    }
    case kDictionaryType: {
      _internal_mutable_dictionarytype()->::CoreML::Specification::DictionaryFeatureType::MergeFrom(from._internal_dictionarytype());
      break;
    }
    case kSequenceType: {
      _internal_mutable_sequencetype()->::CoreML::Specification::SequenceFeatureType::MergeFrom(from._internal_sequencetype());
      break;
    }
    case kStateType: {
      _internal_mutable_statetype()->::CoreML::Specification::StateFeatureType::MergeFrom(from._internal_statetype());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.FeatureType)
}

inline void FeatureType::SharedCtor() {
isoptional_ = false;
clear_has_Type();
}

FeatureType::~FeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.FeatureType)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FeatureType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_Type()) {
    clear_Type();
  }
}

void FeatureType::ArenaDtor(void* object) {
  FeatureType* _this = reinterpret_cast< FeatureType* >(object);
  (void)_this;
}
void FeatureType::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FeatureType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FeatureType::clear_Type() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.FeatureType)
  switch (Type_case()) {
    case kInt64Type: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.int64type_;
      }
      break;
    }
    case kDoubleType: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.doubletype_;
      }
      break;
    }
    case kStringType: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.stringtype_;
      }
      break;
    }
    case kImageType: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.imagetype_;
      }
      break;
    }
    case kMultiArrayType: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.multiarraytype_;
      }
      break;
    }
    case kDictionaryType: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.dictionarytype_;
      }
      break;
    }
    case kSequenceType: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.sequencetype_;
      }
      break;
    }
    case kStateType: {
      if (GetArenaForAllocation() == nullptr) {
        delete Type_.statetype_;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TYPE_NOT_SET;
}


void FeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.FeatureType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  isoptional_ = false;
  clear_Type();
  _internal_metadata_.Clear<std::string>();
}

const char* FeatureType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.Int64FeatureType int64Type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_int64type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.DoubleFeatureType doubleType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_doubletype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.StringFeatureType stringType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_stringtype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ImageFeatureType imageType = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_imagetype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ArrayFeatureType multiArrayType = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_multiarraytype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.DictionaryFeatureType dictionaryType = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_dictionarytype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SequenceFeatureType sequenceType = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_sequencetype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.StateFeatureType stateType = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_statetype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isOptional = 1000;
      case 1000:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          isoptional_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FeatureType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.FeatureType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.Int64FeatureType int64Type = 1;
  if (_internal_has_int64type()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::int64type(this), target, stream);
  }

  // .CoreML.Specification.DoubleFeatureType doubleType = 2;
  if (_internal_has_doubletype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::doubletype(this), target, stream);
  }

  // .CoreML.Specification.StringFeatureType stringType = 3;
  if (_internal_has_stringtype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::stringtype(this), target, stream);
  }

  // .CoreML.Specification.ImageFeatureType imageType = 4;
  if (_internal_has_imagetype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::imagetype(this), target, stream);
  }

  // .CoreML.Specification.ArrayFeatureType multiArrayType = 5;
  if (_internal_has_multiarraytype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::multiarraytype(this), target, stream);
  }

  // .CoreML.Specification.DictionaryFeatureType dictionaryType = 6;
  if (_internal_has_dictionarytype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::dictionarytype(this), target, stream);
  }

  // .CoreML.Specification.SequenceFeatureType sequenceType = 7;
  if (_internal_has_sequencetype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::sequencetype(this), target, stream);
  }

  // .CoreML.Specification.StateFeatureType stateType = 8;
  if (_internal_has_statetype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::statetype(this), target, stream);
  }

  // bool isOptional = 1000;
  if (this->_internal_isoptional() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1000, this->_internal_isoptional(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.FeatureType)
  return target;
}

size_t FeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.FeatureType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool isOptional = 1000;
  if (this->_internal_isoptional() != 0) {
    total_size += 2 + 1;
  }

  switch (Type_case()) {
    // .CoreML.Specification.Int64FeatureType int64Type = 1;
    case kInt64Type: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.int64type_);
      break;
    }
    // .CoreML.Specification.DoubleFeatureType doubleType = 2;
    case kDoubleType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.doubletype_);
      break;
    }
    // .CoreML.Specification.StringFeatureType stringType = 3;
    case kStringType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.stringtype_);
      break;
    }
    // .CoreML.Specification.ImageFeatureType imageType = 4;
    case kImageType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.imagetype_);
      break;
    }
    // .CoreML.Specification.ArrayFeatureType multiArrayType = 5;
    case kMultiArrayType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.multiarraytype_);
      break;
    }
    // .CoreML.Specification.DictionaryFeatureType dictionaryType = 6;
    case kDictionaryType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.dictionarytype_);
      break;
    }
    // .CoreML.Specification.SequenceFeatureType sequenceType = 7;
    case kSequenceType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.sequencetype_);
      break;
    }
    // .CoreML.Specification.StateFeatureType stateType = 8;
    case kStateType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Type_.statetype_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FeatureType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FeatureType*>(
      &from));
}

void FeatureType::MergeFrom(const FeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.FeatureType)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_isoptional() != 0) {
    _internal_set_isoptional(from._internal_isoptional());
  }
  switch (from.Type_case()) {
    case kInt64Type: {
      _internal_mutable_int64type()->::CoreML::Specification::Int64FeatureType::MergeFrom(from._internal_int64type());
      break;
    }
    case kDoubleType: {
      _internal_mutable_doubletype()->::CoreML::Specification::DoubleFeatureType::MergeFrom(from._internal_doubletype());
      break;
    }
    case kStringType: {
      _internal_mutable_stringtype()->::CoreML::Specification::StringFeatureType::MergeFrom(from._internal_stringtype());
      break;
    }
    case kImageType: {
      _internal_mutable_imagetype()->::CoreML::Specification::ImageFeatureType::MergeFrom(from._internal_imagetype());
      break;
    }
    case kMultiArrayType: {
      _internal_mutable_multiarraytype()->::CoreML::Specification::ArrayFeatureType::MergeFrom(from._internal_multiarraytype());
      break;
    }
    case kDictionaryType: {
      _internal_mutable_dictionarytype()->::CoreML::Specification::DictionaryFeatureType::MergeFrom(from._internal_dictionarytype());
      break;
    }
    case kSequenceType: {
      _internal_mutable_sequencetype()->::CoreML::Specification::SequenceFeatureType::MergeFrom(from._internal_sequencetype());
      break;
    }
    case kStateType: {
      _internal_mutable_statetype()->::CoreML::Specification::StateFeatureType::MergeFrom(from._internal_statetype());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FeatureType::CopyFrom(const FeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.FeatureType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeatureType::IsInitialized() const {
  return true;
}

void FeatureType::InternalSwap(FeatureType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(isoptional_, other->isoptional_);
  swap(Type_, other->Type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string FeatureType::GetTypeName() const {
  return "CoreML.Specification.FeatureType";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace Specification
}  // namespace CoreML
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Int64FeatureType* Arena::CreateMaybeMessage< ::CoreML::Specification::Int64FeatureType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Int64FeatureType >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::DoubleFeatureType* Arena::CreateMaybeMessage< ::CoreML::Specification::DoubleFeatureType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::DoubleFeatureType >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::StringFeatureType* Arena::CreateMaybeMessage< ::CoreML::Specification::StringFeatureType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::StringFeatureType >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SizeRange* Arena::CreateMaybeMessage< ::CoreML::Specification::SizeRange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SizeRange >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ImageFeatureType_ImageSize* Arena::CreateMaybeMessage< ::CoreML::Specification::ImageFeatureType_ImageSize >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ImageFeatureType_ImageSize >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* Arena::CreateMaybeMessage< ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ImageFeatureType_ImageSizeRange* Arena::CreateMaybeMessage< ::CoreML::Specification::ImageFeatureType_ImageSizeRange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ImageFeatureType_ImageSizeRange >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ImageFeatureType* Arena::CreateMaybeMessage< ::CoreML::Specification::ImageFeatureType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ImageFeatureType >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ArrayFeatureType_Shape* Arena::CreateMaybeMessage< ::CoreML::Specification::ArrayFeatureType_Shape >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ArrayFeatureType_Shape >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* Arena::CreateMaybeMessage< ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ArrayFeatureType_ShapeRange* Arena::CreateMaybeMessage< ::CoreML::Specification::ArrayFeatureType_ShapeRange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ArrayFeatureType_ShapeRange >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ArrayFeatureType* Arena::CreateMaybeMessage< ::CoreML::Specification::ArrayFeatureType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ArrayFeatureType >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::DictionaryFeatureType* Arena::CreateMaybeMessage< ::CoreML::Specification::DictionaryFeatureType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::DictionaryFeatureType >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SequenceFeatureType* Arena::CreateMaybeMessage< ::CoreML::Specification::SequenceFeatureType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SequenceFeatureType >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::StateFeatureType* Arena::CreateMaybeMessage< ::CoreML::Specification::StateFeatureType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::StateFeatureType >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::FeatureType* Arena::CreateMaybeMessage< ::CoreML::Specification::FeatureType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::FeatureType >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
