// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DataStructures.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "DataStructures.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace CoreML {
namespace Specification {
class StringToInt64Map_MapEntryDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StringToInt64Map::StringToInt64Map_MapEntry> {
} _StringToInt64Map_MapEntry_default_instance_;
class StringToInt64MapDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StringToInt64Map> {
} _StringToInt64Map_default_instance_;
class Int64ToStringMap_MapEntryDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Int64ToStringMap::Int64ToStringMap_MapEntry> {
} _Int64ToStringMap_MapEntry_default_instance_;
class Int64ToStringMapDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Int64ToStringMap> {
} _Int64ToStringMap_default_instance_;
class StringToDoubleMap_MapEntryDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StringToDoubleMap::StringToDoubleMap_MapEntry> {
} _StringToDoubleMap_MapEntry_default_instance_;
class StringToDoubleMapDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StringToDoubleMap> {
} _StringToDoubleMap_default_instance_;
class Int64ToDoubleMap_MapEntryDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Int64ToDoubleMap::Int64ToDoubleMap_MapEntry> {
} _Int64ToDoubleMap_MapEntry_default_instance_;
class Int64ToDoubleMapDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Int64ToDoubleMap> {
} _Int64ToDoubleMap_default_instance_;
class StringVectorDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StringVector> {
} _StringVector_default_instance_;
class Int64VectorDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Int64Vector> {
} _Int64Vector_default_instance_;
class FloatVectorDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<FloatVector> {
} _FloatVector_default_instance_;
class DoubleVectorDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<DoubleVector> {
} _DoubleVector_default_instance_;
class Int64RangeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Int64Range> {
} _Int64Range_default_instance_;
class Int64SetDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Int64Set> {
} _Int64Set_default_instance_;
class DoubleRangeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<DoubleRange> {
} _DoubleRange_default_instance_;

namespace protobuf_DataStructures_2eproto {

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};


void TableStruct::Shutdown() {
  _StringToInt64Map_default_instance_.Shutdown();
  _Int64ToStringMap_default_instance_.Shutdown();
  _StringToDoubleMap_default_instance_.Shutdown();
  _Int64ToDoubleMap_default_instance_.Shutdown();
  _StringVector_default_instance_.Shutdown();
  _Int64Vector_default_instance_.Shutdown();
  _FloatVector_default_instance_.Shutdown();
  _DoubleVector_default_instance_.Shutdown();
  _Int64Range_default_instance_.Shutdown();
  _Int64Set_default_instance_.Shutdown();
  _DoubleRange_default_instance_.Shutdown();
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  ::CoreML::Specification::protobuf_FeatureTypes_2eproto::InitDefaults();
  _StringToInt64Map_MapEntry_default_instance_.DefaultConstruct();
  _StringToInt64Map_default_instance_.DefaultConstruct();
  _Int64ToStringMap_MapEntry_default_instance_.DefaultConstruct();
  _Int64ToStringMap_default_instance_.DefaultConstruct();
  _StringToDoubleMap_MapEntry_default_instance_.DefaultConstruct();
  _StringToDoubleMap_default_instance_.DefaultConstruct();
  _Int64ToDoubleMap_MapEntry_default_instance_.DefaultConstruct();
  _Int64ToDoubleMap_default_instance_.DefaultConstruct();
  _StringVector_default_instance_.DefaultConstruct();
  _Int64Vector_default_instance_.DefaultConstruct();
  _FloatVector_default_instance_.DefaultConstruct();
  _DoubleVector_default_instance_.DefaultConstruct();
  _Int64Range_default_instance_.DefaultConstruct();
  _Int64Set_default_instance_.DefaultConstruct();
  _DoubleRange_default_instance_.DefaultConstruct();
  _StringToInt64Map_MapEntry_default_instance_.get_mutable()->set_default_instance(_StringToInt64Map_MapEntry_default_instance_.get_mutable());
  _StringToInt64Map_MapEntry_default_instance_.get_mutable()->InitAsDefaultInstance();
  _Int64ToStringMap_MapEntry_default_instance_.get_mutable()->set_default_instance(_Int64ToStringMap_MapEntry_default_instance_.get_mutable());
  _Int64ToStringMap_MapEntry_default_instance_.get_mutable()->InitAsDefaultInstance();
  _StringToDoubleMap_MapEntry_default_instance_.get_mutable()->set_default_instance(_StringToDoubleMap_MapEntry_default_instance_.get_mutable());
  _StringToDoubleMap_MapEntry_default_instance_.get_mutable()->InitAsDefaultInstance();
  _Int64ToDoubleMap_MapEntry_default_instance_.get_mutable()->set_default_instance(_Int64ToDoubleMap_MapEntry_default_instance_.get_mutable());
  _Int64ToDoubleMap_MapEntry_default_instance_.get_mutable()->InitAsDefaultInstance();
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  ::CoreML::Specification::protobuf_FeatureTypes_2eproto::AddDescriptors();
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
#endif  // GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

}  // namespace protobuf_DataStructures_2eproto


// ===================================================================

#if PROTOBUF_INLINE_NOT_IN_HEADERS
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StringToInt64Map::kMapFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StringToInt64Map::StringToInt64Map()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_DataStructures_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.StringToInt64Map)
}
StringToInt64Map::StringToInt64Map(const StringToInt64Map& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  map_.MergeFrom(from.map_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.StringToInt64Map)
}

void StringToInt64Map::SharedCtor() {
  _cached_size_ = 0;
}

StringToInt64Map::~StringToInt64Map() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.StringToInt64Map)
  SharedDtor();
}

void StringToInt64Map::SharedDtor() {
}

void StringToInt64Map::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StringToInt64Map& StringToInt64Map::default_instance() {
  protobuf_DataStructures_2eproto::InitDefaults();
  return *internal_default_instance();
}

StringToInt64Map* StringToInt64Map::New(::google::protobuf::Arena* arena) const {
  StringToInt64Map* n = new StringToInt64Map;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StringToInt64Map::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.StringToInt64Map)
  map_.Clear();
}

bool StringToInt64Map::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.StringToInt64Map)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // map<string, int64> map = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          StringToInt64Map_MapEntry::Parser< ::google::protobuf::internal::MapFieldLite<
              StringToInt64Map_MapEntry,
              ::std::string, ::google::protobuf::int64,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
              0 >,
            ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 > > parser(&map_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            parser.key().data(), parser.key().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.StringToInt64Map.MapEntry.key"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.StringToInt64Map)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.StringToInt64Map)
  return false;
#undef DO_
}

void StringToInt64Map::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.StringToInt64Map)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, int64> map = 1;
  if (!this->map().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.StringToInt64Map.MapEntry.key");
      }
    };

    if (output->IsSerializationDeterministic() &&
        this->map().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->map().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >::const_iterator
          it = this->map().begin();
          it != this->map().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<StringToInt64Map_MapEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(map_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *entry, output);
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<StringToInt64Map_MapEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >::const_iterator
          it = this->map().begin();
          it != this->map().end(); ++it) {
        entry.reset(map_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *entry, output);
        Utf8Check::Check(&*it);
      }
    }
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.StringToInt64Map)
}

size_t StringToInt64Map::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.StringToInt64Map)
  size_t total_size = 0;

  // map<string, int64> map = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->map_size());
  {
    ::google::protobuf::scoped_ptr<StringToInt64Map_MapEntry> entry;
    for (::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >::const_iterator
        it = this->map().begin();
        it != this->map().end(); ++it) {
      entry.reset(map_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StringToInt64Map::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StringToInt64Map*>(&from));
}

void StringToInt64Map::MergeFrom(const StringToInt64Map& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.StringToInt64Map)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  map_.MergeFrom(from.map_);
}

void StringToInt64Map::CopyFrom(const StringToInt64Map& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.StringToInt64Map)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringToInt64Map::IsInitialized() const {
  return true;
}

void StringToInt64Map::Swap(StringToInt64Map* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StringToInt64Map::InternalSwap(StringToInt64Map* other) {
  map_.Swap(&other->map_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string StringToInt64Map::GetTypeName() const {
  return "CoreML.Specification.StringToInt64Map";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StringToInt64Map

// map<string, int64> map = 1;
int StringToInt64Map::map_size() const {
  return map_.size();
}
void StringToInt64Map::clear_map() {
  map_.Clear();
}
 const ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >&
StringToInt64Map::map() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.StringToInt64Map.map)
  return map_.GetMap();
}
 ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >*
StringToInt64Map::mutable_map() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.StringToInt64Map.map)
  return map_.MutableMap();
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if PROTOBUF_INLINE_NOT_IN_HEADERS
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Int64ToStringMap::kMapFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Int64ToStringMap::Int64ToStringMap()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_DataStructures_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.Int64ToStringMap)
}
Int64ToStringMap::Int64ToStringMap(const Int64ToStringMap& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  map_.MergeFrom(from.map_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Int64ToStringMap)
}

void Int64ToStringMap::SharedCtor() {
  _cached_size_ = 0;
}

Int64ToStringMap::~Int64ToStringMap() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Int64ToStringMap)
  SharedDtor();
}

void Int64ToStringMap::SharedDtor() {
}

void Int64ToStringMap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Int64ToStringMap& Int64ToStringMap::default_instance() {
  protobuf_DataStructures_2eproto::InitDefaults();
  return *internal_default_instance();
}

Int64ToStringMap* Int64ToStringMap::New(::google::protobuf::Arena* arena) const {
  Int64ToStringMap* n = new Int64ToStringMap;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Int64ToStringMap::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Int64ToStringMap)
  map_.Clear();
}

bool Int64ToStringMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.Int64ToStringMap)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // map<int64, string> map = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          Int64ToStringMap_MapEntry::Parser< ::google::protobuf::internal::MapFieldLite<
              Int64ToStringMap_MapEntry,
              ::google::protobuf::int64, ::std::string,
              ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              0 >,
            ::google::protobuf::Map< ::google::protobuf::int64, ::std::string > > parser(&map_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            parser.value().data(), parser.value().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.Int64ToStringMap.MapEntry.value"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.Int64ToStringMap)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.Int64ToStringMap)
  return false;
#undef DO_
}

void Int64ToStringMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.Int64ToStringMap)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // map<int64, string> map = 1;
  if (!this->map().empty()) {
    typedef ::google::protobuf::Map< ::google::protobuf::int64, ::std::string >::const_pointer
        ConstPtr;
    typedef ::google::protobuf::internal::SortItem< ::google::protobuf::int64, ConstPtr > SortItem;
    typedef ::google::protobuf::internal::CompareByFirstField<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->second.data(), p->second.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.Int64ToStringMap.MapEntry.value");
      }
    };

    if (output->IsSerializationDeterministic() &&
        this->map().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->map().size()]);
      typedef ::google::protobuf::Map< ::google::protobuf::int64, ::std::string >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::google::protobuf::int64, ::std::string >::const_iterator
          it = this->map().begin();
          it != this->map().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<Int64ToStringMap_MapEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(map_.NewEntryWrapper(
            items[i].second->first, items[i].second->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *entry, output);
        Utf8Check::Check(items[i].second);
      }
    } else {
      ::google::protobuf::scoped_ptr<Int64ToStringMap_MapEntry> entry;
      for (::google::protobuf::Map< ::google::protobuf::int64, ::std::string >::const_iterator
          it = this->map().begin();
          it != this->map().end(); ++it) {
        entry.reset(map_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *entry, output);
        Utf8Check::Check(&*it);
      }
    }
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.Int64ToStringMap)
}

size_t Int64ToStringMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Int64ToStringMap)
  size_t total_size = 0;

  // map<int64, string> map = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->map_size());
  {
    ::google::protobuf::scoped_ptr<Int64ToStringMap_MapEntry> entry;
    for (::google::protobuf::Map< ::google::protobuf::int64, ::std::string >::const_iterator
        it = this->map().begin();
        it != this->map().end(); ++it) {
      entry.reset(map_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Int64ToStringMap::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Int64ToStringMap*>(&from));
}

void Int64ToStringMap::MergeFrom(const Int64ToStringMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Int64ToStringMap)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  map_.MergeFrom(from.map_);
}

void Int64ToStringMap::CopyFrom(const Int64ToStringMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Int64ToStringMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int64ToStringMap::IsInitialized() const {
  return true;
}

void Int64ToStringMap::Swap(Int64ToStringMap* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Int64ToStringMap::InternalSwap(Int64ToStringMap* other) {
  map_.Swap(&other->map_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Int64ToStringMap::GetTypeName() const {
  return "CoreML.Specification.Int64ToStringMap";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Int64ToStringMap

// map<int64, string> map = 1;
int Int64ToStringMap::map_size() const {
  return map_.size();
}
void Int64ToStringMap::clear_map() {
  map_.Clear();
}
 const ::google::protobuf::Map< ::google::protobuf::int64, ::std::string >&
Int64ToStringMap::map() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.Int64ToStringMap.map)
  return map_.GetMap();
}
 ::google::protobuf::Map< ::google::protobuf::int64, ::std::string >*
Int64ToStringMap::mutable_map() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.Int64ToStringMap.map)
  return map_.MutableMap();
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if PROTOBUF_INLINE_NOT_IN_HEADERS
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StringToDoubleMap::kMapFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StringToDoubleMap::StringToDoubleMap()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_DataStructures_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.StringToDoubleMap)
}
StringToDoubleMap::StringToDoubleMap(const StringToDoubleMap& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  map_.MergeFrom(from.map_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.StringToDoubleMap)
}

void StringToDoubleMap::SharedCtor() {
  _cached_size_ = 0;
}

StringToDoubleMap::~StringToDoubleMap() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.StringToDoubleMap)
  SharedDtor();
}

void StringToDoubleMap::SharedDtor() {
}

void StringToDoubleMap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StringToDoubleMap& StringToDoubleMap::default_instance() {
  protobuf_DataStructures_2eproto::InitDefaults();
  return *internal_default_instance();
}

StringToDoubleMap* StringToDoubleMap::New(::google::protobuf::Arena* arena) const {
  StringToDoubleMap* n = new StringToDoubleMap;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StringToDoubleMap::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.StringToDoubleMap)
  map_.Clear();
}

bool StringToDoubleMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.StringToDoubleMap)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // map<string, double> map = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          StringToDoubleMap_MapEntry::Parser< ::google::protobuf::internal::MapFieldLite<
              StringToDoubleMap_MapEntry,
              ::std::string, double,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
              0 >,
            ::google::protobuf::Map< ::std::string, double > > parser(&map_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            parser.key().data(), parser.key().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.StringToDoubleMap.MapEntry.key"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.StringToDoubleMap)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.StringToDoubleMap)
  return false;
#undef DO_
}

void StringToDoubleMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.StringToDoubleMap)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, double> map = 1;
  if (!this->map().empty()) {
    typedef ::google::protobuf::Map< ::std::string, double >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.StringToDoubleMap.MapEntry.key");
      }
    };

    if (output->IsSerializationDeterministic() &&
        this->map().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->map().size()]);
      typedef ::google::protobuf::Map< ::std::string, double >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, double >::const_iterator
          it = this->map().begin();
          it != this->map().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<StringToDoubleMap_MapEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(map_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *entry, output);
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<StringToDoubleMap_MapEntry> entry;
      for (::google::protobuf::Map< ::std::string, double >::const_iterator
          it = this->map().begin();
          it != this->map().end(); ++it) {
        entry.reset(map_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *entry, output);
        Utf8Check::Check(&*it);
      }
    }
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.StringToDoubleMap)
}

size_t StringToDoubleMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.StringToDoubleMap)
  size_t total_size = 0;

  // map<string, double> map = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->map_size());
  {
    ::google::protobuf::scoped_ptr<StringToDoubleMap_MapEntry> entry;
    for (::google::protobuf::Map< ::std::string, double >::const_iterator
        it = this->map().begin();
        it != this->map().end(); ++it) {
      entry.reset(map_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StringToDoubleMap::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StringToDoubleMap*>(&from));
}

void StringToDoubleMap::MergeFrom(const StringToDoubleMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.StringToDoubleMap)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  map_.MergeFrom(from.map_);
}

void StringToDoubleMap::CopyFrom(const StringToDoubleMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.StringToDoubleMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringToDoubleMap::IsInitialized() const {
  return true;
}

void StringToDoubleMap::Swap(StringToDoubleMap* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StringToDoubleMap::InternalSwap(StringToDoubleMap* other) {
  map_.Swap(&other->map_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string StringToDoubleMap::GetTypeName() const {
  return "CoreML.Specification.StringToDoubleMap";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StringToDoubleMap

// map<string, double> map = 1;
int StringToDoubleMap::map_size() const {
  return map_.size();
}
void StringToDoubleMap::clear_map() {
  map_.Clear();
}
 const ::google::protobuf::Map< ::std::string, double >&
StringToDoubleMap::map() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.StringToDoubleMap.map)
  return map_.GetMap();
}
 ::google::protobuf::Map< ::std::string, double >*
StringToDoubleMap::mutable_map() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.StringToDoubleMap.map)
  return map_.MutableMap();
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if PROTOBUF_INLINE_NOT_IN_HEADERS
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Int64ToDoubleMap::kMapFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Int64ToDoubleMap::Int64ToDoubleMap()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_DataStructures_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.Int64ToDoubleMap)
}
Int64ToDoubleMap::Int64ToDoubleMap(const Int64ToDoubleMap& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  map_.MergeFrom(from.map_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Int64ToDoubleMap)
}

void Int64ToDoubleMap::SharedCtor() {
  _cached_size_ = 0;
}

Int64ToDoubleMap::~Int64ToDoubleMap() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Int64ToDoubleMap)
  SharedDtor();
}

void Int64ToDoubleMap::SharedDtor() {
}

void Int64ToDoubleMap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Int64ToDoubleMap& Int64ToDoubleMap::default_instance() {
  protobuf_DataStructures_2eproto::InitDefaults();
  return *internal_default_instance();
}

Int64ToDoubleMap* Int64ToDoubleMap::New(::google::protobuf::Arena* arena) const {
  Int64ToDoubleMap* n = new Int64ToDoubleMap;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Int64ToDoubleMap::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Int64ToDoubleMap)
  map_.Clear();
}

bool Int64ToDoubleMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.Int64ToDoubleMap)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // map<int64, double> map = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          Int64ToDoubleMap_MapEntry::Parser< ::google::protobuf::internal::MapFieldLite<
              Int64ToDoubleMap_MapEntry,
              ::google::protobuf::int64, double,
              ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
              ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
              0 >,
            ::google::protobuf::Map< ::google::protobuf::int64, double > > parser(&map_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.Int64ToDoubleMap)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.Int64ToDoubleMap)
  return false;
#undef DO_
}

void Int64ToDoubleMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.Int64ToDoubleMap)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // map<int64, double> map = 1;
  if (!this->map().empty()) {
    typedef ::google::protobuf::Map< ::google::protobuf::int64, double >::const_pointer
        ConstPtr;
    typedef ::google::protobuf::internal::SortItem< ::google::protobuf::int64, ConstPtr > SortItem;
    typedef ::google::protobuf::internal::CompareByFirstField<SortItem> Less;

    if (output->IsSerializationDeterministic() &&
        this->map().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->map().size()]);
      typedef ::google::protobuf::Map< ::google::protobuf::int64, double >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::google::protobuf::int64, double >::const_iterator
          it = this->map().begin();
          it != this->map().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<Int64ToDoubleMap_MapEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(map_.NewEntryWrapper(
            items[i].second->first, items[i].second->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *entry, output);
      }
    } else {
      ::google::protobuf::scoped_ptr<Int64ToDoubleMap_MapEntry> entry;
      for (::google::protobuf::Map< ::google::protobuf::int64, double >::const_iterator
          it = this->map().begin();
          it != this->map().end(); ++it) {
        entry.reset(map_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *entry, output);
      }
    }
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.Int64ToDoubleMap)
}

size_t Int64ToDoubleMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Int64ToDoubleMap)
  size_t total_size = 0;

  // map<int64, double> map = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->map_size());
  {
    ::google::protobuf::scoped_ptr<Int64ToDoubleMap_MapEntry> entry;
    for (::google::protobuf::Map< ::google::protobuf::int64, double >::const_iterator
        it = this->map().begin();
        it != this->map().end(); ++it) {
      entry.reset(map_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Int64ToDoubleMap::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Int64ToDoubleMap*>(&from));
}

void Int64ToDoubleMap::MergeFrom(const Int64ToDoubleMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Int64ToDoubleMap)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  map_.MergeFrom(from.map_);
}

void Int64ToDoubleMap::CopyFrom(const Int64ToDoubleMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Int64ToDoubleMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int64ToDoubleMap::IsInitialized() const {
  return true;
}

void Int64ToDoubleMap::Swap(Int64ToDoubleMap* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Int64ToDoubleMap::InternalSwap(Int64ToDoubleMap* other) {
  map_.Swap(&other->map_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Int64ToDoubleMap::GetTypeName() const {
  return "CoreML.Specification.Int64ToDoubleMap";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Int64ToDoubleMap

// map<int64, double> map = 1;
int Int64ToDoubleMap::map_size() const {
  return map_.size();
}
void Int64ToDoubleMap::clear_map() {
  map_.Clear();
}
 const ::google::protobuf::Map< ::google::protobuf::int64, double >&
Int64ToDoubleMap::map() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.Int64ToDoubleMap.map)
  return map_.GetMap();
}
 ::google::protobuf::Map< ::google::protobuf::int64, double >*
Int64ToDoubleMap::mutable_map() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.Int64ToDoubleMap.map)
  return map_.MutableMap();
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StringVector::kVectorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StringVector::StringVector()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_DataStructures_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.StringVector)
}
StringVector::StringVector(const StringVector& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      vector_(from.vector_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.StringVector)
}

void StringVector::SharedCtor() {
  _cached_size_ = 0;
}

StringVector::~StringVector() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.StringVector)
  SharedDtor();
}

void StringVector::SharedDtor() {
}

void StringVector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StringVector& StringVector::default_instance() {
  protobuf_DataStructures_2eproto::InitDefaults();
  return *internal_default_instance();
}

StringVector* StringVector::New(::google::protobuf::Arena* arena) const {
  StringVector* n = new StringVector;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StringVector::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.StringVector)
  vector_.Clear();
}

bool StringVector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.StringVector)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string vector = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_vector()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->vector(this->vector_size() - 1).data(),
            this->vector(this->vector_size() - 1).length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.StringVector.vector"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.StringVector)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.StringVector)
  return false;
#undef DO_
}

void StringVector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.StringVector)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string vector = 1;
  for (int i = 0, n = this->vector_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vector(i).data(), this->vector(i).length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.StringVector.vector");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->vector(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.StringVector)
}

size_t StringVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.StringVector)
  size_t total_size = 0;

  // repeated string vector = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->vector_size());
  for (int i = 0, n = this->vector_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->vector(i));
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StringVector::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StringVector*>(&from));
}

void StringVector::MergeFrom(const StringVector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.StringVector)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  vector_.MergeFrom(from.vector_);
}

void StringVector::CopyFrom(const StringVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.StringVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringVector::IsInitialized() const {
  return true;
}

void StringVector::Swap(StringVector* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StringVector::InternalSwap(StringVector* other) {
  vector_.InternalSwap(&other->vector_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string StringVector::GetTypeName() const {
  return "CoreML.Specification.StringVector";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StringVector

// repeated string vector = 1;
int StringVector::vector_size() const {
  return vector_.size();
}
void StringVector::clear_vector() {
  vector_.Clear();
}
const ::std::string& StringVector::vector(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.StringVector.vector)
  return vector_.Get(index);
}
::std::string* StringVector::mutable_vector(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.StringVector.vector)
  return vector_.Mutable(index);
}
void StringVector::set_vector(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:CoreML.Specification.StringVector.vector)
  vector_.Mutable(index)->assign(value);
}
#if LANG_CXX11
void StringVector::set_vector(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:CoreML.Specification.StringVector.vector)
  vector_.Mutable(index)->assign(std::move(value));
}
#endif
void StringVector::set_vector(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  vector_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.StringVector.vector)
}
void StringVector::set_vector(int index, const char* value, size_t size) {
  vector_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.StringVector.vector)
}
::std::string* StringVector::add_vector() {
  // @@protoc_insertion_point(field_add_mutable:CoreML.Specification.StringVector.vector)
  return vector_.Add();
}
void StringVector::add_vector(const ::std::string& value) {
  vector_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.StringVector.vector)
}
#if LANG_CXX11
void StringVector::add_vector(::std::string&& value) {
  vector_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CoreML.Specification.StringVector.vector)
}
#endif
void StringVector::add_vector(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  vector_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CoreML.Specification.StringVector.vector)
}
void StringVector::add_vector(const char* value, size_t size) {
  vector_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CoreML.Specification.StringVector.vector)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
StringVector::vector() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.StringVector.vector)
  return vector_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
StringVector::mutable_vector() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.StringVector.vector)
  return &vector_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Int64Vector::kVectorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Int64Vector::Int64Vector()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_DataStructures_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.Int64Vector)
}
Int64Vector::Int64Vector(const Int64Vector& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      vector_(from.vector_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Int64Vector)
}

void Int64Vector::SharedCtor() {
  _cached_size_ = 0;
}

Int64Vector::~Int64Vector() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Int64Vector)
  SharedDtor();
}

void Int64Vector::SharedDtor() {
}

void Int64Vector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Int64Vector& Int64Vector::default_instance() {
  protobuf_DataStructures_2eproto::InitDefaults();
  return *internal_default_instance();
}

Int64Vector* Int64Vector::New(::google::protobuf::Arena* arena) const {
  Int64Vector* n = new Int64Vector;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Int64Vector::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Int64Vector)
  vector_.Clear();
}

bool Int64Vector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.Int64Vector)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int64 vector = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_vector())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(8u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 10u, input, this->mutable_vector())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.Int64Vector)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.Int64Vector)
  return false;
#undef DO_
}

void Int64Vector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.Int64Vector)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 vector = 1;
  if (this->vector_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_vector_cached_byte_size_);
  }
  for (int i = 0, n = this->vector_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64NoTag(
      this->vector(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.Int64Vector)
}

size_t Int64Vector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Int64Vector)
  size_t total_size = 0;

  // repeated int64 vector = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int64Size(this->vector_);
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _vector_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Int64Vector::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Int64Vector*>(&from));
}

void Int64Vector::MergeFrom(const Int64Vector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Int64Vector)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  vector_.MergeFrom(from.vector_);
}

void Int64Vector::CopyFrom(const Int64Vector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Int64Vector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int64Vector::IsInitialized() const {
  return true;
}

void Int64Vector::Swap(Int64Vector* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Int64Vector::InternalSwap(Int64Vector* other) {
  vector_.InternalSwap(&other->vector_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Int64Vector::GetTypeName() const {
  return "CoreML.Specification.Int64Vector";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Int64Vector

// repeated int64 vector = 1;
int Int64Vector::vector_size() const {
  return vector_.size();
}
void Int64Vector::clear_vector() {
  vector_.Clear();
}
::google::protobuf::int64 Int64Vector::vector(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Int64Vector.vector)
  return vector_.Get(index);
}
void Int64Vector::set_vector(int index, ::google::protobuf::int64 value) {
  vector_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Int64Vector.vector)
}
void Int64Vector::add_vector(::google::protobuf::int64 value) {
  vector_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.Int64Vector.vector)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Int64Vector::vector() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.Int64Vector.vector)
  return vector_;
}
::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Int64Vector::mutable_vector() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.Int64Vector.vector)
  return &vector_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FloatVector::kVectorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FloatVector::FloatVector()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_DataStructures_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.FloatVector)
}
FloatVector::FloatVector(const FloatVector& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      vector_(from.vector_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.FloatVector)
}

void FloatVector::SharedCtor() {
  _cached_size_ = 0;
}

FloatVector::~FloatVector() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.FloatVector)
  SharedDtor();
}

void FloatVector::SharedDtor() {
}

void FloatVector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FloatVector& FloatVector::default_instance() {
  protobuf_DataStructures_2eproto::InitDefaults();
  return *internal_default_instance();
}

FloatVector* FloatVector::New(::google::protobuf::Arena* arena) const {
  FloatVector* n = new FloatVector;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FloatVector::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.FloatVector)
  vector_.Clear();
}

bool FloatVector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.FloatVector)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float vector = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_vector())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(13u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 10u, input, this->mutable_vector())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.FloatVector)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.FloatVector)
  return false;
#undef DO_
}

void FloatVector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.FloatVector)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float vector = 1;
  if (this->vector_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_vector_cached_byte_size_);
    ::google::protobuf::internal::WireFormatLite::WriteFloatArray(
      this->vector().data(), this->vector_size(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.FloatVector)
}

size_t FloatVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.FloatVector)
  size_t total_size = 0;

  // repeated float vector = 1;
  {
    unsigned int count = this->vector_size();
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _vector_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FloatVector::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FloatVector*>(&from));
}

void FloatVector::MergeFrom(const FloatVector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.FloatVector)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  vector_.MergeFrom(from.vector_);
}

void FloatVector::CopyFrom(const FloatVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.FloatVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FloatVector::IsInitialized() const {
  return true;
}

void FloatVector::Swap(FloatVector* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FloatVector::InternalSwap(FloatVector* other) {
  vector_.InternalSwap(&other->vector_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FloatVector::GetTypeName() const {
  return "CoreML.Specification.FloatVector";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FloatVector

// repeated float vector = 1;
int FloatVector::vector_size() const {
  return vector_.size();
}
void FloatVector::clear_vector() {
  vector_.Clear();
}
float FloatVector::vector(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FloatVector.vector)
  return vector_.Get(index);
}
void FloatVector::set_vector(int index, float value) {
  vector_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.FloatVector.vector)
}
void FloatVector::add_vector(float value) {
  vector_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.FloatVector.vector)
}
const ::google::protobuf::RepeatedField< float >&
FloatVector::vector() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.FloatVector.vector)
  return vector_;
}
::google::protobuf::RepeatedField< float >*
FloatVector::mutable_vector() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.FloatVector.vector)
  return &vector_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DoubleVector::kVectorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DoubleVector::DoubleVector()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_DataStructures_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.DoubleVector)
}
DoubleVector::DoubleVector(const DoubleVector& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      vector_(from.vector_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DoubleVector)
}

void DoubleVector::SharedCtor() {
  _cached_size_ = 0;
}

DoubleVector::~DoubleVector() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DoubleVector)
  SharedDtor();
}

void DoubleVector::SharedDtor() {
}

void DoubleVector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DoubleVector& DoubleVector::default_instance() {
  protobuf_DataStructures_2eproto::InitDefaults();
  return *internal_default_instance();
}

DoubleVector* DoubleVector::New(::google::protobuf::Arena* arena) const {
  DoubleVector* n = new DoubleVector;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DoubleVector::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DoubleVector)
  vector_.Clear();
}

bool DoubleVector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.DoubleVector)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double vector = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_vector())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(9u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 10u, input, this->mutable_vector())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.DoubleVector)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.DoubleVector)
  return false;
#undef DO_
}

void DoubleVector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.DoubleVector)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double vector = 1;
  if (this->vector_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_vector_cached_byte_size_);
    ::google::protobuf::internal::WireFormatLite::WriteDoubleArray(
      this->vector().data(), this->vector_size(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.DoubleVector)
}

size_t DoubleVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DoubleVector)
  size_t total_size = 0;

  // repeated double vector = 1;
  {
    unsigned int count = this->vector_size();
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _vector_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DoubleVector::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DoubleVector*>(&from));
}

void DoubleVector::MergeFrom(const DoubleVector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DoubleVector)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  vector_.MergeFrom(from.vector_);
}

void DoubleVector::CopyFrom(const DoubleVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DoubleVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoubleVector::IsInitialized() const {
  return true;
}

void DoubleVector::Swap(DoubleVector* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DoubleVector::InternalSwap(DoubleVector* other) {
  vector_.InternalSwap(&other->vector_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DoubleVector::GetTypeName() const {
  return "CoreML.Specification.DoubleVector";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DoubleVector

// repeated double vector = 1;
int DoubleVector::vector_size() const {
  return vector_.size();
}
void DoubleVector::clear_vector() {
  vector_.Clear();
}
double DoubleVector::vector(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DoubleVector.vector)
  return vector_.Get(index);
}
void DoubleVector::set_vector(int index, double value) {
  vector_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.DoubleVector.vector)
}
void DoubleVector::add_vector(double value) {
  vector_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.DoubleVector.vector)
}
const ::google::protobuf::RepeatedField< double >&
DoubleVector::vector() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.DoubleVector.vector)
  return vector_;
}
::google::protobuf::RepeatedField< double >*
DoubleVector::mutable_vector() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.DoubleVector.vector)
  return &vector_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Int64Range::kMinValueFieldNumber;
const int Int64Range::kMaxValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Int64Range::Int64Range()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_DataStructures_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.Int64Range)
}
Int64Range::Int64Range(const Int64Range& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&minvalue_, &from.minvalue_,
    reinterpret_cast<char*>(&maxvalue_) -
    reinterpret_cast<char*>(&minvalue_) + sizeof(maxvalue_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Int64Range)
}

void Int64Range::SharedCtor() {
  ::memset(&minvalue_, 0, reinterpret_cast<char*>(&maxvalue_) -
    reinterpret_cast<char*>(&minvalue_) + sizeof(maxvalue_));
  _cached_size_ = 0;
}

Int64Range::~Int64Range() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Int64Range)
  SharedDtor();
}

void Int64Range::SharedDtor() {
}

void Int64Range::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Int64Range& Int64Range::default_instance() {
  protobuf_DataStructures_2eproto::InitDefaults();
  return *internal_default_instance();
}

Int64Range* Int64Range::New(::google::protobuf::Arena* arena) const {
  Int64Range* n = new Int64Range;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Int64Range::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Int64Range)
  ::memset(&minvalue_, 0, reinterpret_cast<char*>(&maxvalue_) -
    reinterpret_cast<char*>(&minvalue_) + sizeof(maxvalue_));
}

bool Int64Range::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.Int64Range)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int64 minValue = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &minvalue_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 maxValue = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &maxvalue_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.Int64Range)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.Int64Range)
  return false;
#undef DO_
}

void Int64Range::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.Int64Range)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 minValue = 1;
  if (this->minvalue() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->minvalue(), output);
  }

  // int64 maxValue = 2;
  if (this->maxvalue() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->maxvalue(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.Int64Range)
}

size_t Int64Range::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Int64Range)
  size_t total_size = 0;

  // int64 minValue = 1;
  if (this->minvalue() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->minvalue());
  }

  // int64 maxValue = 2;
  if (this->maxvalue() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->maxvalue());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Int64Range::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Int64Range*>(&from));
}

void Int64Range::MergeFrom(const Int64Range& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Int64Range)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.minvalue() != 0) {
    set_minvalue(from.minvalue());
  }
  if (from.maxvalue() != 0) {
    set_maxvalue(from.maxvalue());
  }
}

void Int64Range::CopyFrom(const Int64Range& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Int64Range)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int64Range::IsInitialized() const {
  return true;
}

void Int64Range::Swap(Int64Range* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Int64Range::InternalSwap(Int64Range* other) {
  std::swap(minvalue_, other->minvalue_);
  std::swap(maxvalue_, other->maxvalue_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Int64Range::GetTypeName() const {
  return "CoreML.Specification.Int64Range";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Int64Range

// int64 minValue = 1;
void Int64Range::clear_minvalue() {
  minvalue_ = GOOGLE_LONGLONG(0);
}
::google::protobuf::int64 Int64Range::minvalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Int64Range.minValue)
  return minvalue_;
}
void Int64Range::set_minvalue(::google::protobuf::int64 value) {
  
  minvalue_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.Int64Range.minValue)
}

// int64 maxValue = 2;
void Int64Range::clear_maxvalue() {
  maxvalue_ = GOOGLE_LONGLONG(0);
}
::google::protobuf::int64 Int64Range::maxvalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Int64Range.maxValue)
  return maxvalue_;
}
void Int64Range::set_maxvalue(::google::protobuf::int64 value) {
  
  maxvalue_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.Int64Range.maxValue)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Int64Set::kValuesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Int64Set::Int64Set()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_DataStructures_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.Int64Set)
}
Int64Set::Int64Set(const Int64Set& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      values_(from.values_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Int64Set)
}

void Int64Set::SharedCtor() {
  _cached_size_ = 0;
}

Int64Set::~Int64Set() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Int64Set)
  SharedDtor();
}

void Int64Set::SharedDtor() {
}

void Int64Set::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Int64Set& Int64Set::default_instance() {
  protobuf_DataStructures_2eproto::InitDefaults();
  return *internal_default_instance();
}

Int64Set* Int64Set::New(::google::protobuf::Arena* arena) const {
  Int64Set* n = new Int64Set;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Int64Set::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Int64Set)
  values_.Clear();
}

bool Int64Set::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.Int64Set)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int64 values = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_values())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(8u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 10u, input, this->mutable_values())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.Int64Set)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.Int64Set)
  return false;
#undef DO_
}

void Int64Set::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.Int64Set)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 values = 1;
  if (this->values_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_values_cached_byte_size_);
  }
  for (int i = 0, n = this->values_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64NoTag(
      this->values(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.Int64Set)
}

size_t Int64Set::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Int64Set)
  size_t total_size = 0;

  // repeated int64 values = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int64Size(this->values_);
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _values_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Int64Set::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Int64Set*>(&from));
}

void Int64Set::MergeFrom(const Int64Set& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Int64Set)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
}

void Int64Set::CopyFrom(const Int64Set& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Int64Set)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int64Set::IsInitialized() const {
  return true;
}

void Int64Set::Swap(Int64Set* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Int64Set::InternalSwap(Int64Set* other) {
  values_.InternalSwap(&other->values_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Int64Set::GetTypeName() const {
  return "CoreML.Specification.Int64Set";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Int64Set

// repeated int64 values = 1;
int Int64Set::values_size() const {
  return values_.size();
}
void Int64Set::clear_values() {
  values_.Clear();
}
::google::protobuf::int64 Int64Set::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Int64Set.values)
  return values_.Get(index);
}
void Int64Set::set_values(int index, ::google::protobuf::int64 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Int64Set.values)
}
void Int64Set::add_values(::google::protobuf::int64 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.Int64Set.values)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Int64Set::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.Int64Set.values)
  return values_;
}
::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Int64Set::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.Int64Set.values)
  return &values_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DoubleRange::kMinValueFieldNumber;
const int DoubleRange::kMaxValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DoubleRange::DoubleRange()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_DataStructures_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.DoubleRange)
}
DoubleRange::DoubleRange(const DoubleRange& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&minvalue_, &from.minvalue_,
    reinterpret_cast<char*>(&maxvalue_) -
    reinterpret_cast<char*>(&minvalue_) + sizeof(maxvalue_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DoubleRange)
}

void DoubleRange::SharedCtor() {
  ::memset(&minvalue_, 0, reinterpret_cast<char*>(&maxvalue_) -
    reinterpret_cast<char*>(&minvalue_) + sizeof(maxvalue_));
  _cached_size_ = 0;
}

DoubleRange::~DoubleRange() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DoubleRange)
  SharedDtor();
}

void DoubleRange::SharedDtor() {
}

void DoubleRange::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DoubleRange& DoubleRange::default_instance() {
  protobuf_DataStructures_2eproto::InitDefaults();
  return *internal_default_instance();
}

DoubleRange* DoubleRange::New(::google::protobuf::Arena* arena) const {
  DoubleRange* n = new DoubleRange;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DoubleRange::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DoubleRange)
  ::memset(&minvalue_, 0, reinterpret_cast<char*>(&maxvalue_) -
    reinterpret_cast<char*>(&minvalue_) + sizeof(maxvalue_));
}

bool DoubleRange::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.DoubleRange)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // double minValue = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &minvalue_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double maxValue = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &maxvalue_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.DoubleRange)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.DoubleRange)
  return false;
#undef DO_
}

void DoubleRange::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.DoubleRange)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double minValue = 1;
  if (this->minvalue() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->minvalue(), output);
  }

  // double maxValue = 2;
  if (this->maxvalue() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->maxvalue(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.DoubleRange)
}

size_t DoubleRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DoubleRange)
  size_t total_size = 0;

  // double minValue = 1;
  if (this->minvalue() != 0) {
    total_size += 1 + 8;
  }

  // double maxValue = 2;
  if (this->maxvalue() != 0) {
    total_size += 1 + 8;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DoubleRange::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DoubleRange*>(&from));
}

void DoubleRange::MergeFrom(const DoubleRange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DoubleRange)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.minvalue() != 0) {
    set_minvalue(from.minvalue());
  }
  if (from.maxvalue() != 0) {
    set_maxvalue(from.maxvalue());
  }
}

void DoubleRange::CopyFrom(const DoubleRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DoubleRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoubleRange::IsInitialized() const {
  return true;
}

void DoubleRange::Swap(DoubleRange* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DoubleRange::InternalSwap(DoubleRange* other) {
  std::swap(minvalue_, other->minvalue_);
  std::swap(maxvalue_, other->maxvalue_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DoubleRange::GetTypeName() const {
  return "CoreML.Specification.DoubleRange";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DoubleRange

// double minValue = 1;
void DoubleRange::clear_minvalue() {
  minvalue_ = 0;
}
double DoubleRange::minvalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DoubleRange.minValue)
  return minvalue_;
}
void DoubleRange::set_minvalue(double value) {
  
  minvalue_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.DoubleRange.minValue)
}

// double maxValue = 2;
void DoubleRange::clear_maxvalue() {
  maxvalue_ = 0;
}
double DoubleRange::maxvalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DoubleRange.maxValue)
  return maxvalue_;
}
void DoubleRange::set_maxvalue(double value) {
  
  maxvalue_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.DoubleRange.maxValue)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace Specification
}  // namespace CoreML

// @@protoc_insertion_point(global_scope)
