// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NearestNeighbors.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_NearestNeighbors_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_NearestNeighbors_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "DataStructures.pb.h"
#include "Parameters.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_NearestNeighbors_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_NearestNeighbors_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace CoreML {
namespace Specification {
class InverseDistanceWeighting;
struct InverseDistanceWeightingDefaultTypeInternal;
extern InverseDistanceWeightingDefaultTypeInternal _InverseDistanceWeighting_default_instance_;
class KNearestNeighborsClassifier;
struct KNearestNeighborsClassifierDefaultTypeInternal;
extern KNearestNeighborsClassifierDefaultTypeInternal _KNearestNeighborsClassifier_default_instance_;
class LinearIndex;
struct LinearIndexDefaultTypeInternal;
extern LinearIndexDefaultTypeInternal _LinearIndex_default_instance_;
class NearestNeighborsIndex;
struct NearestNeighborsIndexDefaultTypeInternal;
extern NearestNeighborsIndexDefaultTypeInternal _NearestNeighborsIndex_default_instance_;
class SingleKdTreeIndex;
struct SingleKdTreeIndexDefaultTypeInternal;
extern SingleKdTreeIndexDefaultTypeInternal _SingleKdTreeIndex_default_instance_;
class SquaredEuclideanDistance;
struct SquaredEuclideanDistanceDefaultTypeInternal;
extern SquaredEuclideanDistanceDefaultTypeInternal _SquaredEuclideanDistance_default_instance_;
class UniformWeighting;
struct UniformWeightingDefaultTypeInternal;
extern UniformWeightingDefaultTypeInternal _UniformWeighting_default_instance_;
}  // namespace Specification
}  // namespace CoreML
PROTOBUF_NAMESPACE_OPEN
template<> ::CoreML::Specification::InverseDistanceWeighting* Arena::CreateMaybeMessage<::CoreML::Specification::InverseDistanceWeighting>(Arena*);
template<> ::CoreML::Specification::KNearestNeighborsClassifier* Arena::CreateMaybeMessage<::CoreML::Specification::KNearestNeighborsClassifier>(Arena*);
template<> ::CoreML::Specification::LinearIndex* Arena::CreateMaybeMessage<::CoreML::Specification::LinearIndex>(Arena*);
template<> ::CoreML::Specification::NearestNeighborsIndex* Arena::CreateMaybeMessage<::CoreML::Specification::NearestNeighborsIndex>(Arena*);
template<> ::CoreML::Specification::SingleKdTreeIndex* Arena::CreateMaybeMessage<::CoreML::Specification::SingleKdTreeIndex>(Arena*);
template<> ::CoreML::Specification::SquaredEuclideanDistance* Arena::CreateMaybeMessage<::CoreML::Specification::SquaredEuclideanDistance>(Arena*);
template<> ::CoreML::Specification::UniformWeighting* Arena::CreateMaybeMessage<::CoreML::Specification::UniformWeighting>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace CoreML {
namespace Specification {

// ===================================================================

class KNearestNeighborsClassifier final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.KNearestNeighborsClassifier) */ {
 public:
  inline KNearestNeighborsClassifier() : KNearestNeighborsClassifier(nullptr) {}
  ~KNearestNeighborsClassifier() override;
  explicit constexpr KNearestNeighborsClassifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KNearestNeighborsClassifier(const KNearestNeighborsClassifier& from);
  KNearestNeighborsClassifier(KNearestNeighborsClassifier&& from) noexcept
    : KNearestNeighborsClassifier() {
    *this = ::std::move(from);
  }

  inline KNearestNeighborsClassifier& operator=(const KNearestNeighborsClassifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline KNearestNeighborsClassifier& operator=(KNearestNeighborsClassifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const KNearestNeighborsClassifier& default_instance() {
    return *internal_default_instance();
  }
  enum ClassLabelsCase {
    kStringClassLabels = 100,
    kInt64ClassLabels = 101,
    CLASSLABELS_NOT_SET = 0,
  };

  enum DefaultClassLabelCase {
    kDefaultStringLabel = 110,
    kDefaultInt64Label = 111,
    DEFAULTCLASSLABEL_NOT_SET = 0,
  };

  enum WeightingSchemeCase {
    kUniformWeighting = 200,
    kInverseDistanceWeighting = 210,
    WEIGHTINGSCHEME_NOT_SET = 0,
  };

  static inline const KNearestNeighborsClassifier* internal_default_instance() {
    return reinterpret_cast<const KNearestNeighborsClassifier*>(
               &_KNearestNeighborsClassifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(KNearestNeighborsClassifier& a, KNearestNeighborsClassifier& b) {
    a.Swap(&b);
  }
  inline void Swap(KNearestNeighborsClassifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KNearestNeighborsClassifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KNearestNeighborsClassifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KNearestNeighborsClassifier>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KNearestNeighborsClassifier& from);
  void MergeFrom(const KNearestNeighborsClassifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KNearestNeighborsClassifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.KNearestNeighborsClassifier";
  }
  protected:
  explicit KNearestNeighborsClassifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNearestNeighborsIndexFieldNumber = 1,
    kNumberOfNeighborsFieldNumber = 3,
    kStringClassLabelsFieldNumber = 100,
    kInt64ClassLabelsFieldNumber = 101,
    kDefaultStringLabelFieldNumber = 110,
    kDefaultInt64LabelFieldNumber = 111,
    kUniformWeightingFieldNumber = 200,
    kInverseDistanceWeightingFieldNumber = 210,
  };
  // .CoreML.Specification.NearestNeighborsIndex nearestNeighborsIndex = 1;
  bool has_nearestneighborsindex() const;
  private:
  bool _internal_has_nearestneighborsindex() const;
  public:
  void clear_nearestneighborsindex();
  const ::CoreML::Specification::NearestNeighborsIndex& nearestneighborsindex() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::NearestNeighborsIndex* release_nearestneighborsindex();
  ::CoreML::Specification::NearestNeighborsIndex* mutable_nearestneighborsindex();
  void set_allocated_nearestneighborsindex(::CoreML::Specification::NearestNeighborsIndex* nearestneighborsindex);
  private:
  const ::CoreML::Specification::NearestNeighborsIndex& _internal_nearestneighborsindex() const;
  ::CoreML::Specification::NearestNeighborsIndex* _internal_mutable_nearestneighborsindex();
  public:
  void unsafe_arena_set_allocated_nearestneighborsindex(
      ::CoreML::Specification::NearestNeighborsIndex* nearestneighborsindex);
  ::CoreML::Specification::NearestNeighborsIndex* unsafe_arena_release_nearestneighborsindex();

  // .CoreML.Specification.Int64Parameter numberOfNeighbors = 3;
  bool has_numberofneighbors() const;
  private:
  bool _internal_has_numberofneighbors() const;
  public:
  void clear_numberofneighbors();
  const ::CoreML::Specification::Int64Parameter& numberofneighbors() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::Int64Parameter* release_numberofneighbors();
  ::CoreML::Specification::Int64Parameter* mutable_numberofneighbors();
  void set_allocated_numberofneighbors(::CoreML::Specification::Int64Parameter* numberofneighbors);
  private:
  const ::CoreML::Specification::Int64Parameter& _internal_numberofneighbors() const;
  ::CoreML::Specification::Int64Parameter* _internal_mutable_numberofneighbors();
  public:
  void unsafe_arena_set_allocated_numberofneighbors(
      ::CoreML::Specification::Int64Parameter* numberofneighbors);
  ::CoreML::Specification::Int64Parameter* unsafe_arena_release_numberofneighbors();

  // .CoreML.Specification.StringVector stringClassLabels = 100;
  bool has_stringclasslabels() const;
  private:
  bool _internal_has_stringclasslabels() const;
  public:
  void clear_stringclasslabels();
  const ::CoreML::Specification::StringVector& stringclasslabels() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::StringVector* release_stringclasslabels();
  ::CoreML::Specification::StringVector* mutable_stringclasslabels();
  void set_allocated_stringclasslabels(::CoreML::Specification::StringVector* stringclasslabels);
  private:
  const ::CoreML::Specification::StringVector& _internal_stringclasslabels() const;
  ::CoreML::Specification::StringVector* _internal_mutable_stringclasslabels();
  public:
  void unsafe_arena_set_allocated_stringclasslabels(
      ::CoreML::Specification::StringVector* stringclasslabels);
  ::CoreML::Specification::StringVector* unsafe_arena_release_stringclasslabels();

  // .CoreML.Specification.Int64Vector int64ClassLabels = 101;
  bool has_int64classlabels() const;
  private:
  bool _internal_has_int64classlabels() const;
  public:
  void clear_int64classlabels();
  const ::CoreML::Specification::Int64Vector& int64classlabels() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::Int64Vector* release_int64classlabels();
  ::CoreML::Specification::Int64Vector* mutable_int64classlabels();
  void set_allocated_int64classlabels(::CoreML::Specification::Int64Vector* int64classlabels);
  private:
  const ::CoreML::Specification::Int64Vector& _internal_int64classlabels() const;
  ::CoreML::Specification::Int64Vector* _internal_mutable_int64classlabels();
  public:
  void unsafe_arena_set_allocated_int64classlabels(
      ::CoreML::Specification::Int64Vector* int64classlabels);
  ::CoreML::Specification::Int64Vector* unsafe_arena_release_int64classlabels();

  // string defaultStringLabel = 110;
  bool has_defaultstringlabel() const;
  private:
  bool _internal_has_defaultstringlabel() const;
  public:
  void clear_defaultstringlabel();
  const std::string& defaultstringlabel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_defaultstringlabel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_defaultstringlabel();
  PROTOBUF_NODISCARD std::string* release_defaultstringlabel();
  void set_allocated_defaultstringlabel(std::string* defaultstringlabel);
  private:
  const std::string& _internal_defaultstringlabel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_defaultstringlabel(const std::string& value);
  std::string* _internal_mutable_defaultstringlabel();
  public:

  // int64 defaultInt64Label = 111;
  bool has_defaultint64label() const;
  private:
  bool _internal_has_defaultint64label() const;
  public:
  void clear_defaultint64label();
  int64_t defaultint64label() const;
  void set_defaultint64label(int64_t value);
  private:
  int64_t _internal_defaultint64label() const;
  void _internal_set_defaultint64label(int64_t value);
  public:

  // .CoreML.Specification.UniformWeighting uniformWeighting = 200;
  bool has_uniformweighting() const;
  private:
  bool _internal_has_uniformweighting() const;
  public:
  void clear_uniformweighting();
  const ::CoreML::Specification::UniformWeighting& uniformweighting() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::UniformWeighting* release_uniformweighting();
  ::CoreML::Specification::UniformWeighting* mutable_uniformweighting();
  void set_allocated_uniformweighting(::CoreML::Specification::UniformWeighting* uniformweighting);
  private:
  const ::CoreML::Specification::UniformWeighting& _internal_uniformweighting() const;
  ::CoreML::Specification::UniformWeighting* _internal_mutable_uniformweighting();
  public:
  void unsafe_arena_set_allocated_uniformweighting(
      ::CoreML::Specification::UniformWeighting* uniformweighting);
  ::CoreML::Specification::UniformWeighting* unsafe_arena_release_uniformweighting();

  // .CoreML.Specification.InverseDistanceWeighting inverseDistanceWeighting = 210;
  bool has_inversedistanceweighting() const;
  private:
  bool _internal_has_inversedistanceweighting() const;
  public:
  void clear_inversedistanceweighting();
  const ::CoreML::Specification::InverseDistanceWeighting& inversedistanceweighting() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::InverseDistanceWeighting* release_inversedistanceweighting();
  ::CoreML::Specification::InverseDistanceWeighting* mutable_inversedistanceweighting();
  void set_allocated_inversedistanceweighting(::CoreML::Specification::InverseDistanceWeighting* inversedistanceweighting);
  private:
  const ::CoreML::Specification::InverseDistanceWeighting& _internal_inversedistanceweighting() const;
  ::CoreML::Specification::InverseDistanceWeighting* _internal_mutable_inversedistanceweighting();
  public:
  void unsafe_arena_set_allocated_inversedistanceweighting(
      ::CoreML::Specification::InverseDistanceWeighting* inversedistanceweighting);
  ::CoreML::Specification::InverseDistanceWeighting* unsafe_arena_release_inversedistanceweighting();

  void clear_ClassLabels();
  ClassLabelsCase ClassLabels_case() const;
  void clear_DefaultClassLabel();
  DefaultClassLabelCase DefaultClassLabel_case() const;
  void clear_WeightingScheme();
  WeightingSchemeCase WeightingScheme_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.KNearestNeighborsClassifier)
 private:
  class _Internal;
  void set_has_stringclasslabels();
  void set_has_int64classlabels();
  void set_has_defaultstringlabel();
  void set_has_defaultint64label();
  void set_has_uniformweighting();
  void set_has_inversedistanceweighting();

  inline bool has_ClassLabels() const;
  inline void clear_has_ClassLabels();

  inline bool has_DefaultClassLabel() const;
  inline void clear_has_DefaultClassLabel();

  inline bool has_WeightingScheme() const;
  inline void clear_has_WeightingScheme();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::CoreML::Specification::NearestNeighborsIndex* nearestneighborsindex_;
  ::CoreML::Specification::Int64Parameter* numberofneighbors_;
  union ClassLabelsUnion {
    constexpr ClassLabelsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CoreML::Specification::StringVector* stringclasslabels_;
    ::CoreML::Specification::Int64Vector* int64classlabels_;
  } ClassLabels_;
  union DefaultClassLabelUnion {
    constexpr DefaultClassLabelUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr defaultstringlabel_;
    int64_t defaultint64label_;
  } DefaultClassLabel_;
  union WeightingSchemeUnion {
    constexpr WeightingSchemeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CoreML::Specification::UniformWeighting* uniformweighting_;
    ::CoreML::Specification::InverseDistanceWeighting* inversedistanceweighting_;
  } WeightingScheme_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[3];

  friend struct ::TableStruct_NearestNeighbors_2eproto;
};
// -------------------------------------------------------------------

class NearestNeighborsIndex final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.NearestNeighborsIndex) */ {
 public:
  inline NearestNeighborsIndex() : NearestNeighborsIndex(nullptr) {}
  ~NearestNeighborsIndex() override;
  explicit constexpr NearestNeighborsIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NearestNeighborsIndex(const NearestNeighborsIndex& from);
  NearestNeighborsIndex(NearestNeighborsIndex&& from) noexcept
    : NearestNeighborsIndex() {
    *this = ::std::move(from);
  }

  inline NearestNeighborsIndex& operator=(const NearestNeighborsIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline NearestNeighborsIndex& operator=(NearestNeighborsIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const NearestNeighborsIndex& default_instance() {
    return *internal_default_instance();
  }
  enum IndexTypeCase {
    kLinearIndex = 100,
    kSingleKdTreeIndex = 110,
    INDEXTYPE_NOT_SET = 0,
  };

  enum DistanceFunctionCase {
    kSquaredEuclideanDistance = 200,
    DISTANCEFUNCTION_NOT_SET = 0,
  };

  static inline const NearestNeighborsIndex* internal_default_instance() {
    return reinterpret_cast<const NearestNeighborsIndex*>(
               &_NearestNeighborsIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NearestNeighborsIndex& a, NearestNeighborsIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(NearestNeighborsIndex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NearestNeighborsIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NearestNeighborsIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NearestNeighborsIndex>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NearestNeighborsIndex& from);
  void MergeFrom(const NearestNeighborsIndex& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NearestNeighborsIndex* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.NearestNeighborsIndex";
  }
  protected:
  explicit NearestNeighborsIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFloatSamplesFieldNumber = 2,
    kNumberOfDimensionsFieldNumber = 1,
    kLinearIndexFieldNumber = 100,
    kSingleKdTreeIndexFieldNumber = 110,
    kSquaredEuclideanDistanceFieldNumber = 200,
  };
  // repeated .CoreML.Specification.FloatVector floatSamples = 2;
  int floatsamples_size() const;
  private:
  int _internal_floatsamples_size() const;
  public:
  void clear_floatsamples();
  ::CoreML::Specification::FloatVector* mutable_floatsamples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FloatVector >*
      mutable_floatsamples();
  private:
  const ::CoreML::Specification::FloatVector& _internal_floatsamples(int index) const;
  ::CoreML::Specification::FloatVector* _internal_add_floatsamples();
  public:
  const ::CoreML::Specification::FloatVector& floatsamples(int index) const;
  ::CoreML::Specification::FloatVector* add_floatsamples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FloatVector >&
      floatsamples() const;

  // int32 numberOfDimensions = 1;
  void clear_numberofdimensions();
  int32_t numberofdimensions() const;
  void set_numberofdimensions(int32_t value);
  private:
  int32_t _internal_numberofdimensions() const;
  void _internal_set_numberofdimensions(int32_t value);
  public:

  // .CoreML.Specification.LinearIndex linearIndex = 100;
  bool has_linearindex() const;
  private:
  bool _internal_has_linearindex() const;
  public:
  void clear_linearindex();
  const ::CoreML::Specification::LinearIndex& linearindex() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::LinearIndex* release_linearindex();
  ::CoreML::Specification::LinearIndex* mutable_linearindex();
  void set_allocated_linearindex(::CoreML::Specification::LinearIndex* linearindex);
  private:
  const ::CoreML::Specification::LinearIndex& _internal_linearindex() const;
  ::CoreML::Specification::LinearIndex* _internal_mutable_linearindex();
  public:
  void unsafe_arena_set_allocated_linearindex(
      ::CoreML::Specification::LinearIndex* linearindex);
  ::CoreML::Specification::LinearIndex* unsafe_arena_release_linearindex();

  // .CoreML.Specification.SingleKdTreeIndex singleKdTreeIndex = 110;
  bool has_singlekdtreeindex() const;
  private:
  bool _internal_has_singlekdtreeindex() const;
  public:
  void clear_singlekdtreeindex();
  const ::CoreML::Specification::SingleKdTreeIndex& singlekdtreeindex() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::SingleKdTreeIndex* release_singlekdtreeindex();
  ::CoreML::Specification::SingleKdTreeIndex* mutable_singlekdtreeindex();
  void set_allocated_singlekdtreeindex(::CoreML::Specification::SingleKdTreeIndex* singlekdtreeindex);
  private:
  const ::CoreML::Specification::SingleKdTreeIndex& _internal_singlekdtreeindex() const;
  ::CoreML::Specification::SingleKdTreeIndex* _internal_mutable_singlekdtreeindex();
  public:
  void unsafe_arena_set_allocated_singlekdtreeindex(
      ::CoreML::Specification::SingleKdTreeIndex* singlekdtreeindex);
  ::CoreML::Specification::SingleKdTreeIndex* unsafe_arena_release_singlekdtreeindex();

  // .CoreML.Specification.SquaredEuclideanDistance squaredEuclideanDistance = 200;
  bool has_squaredeuclideandistance() const;
  private:
  bool _internal_has_squaredeuclideandistance() const;
  public:
  void clear_squaredeuclideandistance();
  const ::CoreML::Specification::SquaredEuclideanDistance& squaredeuclideandistance() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::SquaredEuclideanDistance* release_squaredeuclideandistance();
  ::CoreML::Specification::SquaredEuclideanDistance* mutable_squaredeuclideandistance();
  void set_allocated_squaredeuclideandistance(::CoreML::Specification::SquaredEuclideanDistance* squaredeuclideandistance);
  private:
  const ::CoreML::Specification::SquaredEuclideanDistance& _internal_squaredeuclideandistance() const;
  ::CoreML::Specification::SquaredEuclideanDistance* _internal_mutable_squaredeuclideandistance();
  public:
  void unsafe_arena_set_allocated_squaredeuclideandistance(
      ::CoreML::Specification::SquaredEuclideanDistance* squaredeuclideandistance);
  ::CoreML::Specification::SquaredEuclideanDistance* unsafe_arena_release_squaredeuclideandistance();

  void clear_IndexType();
  IndexTypeCase IndexType_case() const;
  void clear_DistanceFunction();
  DistanceFunctionCase DistanceFunction_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.NearestNeighborsIndex)
 private:
  class _Internal;
  void set_has_linearindex();
  void set_has_singlekdtreeindex();
  void set_has_squaredeuclideandistance();

  inline bool has_IndexType() const;
  inline void clear_has_IndexType();

  inline bool has_DistanceFunction() const;
  inline void clear_has_DistanceFunction();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FloatVector > floatsamples_;
  int32_t numberofdimensions_;
  union IndexTypeUnion {
    constexpr IndexTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CoreML::Specification::LinearIndex* linearindex_;
    ::CoreML::Specification::SingleKdTreeIndex* singlekdtreeindex_;
  } IndexType_;
  union DistanceFunctionUnion {
    constexpr DistanceFunctionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CoreML::Specification::SquaredEuclideanDistance* squaredeuclideandistance_;
  } DistanceFunction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[2];

  friend struct ::TableStruct_NearestNeighbors_2eproto;
};
// -------------------------------------------------------------------

class UniformWeighting final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.UniformWeighting) */ {
 public:
  inline UniformWeighting() : UniformWeighting(nullptr) {}
  ~UniformWeighting() override;
  explicit constexpr UniformWeighting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UniformWeighting(const UniformWeighting& from);
  UniformWeighting(UniformWeighting&& from) noexcept
    : UniformWeighting() {
    *this = ::std::move(from);
  }

  inline UniformWeighting& operator=(const UniformWeighting& from) {
    CopyFrom(from);
    return *this;
  }
  inline UniformWeighting& operator=(UniformWeighting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UniformWeighting& default_instance() {
    return *internal_default_instance();
  }
  static inline const UniformWeighting* internal_default_instance() {
    return reinterpret_cast<const UniformWeighting*>(
               &_UniformWeighting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UniformWeighting& a, UniformWeighting& b) {
    a.Swap(&b);
  }
  inline void Swap(UniformWeighting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UniformWeighting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UniformWeighting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UniformWeighting>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UniformWeighting& from);
  void MergeFrom(const UniformWeighting& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UniformWeighting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.UniformWeighting";
  }
  protected:
  explicit UniformWeighting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.UniformWeighting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NearestNeighbors_2eproto;
};
// -------------------------------------------------------------------

class InverseDistanceWeighting final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.InverseDistanceWeighting) */ {
 public:
  inline InverseDistanceWeighting() : InverseDistanceWeighting(nullptr) {}
  ~InverseDistanceWeighting() override;
  explicit constexpr InverseDistanceWeighting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InverseDistanceWeighting(const InverseDistanceWeighting& from);
  InverseDistanceWeighting(InverseDistanceWeighting&& from) noexcept
    : InverseDistanceWeighting() {
    *this = ::std::move(from);
  }

  inline InverseDistanceWeighting& operator=(const InverseDistanceWeighting& from) {
    CopyFrom(from);
    return *this;
  }
  inline InverseDistanceWeighting& operator=(InverseDistanceWeighting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const InverseDistanceWeighting& default_instance() {
    return *internal_default_instance();
  }
  static inline const InverseDistanceWeighting* internal_default_instance() {
    return reinterpret_cast<const InverseDistanceWeighting*>(
               &_InverseDistanceWeighting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InverseDistanceWeighting& a, InverseDistanceWeighting& b) {
    a.Swap(&b);
  }
  inline void Swap(InverseDistanceWeighting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InverseDistanceWeighting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InverseDistanceWeighting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InverseDistanceWeighting>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InverseDistanceWeighting& from);
  void MergeFrom(const InverseDistanceWeighting& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InverseDistanceWeighting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.InverseDistanceWeighting";
  }
  protected:
  explicit InverseDistanceWeighting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.InverseDistanceWeighting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NearestNeighbors_2eproto;
};
// -------------------------------------------------------------------

class LinearIndex final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.LinearIndex) */ {
 public:
  inline LinearIndex() : LinearIndex(nullptr) {}
  ~LinearIndex() override;
  explicit constexpr LinearIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinearIndex(const LinearIndex& from);
  LinearIndex(LinearIndex&& from) noexcept
    : LinearIndex() {
    *this = ::std::move(from);
  }

  inline LinearIndex& operator=(const LinearIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinearIndex& operator=(LinearIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LinearIndex& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinearIndex* internal_default_instance() {
    return reinterpret_cast<const LinearIndex*>(
               &_LinearIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LinearIndex& a, LinearIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(LinearIndex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinearIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinearIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinearIndex>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LinearIndex& from);
  void MergeFrom(const LinearIndex& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LinearIndex* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.LinearIndex";
  }
  protected:
  explicit LinearIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.LinearIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NearestNeighbors_2eproto;
};
// -------------------------------------------------------------------

class SingleKdTreeIndex final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.SingleKdTreeIndex) */ {
 public:
  inline SingleKdTreeIndex() : SingleKdTreeIndex(nullptr) {}
  ~SingleKdTreeIndex() override;
  explicit constexpr SingleKdTreeIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleKdTreeIndex(const SingleKdTreeIndex& from);
  SingleKdTreeIndex(SingleKdTreeIndex&& from) noexcept
    : SingleKdTreeIndex() {
    *this = ::std::move(from);
  }

  inline SingleKdTreeIndex& operator=(const SingleKdTreeIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleKdTreeIndex& operator=(SingleKdTreeIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SingleKdTreeIndex& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleKdTreeIndex* internal_default_instance() {
    return reinterpret_cast<const SingleKdTreeIndex*>(
               &_SingleKdTreeIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SingleKdTreeIndex& a, SingleKdTreeIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleKdTreeIndex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleKdTreeIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SingleKdTreeIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SingleKdTreeIndex>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SingleKdTreeIndex& from);
  void MergeFrom(const SingleKdTreeIndex& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SingleKdTreeIndex* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.SingleKdTreeIndex";
  }
  protected:
  explicit SingleKdTreeIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeafSizeFieldNumber = 1,
  };
  // int32 leafSize = 1;
  void clear_leafsize();
  int32_t leafsize() const;
  void set_leafsize(int32_t value);
  private:
  int32_t _internal_leafsize() const;
  void _internal_set_leafsize(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.SingleKdTreeIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t leafsize_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NearestNeighbors_2eproto;
};
// -------------------------------------------------------------------

class SquaredEuclideanDistance final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.SquaredEuclideanDistance) */ {
 public:
  inline SquaredEuclideanDistance() : SquaredEuclideanDistance(nullptr) {}
  ~SquaredEuclideanDistance() override;
  explicit constexpr SquaredEuclideanDistance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SquaredEuclideanDistance(const SquaredEuclideanDistance& from);
  SquaredEuclideanDistance(SquaredEuclideanDistance&& from) noexcept
    : SquaredEuclideanDistance() {
    *this = ::std::move(from);
  }

  inline SquaredEuclideanDistance& operator=(const SquaredEuclideanDistance& from) {
    CopyFrom(from);
    return *this;
  }
  inline SquaredEuclideanDistance& operator=(SquaredEuclideanDistance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SquaredEuclideanDistance& default_instance() {
    return *internal_default_instance();
  }
  static inline const SquaredEuclideanDistance* internal_default_instance() {
    return reinterpret_cast<const SquaredEuclideanDistance*>(
               &_SquaredEuclideanDistance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SquaredEuclideanDistance& a, SquaredEuclideanDistance& b) {
    a.Swap(&b);
  }
  inline void Swap(SquaredEuclideanDistance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SquaredEuclideanDistance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SquaredEuclideanDistance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SquaredEuclideanDistance>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SquaredEuclideanDistance& from);
  void MergeFrom(const SquaredEuclideanDistance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SquaredEuclideanDistance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.SquaredEuclideanDistance";
  }
  protected:
  explicit SquaredEuclideanDistance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.SquaredEuclideanDistance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NearestNeighbors_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// KNearestNeighborsClassifier

// .CoreML.Specification.NearestNeighborsIndex nearestNeighborsIndex = 1;
inline bool KNearestNeighborsClassifier::_internal_has_nearestneighborsindex() const {
  return this != internal_default_instance() && nearestneighborsindex_ != nullptr;
}
inline bool KNearestNeighborsClassifier::has_nearestneighborsindex() const {
  return _internal_has_nearestneighborsindex();
}
inline void KNearestNeighborsClassifier::clear_nearestneighborsindex() {
  if (GetArenaForAllocation() == nullptr && nearestneighborsindex_ != nullptr) {
    delete nearestneighborsindex_;
  }
  nearestneighborsindex_ = nullptr;
}
inline const ::CoreML::Specification::NearestNeighborsIndex& KNearestNeighborsClassifier::_internal_nearestneighborsindex() const {
  const ::CoreML::Specification::NearestNeighborsIndex* p = nearestneighborsindex_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::NearestNeighborsIndex&>(
      ::CoreML::Specification::_NearestNeighborsIndex_default_instance_);
}
inline const ::CoreML::Specification::NearestNeighborsIndex& KNearestNeighborsClassifier::nearestneighborsindex() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.KNearestNeighborsClassifier.nearestNeighborsIndex)
  return _internal_nearestneighborsindex();
}
inline void KNearestNeighborsClassifier::unsafe_arena_set_allocated_nearestneighborsindex(
    ::CoreML::Specification::NearestNeighborsIndex* nearestneighborsindex) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nearestneighborsindex_);
  }
  nearestneighborsindex_ = nearestneighborsindex;
  if (nearestneighborsindex) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.KNearestNeighborsClassifier.nearestNeighborsIndex)
}
inline ::CoreML::Specification::NearestNeighborsIndex* KNearestNeighborsClassifier::release_nearestneighborsindex() {
  
  ::CoreML::Specification::NearestNeighborsIndex* temp = nearestneighborsindex_;
  nearestneighborsindex_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::NearestNeighborsIndex* KNearestNeighborsClassifier::unsafe_arena_release_nearestneighborsindex() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.KNearestNeighborsClassifier.nearestNeighborsIndex)
  
  ::CoreML::Specification::NearestNeighborsIndex* temp = nearestneighborsindex_;
  nearestneighborsindex_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::NearestNeighborsIndex* KNearestNeighborsClassifier::_internal_mutable_nearestneighborsindex() {
  
  if (nearestneighborsindex_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::NearestNeighborsIndex>(GetArenaForAllocation());
    nearestneighborsindex_ = p;
  }
  return nearestneighborsindex_;
}
inline ::CoreML::Specification::NearestNeighborsIndex* KNearestNeighborsClassifier::mutable_nearestneighborsindex() {
  ::CoreML::Specification::NearestNeighborsIndex* _msg = _internal_mutable_nearestneighborsindex();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.KNearestNeighborsClassifier.nearestNeighborsIndex)
  return _msg;
}
inline void KNearestNeighborsClassifier::set_allocated_nearestneighborsindex(::CoreML::Specification::NearestNeighborsIndex* nearestneighborsindex) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete nearestneighborsindex_;
  }
  if (nearestneighborsindex) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::NearestNeighborsIndex>::GetOwningArena(nearestneighborsindex);
    if (message_arena != submessage_arena) {
      nearestneighborsindex = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nearestneighborsindex, submessage_arena);
    }
    
  } else {
    
  }
  nearestneighborsindex_ = nearestneighborsindex;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.KNearestNeighborsClassifier.nearestNeighborsIndex)
}

// .CoreML.Specification.Int64Parameter numberOfNeighbors = 3;
inline bool KNearestNeighborsClassifier::_internal_has_numberofneighbors() const {
  return this != internal_default_instance() && numberofneighbors_ != nullptr;
}
inline bool KNearestNeighborsClassifier::has_numberofneighbors() const {
  return _internal_has_numberofneighbors();
}
inline const ::CoreML::Specification::Int64Parameter& KNearestNeighborsClassifier::_internal_numberofneighbors() const {
  const ::CoreML::Specification::Int64Parameter* p = numberofneighbors_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::Int64Parameter&>(
      ::CoreML::Specification::_Int64Parameter_default_instance_);
}
inline const ::CoreML::Specification::Int64Parameter& KNearestNeighborsClassifier::numberofneighbors() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.KNearestNeighborsClassifier.numberOfNeighbors)
  return _internal_numberofneighbors();
}
inline void KNearestNeighborsClassifier::unsafe_arena_set_allocated_numberofneighbors(
    ::CoreML::Specification::Int64Parameter* numberofneighbors) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(numberofneighbors_);
  }
  numberofneighbors_ = numberofneighbors;
  if (numberofneighbors) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.KNearestNeighborsClassifier.numberOfNeighbors)
}
inline ::CoreML::Specification::Int64Parameter* KNearestNeighborsClassifier::release_numberofneighbors() {
  
  ::CoreML::Specification::Int64Parameter* temp = numberofneighbors_;
  numberofneighbors_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::Int64Parameter* KNearestNeighborsClassifier::unsafe_arena_release_numberofneighbors() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.KNearestNeighborsClassifier.numberOfNeighbors)
  
  ::CoreML::Specification::Int64Parameter* temp = numberofneighbors_;
  numberofneighbors_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::Int64Parameter* KNearestNeighborsClassifier::_internal_mutable_numberofneighbors() {
  
  if (numberofneighbors_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::Int64Parameter>(GetArenaForAllocation());
    numberofneighbors_ = p;
  }
  return numberofneighbors_;
}
inline ::CoreML::Specification::Int64Parameter* KNearestNeighborsClassifier::mutable_numberofneighbors() {
  ::CoreML::Specification::Int64Parameter* _msg = _internal_mutable_numberofneighbors();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.KNearestNeighborsClassifier.numberOfNeighbors)
  return _msg;
}
inline void KNearestNeighborsClassifier::set_allocated_numberofneighbors(::CoreML::Specification::Int64Parameter* numberofneighbors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(numberofneighbors_);
  }
  if (numberofneighbors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(numberofneighbors));
    if (message_arena != submessage_arena) {
      numberofneighbors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, numberofneighbors, submessage_arena);
    }
    
  } else {
    
  }
  numberofneighbors_ = numberofneighbors;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.KNearestNeighborsClassifier.numberOfNeighbors)
}

// .CoreML.Specification.StringVector stringClassLabels = 100;
inline bool KNearestNeighborsClassifier::_internal_has_stringclasslabels() const {
  return ClassLabels_case() == kStringClassLabels;
}
inline bool KNearestNeighborsClassifier::has_stringclasslabels() const {
  return _internal_has_stringclasslabels();
}
inline void KNearestNeighborsClassifier::set_has_stringclasslabels() {
  _oneof_case_[0] = kStringClassLabels;
}
inline ::CoreML::Specification::StringVector* KNearestNeighborsClassifier::release_stringclasslabels() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.KNearestNeighborsClassifier.stringClassLabels)
  if (_internal_has_stringclasslabels()) {
    clear_has_ClassLabels();
      ::CoreML::Specification::StringVector* temp = ClassLabels_.stringclasslabels_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ClassLabels_.stringclasslabels_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::StringVector& KNearestNeighborsClassifier::_internal_stringclasslabels() const {
  return _internal_has_stringclasslabels()
      ? *ClassLabels_.stringclasslabels_
      : reinterpret_cast< ::CoreML::Specification::StringVector&>(::CoreML::Specification::_StringVector_default_instance_);
}
inline const ::CoreML::Specification::StringVector& KNearestNeighborsClassifier::stringclasslabels() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.KNearestNeighborsClassifier.stringClassLabels)
  return _internal_stringclasslabels();
}
inline ::CoreML::Specification::StringVector* KNearestNeighborsClassifier::unsafe_arena_release_stringclasslabels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.KNearestNeighborsClassifier.stringClassLabels)
  if (_internal_has_stringclasslabels()) {
    clear_has_ClassLabels();
    ::CoreML::Specification::StringVector* temp = ClassLabels_.stringclasslabels_;
    ClassLabels_.stringclasslabels_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KNearestNeighborsClassifier::unsafe_arena_set_allocated_stringclasslabels(::CoreML::Specification::StringVector* stringclasslabels) {
  clear_ClassLabels();
  if (stringclasslabels) {
    set_has_stringclasslabels();
    ClassLabels_.stringclasslabels_ = stringclasslabels;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.KNearestNeighborsClassifier.stringClassLabels)
}
inline ::CoreML::Specification::StringVector* KNearestNeighborsClassifier::_internal_mutable_stringclasslabels() {
  if (!_internal_has_stringclasslabels()) {
    clear_ClassLabels();
    set_has_stringclasslabels();
    ClassLabels_.stringclasslabels_ = CreateMaybeMessage< ::CoreML::Specification::StringVector >(GetArenaForAllocation());
  }
  return ClassLabels_.stringclasslabels_;
}
inline ::CoreML::Specification::StringVector* KNearestNeighborsClassifier::mutable_stringclasslabels() {
  ::CoreML::Specification::StringVector* _msg = _internal_mutable_stringclasslabels();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.KNearestNeighborsClassifier.stringClassLabels)
  return _msg;
}

// .CoreML.Specification.Int64Vector int64ClassLabels = 101;
inline bool KNearestNeighborsClassifier::_internal_has_int64classlabels() const {
  return ClassLabels_case() == kInt64ClassLabels;
}
inline bool KNearestNeighborsClassifier::has_int64classlabels() const {
  return _internal_has_int64classlabels();
}
inline void KNearestNeighborsClassifier::set_has_int64classlabels() {
  _oneof_case_[0] = kInt64ClassLabels;
}
inline ::CoreML::Specification::Int64Vector* KNearestNeighborsClassifier::release_int64classlabels() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.KNearestNeighborsClassifier.int64ClassLabels)
  if (_internal_has_int64classlabels()) {
    clear_has_ClassLabels();
      ::CoreML::Specification::Int64Vector* temp = ClassLabels_.int64classlabels_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ClassLabels_.int64classlabels_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::Int64Vector& KNearestNeighborsClassifier::_internal_int64classlabels() const {
  return _internal_has_int64classlabels()
      ? *ClassLabels_.int64classlabels_
      : reinterpret_cast< ::CoreML::Specification::Int64Vector&>(::CoreML::Specification::_Int64Vector_default_instance_);
}
inline const ::CoreML::Specification::Int64Vector& KNearestNeighborsClassifier::int64classlabels() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.KNearestNeighborsClassifier.int64ClassLabels)
  return _internal_int64classlabels();
}
inline ::CoreML::Specification::Int64Vector* KNearestNeighborsClassifier::unsafe_arena_release_int64classlabels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.KNearestNeighborsClassifier.int64ClassLabels)
  if (_internal_has_int64classlabels()) {
    clear_has_ClassLabels();
    ::CoreML::Specification::Int64Vector* temp = ClassLabels_.int64classlabels_;
    ClassLabels_.int64classlabels_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KNearestNeighborsClassifier::unsafe_arena_set_allocated_int64classlabels(::CoreML::Specification::Int64Vector* int64classlabels) {
  clear_ClassLabels();
  if (int64classlabels) {
    set_has_int64classlabels();
    ClassLabels_.int64classlabels_ = int64classlabels;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.KNearestNeighborsClassifier.int64ClassLabels)
}
inline ::CoreML::Specification::Int64Vector* KNearestNeighborsClassifier::_internal_mutable_int64classlabels() {
  if (!_internal_has_int64classlabels()) {
    clear_ClassLabels();
    set_has_int64classlabels();
    ClassLabels_.int64classlabels_ = CreateMaybeMessage< ::CoreML::Specification::Int64Vector >(GetArenaForAllocation());
  }
  return ClassLabels_.int64classlabels_;
}
inline ::CoreML::Specification::Int64Vector* KNearestNeighborsClassifier::mutable_int64classlabels() {
  ::CoreML::Specification::Int64Vector* _msg = _internal_mutable_int64classlabels();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.KNearestNeighborsClassifier.int64ClassLabels)
  return _msg;
}

// string defaultStringLabel = 110;
inline bool KNearestNeighborsClassifier::_internal_has_defaultstringlabel() const {
  return DefaultClassLabel_case() == kDefaultStringLabel;
}
inline bool KNearestNeighborsClassifier::has_defaultstringlabel() const {
  return _internal_has_defaultstringlabel();
}
inline void KNearestNeighborsClassifier::set_has_defaultstringlabel() {
  _oneof_case_[1] = kDefaultStringLabel;
}
inline void KNearestNeighborsClassifier::clear_defaultstringlabel() {
  if (_internal_has_defaultstringlabel()) {
    DefaultClassLabel_.defaultstringlabel_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_DefaultClassLabel();
  }
}
inline const std::string& KNearestNeighborsClassifier::defaultstringlabel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.KNearestNeighborsClassifier.defaultStringLabel)
  return _internal_defaultstringlabel();
}
template <typename ArgT0, typename... ArgT>
inline void KNearestNeighborsClassifier::set_defaultstringlabel(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_defaultstringlabel()) {
    clear_DefaultClassLabel();
    set_has_defaultstringlabel();
    DefaultClassLabel_.defaultstringlabel_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  DefaultClassLabel_.defaultstringlabel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.KNearestNeighborsClassifier.defaultStringLabel)
}
inline std::string* KNearestNeighborsClassifier::mutable_defaultstringlabel() {
  std::string* _s = _internal_mutable_defaultstringlabel();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.KNearestNeighborsClassifier.defaultStringLabel)
  return _s;
}
inline const std::string& KNearestNeighborsClassifier::_internal_defaultstringlabel() const {
  if (_internal_has_defaultstringlabel()) {
    return DefaultClassLabel_.defaultstringlabel_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void KNearestNeighborsClassifier::_internal_set_defaultstringlabel(const std::string& value) {
  if (!_internal_has_defaultstringlabel()) {
    clear_DefaultClassLabel();
    set_has_defaultstringlabel();
    DefaultClassLabel_.defaultstringlabel_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  DefaultClassLabel_.defaultstringlabel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KNearestNeighborsClassifier::_internal_mutable_defaultstringlabel() {
  if (!_internal_has_defaultstringlabel()) {
    clear_DefaultClassLabel();
    set_has_defaultstringlabel();
    DefaultClassLabel_.defaultstringlabel_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return DefaultClassLabel_.defaultstringlabel_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KNearestNeighborsClassifier::release_defaultstringlabel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.KNearestNeighborsClassifier.defaultStringLabel)
  if (_internal_has_defaultstringlabel()) {
    clear_has_DefaultClassLabel();
    return DefaultClassLabel_.defaultstringlabel_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void KNearestNeighborsClassifier::set_allocated_defaultstringlabel(std::string* defaultstringlabel) {
  if (has_DefaultClassLabel()) {
    clear_DefaultClassLabel();
  }
  if (defaultstringlabel != nullptr) {
    set_has_defaultstringlabel();
    DefaultClassLabel_.defaultstringlabel_.UnsafeSetDefault(defaultstringlabel);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(defaultstringlabel);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.KNearestNeighborsClassifier.defaultStringLabel)
}

// int64 defaultInt64Label = 111;
inline bool KNearestNeighborsClassifier::_internal_has_defaultint64label() const {
  return DefaultClassLabel_case() == kDefaultInt64Label;
}
inline bool KNearestNeighborsClassifier::has_defaultint64label() const {
  return _internal_has_defaultint64label();
}
inline void KNearestNeighborsClassifier::set_has_defaultint64label() {
  _oneof_case_[1] = kDefaultInt64Label;
}
inline void KNearestNeighborsClassifier::clear_defaultint64label() {
  if (_internal_has_defaultint64label()) {
    DefaultClassLabel_.defaultint64label_ = int64_t{0};
    clear_has_DefaultClassLabel();
  }
}
inline int64_t KNearestNeighborsClassifier::_internal_defaultint64label() const {
  if (_internal_has_defaultint64label()) {
    return DefaultClassLabel_.defaultint64label_;
  }
  return int64_t{0};
}
inline void KNearestNeighborsClassifier::_internal_set_defaultint64label(int64_t value) {
  if (!_internal_has_defaultint64label()) {
    clear_DefaultClassLabel();
    set_has_defaultint64label();
  }
  DefaultClassLabel_.defaultint64label_ = value;
}
inline int64_t KNearestNeighborsClassifier::defaultint64label() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.KNearestNeighborsClassifier.defaultInt64Label)
  return _internal_defaultint64label();
}
inline void KNearestNeighborsClassifier::set_defaultint64label(int64_t value) {
  _internal_set_defaultint64label(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.KNearestNeighborsClassifier.defaultInt64Label)
}

// .CoreML.Specification.UniformWeighting uniformWeighting = 200;
inline bool KNearestNeighborsClassifier::_internal_has_uniformweighting() const {
  return WeightingScheme_case() == kUniformWeighting;
}
inline bool KNearestNeighborsClassifier::has_uniformweighting() const {
  return _internal_has_uniformweighting();
}
inline void KNearestNeighborsClassifier::set_has_uniformweighting() {
  _oneof_case_[2] = kUniformWeighting;
}
inline void KNearestNeighborsClassifier::clear_uniformweighting() {
  if (_internal_has_uniformweighting()) {
    if (GetArenaForAllocation() == nullptr) {
      delete WeightingScheme_.uniformweighting_;
    }
    clear_has_WeightingScheme();
  }
}
inline ::CoreML::Specification::UniformWeighting* KNearestNeighborsClassifier::release_uniformweighting() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.KNearestNeighborsClassifier.uniformWeighting)
  if (_internal_has_uniformweighting()) {
    clear_has_WeightingScheme();
      ::CoreML::Specification::UniformWeighting* temp = WeightingScheme_.uniformweighting_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    WeightingScheme_.uniformweighting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::UniformWeighting& KNearestNeighborsClassifier::_internal_uniformweighting() const {
  return _internal_has_uniformweighting()
      ? *WeightingScheme_.uniformweighting_
      : reinterpret_cast< ::CoreML::Specification::UniformWeighting&>(::CoreML::Specification::_UniformWeighting_default_instance_);
}
inline const ::CoreML::Specification::UniformWeighting& KNearestNeighborsClassifier::uniformweighting() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.KNearestNeighborsClassifier.uniformWeighting)
  return _internal_uniformweighting();
}
inline ::CoreML::Specification::UniformWeighting* KNearestNeighborsClassifier::unsafe_arena_release_uniformweighting() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.KNearestNeighborsClassifier.uniformWeighting)
  if (_internal_has_uniformweighting()) {
    clear_has_WeightingScheme();
    ::CoreML::Specification::UniformWeighting* temp = WeightingScheme_.uniformweighting_;
    WeightingScheme_.uniformweighting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KNearestNeighborsClassifier::unsafe_arena_set_allocated_uniformweighting(::CoreML::Specification::UniformWeighting* uniformweighting) {
  clear_WeightingScheme();
  if (uniformweighting) {
    set_has_uniformweighting();
    WeightingScheme_.uniformweighting_ = uniformweighting;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.KNearestNeighborsClassifier.uniformWeighting)
}
inline ::CoreML::Specification::UniformWeighting* KNearestNeighborsClassifier::_internal_mutable_uniformweighting() {
  if (!_internal_has_uniformweighting()) {
    clear_WeightingScheme();
    set_has_uniformweighting();
    WeightingScheme_.uniformweighting_ = CreateMaybeMessage< ::CoreML::Specification::UniformWeighting >(GetArenaForAllocation());
  }
  return WeightingScheme_.uniformweighting_;
}
inline ::CoreML::Specification::UniformWeighting* KNearestNeighborsClassifier::mutable_uniformweighting() {
  ::CoreML::Specification::UniformWeighting* _msg = _internal_mutable_uniformweighting();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.KNearestNeighborsClassifier.uniformWeighting)
  return _msg;
}

// .CoreML.Specification.InverseDistanceWeighting inverseDistanceWeighting = 210;
inline bool KNearestNeighborsClassifier::_internal_has_inversedistanceweighting() const {
  return WeightingScheme_case() == kInverseDistanceWeighting;
}
inline bool KNearestNeighborsClassifier::has_inversedistanceweighting() const {
  return _internal_has_inversedistanceweighting();
}
inline void KNearestNeighborsClassifier::set_has_inversedistanceweighting() {
  _oneof_case_[2] = kInverseDistanceWeighting;
}
inline void KNearestNeighborsClassifier::clear_inversedistanceweighting() {
  if (_internal_has_inversedistanceweighting()) {
    if (GetArenaForAllocation() == nullptr) {
      delete WeightingScheme_.inversedistanceweighting_;
    }
    clear_has_WeightingScheme();
  }
}
inline ::CoreML::Specification::InverseDistanceWeighting* KNearestNeighborsClassifier::release_inversedistanceweighting() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.KNearestNeighborsClassifier.inverseDistanceWeighting)
  if (_internal_has_inversedistanceweighting()) {
    clear_has_WeightingScheme();
      ::CoreML::Specification::InverseDistanceWeighting* temp = WeightingScheme_.inversedistanceweighting_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    WeightingScheme_.inversedistanceweighting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::InverseDistanceWeighting& KNearestNeighborsClassifier::_internal_inversedistanceweighting() const {
  return _internal_has_inversedistanceweighting()
      ? *WeightingScheme_.inversedistanceweighting_
      : reinterpret_cast< ::CoreML::Specification::InverseDistanceWeighting&>(::CoreML::Specification::_InverseDistanceWeighting_default_instance_);
}
inline const ::CoreML::Specification::InverseDistanceWeighting& KNearestNeighborsClassifier::inversedistanceweighting() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.KNearestNeighborsClassifier.inverseDistanceWeighting)
  return _internal_inversedistanceweighting();
}
inline ::CoreML::Specification::InverseDistanceWeighting* KNearestNeighborsClassifier::unsafe_arena_release_inversedistanceweighting() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.KNearestNeighborsClassifier.inverseDistanceWeighting)
  if (_internal_has_inversedistanceweighting()) {
    clear_has_WeightingScheme();
    ::CoreML::Specification::InverseDistanceWeighting* temp = WeightingScheme_.inversedistanceweighting_;
    WeightingScheme_.inversedistanceweighting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KNearestNeighborsClassifier::unsafe_arena_set_allocated_inversedistanceweighting(::CoreML::Specification::InverseDistanceWeighting* inversedistanceweighting) {
  clear_WeightingScheme();
  if (inversedistanceweighting) {
    set_has_inversedistanceweighting();
    WeightingScheme_.inversedistanceweighting_ = inversedistanceweighting;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.KNearestNeighborsClassifier.inverseDistanceWeighting)
}
inline ::CoreML::Specification::InverseDistanceWeighting* KNearestNeighborsClassifier::_internal_mutable_inversedistanceweighting() {
  if (!_internal_has_inversedistanceweighting()) {
    clear_WeightingScheme();
    set_has_inversedistanceweighting();
    WeightingScheme_.inversedistanceweighting_ = CreateMaybeMessage< ::CoreML::Specification::InverseDistanceWeighting >(GetArenaForAllocation());
  }
  return WeightingScheme_.inversedistanceweighting_;
}
inline ::CoreML::Specification::InverseDistanceWeighting* KNearestNeighborsClassifier::mutable_inversedistanceweighting() {
  ::CoreML::Specification::InverseDistanceWeighting* _msg = _internal_mutable_inversedistanceweighting();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.KNearestNeighborsClassifier.inverseDistanceWeighting)
  return _msg;
}

inline bool KNearestNeighborsClassifier::has_ClassLabels() const {
  return ClassLabels_case() != CLASSLABELS_NOT_SET;
}
inline void KNearestNeighborsClassifier::clear_has_ClassLabels() {
  _oneof_case_[0] = CLASSLABELS_NOT_SET;
}
inline bool KNearestNeighborsClassifier::has_DefaultClassLabel() const {
  return DefaultClassLabel_case() != DEFAULTCLASSLABEL_NOT_SET;
}
inline void KNearestNeighborsClassifier::clear_has_DefaultClassLabel() {
  _oneof_case_[1] = DEFAULTCLASSLABEL_NOT_SET;
}
inline bool KNearestNeighborsClassifier::has_WeightingScheme() const {
  return WeightingScheme_case() != WEIGHTINGSCHEME_NOT_SET;
}
inline void KNearestNeighborsClassifier::clear_has_WeightingScheme() {
  _oneof_case_[2] = WEIGHTINGSCHEME_NOT_SET;
}
inline KNearestNeighborsClassifier::ClassLabelsCase KNearestNeighborsClassifier::ClassLabels_case() const {
  return KNearestNeighborsClassifier::ClassLabelsCase(_oneof_case_[0]);
}
inline KNearestNeighborsClassifier::DefaultClassLabelCase KNearestNeighborsClassifier::DefaultClassLabel_case() const {
  return KNearestNeighborsClassifier::DefaultClassLabelCase(_oneof_case_[1]);
}
inline KNearestNeighborsClassifier::WeightingSchemeCase KNearestNeighborsClassifier::WeightingScheme_case() const {
  return KNearestNeighborsClassifier::WeightingSchemeCase(_oneof_case_[2]);
}
// -------------------------------------------------------------------

// NearestNeighborsIndex

// int32 numberOfDimensions = 1;
inline void NearestNeighborsIndex::clear_numberofdimensions() {
  numberofdimensions_ = 0;
}
inline int32_t NearestNeighborsIndex::_internal_numberofdimensions() const {
  return numberofdimensions_;
}
inline int32_t NearestNeighborsIndex::numberofdimensions() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NearestNeighborsIndex.numberOfDimensions)
  return _internal_numberofdimensions();
}
inline void NearestNeighborsIndex::_internal_set_numberofdimensions(int32_t value) {
  
  numberofdimensions_ = value;
}
inline void NearestNeighborsIndex::set_numberofdimensions(int32_t value) {
  _internal_set_numberofdimensions(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.NearestNeighborsIndex.numberOfDimensions)
}

// repeated .CoreML.Specification.FloatVector floatSamples = 2;
inline int NearestNeighborsIndex::_internal_floatsamples_size() const {
  return floatsamples_.size();
}
inline int NearestNeighborsIndex::floatsamples_size() const {
  return _internal_floatsamples_size();
}
inline ::CoreML::Specification::FloatVector* NearestNeighborsIndex::mutable_floatsamples(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NearestNeighborsIndex.floatSamples)
  return floatsamples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FloatVector >*
NearestNeighborsIndex::mutable_floatsamples() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.NearestNeighborsIndex.floatSamples)
  return &floatsamples_;
}
inline const ::CoreML::Specification::FloatVector& NearestNeighborsIndex::_internal_floatsamples(int index) const {
  return floatsamples_.Get(index);
}
inline const ::CoreML::Specification::FloatVector& NearestNeighborsIndex::floatsamples(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NearestNeighborsIndex.floatSamples)
  return _internal_floatsamples(index);
}
inline ::CoreML::Specification::FloatVector* NearestNeighborsIndex::_internal_add_floatsamples() {
  return floatsamples_.Add();
}
inline ::CoreML::Specification::FloatVector* NearestNeighborsIndex::add_floatsamples() {
  ::CoreML::Specification::FloatVector* _add = _internal_add_floatsamples();
  // @@protoc_insertion_point(field_add:CoreML.Specification.NearestNeighborsIndex.floatSamples)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::FloatVector >&
NearestNeighborsIndex::floatsamples() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.NearestNeighborsIndex.floatSamples)
  return floatsamples_;
}

// .CoreML.Specification.LinearIndex linearIndex = 100;
inline bool NearestNeighborsIndex::_internal_has_linearindex() const {
  return IndexType_case() == kLinearIndex;
}
inline bool NearestNeighborsIndex::has_linearindex() const {
  return _internal_has_linearindex();
}
inline void NearestNeighborsIndex::set_has_linearindex() {
  _oneof_case_[0] = kLinearIndex;
}
inline void NearestNeighborsIndex::clear_linearindex() {
  if (_internal_has_linearindex()) {
    if (GetArenaForAllocation() == nullptr) {
      delete IndexType_.linearindex_;
    }
    clear_has_IndexType();
  }
}
inline ::CoreML::Specification::LinearIndex* NearestNeighborsIndex::release_linearindex() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NearestNeighborsIndex.linearIndex)
  if (_internal_has_linearindex()) {
    clear_has_IndexType();
      ::CoreML::Specification::LinearIndex* temp = IndexType_.linearindex_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    IndexType_.linearindex_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::LinearIndex& NearestNeighborsIndex::_internal_linearindex() const {
  return _internal_has_linearindex()
      ? *IndexType_.linearindex_
      : reinterpret_cast< ::CoreML::Specification::LinearIndex&>(::CoreML::Specification::_LinearIndex_default_instance_);
}
inline const ::CoreML::Specification::LinearIndex& NearestNeighborsIndex::linearindex() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NearestNeighborsIndex.linearIndex)
  return _internal_linearindex();
}
inline ::CoreML::Specification::LinearIndex* NearestNeighborsIndex::unsafe_arena_release_linearindex() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.NearestNeighborsIndex.linearIndex)
  if (_internal_has_linearindex()) {
    clear_has_IndexType();
    ::CoreML::Specification::LinearIndex* temp = IndexType_.linearindex_;
    IndexType_.linearindex_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NearestNeighborsIndex::unsafe_arena_set_allocated_linearindex(::CoreML::Specification::LinearIndex* linearindex) {
  clear_IndexType();
  if (linearindex) {
    set_has_linearindex();
    IndexType_.linearindex_ = linearindex;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.NearestNeighborsIndex.linearIndex)
}
inline ::CoreML::Specification::LinearIndex* NearestNeighborsIndex::_internal_mutable_linearindex() {
  if (!_internal_has_linearindex()) {
    clear_IndexType();
    set_has_linearindex();
    IndexType_.linearindex_ = CreateMaybeMessage< ::CoreML::Specification::LinearIndex >(GetArenaForAllocation());
  }
  return IndexType_.linearindex_;
}
inline ::CoreML::Specification::LinearIndex* NearestNeighborsIndex::mutable_linearindex() {
  ::CoreML::Specification::LinearIndex* _msg = _internal_mutable_linearindex();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NearestNeighborsIndex.linearIndex)
  return _msg;
}

// .CoreML.Specification.SingleKdTreeIndex singleKdTreeIndex = 110;
inline bool NearestNeighborsIndex::_internal_has_singlekdtreeindex() const {
  return IndexType_case() == kSingleKdTreeIndex;
}
inline bool NearestNeighborsIndex::has_singlekdtreeindex() const {
  return _internal_has_singlekdtreeindex();
}
inline void NearestNeighborsIndex::set_has_singlekdtreeindex() {
  _oneof_case_[0] = kSingleKdTreeIndex;
}
inline void NearestNeighborsIndex::clear_singlekdtreeindex() {
  if (_internal_has_singlekdtreeindex()) {
    if (GetArenaForAllocation() == nullptr) {
      delete IndexType_.singlekdtreeindex_;
    }
    clear_has_IndexType();
  }
}
inline ::CoreML::Specification::SingleKdTreeIndex* NearestNeighborsIndex::release_singlekdtreeindex() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NearestNeighborsIndex.singleKdTreeIndex)
  if (_internal_has_singlekdtreeindex()) {
    clear_has_IndexType();
      ::CoreML::Specification::SingleKdTreeIndex* temp = IndexType_.singlekdtreeindex_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    IndexType_.singlekdtreeindex_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::SingleKdTreeIndex& NearestNeighborsIndex::_internal_singlekdtreeindex() const {
  return _internal_has_singlekdtreeindex()
      ? *IndexType_.singlekdtreeindex_
      : reinterpret_cast< ::CoreML::Specification::SingleKdTreeIndex&>(::CoreML::Specification::_SingleKdTreeIndex_default_instance_);
}
inline const ::CoreML::Specification::SingleKdTreeIndex& NearestNeighborsIndex::singlekdtreeindex() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NearestNeighborsIndex.singleKdTreeIndex)
  return _internal_singlekdtreeindex();
}
inline ::CoreML::Specification::SingleKdTreeIndex* NearestNeighborsIndex::unsafe_arena_release_singlekdtreeindex() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.NearestNeighborsIndex.singleKdTreeIndex)
  if (_internal_has_singlekdtreeindex()) {
    clear_has_IndexType();
    ::CoreML::Specification::SingleKdTreeIndex* temp = IndexType_.singlekdtreeindex_;
    IndexType_.singlekdtreeindex_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NearestNeighborsIndex::unsafe_arena_set_allocated_singlekdtreeindex(::CoreML::Specification::SingleKdTreeIndex* singlekdtreeindex) {
  clear_IndexType();
  if (singlekdtreeindex) {
    set_has_singlekdtreeindex();
    IndexType_.singlekdtreeindex_ = singlekdtreeindex;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.NearestNeighborsIndex.singleKdTreeIndex)
}
inline ::CoreML::Specification::SingleKdTreeIndex* NearestNeighborsIndex::_internal_mutable_singlekdtreeindex() {
  if (!_internal_has_singlekdtreeindex()) {
    clear_IndexType();
    set_has_singlekdtreeindex();
    IndexType_.singlekdtreeindex_ = CreateMaybeMessage< ::CoreML::Specification::SingleKdTreeIndex >(GetArenaForAllocation());
  }
  return IndexType_.singlekdtreeindex_;
}
inline ::CoreML::Specification::SingleKdTreeIndex* NearestNeighborsIndex::mutable_singlekdtreeindex() {
  ::CoreML::Specification::SingleKdTreeIndex* _msg = _internal_mutable_singlekdtreeindex();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NearestNeighborsIndex.singleKdTreeIndex)
  return _msg;
}

// .CoreML.Specification.SquaredEuclideanDistance squaredEuclideanDistance = 200;
inline bool NearestNeighborsIndex::_internal_has_squaredeuclideandistance() const {
  return DistanceFunction_case() == kSquaredEuclideanDistance;
}
inline bool NearestNeighborsIndex::has_squaredeuclideandistance() const {
  return _internal_has_squaredeuclideandistance();
}
inline void NearestNeighborsIndex::set_has_squaredeuclideandistance() {
  _oneof_case_[1] = kSquaredEuclideanDistance;
}
inline void NearestNeighborsIndex::clear_squaredeuclideandistance() {
  if (_internal_has_squaredeuclideandistance()) {
    if (GetArenaForAllocation() == nullptr) {
      delete DistanceFunction_.squaredeuclideandistance_;
    }
    clear_has_DistanceFunction();
  }
}
inline ::CoreML::Specification::SquaredEuclideanDistance* NearestNeighborsIndex::release_squaredeuclideandistance() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NearestNeighborsIndex.squaredEuclideanDistance)
  if (_internal_has_squaredeuclideandistance()) {
    clear_has_DistanceFunction();
      ::CoreML::Specification::SquaredEuclideanDistance* temp = DistanceFunction_.squaredeuclideandistance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    DistanceFunction_.squaredeuclideandistance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::SquaredEuclideanDistance& NearestNeighborsIndex::_internal_squaredeuclideandistance() const {
  return _internal_has_squaredeuclideandistance()
      ? *DistanceFunction_.squaredeuclideandistance_
      : reinterpret_cast< ::CoreML::Specification::SquaredEuclideanDistance&>(::CoreML::Specification::_SquaredEuclideanDistance_default_instance_);
}
inline const ::CoreML::Specification::SquaredEuclideanDistance& NearestNeighborsIndex::squaredeuclideandistance() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NearestNeighborsIndex.squaredEuclideanDistance)
  return _internal_squaredeuclideandistance();
}
inline ::CoreML::Specification::SquaredEuclideanDistance* NearestNeighborsIndex::unsafe_arena_release_squaredeuclideandistance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.NearestNeighborsIndex.squaredEuclideanDistance)
  if (_internal_has_squaredeuclideandistance()) {
    clear_has_DistanceFunction();
    ::CoreML::Specification::SquaredEuclideanDistance* temp = DistanceFunction_.squaredeuclideandistance_;
    DistanceFunction_.squaredeuclideandistance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NearestNeighborsIndex::unsafe_arena_set_allocated_squaredeuclideandistance(::CoreML::Specification::SquaredEuclideanDistance* squaredeuclideandistance) {
  clear_DistanceFunction();
  if (squaredeuclideandistance) {
    set_has_squaredeuclideandistance();
    DistanceFunction_.squaredeuclideandistance_ = squaredeuclideandistance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.NearestNeighborsIndex.squaredEuclideanDistance)
}
inline ::CoreML::Specification::SquaredEuclideanDistance* NearestNeighborsIndex::_internal_mutable_squaredeuclideandistance() {
  if (!_internal_has_squaredeuclideandistance()) {
    clear_DistanceFunction();
    set_has_squaredeuclideandistance();
    DistanceFunction_.squaredeuclideandistance_ = CreateMaybeMessage< ::CoreML::Specification::SquaredEuclideanDistance >(GetArenaForAllocation());
  }
  return DistanceFunction_.squaredeuclideandistance_;
}
inline ::CoreML::Specification::SquaredEuclideanDistance* NearestNeighborsIndex::mutable_squaredeuclideandistance() {
  ::CoreML::Specification::SquaredEuclideanDistance* _msg = _internal_mutable_squaredeuclideandistance();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NearestNeighborsIndex.squaredEuclideanDistance)
  return _msg;
}

inline bool NearestNeighborsIndex::has_IndexType() const {
  return IndexType_case() != INDEXTYPE_NOT_SET;
}
inline void NearestNeighborsIndex::clear_has_IndexType() {
  _oneof_case_[0] = INDEXTYPE_NOT_SET;
}
inline bool NearestNeighborsIndex::has_DistanceFunction() const {
  return DistanceFunction_case() != DISTANCEFUNCTION_NOT_SET;
}
inline void NearestNeighborsIndex::clear_has_DistanceFunction() {
  _oneof_case_[1] = DISTANCEFUNCTION_NOT_SET;
}
inline NearestNeighborsIndex::IndexTypeCase NearestNeighborsIndex::IndexType_case() const {
  return NearestNeighborsIndex::IndexTypeCase(_oneof_case_[0]);
}
inline NearestNeighborsIndex::DistanceFunctionCase NearestNeighborsIndex::DistanceFunction_case() const {
  return NearestNeighborsIndex::DistanceFunctionCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// UniformWeighting

// -------------------------------------------------------------------

// InverseDistanceWeighting

// -------------------------------------------------------------------

// LinearIndex

// -------------------------------------------------------------------

// SingleKdTreeIndex

// int32 leafSize = 1;
inline void SingleKdTreeIndex::clear_leafsize() {
  leafsize_ = 0;
}
inline int32_t SingleKdTreeIndex::_internal_leafsize() const {
  return leafsize_;
}
inline int32_t SingleKdTreeIndex::leafsize() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SingleKdTreeIndex.leafSize)
  return _internal_leafsize();
}
inline void SingleKdTreeIndex::_internal_set_leafsize(int32_t value) {
  
  leafsize_ = value;
}
inline void SingleKdTreeIndex::set_leafsize(int32_t value) {
  _internal_set_leafsize(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.SingleKdTreeIndex.leafSize)
}

// -------------------------------------------------------------------

// SquaredEuclideanDistance

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Specification
}  // namespace CoreML

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_NearestNeighbors_2eproto
