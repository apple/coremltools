// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FeatureTypes.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "FeatureTypes.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace CoreML {
namespace Specification {
class Int64FeatureTypeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Int64FeatureType> {
} _Int64FeatureType_default_instance_;
class DoubleFeatureTypeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<DoubleFeatureType> {
} _DoubleFeatureType_default_instance_;
class StringFeatureTypeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StringFeatureType> {
} _StringFeatureType_default_instance_;
class SizeRangeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SizeRange> {
} _SizeRange_default_instance_;
class ImageFeatureType_ImageSizeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ImageFeatureType_ImageSize> {
} _ImageFeatureType_ImageSize_default_instance_;
class ImageFeatureType_EnumeratedImageSizesDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ImageFeatureType_EnumeratedImageSizes> {
} _ImageFeatureType_EnumeratedImageSizes_default_instance_;
class ImageFeatureType_ImageSizeRangeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ImageFeatureType_ImageSizeRange> {
} _ImageFeatureType_ImageSizeRange_default_instance_;
class ImageFeatureTypeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ImageFeatureType> {
  public:
  const ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* enumeratedsizes_;
  const ::CoreML::Specification::ImageFeatureType_ImageSizeRange* imagesizerange_;
} _ImageFeatureType_default_instance_;
class ArrayFeatureType_ShapeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ArrayFeatureType_Shape> {
} _ArrayFeatureType_Shape_default_instance_;
class ArrayFeatureType_EnumeratedShapesDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ArrayFeatureType_EnumeratedShapes> {
} _ArrayFeatureType_EnumeratedShapes_default_instance_;
class ArrayFeatureType_ShapeRangeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ArrayFeatureType_ShapeRange> {
} _ArrayFeatureType_ShapeRange_default_instance_;
class ArrayFeatureTypeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ArrayFeatureType> {
  public:
  const ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* enumeratedshapes_;
  const ::CoreML::Specification::ArrayFeatureType_ShapeRange* shaperange_;
} _ArrayFeatureType_default_instance_;
class DictionaryFeatureTypeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<DictionaryFeatureType> {
  public:
  const ::CoreML::Specification::Int64FeatureType* int64keytype_;
  const ::CoreML::Specification::StringFeatureType* stringkeytype_;
} _DictionaryFeatureType_default_instance_;
class SequenceFeatureTypeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SequenceFeatureType> {
  public:
  const ::CoreML::Specification::Int64FeatureType* int64type_;
  const ::CoreML::Specification::StringFeatureType* stringtype_;
} _SequenceFeatureType_default_instance_;
class FeatureTypeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<FeatureType> {
  public:
  const ::CoreML::Specification::Int64FeatureType* int64type_;
  const ::CoreML::Specification::DoubleFeatureType* doubletype_;
  const ::CoreML::Specification::StringFeatureType* stringtype_;
  const ::CoreML::Specification::ImageFeatureType* imagetype_;
  const ::CoreML::Specification::ArrayFeatureType* multiarraytype_;
  const ::CoreML::Specification::DictionaryFeatureType* dictionarytype_;
  const ::CoreML::Specification::SequenceFeatureType* sequencetype_;
} _FeatureType_default_instance_;

namespace protobuf_FeatureTypes_2eproto {

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};


void TableStruct::Shutdown() {
  _Int64FeatureType_default_instance_.Shutdown();
  _DoubleFeatureType_default_instance_.Shutdown();
  _StringFeatureType_default_instance_.Shutdown();
  _SizeRange_default_instance_.Shutdown();
  _ImageFeatureType_ImageSize_default_instance_.Shutdown();
  _ImageFeatureType_EnumeratedImageSizes_default_instance_.Shutdown();
  _ImageFeatureType_ImageSizeRange_default_instance_.Shutdown();
  _ImageFeatureType_default_instance_.Shutdown();
  _ArrayFeatureType_Shape_default_instance_.Shutdown();
  _ArrayFeatureType_EnumeratedShapes_default_instance_.Shutdown();
  _ArrayFeatureType_ShapeRange_default_instance_.Shutdown();
  _ArrayFeatureType_default_instance_.Shutdown();
  _DictionaryFeatureType_default_instance_.Shutdown();
  _SequenceFeatureType_default_instance_.Shutdown();
  _FeatureType_default_instance_.Shutdown();
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  _Int64FeatureType_default_instance_.DefaultConstruct();
  _DoubleFeatureType_default_instance_.DefaultConstruct();
  _StringFeatureType_default_instance_.DefaultConstruct();
  _SizeRange_default_instance_.DefaultConstruct();
  _ImageFeatureType_ImageSize_default_instance_.DefaultConstruct();
  _ImageFeatureType_EnumeratedImageSizes_default_instance_.DefaultConstruct();
  _ImageFeatureType_ImageSizeRange_default_instance_.DefaultConstruct();
  _ImageFeatureType_default_instance_.DefaultConstruct();
  _ArrayFeatureType_Shape_default_instance_.DefaultConstruct();
  _ArrayFeatureType_EnumeratedShapes_default_instance_.DefaultConstruct();
  _ArrayFeatureType_ShapeRange_default_instance_.DefaultConstruct();
  _ArrayFeatureType_default_instance_.DefaultConstruct();
  _DictionaryFeatureType_default_instance_.DefaultConstruct();
  _SequenceFeatureType_default_instance_.DefaultConstruct();
  _FeatureType_default_instance_.DefaultConstruct();
  _ImageFeatureType_ImageSizeRange_default_instance_.get_mutable()->widthrange_ = const_cast< ::CoreML::Specification::SizeRange*>(
      ::CoreML::Specification::SizeRange::internal_default_instance());
  _ImageFeatureType_ImageSizeRange_default_instance_.get_mutable()->heightrange_ = const_cast< ::CoreML::Specification::SizeRange*>(
      ::CoreML::Specification::SizeRange::internal_default_instance());
  _SequenceFeatureType_default_instance_.get_mutable()->sizerange_ = const_cast< ::CoreML::Specification::SizeRange*>(
      ::CoreML::Specification::SizeRange::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
#endif  // GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

}  // namespace protobuf_FeatureTypes_2eproto

bool ImageFeatureType_ColorSpace_IsValid(int value) {
  switch (value) {
    case 0:
    case 10:
    case 20:
    case 30:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ImageFeatureType_ColorSpace ImageFeatureType::INVALID_COLOR_SPACE;
const ImageFeatureType_ColorSpace ImageFeatureType::GRAYSCALE;
const ImageFeatureType_ColorSpace ImageFeatureType::RGB;
const ImageFeatureType_ColorSpace ImageFeatureType::BGR;
const ImageFeatureType_ColorSpace ImageFeatureType::ColorSpace_MIN;
const ImageFeatureType_ColorSpace ImageFeatureType::ColorSpace_MAX;
const int ImageFeatureType::ColorSpace_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool ArrayFeatureType_ArrayDataType_IsValid(int value) {
  switch (value) {
    case 0:
    case 65568:
    case 65600:
    case 131104:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ArrayFeatureType_ArrayDataType ArrayFeatureType::INVALID_ARRAY_DATA_TYPE;
const ArrayFeatureType_ArrayDataType ArrayFeatureType::FLOAT32;
const ArrayFeatureType_ArrayDataType ArrayFeatureType::DOUBLE;
const ArrayFeatureType_ArrayDataType ArrayFeatureType::INT32;
const ArrayFeatureType_ArrayDataType ArrayFeatureType::ArrayDataType_MIN;
const ArrayFeatureType_ArrayDataType ArrayFeatureType::ArrayDataType_MAX;
const int ArrayFeatureType::ArrayDataType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Int64FeatureType::Int64FeatureType()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_FeatureTypes_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.Int64FeatureType)
}
Int64FeatureType::Int64FeatureType(const Int64FeatureType& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Int64FeatureType)
}

void Int64FeatureType::SharedCtor() {
  _cached_size_ = 0;
}

Int64FeatureType::~Int64FeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Int64FeatureType)
  SharedDtor();
}

void Int64FeatureType::SharedDtor() {
}

void Int64FeatureType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Int64FeatureType& Int64FeatureType::default_instance() {
  protobuf_FeatureTypes_2eproto::InitDefaults();
  return *internal_default_instance();
}

Int64FeatureType* Int64FeatureType::New(::google::protobuf::Arena* arena) const {
  Int64FeatureType* n = new Int64FeatureType;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Int64FeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Int64FeatureType)
}

bool Int64FeatureType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.Int64FeatureType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.Int64FeatureType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.Int64FeatureType)
  return false;
#undef DO_
}

void Int64FeatureType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.Int64FeatureType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.Int64FeatureType)
}

size_t Int64FeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Int64FeatureType)
  size_t total_size = 0;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Int64FeatureType::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Int64FeatureType*>(&from));
}

void Int64FeatureType::MergeFrom(const Int64FeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Int64FeatureType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void Int64FeatureType::CopyFrom(const Int64FeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Int64FeatureType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int64FeatureType::IsInitialized() const {
  return true;
}

void Int64FeatureType::Swap(Int64FeatureType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Int64FeatureType::InternalSwap(Int64FeatureType* other) {
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Int64FeatureType::GetTypeName() const {
  return "CoreML.Specification.Int64FeatureType";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Int64FeatureType

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DoubleFeatureType::DoubleFeatureType()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_FeatureTypes_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.DoubleFeatureType)
}
DoubleFeatureType::DoubleFeatureType(const DoubleFeatureType& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DoubleFeatureType)
}

void DoubleFeatureType::SharedCtor() {
  _cached_size_ = 0;
}

DoubleFeatureType::~DoubleFeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DoubleFeatureType)
  SharedDtor();
}

void DoubleFeatureType::SharedDtor() {
}

void DoubleFeatureType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DoubleFeatureType& DoubleFeatureType::default_instance() {
  protobuf_FeatureTypes_2eproto::InitDefaults();
  return *internal_default_instance();
}

DoubleFeatureType* DoubleFeatureType::New(::google::protobuf::Arena* arena) const {
  DoubleFeatureType* n = new DoubleFeatureType;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DoubleFeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DoubleFeatureType)
}

bool DoubleFeatureType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.DoubleFeatureType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.DoubleFeatureType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.DoubleFeatureType)
  return false;
#undef DO_
}

void DoubleFeatureType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.DoubleFeatureType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.DoubleFeatureType)
}

size_t DoubleFeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DoubleFeatureType)
  size_t total_size = 0;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DoubleFeatureType::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DoubleFeatureType*>(&from));
}

void DoubleFeatureType::MergeFrom(const DoubleFeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DoubleFeatureType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void DoubleFeatureType::CopyFrom(const DoubleFeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DoubleFeatureType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoubleFeatureType::IsInitialized() const {
  return true;
}

void DoubleFeatureType::Swap(DoubleFeatureType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DoubleFeatureType::InternalSwap(DoubleFeatureType* other) {
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DoubleFeatureType::GetTypeName() const {
  return "CoreML.Specification.DoubleFeatureType";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DoubleFeatureType

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StringFeatureType::StringFeatureType()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_FeatureTypes_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.StringFeatureType)
}
StringFeatureType::StringFeatureType(const StringFeatureType& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.StringFeatureType)
}

void StringFeatureType::SharedCtor() {
  _cached_size_ = 0;
}

StringFeatureType::~StringFeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.StringFeatureType)
  SharedDtor();
}

void StringFeatureType::SharedDtor() {
}

void StringFeatureType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StringFeatureType& StringFeatureType::default_instance() {
  protobuf_FeatureTypes_2eproto::InitDefaults();
  return *internal_default_instance();
}

StringFeatureType* StringFeatureType::New(::google::protobuf::Arena* arena) const {
  StringFeatureType* n = new StringFeatureType;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StringFeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.StringFeatureType)
}

bool StringFeatureType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.StringFeatureType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.StringFeatureType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.StringFeatureType)
  return false;
#undef DO_
}

void StringFeatureType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.StringFeatureType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.StringFeatureType)
}

size_t StringFeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.StringFeatureType)
  size_t total_size = 0;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StringFeatureType::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StringFeatureType*>(&from));
}

void StringFeatureType::MergeFrom(const StringFeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.StringFeatureType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void StringFeatureType::CopyFrom(const StringFeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.StringFeatureType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringFeatureType::IsInitialized() const {
  return true;
}

void StringFeatureType::Swap(StringFeatureType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StringFeatureType::InternalSwap(StringFeatureType* other) {
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string StringFeatureType::GetTypeName() const {
  return "CoreML.Specification.StringFeatureType";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StringFeatureType

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SizeRange::kLowerBoundFieldNumber;
const int SizeRange::kUpperBoundFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SizeRange::SizeRange()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_FeatureTypes_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.SizeRange)
}
SizeRange::SizeRange(const SizeRange& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&lowerbound_, &from.lowerbound_,
    reinterpret_cast<char*>(&upperbound_) -
    reinterpret_cast<char*>(&lowerbound_) + sizeof(upperbound_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SizeRange)
}

void SizeRange::SharedCtor() {
  ::memset(&lowerbound_, 0, reinterpret_cast<char*>(&upperbound_) -
    reinterpret_cast<char*>(&lowerbound_) + sizeof(upperbound_));
  _cached_size_ = 0;
}

SizeRange::~SizeRange() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SizeRange)
  SharedDtor();
}

void SizeRange::SharedDtor() {
}

void SizeRange::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SizeRange& SizeRange::default_instance() {
  protobuf_FeatureTypes_2eproto::InitDefaults();
  return *internal_default_instance();
}

SizeRange* SizeRange::New(::google::protobuf::Arena* arena) const {
  SizeRange* n = new SizeRange;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SizeRange::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SizeRange)
  ::memset(&lowerbound_, 0, reinterpret_cast<char*>(&upperbound_) -
    reinterpret_cast<char*>(&lowerbound_) + sizeof(upperbound_));
}

bool SizeRange::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.SizeRange)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint64 lowerBound = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &lowerbound_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 upperBound = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &upperbound_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.SizeRange)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.SizeRange)
  return false;
#undef DO_
}

void SizeRange::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.SizeRange)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 lowerBound = 1;
  if (this->lowerbound() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->lowerbound(), output);
  }

  // int64 upperBound = 2;
  if (this->upperbound() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->upperbound(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.SizeRange)
}

size_t SizeRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SizeRange)
  size_t total_size = 0;

  // uint64 lowerBound = 1;
  if (this->lowerbound() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->lowerbound());
  }

  // int64 upperBound = 2;
  if (this->upperbound() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->upperbound());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SizeRange::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SizeRange*>(&from));
}

void SizeRange::MergeFrom(const SizeRange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SizeRange)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.lowerbound() != 0) {
    set_lowerbound(from.lowerbound());
  }
  if (from.upperbound() != 0) {
    set_upperbound(from.upperbound());
  }
}

void SizeRange::CopyFrom(const SizeRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SizeRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SizeRange::IsInitialized() const {
  return true;
}

void SizeRange::Swap(SizeRange* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SizeRange::InternalSwap(SizeRange* other) {
  std::swap(lowerbound_, other->lowerbound_);
  std::swap(upperbound_, other->upperbound_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SizeRange::GetTypeName() const {
  return "CoreML.Specification.SizeRange";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SizeRange

// uint64 lowerBound = 1;
void SizeRange::clear_lowerbound() {
  lowerbound_ = GOOGLE_ULONGLONG(0);
}
::google::protobuf::uint64 SizeRange::lowerbound() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SizeRange.lowerBound)
  return lowerbound_;
}
void SizeRange::set_lowerbound(::google::protobuf::uint64 value) {
  
  lowerbound_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SizeRange.lowerBound)
}

// int64 upperBound = 2;
void SizeRange::clear_upperbound() {
  upperbound_ = GOOGLE_LONGLONG(0);
}
::google::protobuf::int64 SizeRange::upperbound() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SizeRange.upperBound)
  return upperbound_;
}
void SizeRange::set_upperbound(::google::protobuf::int64 value) {
  
  upperbound_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SizeRange.upperBound)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ImageFeatureType_ImageSize::kWidthFieldNumber;
const int ImageFeatureType_ImageSize::kHeightFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ImageFeatureType_ImageSize::ImageFeatureType_ImageSize()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_FeatureTypes_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.ImageFeatureType.ImageSize)
}
ImageFeatureType_ImageSize::ImageFeatureType_ImageSize(const ImageFeatureType_ImageSize& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&width_, &from.width_,
    reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_) + sizeof(height_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ImageFeatureType.ImageSize)
}

void ImageFeatureType_ImageSize::SharedCtor() {
  ::memset(&width_, 0, reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_) + sizeof(height_));
  _cached_size_ = 0;
}

ImageFeatureType_ImageSize::~ImageFeatureType_ImageSize() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ImageFeatureType.ImageSize)
  SharedDtor();
}

void ImageFeatureType_ImageSize::SharedDtor() {
}

void ImageFeatureType_ImageSize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ImageFeatureType_ImageSize& ImageFeatureType_ImageSize::default_instance() {
  protobuf_FeatureTypes_2eproto::InitDefaults();
  return *internal_default_instance();
}

ImageFeatureType_ImageSize* ImageFeatureType_ImageSize::New(::google::protobuf::Arena* arena) const {
  ImageFeatureType_ImageSize* n = new ImageFeatureType_ImageSize;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ImageFeatureType_ImageSize::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ImageFeatureType.ImageSize)
  ::memset(&width_, 0, reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_) + sizeof(height_));
}

bool ImageFeatureType_ImageSize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.ImageFeatureType.ImageSize)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint64 width = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &width_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint64 height = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &height_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.ImageFeatureType.ImageSize)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.ImageFeatureType.ImageSize)
  return false;
#undef DO_
}

void ImageFeatureType_ImageSize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.ImageFeatureType.ImageSize)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 width = 1;
  if (this->width() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->width(), output);
  }

  // uint64 height = 2;
  if (this->height() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->height(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.ImageFeatureType.ImageSize)
}

size_t ImageFeatureType_ImageSize::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ImageFeatureType.ImageSize)
  size_t total_size = 0;

  // uint64 width = 1;
  if (this->width() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->width());
  }

  // uint64 height = 2;
  if (this->height() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->height());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImageFeatureType_ImageSize::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ImageFeatureType_ImageSize*>(&from));
}

void ImageFeatureType_ImageSize::MergeFrom(const ImageFeatureType_ImageSize& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ImageFeatureType.ImageSize)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.width() != 0) {
    set_width(from.width());
  }
  if (from.height() != 0) {
    set_height(from.height());
  }
}

void ImageFeatureType_ImageSize::CopyFrom(const ImageFeatureType_ImageSize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ImageFeatureType.ImageSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageFeatureType_ImageSize::IsInitialized() const {
  return true;
}

void ImageFeatureType_ImageSize::Swap(ImageFeatureType_ImageSize* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ImageFeatureType_ImageSize::InternalSwap(ImageFeatureType_ImageSize* other) {
  std::swap(width_, other->width_);
  std::swap(height_, other->height_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ImageFeatureType_ImageSize::GetTypeName() const {
  return "CoreML.Specification.ImageFeatureType.ImageSize";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ImageFeatureType_ImageSize

// uint64 width = 1;
void ImageFeatureType_ImageSize::clear_width() {
  width_ = GOOGLE_ULONGLONG(0);
}
::google::protobuf::uint64 ImageFeatureType_ImageSize::width() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.ImageSize.width)
  return width_;
}
void ImageFeatureType_ImageSize::set_width(::google::protobuf::uint64 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.ImageSize.width)
}

// uint64 height = 2;
void ImageFeatureType_ImageSize::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
}
::google::protobuf::uint64 ImageFeatureType_ImageSize::height() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.ImageSize.height)
  return height_;
}
void ImageFeatureType_ImageSize::set_height(::google::protobuf::uint64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.ImageSize.height)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ImageFeatureType_EnumeratedImageSizes::kSizesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ImageFeatureType_EnumeratedImageSizes::ImageFeatureType_EnumeratedImageSizes()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_FeatureTypes_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
}
ImageFeatureType_EnumeratedImageSizes::ImageFeatureType_EnumeratedImageSizes(const ImageFeatureType_EnumeratedImageSizes& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      sizes_(from.sizes_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
}

void ImageFeatureType_EnumeratedImageSizes::SharedCtor() {
  _cached_size_ = 0;
}

ImageFeatureType_EnumeratedImageSizes::~ImageFeatureType_EnumeratedImageSizes() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
  SharedDtor();
}

void ImageFeatureType_EnumeratedImageSizes::SharedDtor() {
}

void ImageFeatureType_EnumeratedImageSizes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ImageFeatureType_EnumeratedImageSizes& ImageFeatureType_EnumeratedImageSizes::default_instance() {
  protobuf_FeatureTypes_2eproto::InitDefaults();
  return *internal_default_instance();
}

ImageFeatureType_EnumeratedImageSizes* ImageFeatureType_EnumeratedImageSizes::New(::google::protobuf::Arena* arena) const {
  ImageFeatureType_EnumeratedImageSizes* n = new ImageFeatureType_EnumeratedImageSizes;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ImageFeatureType_EnumeratedImageSizes::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
  sizes_.Clear();
}

bool ImageFeatureType_EnumeratedImageSizes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CoreML.Specification.ImageFeatureType.ImageSize sizes = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sizes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
  return false;
#undef DO_
}

void ImageFeatureType_EnumeratedImageSizes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.ImageFeatureType.ImageSize sizes = 1;
  for (unsigned int i = 0, n = this->sizes_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->sizes(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
}

size_t ImageFeatureType_EnumeratedImageSizes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
  size_t total_size = 0;

  // repeated .CoreML.Specification.ImageFeatureType.ImageSize sizes = 1;
  {
    unsigned int count = this->sizes_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sizes(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImageFeatureType_EnumeratedImageSizes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ImageFeatureType_EnumeratedImageSizes*>(&from));
}

void ImageFeatureType_EnumeratedImageSizes::MergeFrom(const ImageFeatureType_EnumeratedImageSizes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  sizes_.MergeFrom(from.sizes_);
}

void ImageFeatureType_EnumeratedImageSizes::CopyFrom(const ImageFeatureType_EnumeratedImageSizes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageFeatureType_EnumeratedImageSizes::IsInitialized() const {
  return true;
}

void ImageFeatureType_EnumeratedImageSizes::Swap(ImageFeatureType_EnumeratedImageSizes* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ImageFeatureType_EnumeratedImageSizes::InternalSwap(ImageFeatureType_EnumeratedImageSizes* other) {
  sizes_.InternalSwap(&other->sizes_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ImageFeatureType_EnumeratedImageSizes::GetTypeName() const {
  return "CoreML.Specification.ImageFeatureType.EnumeratedImageSizes";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ImageFeatureType_EnumeratedImageSizes

// repeated .CoreML.Specification.ImageFeatureType.ImageSize sizes = 1;
int ImageFeatureType_EnumeratedImageSizes::sizes_size() const {
  return sizes_.size();
}
void ImageFeatureType_EnumeratedImageSizes::clear_sizes() {
  sizes_.Clear();
}
const ::CoreML::Specification::ImageFeatureType_ImageSize& ImageFeatureType_EnumeratedImageSizes::sizes(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.sizes)
  return sizes_.Get(index);
}
::CoreML::Specification::ImageFeatureType_ImageSize* ImageFeatureType_EnumeratedImageSizes::mutable_sizes(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.sizes)
  return sizes_.Mutable(index);
}
::CoreML::Specification::ImageFeatureType_ImageSize* ImageFeatureType_EnumeratedImageSizes::add_sizes() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.sizes)
  return sizes_.Add();
}
::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ImageFeatureType_ImageSize >*
ImageFeatureType_EnumeratedImageSizes::mutable_sizes() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.sizes)
  return &sizes_;
}
const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ImageFeatureType_ImageSize >&
ImageFeatureType_EnumeratedImageSizes::sizes() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.sizes)
  return sizes_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ImageFeatureType_ImageSizeRange::kWidthRangeFieldNumber;
const int ImageFeatureType_ImageSizeRange::kHeightRangeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ImageFeatureType_ImageSizeRange::ImageFeatureType_ImageSizeRange()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_FeatureTypes_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.ImageFeatureType.ImageSizeRange)
}
ImageFeatureType_ImageSizeRange::ImageFeatureType_ImageSizeRange(const ImageFeatureType_ImageSizeRange& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_widthrange()) {
    widthrange_ = new ::CoreML::Specification::SizeRange(*from.widthrange_);
  } else {
    widthrange_ = NULL;
  }
  if (from.has_heightrange()) {
    heightrange_ = new ::CoreML::Specification::SizeRange(*from.heightrange_);
  } else {
    heightrange_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ImageFeatureType.ImageSizeRange)
}

void ImageFeatureType_ImageSizeRange::SharedCtor() {
  ::memset(&widthrange_, 0, reinterpret_cast<char*>(&heightrange_) -
    reinterpret_cast<char*>(&widthrange_) + sizeof(heightrange_));
  _cached_size_ = 0;
}

ImageFeatureType_ImageSizeRange::~ImageFeatureType_ImageSizeRange() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ImageFeatureType.ImageSizeRange)
  SharedDtor();
}

void ImageFeatureType_ImageSizeRange::SharedDtor() {
  if (this != internal_default_instance()) {
    delete widthrange_;
  }
  if (this != internal_default_instance()) {
    delete heightrange_;
  }
}

void ImageFeatureType_ImageSizeRange::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ImageFeatureType_ImageSizeRange& ImageFeatureType_ImageSizeRange::default_instance() {
  protobuf_FeatureTypes_2eproto::InitDefaults();
  return *internal_default_instance();
}

ImageFeatureType_ImageSizeRange* ImageFeatureType_ImageSizeRange::New(::google::protobuf::Arena* arena) const {
  ImageFeatureType_ImageSizeRange* n = new ImageFeatureType_ImageSizeRange;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ImageFeatureType_ImageSizeRange::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ImageFeatureType.ImageSizeRange)
  if (GetArenaNoVirtual() == NULL && widthrange_ != NULL) {
    delete widthrange_;
  }
  widthrange_ = NULL;
  if (GetArenaNoVirtual() == NULL && heightrange_ != NULL) {
    delete heightrange_;
  }
  heightrange_ = NULL;
}

bool ImageFeatureType_ImageSizeRange::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.ImageFeatureType.ImageSizeRange)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .CoreML.Specification.SizeRange widthRange = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_widthrange()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.SizeRange heightRange = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_heightrange()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.ImageFeatureType.ImageSizeRange)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.ImageFeatureType.ImageSizeRange)
  return false;
#undef DO_
}

void ImageFeatureType_ImageSizeRange::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.ImageFeatureType.ImageSizeRange)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.SizeRange widthRange = 1;
  if (this->has_widthrange()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->widthrange_, output);
  }

  // .CoreML.Specification.SizeRange heightRange = 2;
  if (this->has_heightrange()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->heightrange_, output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.ImageFeatureType.ImageSizeRange)
}

size_t ImageFeatureType_ImageSizeRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ImageFeatureType.ImageSizeRange)
  size_t total_size = 0;

  // .CoreML.Specification.SizeRange widthRange = 1;
  if (this->has_widthrange()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->widthrange_);
  }

  // .CoreML.Specification.SizeRange heightRange = 2;
  if (this->has_heightrange()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->heightrange_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImageFeatureType_ImageSizeRange::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ImageFeatureType_ImageSizeRange*>(&from));
}

void ImageFeatureType_ImageSizeRange::MergeFrom(const ImageFeatureType_ImageSizeRange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ImageFeatureType.ImageSizeRange)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_widthrange()) {
    mutable_widthrange()->::CoreML::Specification::SizeRange::MergeFrom(from.widthrange());
  }
  if (from.has_heightrange()) {
    mutable_heightrange()->::CoreML::Specification::SizeRange::MergeFrom(from.heightrange());
  }
}

void ImageFeatureType_ImageSizeRange::CopyFrom(const ImageFeatureType_ImageSizeRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ImageFeatureType.ImageSizeRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageFeatureType_ImageSizeRange::IsInitialized() const {
  return true;
}

void ImageFeatureType_ImageSizeRange::Swap(ImageFeatureType_ImageSizeRange* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ImageFeatureType_ImageSizeRange::InternalSwap(ImageFeatureType_ImageSizeRange* other) {
  std::swap(widthrange_, other->widthrange_);
  std::swap(heightrange_, other->heightrange_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ImageFeatureType_ImageSizeRange::GetTypeName() const {
  return "CoreML.Specification.ImageFeatureType.ImageSizeRange";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ImageFeatureType_ImageSizeRange

// .CoreML.Specification.SizeRange widthRange = 1;
bool ImageFeatureType_ImageSizeRange::has_widthrange() const {
  return this != internal_default_instance() && widthrange_ != NULL;
}
void ImageFeatureType_ImageSizeRange::clear_widthrange() {
  if (GetArenaNoVirtual() == NULL && widthrange_ != NULL) delete widthrange_;
  widthrange_ = NULL;
}
const ::CoreML::Specification::SizeRange& ImageFeatureType_ImageSizeRange::widthrange() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.ImageSizeRange.widthRange)
  return widthrange_ != NULL ? *widthrange_
                         : *::CoreML::Specification::SizeRange::internal_default_instance();
}
::CoreML::Specification::SizeRange* ImageFeatureType_ImageSizeRange::mutable_widthrange() {
  
  if (widthrange_ == NULL) {
    widthrange_ = new ::CoreML::Specification::SizeRange;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ImageFeatureType.ImageSizeRange.widthRange)
  return widthrange_;
}
::CoreML::Specification::SizeRange* ImageFeatureType_ImageSizeRange::release_widthrange() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ImageFeatureType.ImageSizeRange.widthRange)
  
  ::CoreML::Specification::SizeRange* temp = widthrange_;
  widthrange_ = NULL;
  return temp;
}
void ImageFeatureType_ImageSizeRange::set_allocated_widthrange(::CoreML::Specification::SizeRange* widthrange) {
  delete widthrange_;
  widthrange_ = widthrange;
  if (widthrange) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ImageFeatureType.ImageSizeRange.widthRange)
}

// .CoreML.Specification.SizeRange heightRange = 2;
bool ImageFeatureType_ImageSizeRange::has_heightrange() const {
  return this != internal_default_instance() && heightrange_ != NULL;
}
void ImageFeatureType_ImageSizeRange::clear_heightrange() {
  if (GetArenaNoVirtual() == NULL && heightrange_ != NULL) delete heightrange_;
  heightrange_ = NULL;
}
const ::CoreML::Specification::SizeRange& ImageFeatureType_ImageSizeRange::heightrange() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.ImageSizeRange.heightRange)
  return heightrange_ != NULL ? *heightrange_
                         : *::CoreML::Specification::SizeRange::internal_default_instance();
}
::CoreML::Specification::SizeRange* ImageFeatureType_ImageSizeRange::mutable_heightrange() {
  
  if (heightrange_ == NULL) {
    heightrange_ = new ::CoreML::Specification::SizeRange;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ImageFeatureType.ImageSizeRange.heightRange)
  return heightrange_;
}
::CoreML::Specification::SizeRange* ImageFeatureType_ImageSizeRange::release_heightrange() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ImageFeatureType.ImageSizeRange.heightRange)
  
  ::CoreML::Specification::SizeRange* temp = heightrange_;
  heightrange_ = NULL;
  return temp;
}
void ImageFeatureType_ImageSizeRange::set_allocated_heightrange(::CoreML::Specification::SizeRange* heightrange) {
  delete heightrange_;
  heightrange_ = heightrange;
  if (heightrange) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ImageFeatureType.ImageSizeRange.heightRange)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ImageFeatureType::kWidthFieldNumber;
const int ImageFeatureType::kHeightFieldNumber;
const int ImageFeatureType::kEnumeratedSizesFieldNumber;
const int ImageFeatureType::kImageSizeRangeFieldNumber;
const int ImageFeatureType::kColorSpaceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ImageFeatureType::ImageFeatureType()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_FeatureTypes_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.ImageFeatureType)
}
ImageFeatureType::ImageFeatureType(const ImageFeatureType& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&width_, &from.width_,
    reinterpret_cast<char*>(&colorspace_) -
    reinterpret_cast<char*>(&width_) + sizeof(colorspace_));
  clear_has_SizeFlexibility();
  switch (from.SizeFlexibility_case()) {
    case kEnumeratedSizes: {
      mutable_enumeratedsizes()->::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes::MergeFrom(from.enumeratedsizes());
      break;
    }
    case kImageSizeRange: {
      mutable_imagesizerange()->::CoreML::Specification::ImageFeatureType_ImageSizeRange::MergeFrom(from.imagesizerange());
      break;
    }
    case SIZEFLEXIBILITY_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ImageFeatureType)
}

void ImageFeatureType::SharedCtor() {
  ::memset(&width_, 0, reinterpret_cast<char*>(&colorspace_) -
    reinterpret_cast<char*>(&width_) + sizeof(colorspace_));
  clear_has_SizeFlexibility();
  _cached_size_ = 0;
}

ImageFeatureType::~ImageFeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ImageFeatureType)
  SharedDtor();
}

void ImageFeatureType::SharedDtor() {
  if (has_SizeFlexibility()) {
    clear_SizeFlexibility();
  }
}

void ImageFeatureType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ImageFeatureType& ImageFeatureType::default_instance() {
  protobuf_FeatureTypes_2eproto::InitDefaults();
  return *internal_default_instance();
}

ImageFeatureType* ImageFeatureType::New(::google::protobuf::Arena* arena) const {
  ImageFeatureType* n = new ImageFeatureType;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ImageFeatureType::clear_SizeFlexibility() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.ImageFeatureType)
  switch (SizeFlexibility_case()) {
    case kEnumeratedSizes: {
      delete SizeFlexibility_.enumeratedsizes_;
      break;
    }
    case kImageSizeRange: {
      delete SizeFlexibility_.imagesizerange_;
      break;
    }
    case SIZEFLEXIBILITY_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SIZEFLEXIBILITY_NOT_SET;
}


void ImageFeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ImageFeatureType)
  ::memset(&width_, 0, reinterpret_cast<char*>(&colorspace_) -
    reinterpret_cast<char*>(&width_) + sizeof(colorspace_));
  clear_SizeFlexibility();
}

bool ImageFeatureType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.ImageFeatureType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int64 width = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &width_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 height = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &height_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.ImageFeatureType.ColorSpace colorSpace = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_colorspace(static_cast< ::CoreML::Specification::ImageFeatureType_ColorSpace >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.ImageFeatureType.EnumeratedImageSizes enumeratedSizes = 21;
      case 21: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(170u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_enumeratedsizes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.ImageFeatureType.ImageSizeRange imageSizeRange = 31;
      case 31: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(250u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_imagesizerange()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.ImageFeatureType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.ImageFeatureType)
  return false;
#undef DO_
}

void ImageFeatureType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.ImageFeatureType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 width = 1;
  if (this->width() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->width(), output);
  }

  // int64 height = 2;
  if (this->height() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->height(), output);
  }

  // .CoreML.Specification.ImageFeatureType.ColorSpace colorSpace = 3;
  if (this->colorspace() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->colorspace(), output);
  }

  // .CoreML.Specification.ImageFeatureType.EnumeratedImageSizes enumeratedSizes = 21;
  if (has_enumeratedsizes()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      21, *SizeFlexibility_.enumeratedsizes_, output);
  }

  // .CoreML.Specification.ImageFeatureType.ImageSizeRange imageSizeRange = 31;
  if (has_imagesizerange()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      31, *SizeFlexibility_.imagesizerange_, output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.ImageFeatureType)
}

size_t ImageFeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ImageFeatureType)
  size_t total_size = 0;

  // int64 width = 1;
  if (this->width() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->width());
  }

  // int64 height = 2;
  if (this->height() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->height());
  }

  // .CoreML.Specification.ImageFeatureType.ColorSpace colorSpace = 3;
  if (this->colorspace() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->colorspace());
  }

  switch (SizeFlexibility_case()) {
    // .CoreML.Specification.ImageFeatureType.EnumeratedImageSizes enumeratedSizes = 21;
    case kEnumeratedSizes: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *SizeFlexibility_.enumeratedsizes_);
      break;
    }
    // .CoreML.Specification.ImageFeatureType.ImageSizeRange imageSizeRange = 31;
    case kImageSizeRange: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *SizeFlexibility_.imagesizerange_);
      break;
    }
    case SIZEFLEXIBILITY_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImageFeatureType::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ImageFeatureType*>(&from));
}

void ImageFeatureType::MergeFrom(const ImageFeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ImageFeatureType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.width() != 0) {
    set_width(from.width());
  }
  if (from.height() != 0) {
    set_height(from.height());
  }
  if (from.colorspace() != 0) {
    set_colorspace(from.colorspace());
  }
  switch (from.SizeFlexibility_case()) {
    case kEnumeratedSizes: {
      mutable_enumeratedsizes()->::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes::MergeFrom(from.enumeratedsizes());
      break;
    }
    case kImageSizeRange: {
      mutable_imagesizerange()->::CoreML::Specification::ImageFeatureType_ImageSizeRange::MergeFrom(from.imagesizerange());
      break;
    }
    case SIZEFLEXIBILITY_NOT_SET: {
      break;
    }
  }
}

void ImageFeatureType::CopyFrom(const ImageFeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ImageFeatureType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageFeatureType::IsInitialized() const {
  return true;
}

void ImageFeatureType::Swap(ImageFeatureType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ImageFeatureType::InternalSwap(ImageFeatureType* other) {
  std::swap(width_, other->width_);
  std::swap(height_, other->height_);
  std::swap(colorspace_, other->colorspace_);
  std::swap(SizeFlexibility_, other->SizeFlexibility_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ImageFeatureType::GetTypeName() const {
  return "CoreML.Specification.ImageFeatureType";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ImageFeatureType

// int64 width = 1;
void ImageFeatureType::clear_width() {
  width_ = GOOGLE_LONGLONG(0);
}
::google::protobuf::int64 ImageFeatureType::width() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.width)
  return width_;
}
void ImageFeatureType::set_width(::google::protobuf::int64 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.width)
}

// int64 height = 2;
void ImageFeatureType::clear_height() {
  height_ = GOOGLE_LONGLONG(0);
}
::google::protobuf::int64 ImageFeatureType::height() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.height)
  return height_;
}
void ImageFeatureType::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.height)
}

// .CoreML.Specification.ImageFeatureType.EnumeratedImageSizes enumeratedSizes = 21;
bool ImageFeatureType::has_enumeratedsizes() const {
  return SizeFlexibility_case() == kEnumeratedSizes;
}
void ImageFeatureType::set_has_enumeratedsizes() {
  _oneof_case_[0] = kEnumeratedSizes;
}
void ImageFeatureType::clear_enumeratedsizes() {
  if (has_enumeratedsizes()) {
    delete SizeFlexibility_.enumeratedsizes_;
    clear_has_SizeFlexibility();
  }
}
 const ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes& ImageFeatureType::enumeratedsizes() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.enumeratedSizes)
  return has_enumeratedsizes()
      ? *SizeFlexibility_.enumeratedsizes_
      : ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes::default_instance();
}
::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* ImageFeatureType::mutable_enumeratedsizes() {
  if (!has_enumeratedsizes()) {
    clear_SizeFlexibility();
    set_has_enumeratedsizes();
    SizeFlexibility_.enumeratedsizes_ = new ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ImageFeatureType.enumeratedSizes)
  return SizeFlexibility_.enumeratedsizes_;
}
::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* ImageFeatureType::release_enumeratedsizes() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ImageFeatureType.enumeratedSizes)
  if (has_enumeratedsizes()) {
    clear_has_SizeFlexibility();
    ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* temp = SizeFlexibility_.enumeratedsizes_;
    SizeFlexibility_.enumeratedsizes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ImageFeatureType::set_allocated_enumeratedsizes(::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* enumeratedsizes) {
  clear_SizeFlexibility();
  if (enumeratedsizes) {
    set_has_enumeratedsizes();
    SizeFlexibility_.enumeratedsizes_ = enumeratedsizes;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ImageFeatureType.enumeratedSizes)
}

// .CoreML.Specification.ImageFeatureType.ImageSizeRange imageSizeRange = 31;
bool ImageFeatureType::has_imagesizerange() const {
  return SizeFlexibility_case() == kImageSizeRange;
}
void ImageFeatureType::set_has_imagesizerange() {
  _oneof_case_[0] = kImageSizeRange;
}
void ImageFeatureType::clear_imagesizerange() {
  if (has_imagesizerange()) {
    delete SizeFlexibility_.imagesizerange_;
    clear_has_SizeFlexibility();
  }
}
 const ::CoreML::Specification::ImageFeatureType_ImageSizeRange& ImageFeatureType::imagesizerange() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.imageSizeRange)
  return has_imagesizerange()
      ? *SizeFlexibility_.imagesizerange_
      : ::CoreML::Specification::ImageFeatureType_ImageSizeRange::default_instance();
}
::CoreML::Specification::ImageFeatureType_ImageSizeRange* ImageFeatureType::mutable_imagesizerange() {
  if (!has_imagesizerange()) {
    clear_SizeFlexibility();
    set_has_imagesizerange();
    SizeFlexibility_.imagesizerange_ = new ::CoreML::Specification::ImageFeatureType_ImageSizeRange;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ImageFeatureType.imageSizeRange)
  return SizeFlexibility_.imagesizerange_;
}
::CoreML::Specification::ImageFeatureType_ImageSizeRange* ImageFeatureType::release_imagesizerange() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ImageFeatureType.imageSizeRange)
  if (has_imagesizerange()) {
    clear_has_SizeFlexibility();
    ::CoreML::Specification::ImageFeatureType_ImageSizeRange* temp = SizeFlexibility_.imagesizerange_;
    SizeFlexibility_.imagesizerange_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ImageFeatureType::set_allocated_imagesizerange(::CoreML::Specification::ImageFeatureType_ImageSizeRange* imagesizerange) {
  clear_SizeFlexibility();
  if (imagesizerange) {
    set_has_imagesizerange();
    SizeFlexibility_.imagesizerange_ = imagesizerange;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ImageFeatureType.imageSizeRange)
}

// .CoreML.Specification.ImageFeatureType.ColorSpace colorSpace = 3;
void ImageFeatureType::clear_colorspace() {
  colorspace_ = 0;
}
::CoreML::Specification::ImageFeatureType_ColorSpace ImageFeatureType::colorspace() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.colorSpace)
  return static_cast< ::CoreML::Specification::ImageFeatureType_ColorSpace >(colorspace_);
}
void ImageFeatureType::set_colorspace(::CoreML::Specification::ImageFeatureType_ColorSpace value) {
  
  colorspace_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.colorSpace)
}

bool ImageFeatureType::has_SizeFlexibility() const {
  return SizeFlexibility_case() != SIZEFLEXIBILITY_NOT_SET;
}
void ImageFeatureType::clear_has_SizeFlexibility() {
  _oneof_case_[0] = SIZEFLEXIBILITY_NOT_SET;
}
ImageFeatureType::SizeFlexibilityCase ImageFeatureType::SizeFlexibility_case() const {
  return ImageFeatureType::SizeFlexibilityCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ArrayFeatureType_Shape::kShapeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ArrayFeatureType_Shape::ArrayFeatureType_Shape()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_FeatureTypes_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.ArrayFeatureType.Shape)
}
ArrayFeatureType_Shape::ArrayFeatureType_Shape(const ArrayFeatureType_Shape& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      shape_(from.shape_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ArrayFeatureType.Shape)
}

void ArrayFeatureType_Shape::SharedCtor() {
  _cached_size_ = 0;
}

ArrayFeatureType_Shape::~ArrayFeatureType_Shape() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ArrayFeatureType.Shape)
  SharedDtor();
}

void ArrayFeatureType_Shape::SharedDtor() {
}

void ArrayFeatureType_Shape::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ArrayFeatureType_Shape& ArrayFeatureType_Shape::default_instance() {
  protobuf_FeatureTypes_2eproto::InitDefaults();
  return *internal_default_instance();
}

ArrayFeatureType_Shape* ArrayFeatureType_Shape::New(::google::protobuf::Arena* arena) const {
  ArrayFeatureType_Shape* n = new ArrayFeatureType_Shape;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ArrayFeatureType_Shape::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ArrayFeatureType.Shape)
  shape_.Clear();
}

bool ArrayFeatureType_Shape::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.ArrayFeatureType.Shape)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int64 shape = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_shape())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(8u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 10u, input, this->mutable_shape())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.ArrayFeatureType.Shape)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.ArrayFeatureType.Shape)
  return false;
#undef DO_
}

void ArrayFeatureType_Shape::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.ArrayFeatureType.Shape)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 shape = 1;
  if (this->shape_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_shape_cached_byte_size_);
  }
  for (int i = 0, n = this->shape_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64NoTag(
      this->shape(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.ArrayFeatureType.Shape)
}

size_t ArrayFeatureType_Shape::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ArrayFeatureType.Shape)
  size_t total_size = 0;

  // repeated int64 shape = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int64Size(this->shape_);
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _shape_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ArrayFeatureType_Shape::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ArrayFeatureType_Shape*>(&from));
}

void ArrayFeatureType_Shape::MergeFrom(const ArrayFeatureType_Shape& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ArrayFeatureType.Shape)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  shape_.MergeFrom(from.shape_);
}

void ArrayFeatureType_Shape::CopyFrom(const ArrayFeatureType_Shape& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ArrayFeatureType.Shape)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArrayFeatureType_Shape::IsInitialized() const {
  return true;
}

void ArrayFeatureType_Shape::Swap(ArrayFeatureType_Shape* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ArrayFeatureType_Shape::InternalSwap(ArrayFeatureType_Shape* other) {
  shape_.InternalSwap(&other->shape_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ArrayFeatureType_Shape::GetTypeName() const {
  return "CoreML.Specification.ArrayFeatureType.Shape";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ArrayFeatureType_Shape

// repeated int64 shape = 1;
int ArrayFeatureType_Shape::shape_size() const {
  return shape_.size();
}
void ArrayFeatureType_Shape::clear_shape() {
  shape_.Clear();
}
::google::protobuf::int64 ArrayFeatureType_Shape::shape(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.Shape.shape)
  return shape_.Get(index);
}
void ArrayFeatureType_Shape::set_shape(int index, ::google::protobuf::int64 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ArrayFeatureType.Shape.shape)
}
void ArrayFeatureType_Shape::add_shape(::google::protobuf::int64 value) {
  shape_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.ArrayFeatureType.Shape.shape)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
ArrayFeatureType_Shape::shape() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ArrayFeatureType.Shape.shape)
  return shape_;
}
::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
ArrayFeatureType_Shape::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ArrayFeatureType.Shape.shape)
  return &shape_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ArrayFeatureType_EnumeratedShapes::kShapesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ArrayFeatureType_EnumeratedShapes::ArrayFeatureType_EnumeratedShapes()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_FeatureTypes_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
}
ArrayFeatureType_EnumeratedShapes::ArrayFeatureType_EnumeratedShapes(const ArrayFeatureType_EnumeratedShapes& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      shapes_(from.shapes_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
}

void ArrayFeatureType_EnumeratedShapes::SharedCtor() {
  _cached_size_ = 0;
}

ArrayFeatureType_EnumeratedShapes::~ArrayFeatureType_EnumeratedShapes() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
  SharedDtor();
}

void ArrayFeatureType_EnumeratedShapes::SharedDtor() {
}

void ArrayFeatureType_EnumeratedShapes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ArrayFeatureType_EnumeratedShapes& ArrayFeatureType_EnumeratedShapes::default_instance() {
  protobuf_FeatureTypes_2eproto::InitDefaults();
  return *internal_default_instance();
}

ArrayFeatureType_EnumeratedShapes* ArrayFeatureType_EnumeratedShapes::New(::google::protobuf::Arena* arena) const {
  ArrayFeatureType_EnumeratedShapes* n = new ArrayFeatureType_EnumeratedShapes;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ArrayFeatureType_EnumeratedShapes::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
  shapes_.Clear();
}

bool ArrayFeatureType_EnumeratedShapes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CoreML.Specification.ArrayFeatureType.Shape shapes = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_shapes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
  return false;
#undef DO_
}

void ArrayFeatureType_EnumeratedShapes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.ArrayFeatureType.Shape shapes = 1;
  for (unsigned int i = 0, n = this->shapes_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->shapes(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
}

size_t ArrayFeatureType_EnumeratedShapes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
  size_t total_size = 0;

  // repeated .CoreML.Specification.ArrayFeatureType.Shape shapes = 1;
  {
    unsigned int count = this->shapes_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->shapes(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ArrayFeatureType_EnumeratedShapes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ArrayFeatureType_EnumeratedShapes*>(&from));
}

void ArrayFeatureType_EnumeratedShapes::MergeFrom(const ArrayFeatureType_EnumeratedShapes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  shapes_.MergeFrom(from.shapes_);
}

void ArrayFeatureType_EnumeratedShapes::CopyFrom(const ArrayFeatureType_EnumeratedShapes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArrayFeatureType_EnumeratedShapes::IsInitialized() const {
  return true;
}

void ArrayFeatureType_EnumeratedShapes::Swap(ArrayFeatureType_EnumeratedShapes* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ArrayFeatureType_EnumeratedShapes::InternalSwap(ArrayFeatureType_EnumeratedShapes* other) {
  shapes_.InternalSwap(&other->shapes_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ArrayFeatureType_EnumeratedShapes::GetTypeName() const {
  return "CoreML.Specification.ArrayFeatureType.EnumeratedShapes";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ArrayFeatureType_EnumeratedShapes

// repeated .CoreML.Specification.ArrayFeatureType.Shape shapes = 1;
int ArrayFeatureType_EnumeratedShapes::shapes_size() const {
  return shapes_.size();
}
void ArrayFeatureType_EnumeratedShapes::clear_shapes() {
  shapes_.Clear();
}
const ::CoreML::Specification::ArrayFeatureType_Shape& ArrayFeatureType_EnumeratedShapes::shapes(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.EnumeratedShapes.shapes)
  return shapes_.Get(index);
}
::CoreML::Specification::ArrayFeatureType_Shape* ArrayFeatureType_EnumeratedShapes::mutable_shapes(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ArrayFeatureType.EnumeratedShapes.shapes)
  return shapes_.Mutable(index);
}
::CoreML::Specification::ArrayFeatureType_Shape* ArrayFeatureType_EnumeratedShapes::add_shapes() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.ArrayFeatureType.EnumeratedShapes.shapes)
  return shapes_.Add();
}
::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ArrayFeatureType_Shape >*
ArrayFeatureType_EnumeratedShapes::mutable_shapes() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ArrayFeatureType.EnumeratedShapes.shapes)
  return &shapes_;
}
const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ArrayFeatureType_Shape >&
ArrayFeatureType_EnumeratedShapes::shapes() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ArrayFeatureType.EnumeratedShapes.shapes)
  return shapes_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ArrayFeatureType_ShapeRange::kSizeRangesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ArrayFeatureType_ShapeRange::ArrayFeatureType_ShapeRange()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_FeatureTypes_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.ArrayFeatureType.ShapeRange)
}
ArrayFeatureType_ShapeRange::ArrayFeatureType_ShapeRange(const ArrayFeatureType_ShapeRange& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      sizeranges_(from.sizeranges_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ArrayFeatureType.ShapeRange)
}

void ArrayFeatureType_ShapeRange::SharedCtor() {
  _cached_size_ = 0;
}

ArrayFeatureType_ShapeRange::~ArrayFeatureType_ShapeRange() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ArrayFeatureType.ShapeRange)
  SharedDtor();
}

void ArrayFeatureType_ShapeRange::SharedDtor() {
}

void ArrayFeatureType_ShapeRange::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ArrayFeatureType_ShapeRange& ArrayFeatureType_ShapeRange::default_instance() {
  protobuf_FeatureTypes_2eproto::InitDefaults();
  return *internal_default_instance();
}

ArrayFeatureType_ShapeRange* ArrayFeatureType_ShapeRange::New(::google::protobuf::Arena* arena) const {
  ArrayFeatureType_ShapeRange* n = new ArrayFeatureType_ShapeRange;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ArrayFeatureType_ShapeRange::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ArrayFeatureType.ShapeRange)
  sizeranges_.Clear();
}

bool ArrayFeatureType_ShapeRange::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.ArrayFeatureType.ShapeRange)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CoreML.Specification.SizeRange sizeRanges = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sizeranges()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.ArrayFeatureType.ShapeRange)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.ArrayFeatureType.ShapeRange)
  return false;
#undef DO_
}

void ArrayFeatureType_ShapeRange::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.ArrayFeatureType.ShapeRange)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.SizeRange sizeRanges = 1;
  for (unsigned int i = 0, n = this->sizeranges_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->sizeranges(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.ArrayFeatureType.ShapeRange)
}

size_t ArrayFeatureType_ShapeRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ArrayFeatureType.ShapeRange)
  size_t total_size = 0;

  // repeated .CoreML.Specification.SizeRange sizeRanges = 1;
  {
    unsigned int count = this->sizeranges_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sizeranges(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ArrayFeatureType_ShapeRange::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ArrayFeatureType_ShapeRange*>(&from));
}

void ArrayFeatureType_ShapeRange::MergeFrom(const ArrayFeatureType_ShapeRange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ArrayFeatureType.ShapeRange)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  sizeranges_.MergeFrom(from.sizeranges_);
}

void ArrayFeatureType_ShapeRange::CopyFrom(const ArrayFeatureType_ShapeRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ArrayFeatureType.ShapeRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArrayFeatureType_ShapeRange::IsInitialized() const {
  return true;
}

void ArrayFeatureType_ShapeRange::Swap(ArrayFeatureType_ShapeRange* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ArrayFeatureType_ShapeRange::InternalSwap(ArrayFeatureType_ShapeRange* other) {
  sizeranges_.InternalSwap(&other->sizeranges_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ArrayFeatureType_ShapeRange::GetTypeName() const {
  return "CoreML.Specification.ArrayFeatureType.ShapeRange";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ArrayFeatureType_ShapeRange

// repeated .CoreML.Specification.SizeRange sizeRanges = 1;
int ArrayFeatureType_ShapeRange::sizeranges_size() const {
  return sizeranges_.size();
}
void ArrayFeatureType_ShapeRange::clear_sizeranges() {
  sizeranges_.Clear();
}
const ::CoreML::Specification::SizeRange& ArrayFeatureType_ShapeRange::sizeranges(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.ShapeRange.sizeRanges)
  return sizeranges_.Get(index);
}
::CoreML::Specification::SizeRange* ArrayFeatureType_ShapeRange::mutable_sizeranges(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ArrayFeatureType.ShapeRange.sizeRanges)
  return sizeranges_.Mutable(index);
}
::CoreML::Specification::SizeRange* ArrayFeatureType_ShapeRange::add_sizeranges() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.ArrayFeatureType.ShapeRange.sizeRanges)
  return sizeranges_.Add();
}
::google::protobuf::RepeatedPtrField< ::CoreML::Specification::SizeRange >*
ArrayFeatureType_ShapeRange::mutable_sizeranges() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ArrayFeatureType.ShapeRange.sizeRanges)
  return &sizeranges_;
}
const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::SizeRange >&
ArrayFeatureType_ShapeRange::sizeranges() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ArrayFeatureType.ShapeRange.sizeRanges)
  return sizeranges_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ArrayFeatureType::kShapeFieldNumber;
const int ArrayFeatureType::kDataTypeFieldNumber;
const int ArrayFeatureType::kEnumeratedShapesFieldNumber;
const int ArrayFeatureType::kShapeRangeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ArrayFeatureType::ArrayFeatureType()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_FeatureTypes_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.ArrayFeatureType)
}
ArrayFeatureType::ArrayFeatureType(const ArrayFeatureType& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      shape_(from.shape_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  datatype_ = from.datatype_;
  clear_has_ShapeFlexibility();
  switch (from.ShapeFlexibility_case()) {
    case kEnumeratedShapes: {
      mutable_enumeratedshapes()->::CoreML::Specification::ArrayFeatureType_EnumeratedShapes::MergeFrom(from.enumeratedshapes());
      break;
    }
    case kShapeRange: {
      mutable_shaperange()->::CoreML::Specification::ArrayFeatureType_ShapeRange::MergeFrom(from.shaperange());
      break;
    }
    case SHAPEFLEXIBILITY_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ArrayFeatureType)
}

void ArrayFeatureType::SharedCtor() {
  datatype_ = 0;
  clear_has_ShapeFlexibility();
  _cached_size_ = 0;
}

ArrayFeatureType::~ArrayFeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ArrayFeatureType)
  SharedDtor();
}

void ArrayFeatureType::SharedDtor() {
  if (has_ShapeFlexibility()) {
    clear_ShapeFlexibility();
  }
}

void ArrayFeatureType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ArrayFeatureType& ArrayFeatureType::default_instance() {
  protobuf_FeatureTypes_2eproto::InitDefaults();
  return *internal_default_instance();
}

ArrayFeatureType* ArrayFeatureType::New(::google::protobuf::Arena* arena) const {
  ArrayFeatureType* n = new ArrayFeatureType;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ArrayFeatureType::clear_ShapeFlexibility() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.ArrayFeatureType)
  switch (ShapeFlexibility_case()) {
    case kEnumeratedShapes: {
      delete ShapeFlexibility_.enumeratedshapes_;
      break;
    }
    case kShapeRange: {
      delete ShapeFlexibility_.shaperange_;
      break;
    }
    case SHAPEFLEXIBILITY_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SHAPEFLEXIBILITY_NOT_SET;
}


void ArrayFeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ArrayFeatureType)
  shape_.Clear();
  datatype_ = 0;
  clear_ShapeFlexibility();
}

bool ArrayFeatureType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.ArrayFeatureType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int64 shape = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_shape())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(8u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 10u, input, this->mutable_shape())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.ArrayFeatureType.ArrayDataType dataType = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_datatype(static_cast< ::CoreML::Specification::ArrayFeatureType_ArrayDataType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.ArrayFeatureType.EnumeratedShapes enumeratedShapes = 21;
      case 21: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(170u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_enumeratedshapes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.ArrayFeatureType.ShapeRange shapeRange = 31;
      case 31: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(250u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_shaperange()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.ArrayFeatureType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.ArrayFeatureType)
  return false;
#undef DO_
}

void ArrayFeatureType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.ArrayFeatureType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 shape = 1;
  if (this->shape_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_shape_cached_byte_size_);
  }
  for (int i = 0, n = this->shape_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64NoTag(
      this->shape(i), output);
  }

  // .CoreML.Specification.ArrayFeatureType.ArrayDataType dataType = 2;
  if (this->datatype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->datatype(), output);
  }

  // .CoreML.Specification.ArrayFeatureType.EnumeratedShapes enumeratedShapes = 21;
  if (has_enumeratedshapes()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      21, *ShapeFlexibility_.enumeratedshapes_, output);
  }

  // .CoreML.Specification.ArrayFeatureType.ShapeRange shapeRange = 31;
  if (has_shaperange()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      31, *ShapeFlexibility_.shaperange_, output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.ArrayFeatureType)
}

size_t ArrayFeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ArrayFeatureType)
  size_t total_size = 0;

  // repeated int64 shape = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int64Size(this->shape_);
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _shape_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // .CoreML.Specification.ArrayFeatureType.ArrayDataType dataType = 2;
  if (this->datatype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->datatype());
  }

  switch (ShapeFlexibility_case()) {
    // .CoreML.Specification.ArrayFeatureType.EnumeratedShapes enumeratedShapes = 21;
    case kEnumeratedShapes: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *ShapeFlexibility_.enumeratedshapes_);
      break;
    }
    // .CoreML.Specification.ArrayFeatureType.ShapeRange shapeRange = 31;
    case kShapeRange: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *ShapeFlexibility_.shaperange_);
      break;
    }
    case SHAPEFLEXIBILITY_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ArrayFeatureType::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ArrayFeatureType*>(&from));
}

void ArrayFeatureType::MergeFrom(const ArrayFeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ArrayFeatureType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  shape_.MergeFrom(from.shape_);
  if (from.datatype() != 0) {
    set_datatype(from.datatype());
  }
  switch (from.ShapeFlexibility_case()) {
    case kEnumeratedShapes: {
      mutable_enumeratedshapes()->::CoreML::Specification::ArrayFeatureType_EnumeratedShapes::MergeFrom(from.enumeratedshapes());
      break;
    }
    case kShapeRange: {
      mutable_shaperange()->::CoreML::Specification::ArrayFeatureType_ShapeRange::MergeFrom(from.shaperange());
      break;
    }
    case SHAPEFLEXIBILITY_NOT_SET: {
      break;
    }
  }
}

void ArrayFeatureType::CopyFrom(const ArrayFeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ArrayFeatureType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArrayFeatureType::IsInitialized() const {
  return true;
}

void ArrayFeatureType::Swap(ArrayFeatureType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ArrayFeatureType::InternalSwap(ArrayFeatureType* other) {
  shape_.InternalSwap(&other->shape_);
  std::swap(datatype_, other->datatype_);
  std::swap(ShapeFlexibility_, other->ShapeFlexibility_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ArrayFeatureType::GetTypeName() const {
  return "CoreML.Specification.ArrayFeatureType";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ArrayFeatureType

// repeated int64 shape = 1;
int ArrayFeatureType::shape_size() const {
  return shape_.size();
}
void ArrayFeatureType::clear_shape() {
  shape_.Clear();
}
::google::protobuf::int64 ArrayFeatureType::shape(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.shape)
  return shape_.Get(index);
}
void ArrayFeatureType::set_shape(int index, ::google::protobuf::int64 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ArrayFeatureType.shape)
}
void ArrayFeatureType::add_shape(::google::protobuf::int64 value) {
  shape_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.ArrayFeatureType.shape)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
ArrayFeatureType::shape() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ArrayFeatureType.shape)
  return shape_;
}
::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
ArrayFeatureType::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ArrayFeatureType.shape)
  return &shape_;
}

// .CoreML.Specification.ArrayFeatureType.ArrayDataType dataType = 2;
void ArrayFeatureType::clear_datatype() {
  datatype_ = 0;
}
::CoreML::Specification::ArrayFeatureType_ArrayDataType ArrayFeatureType::datatype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.dataType)
  return static_cast< ::CoreML::Specification::ArrayFeatureType_ArrayDataType >(datatype_);
}
void ArrayFeatureType::set_datatype(::CoreML::Specification::ArrayFeatureType_ArrayDataType value) {
  
  datatype_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ArrayFeatureType.dataType)
}

// .CoreML.Specification.ArrayFeatureType.EnumeratedShapes enumeratedShapes = 21;
bool ArrayFeatureType::has_enumeratedshapes() const {
  return ShapeFlexibility_case() == kEnumeratedShapes;
}
void ArrayFeatureType::set_has_enumeratedshapes() {
  _oneof_case_[0] = kEnumeratedShapes;
}
void ArrayFeatureType::clear_enumeratedshapes() {
  if (has_enumeratedshapes()) {
    delete ShapeFlexibility_.enumeratedshapes_;
    clear_has_ShapeFlexibility();
  }
}
 const ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes& ArrayFeatureType::enumeratedshapes() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.enumeratedShapes)
  return has_enumeratedshapes()
      ? *ShapeFlexibility_.enumeratedshapes_
      : ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes::default_instance();
}
::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* ArrayFeatureType::mutable_enumeratedshapes() {
  if (!has_enumeratedshapes()) {
    clear_ShapeFlexibility();
    set_has_enumeratedshapes();
    ShapeFlexibility_.enumeratedshapes_ = new ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ArrayFeatureType.enumeratedShapes)
  return ShapeFlexibility_.enumeratedshapes_;
}
::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* ArrayFeatureType::release_enumeratedshapes() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ArrayFeatureType.enumeratedShapes)
  if (has_enumeratedshapes()) {
    clear_has_ShapeFlexibility();
    ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* temp = ShapeFlexibility_.enumeratedshapes_;
    ShapeFlexibility_.enumeratedshapes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ArrayFeatureType::set_allocated_enumeratedshapes(::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* enumeratedshapes) {
  clear_ShapeFlexibility();
  if (enumeratedshapes) {
    set_has_enumeratedshapes();
    ShapeFlexibility_.enumeratedshapes_ = enumeratedshapes;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ArrayFeatureType.enumeratedShapes)
}

// .CoreML.Specification.ArrayFeatureType.ShapeRange shapeRange = 31;
bool ArrayFeatureType::has_shaperange() const {
  return ShapeFlexibility_case() == kShapeRange;
}
void ArrayFeatureType::set_has_shaperange() {
  _oneof_case_[0] = kShapeRange;
}
void ArrayFeatureType::clear_shaperange() {
  if (has_shaperange()) {
    delete ShapeFlexibility_.shaperange_;
    clear_has_ShapeFlexibility();
  }
}
 const ::CoreML::Specification::ArrayFeatureType_ShapeRange& ArrayFeatureType::shaperange() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.shapeRange)
  return has_shaperange()
      ? *ShapeFlexibility_.shaperange_
      : ::CoreML::Specification::ArrayFeatureType_ShapeRange::default_instance();
}
::CoreML::Specification::ArrayFeatureType_ShapeRange* ArrayFeatureType::mutable_shaperange() {
  if (!has_shaperange()) {
    clear_ShapeFlexibility();
    set_has_shaperange();
    ShapeFlexibility_.shaperange_ = new ::CoreML::Specification::ArrayFeatureType_ShapeRange;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ArrayFeatureType.shapeRange)
  return ShapeFlexibility_.shaperange_;
}
::CoreML::Specification::ArrayFeatureType_ShapeRange* ArrayFeatureType::release_shaperange() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ArrayFeatureType.shapeRange)
  if (has_shaperange()) {
    clear_has_ShapeFlexibility();
    ::CoreML::Specification::ArrayFeatureType_ShapeRange* temp = ShapeFlexibility_.shaperange_;
    ShapeFlexibility_.shaperange_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ArrayFeatureType::set_allocated_shaperange(::CoreML::Specification::ArrayFeatureType_ShapeRange* shaperange) {
  clear_ShapeFlexibility();
  if (shaperange) {
    set_has_shaperange();
    ShapeFlexibility_.shaperange_ = shaperange;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ArrayFeatureType.shapeRange)
}

bool ArrayFeatureType::has_ShapeFlexibility() const {
  return ShapeFlexibility_case() != SHAPEFLEXIBILITY_NOT_SET;
}
void ArrayFeatureType::clear_has_ShapeFlexibility() {
  _oneof_case_[0] = SHAPEFLEXIBILITY_NOT_SET;
}
ArrayFeatureType::ShapeFlexibilityCase ArrayFeatureType::ShapeFlexibility_case() const {
  return ArrayFeatureType::ShapeFlexibilityCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DictionaryFeatureType::kInt64KeyTypeFieldNumber;
const int DictionaryFeatureType::kStringKeyTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DictionaryFeatureType::DictionaryFeatureType()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_FeatureTypes_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.DictionaryFeatureType)
}
DictionaryFeatureType::DictionaryFeatureType(const DictionaryFeatureType& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  clear_has_KeyType();
  switch (from.KeyType_case()) {
    case kInt64KeyType: {
      mutable_int64keytype()->::CoreML::Specification::Int64FeatureType::MergeFrom(from.int64keytype());
      break;
    }
    case kStringKeyType: {
      mutable_stringkeytype()->::CoreML::Specification::StringFeatureType::MergeFrom(from.stringkeytype());
      break;
    }
    case KEYTYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DictionaryFeatureType)
}

void DictionaryFeatureType::SharedCtor() {
  clear_has_KeyType();
  _cached_size_ = 0;
}

DictionaryFeatureType::~DictionaryFeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DictionaryFeatureType)
  SharedDtor();
}

void DictionaryFeatureType::SharedDtor() {
  if (has_KeyType()) {
    clear_KeyType();
  }
}

void DictionaryFeatureType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DictionaryFeatureType& DictionaryFeatureType::default_instance() {
  protobuf_FeatureTypes_2eproto::InitDefaults();
  return *internal_default_instance();
}

DictionaryFeatureType* DictionaryFeatureType::New(::google::protobuf::Arena* arena) const {
  DictionaryFeatureType* n = new DictionaryFeatureType;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DictionaryFeatureType::clear_KeyType() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.DictionaryFeatureType)
  switch (KeyType_case()) {
    case kInt64KeyType: {
      delete KeyType_.int64keytype_;
      break;
    }
    case kStringKeyType: {
      delete KeyType_.stringkeytype_;
      break;
    }
    case KEYTYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = KEYTYPE_NOT_SET;
}


void DictionaryFeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DictionaryFeatureType)
  clear_KeyType();
}

bool DictionaryFeatureType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.DictionaryFeatureType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .CoreML.Specification.Int64FeatureType int64KeyType = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_int64keytype()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.StringFeatureType stringKeyType = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stringkeytype()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.DictionaryFeatureType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.DictionaryFeatureType)
  return false;
#undef DO_
}

void DictionaryFeatureType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.DictionaryFeatureType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.Int64FeatureType int64KeyType = 1;
  if (has_int64keytype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *KeyType_.int64keytype_, output);
  }

  // .CoreML.Specification.StringFeatureType stringKeyType = 2;
  if (has_stringkeytype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *KeyType_.stringkeytype_, output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.DictionaryFeatureType)
}

size_t DictionaryFeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DictionaryFeatureType)
  size_t total_size = 0;

  switch (KeyType_case()) {
    // .CoreML.Specification.Int64FeatureType int64KeyType = 1;
    case kInt64KeyType: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *KeyType_.int64keytype_);
      break;
    }
    // .CoreML.Specification.StringFeatureType stringKeyType = 2;
    case kStringKeyType: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *KeyType_.stringkeytype_);
      break;
    }
    case KEYTYPE_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DictionaryFeatureType::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DictionaryFeatureType*>(&from));
}

void DictionaryFeatureType::MergeFrom(const DictionaryFeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DictionaryFeatureType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.KeyType_case()) {
    case kInt64KeyType: {
      mutable_int64keytype()->::CoreML::Specification::Int64FeatureType::MergeFrom(from.int64keytype());
      break;
    }
    case kStringKeyType: {
      mutable_stringkeytype()->::CoreML::Specification::StringFeatureType::MergeFrom(from.stringkeytype());
      break;
    }
    case KEYTYPE_NOT_SET: {
      break;
    }
  }
}

void DictionaryFeatureType::CopyFrom(const DictionaryFeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DictionaryFeatureType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DictionaryFeatureType::IsInitialized() const {
  return true;
}

void DictionaryFeatureType::Swap(DictionaryFeatureType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DictionaryFeatureType::InternalSwap(DictionaryFeatureType* other) {
  std::swap(KeyType_, other->KeyType_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DictionaryFeatureType::GetTypeName() const {
  return "CoreML.Specification.DictionaryFeatureType";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DictionaryFeatureType

// .CoreML.Specification.Int64FeatureType int64KeyType = 1;
bool DictionaryFeatureType::has_int64keytype() const {
  return KeyType_case() == kInt64KeyType;
}
void DictionaryFeatureType::set_has_int64keytype() {
  _oneof_case_[0] = kInt64KeyType;
}
void DictionaryFeatureType::clear_int64keytype() {
  if (has_int64keytype()) {
    delete KeyType_.int64keytype_;
    clear_has_KeyType();
  }
}
 const ::CoreML::Specification::Int64FeatureType& DictionaryFeatureType::int64keytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DictionaryFeatureType.int64KeyType)
  return has_int64keytype()
      ? *KeyType_.int64keytype_
      : ::CoreML::Specification::Int64FeatureType::default_instance();
}
::CoreML::Specification::Int64FeatureType* DictionaryFeatureType::mutable_int64keytype() {
  if (!has_int64keytype()) {
    clear_KeyType();
    set_has_int64keytype();
    KeyType_.int64keytype_ = new ::CoreML::Specification::Int64FeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.DictionaryFeatureType.int64KeyType)
  return KeyType_.int64keytype_;
}
::CoreML::Specification::Int64FeatureType* DictionaryFeatureType::release_int64keytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.DictionaryFeatureType.int64KeyType)
  if (has_int64keytype()) {
    clear_has_KeyType();
    ::CoreML::Specification::Int64FeatureType* temp = KeyType_.int64keytype_;
    KeyType_.int64keytype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void DictionaryFeatureType::set_allocated_int64keytype(::CoreML::Specification::Int64FeatureType* int64keytype) {
  clear_KeyType();
  if (int64keytype) {
    set_has_int64keytype();
    KeyType_.int64keytype_ = int64keytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.DictionaryFeatureType.int64KeyType)
}

// .CoreML.Specification.StringFeatureType stringKeyType = 2;
bool DictionaryFeatureType::has_stringkeytype() const {
  return KeyType_case() == kStringKeyType;
}
void DictionaryFeatureType::set_has_stringkeytype() {
  _oneof_case_[0] = kStringKeyType;
}
void DictionaryFeatureType::clear_stringkeytype() {
  if (has_stringkeytype()) {
    delete KeyType_.stringkeytype_;
    clear_has_KeyType();
  }
}
 const ::CoreML::Specification::StringFeatureType& DictionaryFeatureType::stringkeytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DictionaryFeatureType.stringKeyType)
  return has_stringkeytype()
      ? *KeyType_.stringkeytype_
      : ::CoreML::Specification::StringFeatureType::default_instance();
}
::CoreML::Specification::StringFeatureType* DictionaryFeatureType::mutable_stringkeytype() {
  if (!has_stringkeytype()) {
    clear_KeyType();
    set_has_stringkeytype();
    KeyType_.stringkeytype_ = new ::CoreML::Specification::StringFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.DictionaryFeatureType.stringKeyType)
  return KeyType_.stringkeytype_;
}
::CoreML::Specification::StringFeatureType* DictionaryFeatureType::release_stringkeytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.DictionaryFeatureType.stringKeyType)
  if (has_stringkeytype()) {
    clear_has_KeyType();
    ::CoreML::Specification::StringFeatureType* temp = KeyType_.stringkeytype_;
    KeyType_.stringkeytype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void DictionaryFeatureType::set_allocated_stringkeytype(::CoreML::Specification::StringFeatureType* stringkeytype) {
  clear_KeyType();
  if (stringkeytype) {
    set_has_stringkeytype();
    KeyType_.stringkeytype_ = stringkeytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.DictionaryFeatureType.stringKeyType)
}

bool DictionaryFeatureType::has_KeyType() const {
  return KeyType_case() != KEYTYPE_NOT_SET;
}
void DictionaryFeatureType::clear_has_KeyType() {
  _oneof_case_[0] = KEYTYPE_NOT_SET;
}
DictionaryFeatureType::KeyTypeCase DictionaryFeatureType::KeyType_case() const {
  return DictionaryFeatureType::KeyTypeCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SequenceFeatureType::kInt64TypeFieldNumber;
const int SequenceFeatureType::kStringTypeFieldNumber;
const int SequenceFeatureType::kSizeRangeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SequenceFeatureType::SequenceFeatureType()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_FeatureTypes_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.SequenceFeatureType)
}
SequenceFeatureType::SequenceFeatureType(const SequenceFeatureType& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_sizerange()) {
    sizerange_ = new ::CoreML::Specification::SizeRange(*from.sizerange_);
  } else {
    sizerange_ = NULL;
  }
  clear_has_Type();
  switch (from.Type_case()) {
    case kInt64Type: {
      mutable_int64type()->::CoreML::Specification::Int64FeatureType::MergeFrom(from.int64type());
      break;
    }
    case kStringType: {
      mutable_stringtype()->::CoreML::Specification::StringFeatureType::MergeFrom(from.stringtype());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SequenceFeatureType)
}

void SequenceFeatureType::SharedCtor() {
  sizerange_ = NULL;
  clear_has_Type();
  _cached_size_ = 0;
}

SequenceFeatureType::~SequenceFeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SequenceFeatureType)
  SharedDtor();
}

void SequenceFeatureType::SharedDtor() {
  if (this != internal_default_instance()) {
    delete sizerange_;
  }
  if (has_Type()) {
    clear_Type();
  }
}

void SequenceFeatureType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SequenceFeatureType& SequenceFeatureType::default_instance() {
  protobuf_FeatureTypes_2eproto::InitDefaults();
  return *internal_default_instance();
}

SequenceFeatureType* SequenceFeatureType::New(::google::protobuf::Arena* arena) const {
  SequenceFeatureType* n = new SequenceFeatureType;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SequenceFeatureType::clear_Type() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.SequenceFeatureType)
  switch (Type_case()) {
    case kInt64Type: {
      delete Type_.int64type_;
      break;
    }
    case kStringType: {
      delete Type_.stringtype_;
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TYPE_NOT_SET;
}


void SequenceFeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SequenceFeatureType)
  if (GetArenaNoVirtual() == NULL && sizerange_ != NULL) {
    delete sizerange_;
  }
  sizerange_ = NULL;
  clear_Type();
}

bool SequenceFeatureType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.SequenceFeatureType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .CoreML.Specification.Int64FeatureType int64Type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_int64type()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.StringFeatureType stringType = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stringtype()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.SizeRange sizeRange = 101;
      case 101: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(810u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sizerange()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.SequenceFeatureType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.SequenceFeatureType)
  return false;
#undef DO_
}

void SequenceFeatureType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.SequenceFeatureType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.Int64FeatureType int64Type = 1;
  if (has_int64type()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *Type_.int64type_, output);
  }

  // .CoreML.Specification.StringFeatureType stringType = 3;
  if (has_stringtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *Type_.stringtype_, output);
  }

  // .CoreML.Specification.SizeRange sizeRange = 101;
  if (this->has_sizerange()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      101, *this->sizerange_, output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.SequenceFeatureType)
}

size_t SequenceFeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SequenceFeatureType)
  size_t total_size = 0;

  // .CoreML.Specification.SizeRange sizeRange = 101;
  if (this->has_sizerange()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->sizerange_);
  }

  switch (Type_case()) {
    // .CoreML.Specification.Int64FeatureType int64Type = 1;
    case kInt64Type: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.int64type_);
      break;
    }
    // .CoreML.Specification.StringFeatureType stringType = 3;
    case kStringType: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.stringtype_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SequenceFeatureType::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SequenceFeatureType*>(&from));
}

void SequenceFeatureType::MergeFrom(const SequenceFeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SequenceFeatureType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_sizerange()) {
    mutable_sizerange()->::CoreML::Specification::SizeRange::MergeFrom(from.sizerange());
  }
  switch (from.Type_case()) {
    case kInt64Type: {
      mutable_int64type()->::CoreML::Specification::Int64FeatureType::MergeFrom(from.int64type());
      break;
    }
    case kStringType: {
      mutable_stringtype()->::CoreML::Specification::StringFeatureType::MergeFrom(from.stringtype());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
}

void SequenceFeatureType::CopyFrom(const SequenceFeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SequenceFeatureType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SequenceFeatureType::IsInitialized() const {
  return true;
}

void SequenceFeatureType::Swap(SequenceFeatureType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SequenceFeatureType::InternalSwap(SequenceFeatureType* other) {
  std::swap(sizerange_, other->sizerange_);
  std::swap(Type_, other->Type_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SequenceFeatureType::GetTypeName() const {
  return "CoreML.Specification.SequenceFeatureType";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SequenceFeatureType

// .CoreML.Specification.Int64FeatureType int64Type = 1;
bool SequenceFeatureType::has_int64type() const {
  return Type_case() == kInt64Type;
}
void SequenceFeatureType::set_has_int64type() {
  _oneof_case_[0] = kInt64Type;
}
void SequenceFeatureType::clear_int64type() {
  if (has_int64type()) {
    delete Type_.int64type_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::Int64FeatureType& SequenceFeatureType::int64type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SequenceFeatureType.int64Type)
  return has_int64type()
      ? *Type_.int64type_
      : ::CoreML::Specification::Int64FeatureType::default_instance();
}
::CoreML::Specification::Int64FeatureType* SequenceFeatureType::mutable_int64type() {
  if (!has_int64type()) {
    clear_Type();
    set_has_int64type();
    Type_.int64type_ = new ::CoreML::Specification::Int64FeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SequenceFeatureType.int64Type)
  return Type_.int64type_;
}
::CoreML::Specification::Int64FeatureType* SequenceFeatureType::release_int64type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SequenceFeatureType.int64Type)
  if (has_int64type()) {
    clear_has_Type();
    ::CoreML::Specification::Int64FeatureType* temp = Type_.int64type_;
    Type_.int64type_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SequenceFeatureType::set_allocated_int64type(::CoreML::Specification::Int64FeatureType* int64type) {
  clear_Type();
  if (int64type) {
    set_has_int64type();
    Type_.int64type_ = int64type;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SequenceFeatureType.int64Type)
}

// .CoreML.Specification.StringFeatureType stringType = 3;
bool SequenceFeatureType::has_stringtype() const {
  return Type_case() == kStringType;
}
void SequenceFeatureType::set_has_stringtype() {
  _oneof_case_[0] = kStringType;
}
void SequenceFeatureType::clear_stringtype() {
  if (has_stringtype()) {
    delete Type_.stringtype_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::StringFeatureType& SequenceFeatureType::stringtype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SequenceFeatureType.stringType)
  return has_stringtype()
      ? *Type_.stringtype_
      : ::CoreML::Specification::StringFeatureType::default_instance();
}
::CoreML::Specification::StringFeatureType* SequenceFeatureType::mutable_stringtype() {
  if (!has_stringtype()) {
    clear_Type();
    set_has_stringtype();
    Type_.stringtype_ = new ::CoreML::Specification::StringFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SequenceFeatureType.stringType)
  return Type_.stringtype_;
}
::CoreML::Specification::StringFeatureType* SequenceFeatureType::release_stringtype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SequenceFeatureType.stringType)
  if (has_stringtype()) {
    clear_has_Type();
    ::CoreML::Specification::StringFeatureType* temp = Type_.stringtype_;
    Type_.stringtype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SequenceFeatureType::set_allocated_stringtype(::CoreML::Specification::StringFeatureType* stringtype) {
  clear_Type();
  if (stringtype) {
    set_has_stringtype();
    Type_.stringtype_ = stringtype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SequenceFeatureType.stringType)
}

// .CoreML.Specification.SizeRange sizeRange = 101;
bool SequenceFeatureType::has_sizerange() const {
  return this != internal_default_instance() && sizerange_ != NULL;
}
void SequenceFeatureType::clear_sizerange() {
  if (GetArenaNoVirtual() == NULL && sizerange_ != NULL) delete sizerange_;
  sizerange_ = NULL;
}
const ::CoreML::Specification::SizeRange& SequenceFeatureType::sizerange() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SequenceFeatureType.sizeRange)
  return sizerange_ != NULL ? *sizerange_
                         : *::CoreML::Specification::SizeRange::internal_default_instance();
}
::CoreML::Specification::SizeRange* SequenceFeatureType::mutable_sizerange() {
  
  if (sizerange_ == NULL) {
    sizerange_ = new ::CoreML::Specification::SizeRange;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SequenceFeatureType.sizeRange)
  return sizerange_;
}
::CoreML::Specification::SizeRange* SequenceFeatureType::release_sizerange() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SequenceFeatureType.sizeRange)
  
  ::CoreML::Specification::SizeRange* temp = sizerange_;
  sizerange_ = NULL;
  return temp;
}
void SequenceFeatureType::set_allocated_sizerange(::CoreML::Specification::SizeRange* sizerange) {
  delete sizerange_;
  sizerange_ = sizerange;
  if (sizerange) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SequenceFeatureType.sizeRange)
}

bool SequenceFeatureType::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
void SequenceFeatureType::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
SequenceFeatureType::TypeCase SequenceFeatureType::Type_case() const {
  return SequenceFeatureType::TypeCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FeatureType::kInt64TypeFieldNumber;
const int FeatureType::kDoubleTypeFieldNumber;
const int FeatureType::kStringTypeFieldNumber;
const int FeatureType::kImageTypeFieldNumber;
const int FeatureType::kMultiArrayTypeFieldNumber;
const int FeatureType::kDictionaryTypeFieldNumber;
const int FeatureType::kSequenceTypeFieldNumber;
const int FeatureType::kIsOptionalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FeatureType::FeatureType()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_FeatureTypes_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.FeatureType)
}
FeatureType::FeatureType(const FeatureType& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  isoptional_ = from.isoptional_;
  clear_has_Type();
  switch (from.Type_case()) {
    case kInt64Type: {
      mutable_int64type()->::CoreML::Specification::Int64FeatureType::MergeFrom(from.int64type());
      break;
    }
    case kDoubleType: {
      mutable_doubletype()->::CoreML::Specification::DoubleFeatureType::MergeFrom(from.doubletype());
      break;
    }
    case kStringType: {
      mutable_stringtype()->::CoreML::Specification::StringFeatureType::MergeFrom(from.stringtype());
      break;
    }
    case kImageType: {
      mutable_imagetype()->::CoreML::Specification::ImageFeatureType::MergeFrom(from.imagetype());
      break;
    }
    case kMultiArrayType: {
      mutable_multiarraytype()->::CoreML::Specification::ArrayFeatureType::MergeFrom(from.multiarraytype());
      break;
    }
    case kDictionaryType: {
      mutable_dictionarytype()->::CoreML::Specification::DictionaryFeatureType::MergeFrom(from.dictionarytype());
      break;
    }
    case kSequenceType: {
      mutable_sequencetype()->::CoreML::Specification::SequenceFeatureType::MergeFrom(from.sequencetype());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.FeatureType)
}

void FeatureType::SharedCtor() {
  isoptional_ = false;
  clear_has_Type();
  _cached_size_ = 0;
}

FeatureType::~FeatureType() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.FeatureType)
  SharedDtor();
}

void FeatureType::SharedDtor() {
  if (has_Type()) {
    clear_Type();
  }
}

void FeatureType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FeatureType& FeatureType::default_instance() {
  protobuf_FeatureTypes_2eproto::InitDefaults();
  return *internal_default_instance();
}

FeatureType* FeatureType::New(::google::protobuf::Arena* arena) const {
  FeatureType* n = new FeatureType;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FeatureType::clear_Type() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.FeatureType)
  switch (Type_case()) {
    case kInt64Type: {
      delete Type_.int64type_;
      break;
    }
    case kDoubleType: {
      delete Type_.doubletype_;
      break;
    }
    case kStringType: {
      delete Type_.stringtype_;
      break;
    }
    case kImageType: {
      delete Type_.imagetype_;
      break;
    }
    case kMultiArrayType: {
      delete Type_.multiarraytype_;
      break;
    }
    case kDictionaryType: {
      delete Type_.dictionarytype_;
      break;
    }
    case kSequenceType: {
      delete Type_.sequencetype_;
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TYPE_NOT_SET;
}


void FeatureType::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.FeatureType)
  isoptional_ = false;
  clear_Type();
}

bool FeatureType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.FeatureType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .CoreML.Specification.Int64FeatureType int64Type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_int64type()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.DoubleFeatureType doubleType = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_doubletype()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.StringFeatureType stringType = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stringtype()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.ImageFeatureType imageType = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_imagetype()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.ArrayFeatureType multiArrayType = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_multiarraytype()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.DictionaryFeatureType dictionaryType = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dictionarytype()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.SequenceFeatureType sequenceType = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sequencetype()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool isOptional = 1000;
      case 1000: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8000u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isoptional_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.FeatureType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.FeatureType)
  return false;
#undef DO_
}

void FeatureType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.FeatureType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.Int64FeatureType int64Type = 1;
  if (has_int64type()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *Type_.int64type_, output);
  }

  // .CoreML.Specification.DoubleFeatureType doubleType = 2;
  if (has_doubletype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *Type_.doubletype_, output);
  }

  // .CoreML.Specification.StringFeatureType stringType = 3;
  if (has_stringtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *Type_.stringtype_, output);
  }

  // .CoreML.Specification.ImageFeatureType imageType = 4;
  if (has_imagetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *Type_.imagetype_, output);
  }

  // .CoreML.Specification.ArrayFeatureType multiArrayType = 5;
  if (has_multiarraytype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *Type_.multiarraytype_, output);
  }

  // .CoreML.Specification.DictionaryFeatureType dictionaryType = 6;
  if (has_dictionarytype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *Type_.dictionarytype_, output);
  }

  // .CoreML.Specification.SequenceFeatureType sequenceType = 7;
  if (has_sequencetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, *Type_.sequencetype_, output);
  }

  // bool isOptional = 1000;
  if (this->isoptional() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1000, this->isoptional(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.FeatureType)
}

size_t FeatureType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.FeatureType)
  size_t total_size = 0;

  // bool isOptional = 1000;
  if (this->isoptional() != 0) {
    total_size += 2 + 1;
  }

  switch (Type_case()) {
    // .CoreML.Specification.Int64FeatureType int64Type = 1;
    case kInt64Type: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.int64type_);
      break;
    }
    // .CoreML.Specification.DoubleFeatureType doubleType = 2;
    case kDoubleType: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.doubletype_);
      break;
    }
    // .CoreML.Specification.StringFeatureType stringType = 3;
    case kStringType: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.stringtype_);
      break;
    }
    // .CoreML.Specification.ImageFeatureType imageType = 4;
    case kImageType: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.imagetype_);
      break;
    }
    // .CoreML.Specification.ArrayFeatureType multiArrayType = 5;
    case kMultiArrayType: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.multiarraytype_);
      break;
    }
    // .CoreML.Specification.DictionaryFeatureType dictionaryType = 6;
    case kDictionaryType: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.dictionarytype_);
      break;
    }
    // .CoreML.Specification.SequenceFeatureType sequenceType = 7;
    case kSequenceType: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *Type_.sequencetype_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FeatureType::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FeatureType*>(&from));
}

void FeatureType::MergeFrom(const FeatureType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.FeatureType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.isoptional() != 0) {
    set_isoptional(from.isoptional());
  }
  switch (from.Type_case()) {
    case kInt64Type: {
      mutable_int64type()->::CoreML::Specification::Int64FeatureType::MergeFrom(from.int64type());
      break;
    }
    case kDoubleType: {
      mutable_doubletype()->::CoreML::Specification::DoubleFeatureType::MergeFrom(from.doubletype());
      break;
    }
    case kStringType: {
      mutable_stringtype()->::CoreML::Specification::StringFeatureType::MergeFrom(from.stringtype());
      break;
    }
    case kImageType: {
      mutable_imagetype()->::CoreML::Specification::ImageFeatureType::MergeFrom(from.imagetype());
      break;
    }
    case kMultiArrayType: {
      mutable_multiarraytype()->::CoreML::Specification::ArrayFeatureType::MergeFrom(from.multiarraytype());
      break;
    }
    case kDictionaryType: {
      mutable_dictionarytype()->::CoreML::Specification::DictionaryFeatureType::MergeFrom(from.dictionarytype());
      break;
    }
    case kSequenceType: {
      mutable_sequencetype()->::CoreML::Specification::SequenceFeatureType::MergeFrom(from.sequencetype());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
}

void FeatureType::CopyFrom(const FeatureType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.FeatureType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeatureType::IsInitialized() const {
  return true;
}

void FeatureType::Swap(FeatureType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FeatureType::InternalSwap(FeatureType* other) {
  std::swap(isoptional_, other->isoptional_);
  std::swap(Type_, other->Type_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FeatureType::GetTypeName() const {
  return "CoreML.Specification.FeatureType";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FeatureType

// .CoreML.Specification.Int64FeatureType int64Type = 1;
bool FeatureType::has_int64type() const {
  return Type_case() == kInt64Type;
}
void FeatureType::set_has_int64type() {
  _oneof_case_[0] = kInt64Type;
}
void FeatureType::clear_int64type() {
  if (has_int64type()) {
    delete Type_.int64type_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::Int64FeatureType& FeatureType::int64type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.int64Type)
  return has_int64type()
      ? *Type_.int64type_
      : ::CoreML::Specification::Int64FeatureType::default_instance();
}
::CoreML::Specification::Int64FeatureType* FeatureType::mutable_int64type() {
  if (!has_int64type()) {
    clear_Type();
    set_has_int64type();
    Type_.int64type_ = new ::CoreML::Specification::Int64FeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.int64Type)
  return Type_.int64type_;
}
::CoreML::Specification::Int64FeatureType* FeatureType::release_int64type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.int64Type)
  if (has_int64type()) {
    clear_has_Type();
    ::CoreML::Specification::Int64FeatureType* temp = Type_.int64type_;
    Type_.int64type_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void FeatureType::set_allocated_int64type(::CoreML::Specification::Int64FeatureType* int64type) {
  clear_Type();
  if (int64type) {
    set_has_int64type();
    Type_.int64type_ = int64type;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.int64Type)
}

// .CoreML.Specification.DoubleFeatureType doubleType = 2;
bool FeatureType::has_doubletype() const {
  return Type_case() == kDoubleType;
}
void FeatureType::set_has_doubletype() {
  _oneof_case_[0] = kDoubleType;
}
void FeatureType::clear_doubletype() {
  if (has_doubletype()) {
    delete Type_.doubletype_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::DoubleFeatureType& FeatureType::doubletype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.doubleType)
  return has_doubletype()
      ? *Type_.doubletype_
      : ::CoreML::Specification::DoubleFeatureType::default_instance();
}
::CoreML::Specification::DoubleFeatureType* FeatureType::mutable_doubletype() {
  if (!has_doubletype()) {
    clear_Type();
    set_has_doubletype();
    Type_.doubletype_ = new ::CoreML::Specification::DoubleFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.doubleType)
  return Type_.doubletype_;
}
::CoreML::Specification::DoubleFeatureType* FeatureType::release_doubletype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.doubleType)
  if (has_doubletype()) {
    clear_has_Type();
    ::CoreML::Specification::DoubleFeatureType* temp = Type_.doubletype_;
    Type_.doubletype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void FeatureType::set_allocated_doubletype(::CoreML::Specification::DoubleFeatureType* doubletype) {
  clear_Type();
  if (doubletype) {
    set_has_doubletype();
    Type_.doubletype_ = doubletype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.doubleType)
}

// .CoreML.Specification.StringFeatureType stringType = 3;
bool FeatureType::has_stringtype() const {
  return Type_case() == kStringType;
}
void FeatureType::set_has_stringtype() {
  _oneof_case_[0] = kStringType;
}
void FeatureType::clear_stringtype() {
  if (has_stringtype()) {
    delete Type_.stringtype_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::StringFeatureType& FeatureType::stringtype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.stringType)
  return has_stringtype()
      ? *Type_.stringtype_
      : ::CoreML::Specification::StringFeatureType::default_instance();
}
::CoreML::Specification::StringFeatureType* FeatureType::mutable_stringtype() {
  if (!has_stringtype()) {
    clear_Type();
    set_has_stringtype();
    Type_.stringtype_ = new ::CoreML::Specification::StringFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.stringType)
  return Type_.stringtype_;
}
::CoreML::Specification::StringFeatureType* FeatureType::release_stringtype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.stringType)
  if (has_stringtype()) {
    clear_has_Type();
    ::CoreML::Specification::StringFeatureType* temp = Type_.stringtype_;
    Type_.stringtype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void FeatureType::set_allocated_stringtype(::CoreML::Specification::StringFeatureType* stringtype) {
  clear_Type();
  if (stringtype) {
    set_has_stringtype();
    Type_.stringtype_ = stringtype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.stringType)
}

// .CoreML.Specification.ImageFeatureType imageType = 4;
bool FeatureType::has_imagetype() const {
  return Type_case() == kImageType;
}
void FeatureType::set_has_imagetype() {
  _oneof_case_[0] = kImageType;
}
void FeatureType::clear_imagetype() {
  if (has_imagetype()) {
    delete Type_.imagetype_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::ImageFeatureType& FeatureType::imagetype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.imageType)
  return has_imagetype()
      ? *Type_.imagetype_
      : ::CoreML::Specification::ImageFeatureType::default_instance();
}
::CoreML::Specification::ImageFeatureType* FeatureType::mutable_imagetype() {
  if (!has_imagetype()) {
    clear_Type();
    set_has_imagetype();
    Type_.imagetype_ = new ::CoreML::Specification::ImageFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.imageType)
  return Type_.imagetype_;
}
::CoreML::Specification::ImageFeatureType* FeatureType::release_imagetype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.imageType)
  if (has_imagetype()) {
    clear_has_Type();
    ::CoreML::Specification::ImageFeatureType* temp = Type_.imagetype_;
    Type_.imagetype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void FeatureType::set_allocated_imagetype(::CoreML::Specification::ImageFeatureType* imagetype) {
  clear_Type();
  if (imagetype) {
    set_has_imagetype();
    Type_.imagetype_ = imagetype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.imageType)
}

// .CoreML.Specification.ArrayFeatureType multiArrayType = 5;
bool FeatureType::has_multiarraytype() const {
  return Type_case() == kMultiArrayType;
}
void FeatureType::set_has_multiarraytype() {
  _oneof_case_[0] = kMultiArrayType;
}
void FeatureType::clear_multiarraytype() {
  if (has_multiarraytype()) {
    delete Type_.multiarraytype_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::ArrayFeatureType& FeatureType::multiarraytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.multiArrayType)
  return has_multiarraytype()
      ? *Type_.multiarraytype_
      : ::CoreML::Specification::ArrayFeatureType::default_instance();
}
::CoreML::Specification::ArrayFeatureType* FeatureType::mutable_multiarraytype() {
  if (!has_multiarraytype()) {
    clear_Type();
    set_has_multiarraytype();
    Type_.multiarraytype_ = new ::CoreML::Specification::ArrayFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.multiArrayType)
  return Type_.multiarraytype_;
}
::CoreML::Specification::ArrayFeatureType* FeatureType::release_multiarraytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.multiArrayType)
  if (has_multiarraytype()) {
    clear_has_Type();
    ::CoreML::Specification::ArrayFeatureType* temp = Type_.multiarraytype_;
    Type_.multiarraytype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void FeatureType::set_allocated_multiarraytype(::CoreML::Specification::ArrayFeatureType* multiarraytype) {
  clear_Type();
  if (multiarraytype) {
    set_has_multiarraytype();
    Type_.multiarraytype_ = multiarraytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.multiArrayType)
}

// .CoreML.Specification.DictionaryFeatureType dictionaryType = 6;
bool FeatureType::has_dictionarytype() const {
  return Type_case() == kDictionaryType;
}
void FeatureType::set_has_dictionarytype() {
  _oneof_case_[0] = kDictionaryType;
}
void FeatureType::clear_dictionarytype() {
  if (has_dictionarytype()) {
    delete Type_.dictionarytype_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::DictionaryFeatureType& FeatureType::dictionarytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.dictionaryType)
  return has_dictionarytype()
      ? *Type_.dictionarytype_
      : ::CoreML::Specification::DictionaryFeatureType::default_instance();
}
::CoreML::Specification::DictionaryFeatureType* FeatureType::mutable_dictionarytype() {
  if (!has_dictionarytype()) {
    clear_Type();
    set_has_dictionarytype();
    Type_.dictionarytype_ = new ::CoreML::Specification::DictionaryFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.dictionaryType)
  return Type_.dictionarytype_;
}
::CoreML::Specification::DictionaryFeatureType* FeatureType::release_dictionarytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.dictionaryType)
  if (has_dictionarytype()) {
    clear_has_Type();
    ::CoreML::Specification::DictionaryFeatureType* temp = Type_.dictionarytype_;
    Type_.dictionarytype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void FeatureType::set_allocated_dictionarytype(::CoreML::Specification::DictionaryFeatureType* dictionarytype) {
  clear_Type();
  if (dictionarytype) {
    set_has_dictionarytype();
    Type_.dictionarytype_ = dictionarytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.dictionaryType)
}

// .CoreML.Specification.SequenceFeatureType sequenceType = 7;
bool FeatureType::has_sequencetype() const {
  return Type_case() == kSequenceType;
}
void FeatureType::set_has_sequencetype() {
  _oneof_case_[0] = kSequenceType;
}
void FeatureType::clear_sequencetype() {
  if (has_sequencetype()) {
    delete Type_.sequencetype_;
    clear_has_Type();
  }
}
 const ::CoreML::Specification::SequenceFeatureType& FeatureType::sequencetype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.sequenceType)
  return has_sequencetype()
      ? *Type_.sequencetype_
      : ::CoreML::Specification::SequenceFeatureType::default_instance();
}
::CoreML::Specification::SequenceFeatureType* FeatureType::mutable_sequencetype() {
  if (!has_sequencetype()) {
    clear_Type();
    set_has_sequencetype();
    Type_.sequencetype_ = new ::CoreML::Specification::SequenceFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.sequenceType)
  return Type_.sequencetype_;
}
::CoreML::Specification::SequenceFeatureType* FeatureType::release_sequencetype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.sequenceType)
  if (has_sequencetype()) {
    clear_has_Type();
    ::CoreML::Specification::SequenceFeatureType* temp = Type_.sequencetype_;
    Type_.sequencetype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void FeatureType::set_allocated_sequencetype(::CoreML::Specification::SequenceFeatureType* sequencetype) {
  clear_Type();
  if (sequencetype) {
    set_has_sequencetype();
    Type_.sequencetype_ = sequencetype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.sequenceType)
}

// bool isOptional = 1000;
void FeatureType::clear_isoptional() {
  isoptional_ = false;
}
bool FeatureType::isoptional() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.isOptional)
  return isoptional_;
}
void FeatureType::set_isoptional(bool value) {
  
  isoptional_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.FeatureType.isOptional)
}

bool FeatureType::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
void FeatureType::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
FeatureType::TypeCase FeatureType::Type_case() const {
  return FeatureType::TypeCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace Specification
}  // namespace CoreML

// @@protoc_insertion_point(global_scope)
