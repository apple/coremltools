// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MIL.proto

#ifndef PROTOBUF_MIL_2eproto__INCLUDED
#define PROTOBUF_MIL_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
namespace CoreML {
namespace Specification {
namespace MILSpec {
class Argument;
class ArgumentDefaultTypeInternal;
extern ArgumentDefaultTypeInternal _Argument_default_instance_;
class Argument_Binding;
class Argument_BindingDefaultTypeInternal;
extern Argument_BindingDefaultTypeInternal _Argument_Binding_default_instance_;
class Block;
class BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class Block_AttributesEntry;
class Block_AttributesEntryDefaultTypeInternal;
extern Block_AttributesEntryDefaultTypeInternal _Block_AttributesEntry_default_instance_;
class DictionaryType;
class DictionaryTypeDefaultTypeInternal;
extern DictionaryTypeDefaultTypeInternal _DictionaryType_default_instance_;
class DictionaryValue;
class DictionaryValueDefaultTypeInternal;
extern DictionaryValueDefaultTypeInternal _DictionaryValue_default_instance_;
class DictionaryValue_KeyValuePair;
class DictionaryValue_KeyValuePairDefaultTypeInternal;
extern DictionaryValue_KeyValuePairDefaultTypeInternal _DictionaryValue_KeyValuePair_default_instance_;
class Dimension;
class DimensionDefaultTypeInternal;
extern DimensionDefaultTypeInternal _Dimension_default_instance_;
class Dimension_ConstantDimension;
class Dimension_ConstantDimensionDefaultTypeInternal;
extern Dimension_ConstantDimensionDefaultTypeInternal _Dimension_ConstantDimension_default_instance_;
class Dimension_UnknownDimension;
class Dimension_UnknownDimensionDefaultTypeInternal;
extern Dimension_UnknownDimensionDefaultTypeInternal _Dimension_UnknownDimension_default_instance_;
class Function;
class FunctionDefaultTypeInternal;
extern FunctionDefaultTypeInternal _Function_default_instance_;
class Function_AttributesEntry;
class Function_AttributesEntryDefaultTypeInternal;
extern Function_AttributesEntryDefaultTypeInternal _Function_AttributesEntry_default_instance_;
class Function_BlockSpecializationsEntry;
class Function_BlockSpecializationsEntryDefaultTypeInternal;
extern Function_BlockSpecializationsEntryDefaultTypeInternal _Function_BlockSpecializationsEntry_default_instance_;
class ListType;
class ListTypeDefaultTypeInternal;
extern ListTypeDefaultTypeInternal _ListType_default_instance_;
class ListValue;
class ListValueDefaultTypeInternal;
extern ListValueDefaultTypeInternal _ListValue_default_instance_;
class NamedValueType;
class NamedValueTypeDefaultTypeInternal;
extern NamedValueTypeDefaultTypeInternal _NamedValueType_default_instance_;
class Operation;
class OperationDefaultTypeInternal;
extern OperationDefaultTypeInternal _Operation_default_instance_;
class Operation_AttributesEntry;
class Operation_AttributesEntryDefaultTypeInternal;
extern Operation_AttributesEntryDefaultTypeInternal _Operation_AttributesEntry_default_instance_;
class Operation_InputsEntry;
class Operation_InputsEntryDefaultTypeInternal;
extern Operation_InputsEntryDefaultTypeInternal _Operation_InputsEntry_default_instance_;
class Program;
class ProgramDefaultTypeInternal;
extern ProgramDefaultTypeInternal _Program_default_instance_;
class Program_AttributesEntry;
class Program_AttributesEntryDefaultTypeInternal;
extern Program_AttributesEntryDefaultTypeInternal _Program_AttributesEntry_default_instance_;
class Program_FunctionsEntry;
class Program_FunctionsEntryDefaultTypeInternal;
extern Program_FunctionsEntryDefaultTypeInternal _Program_FunctionsEntry_default_instance_;
class TensorType;
class TensorTypeDefaultTypeInternal;
extern TensorTypeDefaultTypeInternal _TensorType_default_instance_;
class TensorType_AttributesEntry;
class TensorType_AttributesEntryDefaultTypeInternal;
extern TensorType_AttributesEntryDefaultTypeInternal _TensorType_AttributesEntry_default_instance_;
class TensorValue;
class TensorValueDefaultTypeInternal;
extern TensorValueDefaultTypeInternal _TensorValue_default_instance_;
class TensorValue_RepeatedBools;
class TensorValue_RepeatedBoolsDefaultTypeInternal;
extern TensorValue_RepeatedBoolsDefaultTypeInternal _TensorValue_RepeatedBools_default_instance_;
class TensorValue_RepeatedBytes;
class TensorValue_RepeatedBytesDefaultTypeInternal;
extern TensorValue_RepeatedBytesDefaultTypeInternal _TensorValue_RepeatedBytes_default_instance_;
class TensorValue_RepeatedDoubles;
class TensorValue_RepeatedDoublesDefaultTypeInternal;
extern TensorValue_RepeatedDoublesDefaultTypeInternal _TensorValue_RepeatedDoubles_default_instance_;
class TensorValue_RepeatedFloats;
class TensorValue_RepeatedFloatsDefaultTypeInternal;
extern TensorValue_RepeatedFloatsDefaultTypeInternal _TensorValue_RepeatedFloats_default_instance_;
class TensorValue_RepeatedInts;
class TensorValue_RepeatedIntsDefaultTypeInternal;
extern TensorValue_RepeatedIntsDefaultTypeInternal _TensorValue_RepeatedInts_default_instance_;
class TensorValue_RepeatedLongInts;
class TensorValue_RepeatedLongIntsDefaultTypeInternal;
extern TensorValue_RepeatedLongIntsDefaultTypeInternal _TensorValue_RepeatedLongInts_default_instance_;
class TensorValue_RepeatedStrings;
class TensorValue_RepeatedStringsDefaultTypeInternal;
extern TensorValue_RepeatedStringsDefaultTypeInternal _TensorValue_RepeatedStrings_default_instance_;
class TupleType;
class TupleTypeDefaultTypeInternal;
extern TupleTypeDefaultTypeInternal _TupleType_default_instance_;
class TupleValue;
class TupleValueDefaultTypeInternal;
extern TupleValueDefaultTypeInternal _TupleValue_default_instance_;
class Value;
class ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class ValueType;
class ValueTypeDefaultTypeInternal;
extern ValueTypeDefaultTypeInternal _ValueType_default_instance_;
class Value_BlobFileValue;
class Value_BlobFileValueDefaultTypeInternal;
extern Value_BlobFileValueDefaultTypeInternal _Value_BlobFileValue_default_instance_;
class Value_ImmediateValue;
class Value_ImmediateValueDefaultTypeInternal;
extern Value_ImmediateValueDefaultTypeInternal _Value_ImmediateValue_default_instance_;
}  // namespace MILSpec
}  // namespace Specification
}  // namespace CoreML

namespace CoreML {
namespace Specification {
namespace MILSpec {

namespace protobuf_MIL_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_MIL_2eproto

enum DataType {
  UNUSED_TYPE = 0,
  BOOL = 1,
  STRING = 2,
  FLOAT16 = 10,
  FLOAT32 = 11,
  FLOAT64 = 12,
  INT8 = 21,
  INT16 = 22,
  INT32 = 23,
  INT64 = 24,
  UINT8 = 31,
  UINT16 = 32,
  UINT32 = 33,
  UINT64 = 34,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DataType_IsValid(int value);
const DataType DataType_MIN = UNUSED_TYPE;
const DataType DataType_MAX = UINT64;
const int DataType_ARRAYSIZE = DataType_MAX + 1;

// ===================================================================


// -------------------------------------------------------------------


// -------------------------------------------------------------------

class Program : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Program) */ {
 public:
  Program();
  virtual ~Program();

  Program(const Program& from);

  inline Program& operator=(const Program& from) {
    CopyFrom(from);
    return *this;
  }

  static const Program& default_instance();

  static inline const Program* internal_default_instance() {
    return reinterpret_cast<const Program*>(
               &_Program_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Program* other);

  // implements Message ----------------------------------------------

  inline Program* New() const PROTOBUF_FINAL { return New(NULL); }

  Program* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Program& from);
  void MergeFrom(const Program& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Program* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .CoreML.Specification.MILSpec.Function> functions = 2;
  int functions_size() const;
  void clear_functions();
  static const int kFunctionsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Function >&
      functions() const;
  ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Function >*
      mutable_functions();

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >&
      attributes() const;
  ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >*
      mutable_attributes();

  // string docString = 3;
  void clear_docstring();
  static const int kDocStringFieldNumber = 3;
  const ::std::string& docstring() const;
  void set_docstring(const ::std::string& value);
  #if LANG_CXX11
  void set_docstring(::std::string&& value);
  #endif
  void set_docstring(const char* value);
  void set_docstring(const char* value, size_t size);
  ::std::string* mutable_docstring();
  ::std::string* release_docstring();
  void set_allocated_docstring(::std::string* docstring);

  // int64 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::int64 version() const;
  void set_version(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Program)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  public:
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::CoreML::Specification::MILSpec::Function,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      Program_FunctionsEntry;
  ::google::protobuf::internal::MapFieldLite<
      Program_FunctionsEntry,
      ::std::string, ::CoreML::Specification::MILSpec::Function,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > functions_;
  private:
  public:
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::CoreML::Specification::MILSpec::Value,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      Program_AttributesEntry;
  ::google::protobuf::internal::MapFieldLite<
      Program_AttributesEntry,
      ::std::string, ::CoreML::Specification::MILSpec::Value,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > attributes_;
  private:
  ::google::protobuf::internal::ArenaStringPtr docstring_;
  ::google::protobuf::int64 version_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------


// -------------------------------------------------------------------

class Function : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Function) */ {
 public:
  Function();
  virtual ~Function();

  Function(const Function& from);

  inline Function& operator=(const Function& from) {
    CopyFrom(from);
    return *this;
  }

  static const Function& default_instance();

  static inline const Function* internal_default_instance() {
    return reinterpret_cast<const Function*>(
               &_Function_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Function* other);

  // implements Message ----------------------------------------------

  inline Function* New() const PROTOBUF_FINAL { return New(NULL); }

  Function* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Function& from);
  void MergeFrom(const Function& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Function* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.MILSpec.NamedValueType inputs = 1;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 1;
  const ::CoreML::Specification::MILSpec::NamedValueType& inputs(int index) const;
  ::CoreML::Specification::MILSpec::NamedValueType* mutable_inputs(int index);
  ::CoreML::Specification::MILSpec::NamedValueType* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >&
      inputs() const;

  // map<string, .CoreML.Specification.MILSpec.Block> block_specializations = 3;
  int block_specializations_size() const;
  void clear_block_specializations();
  static const int kBlockSpecializationsFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Block >&
      block_specializations() const;
  ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Block >*
      mutable_block_specializations();

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >&
      attributes() const;
  ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >*
      mutable_attributes();

  // string opset = 2;
  void clear_opset();
  static const int kOpsetFieldNumber = 2;
  const ::std::string& opset() const;
  void set_opset(const ::std::string& value);
  #if LANG_CXX11
  void set_opset(::std::string&& value);
  #endif
  void set_opset(const char* value);
  void set_opset(const char* value, size_t size);
  ::std::string* mutable_opset();
  ::std::string* release_opset();
  void set_allocated_opset(::std::string* opset);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Function)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType > inputs_;
  public:
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::CoreML::Specification::MILSpec::Block,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      Function_BlockSpecializationsEntry;
  ::google::protobuf::internal::MapFieldLite<
      Function_BlockSpecializationsEntry,
      ::std::string, ::CoreML::Specification::MILSpec::Block,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > block_specializations_;
  private:
  public:
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::CoreML::Specification::MILSpec::Value,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      Function_AttributesEntry;
  ::google::protobuf::internal::MapFieldLite<
      Function_AttributesEntry,
      ::std::string, ::CoreML::Specification::MILSpec::Value,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > attributes_;
  private:
  ::google::protobuf::internal::ArenaStringPtr opset_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class Block : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Block) */ {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }

  static const Block& default_instance();

  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Block* other);

  // implements Message ----------------------------------------------

  inline Block* New() const PROTOBUF_FINAL { return New(NULL); }

  Block* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Block* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.MILSpec.NamedValueType inputs = 1;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 1;
  const ::CoreML::Specification::MILSpec::NamedValueType& inputs(int index) const;
  ::CoreML::Specification::MILSpec::NamedValueType* mutable_inputs(int index);
  ::CoreML::Specification::MILSpec::NamedValueType* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >&
      inputs() const;

  // repeated string outputs = 2;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  const ::std::string& outputs(int index) const;
  ::std::string* mutable_outputs(int index);
  void set_outputs(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_outputs(int index, ::std::string&& value);
  #endif
  void set_outputs(int index, const char* value);
  void set_outputs(int index, const char* value, size_t size);
  ::std::string* add_outputs();
  void add_outputs(const ::std::string& value);
  #if LANG_CXX11
  void add_outputs(::std::string&& value);
  #endif
  void add_outputs(const char* value);
  void add_outputs(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& outputs() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_outputs();

  // repeated .CoreML.Specification.MILSpec.Operation operations = 3;
  int operations_size() const;
  void clear_operations();
  static const int kOperationsFieldNumber = 3;
  const ::CoreML::Specification::MILSpec::Operation& operations(int index) const;
  ::CoreML::Specification::MILSpec::Operation* mutable_operations(int index);
  ::CoreML::Specification::MILSpec::Operation* add_operations();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Operation >*
      mutable_operations();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Operation >&
      operations() const;

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >&
      attributes() const;
  ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >*
      mutable_attributes();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Block)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType > inputs_;
  ::google::protobuf::RepeatedPtrField< ::std::string> outputs_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Operation > operations_;
  public:
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::CoreML::Specification::MILSpec::Value,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      Block_AttributesEntry;
  ::google::protobuf::internal::MapFieldLite<
      Block_AttributesEntry,
      ::std::string, ::CoreML::Specification::MILSpec::Value,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > attributes_;
  private:
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Argument_Binding : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Argument.Binding) */ {
 public:
  Argument_Binding();
  virtual ~Argument_Binding();

  Argument_Binding(const Argument_Binding& from);

  inline Argument_Binding& operator=(const Argument_Binding& from) {
    CopyFrom(from);
    return *this;
  }

  static const Argument_Binding& default_instance();

  enum BindingCase {
    kName = 1,
    kValue = 2,
    BINDING_NOT_SET = 0,
  };

  static inline const Argument_Binding* internal_default_instance() {
    return reinterpret_cast<const Argument_Binding*>(
               &_Argument_Binding_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Argument_Binding* other);

  // implements Message ----------------------------------------------

  inline Argument_Binding* New() const PROTOBUF_FINAL { return New(NULL); }

  Argument_Binding* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Argument_Binding& from);
  void MergeFrom(const Argument_Binding& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Argument_Binding* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  private:
  bool has_name() const;
  public:
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .CoreML.Specification.MILSpec.Value value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::CoreML::Specification::MILSpec::Value& value() const;
  ::CoreML::Specification::MILSpec::Value* mutable_value();
  ::CoreML::Specification::MILSpec::Value* release_value();
  void set_allocated_value(::CoreML::Specification::MILSpec::Value* value);

  BindingCase binding_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Argument.Binding)
 private:
  void set_has_name();
  void set_has_value();

  inline bool has_binding() const;
  void clear_binding();
  inline void clear_has_binding();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union BindingUnion {
    BindingUnion() {}
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::CoreML::Specification::MILSpec::Value* value_;
  } binding_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Argument : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Argument) */ {
 public:
  Argument();
  virtual ~Argument();

  Argument(const Argument& from);

  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }

  static const Argument& default_instance();

  static inline const Argument* internal_default_instance() {
    return reinterpret_cast<const Argument*>(
               &_Argument_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Argument* other);

  // implements Message ----------------------------------------------

  inline Argument* New() const PROTOBUF_FINAL { return New(NULL); }

  Argument* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Argument& from);
  void MergeFrom(const Argument& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Argument* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Argument_Binding Binding;

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.MILSpec.Argument.Binding arguments = 1;
  int arguments_size() const;
  void clear_arguments();
  static const int kArgumentsFieldNumber = 1;
  const ::CoreML::Specification::MILSpec::Argument_Binding& arguments(int index) const;
  ::CoreML::Specification::MILSpec::Argument_Binding* mutable_arguments(int index);
  ::CoreML::Specification::MILSpec::Argument_Binding* add_arguments();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Argument_Binding >*
      mutable_arguments();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Argument_Binding >&
      arguments() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Argument)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Argument_Binding > arguments_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------


// -------------------------------------------------------------------

class Operation : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Operation) */ {
 public:
  Operation();
  virtual ~Operation();

  Operation(const Operation& from);

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }

  static const Operation& default_instance();

  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(Operation* other);

  // implements Message ----------------------------------------------

  inline Operation* New() const PROTOBUF_FINAL { return New(NULL); }

  Operation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Operation& from);
  void MergeFrom(const Operation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Operation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .CoreML.Specification.MILSpec.Argument> inputs = 2;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Argument >&
      inputs() const;
  ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Argument >*
      mutable_inputs();

  // repeated .CoreML.Specification.MILSpec.NamedValueType outputs = 3;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 3;
  const ::CoreML::Specification::MILSpec::NamedValueType& outputs(int index) const;
  ::CoreML::Specification::MILSpec::NamedValueType* mutable_outputs(int index);
  ::CoreML::Specification::MILSpec::NamedValueType* add_outputs();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >*
      mutable_outputs();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >&
      outputs() const;

  // repeated .CoreML.Specification.MILSpec.Block blocks = 4;
  int blocks_size() const;
  void clear_blocks();
  static const int kBlocksFieldNumber = 4;
  const ::CoreML::Specification::MILSpec::Block& blocks(int index) const;
  ::CoreML::Specification::MILSpec::Block* mutable_blocks(int index);
  ::CoreML::Specification::MILSpec::Block* add_blocks();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Block >*
      mutable_blocks();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Block >&
      blocks() const;

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 5;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >&
      attributes() const;
  ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >*
      mutable_attributes();

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Operation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  public:
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::CoreML::Specification::MILSpec::Argument,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      Operation_InputsEntry;
  ::google::protobuf::internal::MapFieldLite<
      Operation_InputsEntry,
      ::std::string, ::CoreML::Specification::MILSpec::Argument,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > inputs_;
  private:
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType > outputs_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Block > blocks_;
  public:
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::CoreML::Specification::MILSpec::Value,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      Operation_AttributesEntry;
  ::google::protobuf::internal::MapFieldLite<
      Operation_AttributesEntry,
      ::std::string, ::CoreML::Specification::MILSpec::Value,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > attributes_;
  private:
  ::google::protobuf::internal::ArenaStringPtr type_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NamedValueType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.NamedValueType) */ {
 public:
  NamedValueType();
  virtual ~NamedValueType();

  NamedValueType(const NamedValueType& from);

  inline NamedValueType& operator=(const NamedValueType& from) {
    CopyFrom(from);
    return *this;
  }

  static const NamedValueType& default_instance();

  static inline const NamedValueType* internal_default_instance() {
    return reinterpret_cast<const NamedValueType*>(
               &_NamedValueType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(NamedValueType* other);

  // implements Message ----------------------------------------------

  inline NamedValueType* New() const PROTOBUF_FINAL { return New(NULL); }

  NamedValueType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NamedValueType& from);
  void MergeFrom(const NamedValueType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NamedValueType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .CoreML.Specification.MILSpec.ValueType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::CoreML::Specification::MILSpec::ValueType& type() const;
  ::CoreML::Specification::MILSpec::ValueType* mutable_type();
  ::CoreML::Specification::MILSpec::ValueType* release_type();
  void set_allocated_type(::CoreML::Specification::MILSpec::ValueType* type);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.NamedValueType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::CoreML::Specification::MILSpec::ValueType* type_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ValueType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.ValueType) */ {
 public:
  ValueType();
  virtual ~ValueType();

  ValueType(const ValueType& from);

  inline ValueType& operator=(const ValueType& from) {
    CopyFrom(from);
    return *this;
  }

  static const ValueType& default_instance();

  enum TypeCase {
    kTensorType = 1,
    kListType = 2,
    kTupleType = 3,
    kDictionaryType = 4,
    TYPE_NOT_SET = 0,
  };

  static inline const ValueType* internal_default_instance() {
    return reinterpret_cast<const ValueType*>(
               &_ValueType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(ValueType* other);

  // implements Message ----------------------------------------------

  inline ValueType* New() const PROTOBUF_FINAL { return New(NULL); }

  ValueType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ValueType& from);
  void MergeFrom(const ValueType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ValueType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.MILSpec.TensorType tensorType = 1;
  bool has_tensortype() const;
  void clear_tensortype();
  static const int kTensorTypeFieldNumber = 1;
  const ::CoreML::Specification::MILSpec::TensorType& tensortype() const;
  ::CoreML::Specification::MILSpec::TensorType* mutable_tensortype();
  ::CoreML::Specification::MILSpec::TensorType* release_tensortype();
  void set_allocated_tensortype(::CoreML::Specification::MILSpec::TensorType* tensortype);

  // .CoreML.Specification.MILSpec.ListType listType = 2;
  bool has_listtype() const;
  void clear_listtype();
  static const int kListTypeFieldNumber = 2;
  const ::CoreML::Specification::MILSpec::ListType& listtype() const;
  ::CoreML::Specification::MILSpec::ListType* mutable_listtype();
  ::CoreML::Specification::MILSpec::ListType* release_listtype();
  void set_allocated_listtype(::CoreML::Specification::MILSpec::ListType* listtype);

  // .CoreML.Specification.MILSpec.TupleType tupleType = 3;
  bool has_tupletype() const;
  void clear_tupletype();
  static const int kTupleTypeFieldNumber = 3;
  const ::CoreML::Specification::MILSpec::TupleType& tupletype() const;
  ::CoreML::Specification::MILSpec::TupleType* mutable_tupletype();
  ::CoreML::Specification::MILSpec::TupleType* release_tupletype();
  void set_allocated_tupletype(::CoreML::Specification::MILSpec::TupleType* tupletype);

  // .CoreML.Specification.MILSpec.DictionaryType dictionaryType = 4;
  bool has_dictionarytype() const;
  void clear_dictionarytype();
  static const int kDictionaryTypeFieldNumber = 4;
  const ::CoreML::Specification::MILSpec::DictionaryType& dictionarytype() const;
  ::CoreML::Specification::MILSpec::DictionaryType* mutable_dictionarytype();
  ::CoreML::Specification::MILSpec::DictionaryType* release_dictionarytype();
  void set_allocated_dictionarytype(::CoreML::Specification::MILSpec::DictionaryType* dictionarytype);

  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.ValueType)
 private:
  void set_has_tensortype();
  void set_has_listtype();
  void set_has_tupletype();
  void set_has_dictionarytype();

  inline bool has_type() const;
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union TypeUnion {
    TypeUnion() {}
    ::CoreML::Specification::MILSpec::TensorType* tensortype_;
    ::CoreML::Specification::MILSpec::ListType* listtype_;
    ::CoreML::Specification::MILSpec::TupleType* tupletype_;
    ::CoreML::Specification::MILSpec::DictionaryType* dictionarytype_;
  } type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class TensorType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TensorType) */ {
 public:
  TensorType();
  virtual ~TensorType();

  TensorType(const TensorType& from);

  inline TensorType& operator=(const TensorType& from) {
    CopyFrom(from);
    return *this;
  }

  static const TensorType& default_instance();

  static inline const TensorType* internal_default_instance() {
    return reinterpret_cast<const TensorType*>(
               &_TensorType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(TensorType* other);

  // implements Message ----------------------------------------------

  inline TensorType* New() const PROTOBUF_FINAL { return New(NULL); }

  TensorType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TensorType& from);
  void MergeFrom(const TensorType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.MILSpec.Dimension dimensions = 3;
  int dimensions_size() const;
  void clear_dimensions();
  static const int kDimensionsFieldNumber = 3;
  const ::CoreML::Specification::MILSpec::Dimension& dimensions(int index) const;
  ::CoreML::Specification::MILSpec::Dimension* mutable_dimensions(int index);
  ::CoreML::Specification::MILSpec::Dimension* add_dimensions();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Dimension >*
      mutable_dimensions();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Dimension >&
      dimensions() const;

  // map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >&
      attributes() const;
  ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >*
      mutable_attributes();

  // int64 rank = 2;
  void clear_rank();
  static const int kRankFieldNumber = 2;
  ::google::protobuf::int64 rank() const;
  void set_rank(::google::protobuf::int64 value);

  // .CoreML.Specification.MILSpec.DataType dataType = 1;
  void clear_datatype();
  static const int kDataTypeFieldNumber = 1;
  ::CoreML::Specification::MILSpec::DataType datatype() const;
  void set_datatype(::CoreML::Specification::MILSpec::DataType value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TensorType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Dimension > dimensions_;
  public:
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::CoreML::Specification::MILSpec::Value,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      TensorType_AttributesEntry;
  ::google::protobuf::internal::MapFieldLite<
      TensorType_AttributesEntry,
      ::std::string, ::CoreML::Specification::MILSpec::Value,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > attributes_;
  private:
  ::google::protobuf::int64 rank_;
  int datatype_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TupleType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TupleType) */ {
 public:
  TupleType();
  virtual ~TupleType();

  TupleType(const TupleType& from);

  inline TupleType& operator=(const TupleType& from) {
    CopyFrom(from);
    return *this;
  }

  static const TupleType& default_instance();

  static inline const TupleType* internal_default_instance() {
    return reinterpret_cast<const TupleType*>(
               &_TupleType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(TupleType* other);

  // implements Message ----------------------------------------------

  inline TupleType* New() const PROTOBUF_FINAL { return New(NULL); }

  TupleType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TupleType& from);
  void MergeFrom(const TupleType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TupleType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.MILSpec.ValueType types = 1;
  int types_size() const;
  void clear_types();
  static const int kTypesFieldNumber = 1;
  const ::CoreML::Specification::MILSpec::ValueType& types(int index) const;
  ::CoreML::Specification::MILSpec::ValueType* mutable_types(int index);
  ::CoreML::Specification::MILSpec::ValueType* add_types();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::ValueType >*
      mutable_types();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::ValueType >&
      types() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TupleType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::ValueType > types_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.ListType) */ {
 public:
  ListType();
  virtual ~ListType();

  ListType(const ListType& from);

  inline ListType& operator=(const ListType& from) {
    CopyFrom(from);
    return *this;
  }

  static const ListType& default_instance();

  static inline const ListType* internal_default_instance() {
    return reinterpret_cast<const ListType*>(
               &_ListType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(ListType* other);

  // implements Message ----------------------------------------------

  inline ListType* New() const PROTOBUF_FINAL { return New(NULL); }

  ListType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ListType& from);
  void MergeFrom(const ListType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.MILSpec.ValueType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::CoreML::Specification::MILSpec::ValueType& type() const;
  ::CoreML::Specification::MILSpec::ValueType* mutable_type();
  ::CoreML::Specification::MILSpec::ValueType* release_type();
  void set_allocated_type(::CoreML::Specification::MILSpec::ValueType* type);

  // .CoreML.Specification.MILSpec.Dimension length = 2;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  const ::CoreML::Specification::MILSpec::Dimension& length() const;
  ::CoreML::Specification::MILSpec::Dimension* mutable_length();
  ::CoreML::Specification::MILSpec::Dimension* release_length();
  void set_allocated_length(::CoreML::Specification::MILSpec::Dimension* length);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.ListType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::CoreML::Specification::MILSpec::ValueType* type_;
  ::CoreML::Specification::MILSpec::Dimension* length_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DictionaryType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.DictionaryType) */ {
 public:
  DictionaryType();
  virtual ~DictionaryType();

  DictionaryType(const DictionaryType& from);

  inline DictionaryType& operator=(const DictionaryType& from) {
    CopyFrom(from);
    return *this;
  }

  static const DictionaryType& default_instance();

  static inline const DictionaryType* internal_default_instance() {
    return reinterpret_cast<const DictionaryType*>(
               &_DictionaryType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(DictionaryType* other);

  // implements Message ----------------------------------------------

  inline DictionaryType* New() const PROTOBUF_FINAL { return New(NULL); }

  DictionaryType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DictionaryType& from);
  void MergeFrom(const DictionaryType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DictionaryType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.MILSpec.ValueType keyType = 1;
  bool has_keytype() const;
  void clear_keytype();
  static const int kKeyTypeFieldNumber = 1;
  const ::CoreML::Specification::MILSpec::ValueType& keytype() const;
  ::CoreML::Specification::MILSpec::ValueType* mutable_keytype();
  ::CoreML::Specification::MILSpec::ValueType* release_keytype();
  void set_allocated_keytype(::CoreML::Specification::MILSpec::ValueType* keytype);

  // .CoreML.Specification.MILSpec.ValueType valueType = 2;
  bool has_valuetype() const;
  void clear_valuetype();
  static const int kValueTypeFieldNumber = 2;
  const ::CoreML::Specification::MILSpec::ValueType& valuetype() const;
  ::CoreML::Specification::MILSpec::ValueType* mutable_valuetype();
  ::CoreML::Specification::MILSpec::ValueType* release_valuetype();
  void set_allocated_valuetype(::CoreML::Specification::MILSpec::ValueType* valuetype);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.DictionaryType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::CoreML::Specification::MILSpec::ValueType* keytype_;
  ::CoreML::Specification::MILSpec::ValueType* valuetype_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Dimension_ConstantDimension : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Dimension.ConstantDimension) */ {
 public:
  Dimension_ConstantDimension();
  virtual ~Dimension_ConstantDimension();

  Dimension_ConstantDimension(const Dimension_ConstantDimension& from);

  inline Dimension_ConstantDimension& operator=(const Dimension_ConstantDimension& from) {
    CopyFrom(from);
    return *this;
  }

  static const Dimension_ConstantDimension& default_instance();

  static inline const Dimension_ConstantDimension* internal_default_instance() {
    return reinterpret_cast<const Dimension_ConstantDimension*>(
               &_Dimension_ConstantDimension_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(Dimension_ConstantDimension* other);

  // implements Message ----------------------------------------------

  inline Dimension_ConstantDimension* New() const PROTOBUF_FINAL { return New(NULL); }

  Dimension_ConstantDimension* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Dimension_ConstantDimension& from);
  void MergeFrom(const Dimension_ConstantDimension& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Dimension_ConstantDimension* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 size = 1;
  void clear_size();
  static const int kSizeFieldNumber = 1;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Dimension.ConstantDimension)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint64 size_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Dimension_UnknownDimension : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Dimension.UnknownDimension) */ {
 public:
  Dimension_UnknownDimension();
  virtual ~Dimension_UnknownDimension();

  Dimension_UnknownDimension(const Dimension_UnknownDimension& from);

  inline Dimension_UnknownDimension& operator=(const Dimension_UnknownDimension& from) {
    CopyFrom(from);
    return *this;
  }

  static const Dimension_UnknownDimension& default_instance();

  static inline const Dimension_UnknownDimension* internal_default_instance() {
    return reinterpret_cast<const Dimension_UnknownDimension*>(
               &_Dimension_UnknownDimension_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(Dimension_UnknownDimension* other);

  // implements Message ----------------------------------------------

  inline Dimension_UnknownDimension* New() const PROTOBUF_FINAL { return New(NULL); }

  Dimension_UnknownDimension* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Dimension_UnknownDimension& from);
  void MergeFrom(const Dimension_UnknownDimension& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Dimension_UnknownDimension* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool variadic = 1;
  void clear_variadic();
  static const int kVariadicFieldNumber = 1;
  bool variadic() const;
  void set_variadic(bool value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Dimension.UnknownDimension)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  bool variadic_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Dimension : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Dimension) */ {
 public:
  Dimension();
  virtual ~Dimension();

  Dimension(const Dimension& from);

  inline Dimension& operator=(const Dimension& from) {
    CopyFrom(from);
    return *this;
  }

  static const Dimension& default_instance();

  enum DimensionCase {
    kConstant = 1,
    kUnknown = 2,
    DIMENSION_NOT_SET = 0,
  };

  static inline const Dimension* internal_default_instance() {
    return reinterpret_cast<const Dimension*>(
               &_Dimension_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(Dimension* other);

  // implements Message ----------------------------------------------

  inline Dimension* New() const PROTOBUF_FINAL { return New(NULL); }

  Dimension* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Dimension& from);
  void MergeFrom(const Dimension& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Dimension* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Dimension_ConstantDimension ConstantDimension;
  typedef Dimension_UnknownDimension UnknownDimension;

  // accessors -------------------------------------------------------

  // .CoreML.Specification.MILSpec.Dimension.ConstantDimension constant = 1;
  bool has_constant() const;
  void clear_constant();
  static const int kConstantFieldNumber = 1;
  const ::CoreML::Specification::MILSpec::Dimension_ConstantDimension& constant() const;
  ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* mutable_constant();
  ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* release_constant();
  void set_allocated_constant(::CoreML::Specification::MILSpec::Dimension_ConstantDimension* constant);

  // .CoreML.Specification.MILSpec.Dimension.UnknownDimension unknown = 2;
  bool has_unknown() const;
  void clear_unknown();
  static const int kUnknownFieldNumber = 2;
  const ::CoreML::Specification::MILSpec::Dimension_UnknownDimension& unknown() const;
  ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* mutable_unknown();
  ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* release_unknown();
  void set_allocated_unknown(::CoreML::Specification::MILSpec::Dimension_UnknownDimension* unknown);

  DimensionCase dimension_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Dimension)
 private:
  void set_has_constant();
  void set_has_unknown();

  inline bool has_dimension() const;
  void clear_dimension();
  inline void clear_has_dimension();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union DimensionUnion {
    DimensionUnion() {}
    ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* constant_;
    ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* unknown_;
  } dimension_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Value_ImmediateValue : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Value.ImmediateValue) */ {
 public:
  Value_ImmediateValue();
  virtual ~Value_ImmediateValue();

  Value_ImmediateValue(const Value_ImmediateValue& from);

  inline Value_ImmediateValue& operator=(const Value_ImmediateValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const Value_ImmediateValue& default_instance();

  enum ValueCase {
    kTensor = 1,
    kTuple = 2,
    kList = 3,
    kDictionary = 4,
    VALUE_NOT_SET = 0,
  };

  static inline const Value_ImmediateValue* internal_default_instance() {
    return reinterpret_cast<const Value_ImmediateValue*>(
               &_Value_ImmediateValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(Value_ImmediateValue* other);

  // implements Message ----------------------------------------------

  inline Value_ImmediateValue* New() const PROTOBUF_FINAL { return New(NULL); }

  Value_ImmediateValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Value_ImmediateValue& from);
  void MergeFrom(const Value_ImmediateValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Value_ImmediateValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.MILSpec.TensorValue tensor = 1;
  bool has_tensor() const;
  void clear_tensor();
  static const int kTensorFieldNumber = 1;
  const ::CoreML::Specification::MILSpec::TensorValue& tensor() const;
  ::CoreML::Specification::MILSpec::TensorValue* mutable_tensor();
  ::CoreML::Specification::MILSpec::TensorValue* release_tensor();
  void set_allocated_tensor(::CoreML::Specification::MILSpec::TensorValue* tensor);

  // .CoreML.Specification.MILSpec.TupleValue tuple = 2;
  bool has_tuple() const;
  void clear_tuple();
  static const int kTupleFieldNumber = 2;
  const ::CoreML::Specification::MILSpec::TupleValue& tuple() const;
  ::CoreML::Specification::MILSpec::TupleValue* mutable_tuple();
  ::CoreML::Specification::MILSpec::TupleValue* release_tuple();
  void set_allocated_tuple(::CoreML::Specification::MILSpec::TupleValue* tuple);

  // .CoreML.Specification.MILSpec.ListValue list = 3;
  bool has_list() const;
  void clear_list();
  static const int kListFieldNumber = 3;
  const ::CoreML::Specification::MILSpec::ListValue& list() const;
  ::CoreML::Specification::MILSpec::ListValue* mutable_list();
  ::CoreML::Specification::MILSpec::ListValue* release_list();
  void set_allocated_list(::CoreML::Specification::MILSpec::ListValue* list);

  // .CoreML.Specification.MILSpec.DictionaryValue dictionary = 4;
  bool has_dictionary() const;
  void clear_dictionary();
  static const int kDictionaryFieldNumber = 4;
  const ::CoreML::Specification::MILSpec::DictionaryValue& dictionary() const;
  ::CoreML::Specification::MILSpec::DictionaryValue* mutable_dictionary();
  ::CoreML::Specification::MILSpec::DictionaryValue* release_dictionary();
  void set_allocated_dictionary(::CoreML::Specification::MILSpec::DictionaryValue* dictionary);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Value.ImmediateValue)
 private:
  void set_has_tensor();
  void set_has_tuple();
  void set_has_list();
  void set_has_dictionary();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::CoreML::Specification::MILSpec::TensorValue* tensor_;
    ::CoreML::Specification::MILSpec::TupleValue* tuple_;
    ::CoreML::Specification::MILSpec::ListValue* list_;
    ::CoreML::Specification::MILSpec::DictionaryValue* dictionary_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Value_BlobFileValue : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Value.BlobFileValue) */ {
 public:
  Value_BlobFileValue();
  virtual ~Value_BlobFileValue();

  Value_BlobFileValue(const Value_BlobFileValue& from);

  inline Value_BlobFileValue& operator=(const Value_BlobFileValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const Value_BlobFileValue& default_instance();

  static inline const Value_BlobFileValue* internal_default_instance() {
    return reinterpret_cast<const Value_BlobFileValue*>(
               &_Value_BlobFileValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(Value_BlobFileValue* other);

  // implements Message ----------------------------------------------

  inline Value_BlobFileValue* New() const PROTOBUF_FINAL { return New(NULL); }

  Value_BlobFileValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Value_BlobFileValue& from);
  void MergeFrom(const Value_BlobFileValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Value_BlobFileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string fileName = 1;
  void clear_filename();
  static const int kFileNameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // uint64 offset = 2;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Value.BlobFileValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  ::google::protobuf::uint64 offset_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Value : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.Value) */ {
 public:
  Value();
  virtual ~Value();

  Value(const Value& from);

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }

  static const Value& default_instance();

  enum ValueCase {
    kImmediateValue = 3,
    kBlobFileValue = 5,
    VALUE_NOT_SET = 0,
  };

  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(Value* other);

  // implements Message ----------------------------------------------

  inline Value* New() const PROTOBUF_FINAL { return New(NULL); }

  Value* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Value* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Value_ImmediateValue ImmediateValue;
  typedef Value_BlobFileValue BlobFileValue;

  // accessors -------------------------------------------------------

  // string docString = 1;
  void clear_docstring();
  static const int kDocStringFieldNumber = 1;
  const ::std::string& docstring() const;
  void set_docstring(const ::std::string& value);
  #if LANG_CXX11
  void set_docstring(::std::string&& value);
  #endif
  void set_docstring(const char* value);
  void set_docstring(const char* value, size_t size);
  ::std::string* mutable_docstring();
  ::std::string* release_docstring();
  void set_allocated_docstring(::std::string* docstring);

  // .CoreML.Specification.MILSpec.ValueType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::CoreML::Specification::MILSpec::ValueType& type() const;
  ::CoreML::Specification::MILSpec::ValueType* mutable_type();
  ::CoreML::Specification::MILSpec::ValueType* release_type();
  void set_allocated_type(::CoreML::Specification::MILSpec::ValueType* type);

  // .CoreML.Specification.MILSpec.Value.ImmediateValue immediateValue = 3;
  bool has_immediatevalue() const;
  void clear_immediatevalue();
  static const int kImmediateValueFieldNumber = 3;
  const ::CoreML::Specification::MILSpec::Value_ImmediateValue& immediatevalue() const;
  ::CoreML::Specification::MILSpec::Value_ImmediateValue* mutable_immediatevalue();
  ::CoreML::Specification::MILSpec::Value_ImmediateValue* release_immediatevalue();
  void set_allocated_immediatevalue(::CoreML::Specification::MILSpec::Value_ImmediateValue* immediatevalue);

  // .CoreML.Specification.MILSpec.Value.BlobFileValue blobFileValue = 5;
  bool has_blobfilevalue() const;
  void clear_blobfilevalue();
  static const int kBlobFileValueFieldNumber = 5;
  const ::CoreML::Specification::MILSpec::Value_BlobFileValue& blobfilevalue() const;
  ::CoreML::Specification::MILSpec::Value_BlobFileValue* mutable_blobfilevalue();
  ::CoreML::Specification::MILSpec::Value_BlobFileValue* release_blobfilevalue();
  void set_allocated_blobfilevalue(::CoreML::Specification::MILSpec::Value_BlobFileValue* blobfilevalue);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.Value)
 private:
  void set_has_immediatevalue();
  void set_has_blobfilevalue();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr docstring_;
  ::CoreML::Specification::MILSpec::ValueType* type_;
  union ValueUnion {
    ValueUnion() {}
    ::CoreML::Specification::MILSpec::Value_ImmediateValue* immediatevalue_;
    ::CoreML::Specification::MILSpec::Value_BlobFileValue* blobfilevalue_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TensorValue_RepeatedFloats : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats) */ {
 public:
  TensorValue_RepeatedFloats();
  virtual ~TensorValue_RepeatedFloats();

  TensorValue_RepeatedFloats(const TensorValue_RepeatedFloats& from);

  inline TensorValue_RepeatedFloats& operator=(const TensorValue_RepeatedFloats& from) {
    CopyFrom(from);
    return *this;
  }

  static const TensorValue_RepeatedFloats& default_instance();

  static inline const TensorValue_RepeatedFloats* internal_default_instance() {
    return reinterpret_cast<const TensorValue_RepeatedFloats*>(
               &_TensorValue_RepeatedFloats_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(TensorValue_RepeatedFloats* other);

  // implements Message ----------------------------------------------

  inline TensorValue_RepeatedFloats* New() const PROTOBUF_FINAL { return New(NULL); }

  TensorValue_RepeatedFloats* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TensorValue_RepeatedFloats& from);
  void MergeFrom(const TensorValue_RepeatedFloats& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorValue_RepeatedFloats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float values = 1 [packed = true];
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::google::protobuf::RepeatedField< float >&
      values() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< float > values_;
  mutable int _values_cached_byte_size_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TensorValue_RepeatedDoubles : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles) */ {
 public:
  TensorValue_RepeatedDoubles();
  virtual ~TensorValue_RepeatedDoubles();

  TensorValue_RepeatedDoubles(const TensorValue_RepeatedDoubles& from);

  inline TensorValue_RepeatedDoubles& operator=(const TensorValue_RepeatedDoubles& from) {
    CopyFrom(from);
    return *this;
  }

  static const TensorValue_RepeatedDoubles& default_instance();

  static inline const TensorValue_RepeatedDoubles* internal_default_instance() {
    return reinterpret_cast<const TensorValue_RepeatedDoubles*>(
               &_TensorValue_RepeatedDoubles_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(TensorValue_RepeatedDoubles* other);

  // implements Message ----------------------------------------------

  inline TensorValue_RepeatedDoubles* New() const PROTOBUF_FINAL { return New(NULL); }

  TensorValue_RepeatedDoubles* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TensorValue_RepeatedDoubles& from);
  void MergeFrom(const TensorValue_RepeatedDoubles& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorValue_RepeatedDoubles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double values = 1 [packed = true];
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::google::protobuf::RepeatedField< double >&
      values() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< double > values_;
  mutable int _values_cached_byte_size_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TensorValue_RepeatedInts : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TensorValue.RepeatedInts) */ {
 public:
  TensorValue_RepeatedInts();
  virtual ~TensorValue_RepeatedInts();

  TensorValue_RepeatedInts(const TensorValue_RepeatedInts& from);

  inline TensorValue_RepeatedInts& operator=(const TensorValue_RepeatedInts& from) {
    CopyFrom(from);
    return *this;
  }

  static const TensorValue_RepeatedInts& default_instance();

  static inline const TensorValue_RepeatedInts* internal_default_instance() {
    return reinterpret_cast<const TensorValue_RepeatedInts*>(
               &_TensorValue_RepeatedInts_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(TensorValue_RepeatedInts* other);

  // implements Message ----------------------------------------------

  inline TensorValue_RepeatedInts* New() const PROTOBUF_FINAL { return New(NULL); }

  TensorValue_RepeatedInts* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TensorValue_RepeatedInts& from);
  void MergeFrom(const TensorValue_RepeatedInts& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorValue_RepeatedInts* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 values = 1 [packed = true];
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::google::protobuf::int32 values(int index) const;
  void set_values(int index, ::google::protobuf::int32 value);
  void add_values(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TensorValue.RepeatedInts)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > values_;
  mutable int _values_cached_byte_size_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TensorValue_RepeatedLongInts : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts) */ {
 public:
  TensorValue_RepeatedLongInts();
  virtual ~TensorValue_RepeatedLongInts();

  TensorValue_RepeatedLongInts(const TensorValue_RepeatedLongInts& from);

  inline TensorValue_RepeatedLongInts& operator=(const TensorValue_RepeatedLongInts& from) {
    CopyFrom(from);
    return *this;
  }

  static const TensorValue_RepeatedLongInts& default_instance();

  static inline const TensorValue_RepeatedLongInts* internal_default_instance() {
    return reinterpret_cast<const TensorValue_RepeatedLongInts*>(
               &_TensorValue_RepeatedLongInts_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(TensorValue_RepeatedLongInts* other);

  // implements Message ----------------------------------------------

  inline TensorValue_RepeatedLongInts* New() const PROTOBUF_FINAL { return New(NULL); }

  TensorValue_RepeatedLongInts* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TensorValue_RepeatedLongInts& from);
  void MergeFrom(const TensorValue_RepeatedLongInts& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorValue_RepeatedLongInts* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 values = 1 [packed = true];
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::google::protobuf::int64 values(int index) const;
  void set_values(int index, ::google::protobuf::int64 value);
  void add_values(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > values_;
  mutable int _values_cached_byte_size_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TensorValue_RepeatedBools : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TensorValue.RepeatedBools) */ {
 public:
  TensorValue_RepeatedBools();
  virtual ~TensorValue_RepeatedBools();

  TensorValue_RepeatedBools(const TensorValue_RepeatedBools& from);

  inline TensorValue_RepeatedBools& operator=(const TensorValue_RepeatedBools& from) {
    CopyFrom(from);
    return *this;
  }

  static const TensorValue_RepeatedBools& default_instance();

  static inline const TensorValue_RepeatedBools* internal_default_instance() {
    return reinterpret_cast<const TensorValue_RepeatedBools*>(
               &_TensorValue_RepeatedBools_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(TensorValue_RepeatedBools* other);

  // implements Message ----------------------------------------------

  inline TensorValue_RepeatedBools* New() const PROTOBUF_FINAL { return New(NULL); }

  TensorValue_RepeatedBools* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TensorValue_RepeatedBools& from);
  void MergeFrom(const TensorValue_RepeatedBools& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorValue_RepeatedBools* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool values = 1 [packed = true];
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  bool values(int index) const;
  void set_values(int index, bool value);
  void add_values(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      values() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TensorValue.RepeatedBools)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< bool > values_;
  mutable int _values_cached_byte_size_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TensorValue_RepeatedStrings : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings) */ {
 public:
  TensorValue_RepeatedStrings();
  virtual ~TensorValue_RepeatedStrings();

  TensorValue_RepeatedStrings(const TensorValue_RepeatedStrings& from);

  inline TensorValue_RepeatedStrings& operator=(const TensorValue_RepeatedStrings& from) {
    CopyFrom(from);
    return *this;
  }

  static const TensorValue_RepeatedStrings& default_instance();

  static inline const TensorValue_RepeatedStrings* internal_default_instance() {
    return reinterpret_cast<const TensorValue_RepeatedStrings*>(
               &_TensorValue_RepeatedStrings_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(TensorValue_RepeatedStrings* other);

  // implements Message ----------------------------------------------

  inline TensorValue_RepeatedStrings* New() const PROTOBUF_FINAL { return New(NULL); }

  TensorValue_RepeatedStrings* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TensorValue_RepeatedStrings& from);
  void MergeFrom(const TensorValue_RepeatedStrings& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorValue_RepeatedStrings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  const ::std::string& values(int index) const;
  ::std::string* mutable_values(int index);
  void set_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_values(int index, ::std::string&& value);
  #endif
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  ::std::string* add_values();
  void add_values(const ::std::string& value);
  #if LANG_CXX11
  void add_values(::std::string&& value);
  #endif
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TensorValue_RepeatedBytes : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes) */ {
 public:
  TensorValue_RepeatedBytes();
  virtual ~TensorValue_RepeatedBytes();

  TensorValue_RepeatedBytes(const TensorValue_RepeatedBytes& from);

  inline TensorValue_RepeatedBytes& operator=(const TensorValue_RepeatedBytes& from) {
    CopyFrom(from);
    return *this;
  }

  static const TensorValue_RepeatedBytes& default_instance();

  static inline const TensorValue_RepeatedBytes* internal_default_instance() {
    return reinterpret_cast<const TensorValue_RepeatedBytes*>(
               &_TensorValue_RepeatedBytes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(TensorValue_RepeatedBytes* other);

  // implements Message ----------------------------------------------

  inline TensorValue_RepeatedBytes* New() const PROTOBUF_FINAL { return New(NULL); }

  TensorValue_RepeatedBytes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TensorValue_RepeatedBytes& from);
  void MergeFrom(const TensorValue_RepeatedBytes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorValue_RepeatedBytes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes values = 1;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  const ::std::string& values() const;
  void set_values(const ::std::string& value);
  #if LANG_CXX11
  void set_values(::std::string&& value);
  #endif
  void set_values(const char* value);
  void set_values(const void* value, size_t size);
  ::std::string* mutable_values();
  ::std::string* release_values();
  void set_allocated_values(::std::string* values);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr values_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TensorValue : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TensorValue) */ {
 public:
  TensorValue();
  virtual ~TensorValue();

  TensorValue(const TensorValue& from);

  inline TensorValue& operator=(const TensorValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const TensorValue& default_instance();

  enum ValueCase {
    kFloats = 1,
    kInts = 2,
    kBools = 3,
    kStrings = 4,
    kLongInts = 5,
    kDoubles = 6,
    kBytes = 7,
    VALUE_NOT_SET = 0,
  };

  static inline const TensorValue* internal_default_instance() {
    return reinterpret_cast<const TensorValue*>(
               &_TensorValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(TensorValue* other);

  // implements Message ----------------------------------------------

  inline TensorValue* New() const PROTOBUF_FINAL { return New(NULL); }

  TensorValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TensorValue& from);
  void MergeFrom(const TensorValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TensorValue_RepeatedFloats RepeatedFloats;
  typedef TensorValue_RepeatedDoubles RepeatedDoubles;
  typedef TensorValue_RepeatedInts RepeatedInts;
  typedef TensorValue_RepeatedLongInts RepeatedLongInts;
  typedef TensorValue_RepeatedBools RepeatedBools;
  typedef TensorValue_RepeatedStrings RepeatedStrings;
  typedef TensorValue_RepeatedBytes RepeatedBytes;

  // accessors -------------------------------------------------------

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedFloats floats = 1;
  bool has_floats() const;
  void clear_floats();
  static const int kFloatsFieldNumber = 1;
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats& floats() const;
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* mutable_floats();
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* release_floats();
  void set_allocated_floats(::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* floats);

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedInts ints = 2;
  bool has_ints() const;
  void clear_ints();
  static const int kIntsFieldNumber = 2;
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts& ints() const;
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* mutable_ints();
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* release_ints();
  void set_allocated_ints(::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* ints);

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedBools bools = 3;
  bool has_bools() const;
  void clear_bools();
  static const int kBoolsFieldNumber = 3;
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools& bools() const;
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* mutable_bools();
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* release_bools();
  void set_allocated_bools(::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* bools);

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedStrings strings = 4;
  bool has_strings() const;
  void clear_strings();
  static const int kStringsFieldNumber = 4;
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings& strings() const;
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* mutable_strings();
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* release_strings();
  void set_allocated_strings(::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* strings);

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts longInts = 5;
  bool has_longints() const;
  void clear_longints();
  static const int kLongIntsFieldNumber = 5;
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts& longints() const;
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* mutable_longints();
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* release_longints();
  void set_allocated_longints(::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* longints);

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles doubles = 6;
  bool has_doubles() const;
  void clear_doubles();
  static const int kDoublesFieldNumber = 6;
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles& doubles() const;
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* mutable_doubles();
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* release_doubles();
  void set_allocated_doubles(::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* doubles);

  // .CoreML.Specification.MILSpec.TensorValue.RepeatedBytes bytes = 7;
  bool has_bytes() const;
  void clear_bytes();
  static const int kBytesFieldNumber = 7;
  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes& bytes() const;
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* mutable_bytes();
  ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* release_bytes();
  void set_allocated_bytes(::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* bytes);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TensorValue)
 private:
  void set_has_floats();
  void set_has_ints();
  void set_has_bools();
  void set_has_strings();
  void set_has_longints();
  void set_has_doubles();
  void set_has_bytes();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* floats_;
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* ints_;
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* bools_;
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* strings_;
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* longints_;
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* doubles_;
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* bytes_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TupleValue : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.TupleValue) */ {
 public:
  TupleValue();
  virtual ~TupleValue();

  TupleValue(const TupleValue& from);

  inline TupleValue& operator=(const TupleValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const TupleValue& default_instance();

  static inline const TupleValue* internal_default_instance() {
    return reinterpret_cast<const TupleValue*>(
               &_TupleValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(TupleValue* other);

  // implements Message ----------------------------------------------

  inline TupleValue* New() const PROTOBUF_FINAL { return New(NULL); }

  TupleValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TupleValue& from);
  void MergeFrom(const TupleValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TupleValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.MILSpec.Value values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  const ::CoreML::Specification::MILSpec::Value& values(int index) const;
  ::CoreML::Specification::MILSpec::Value* mutable_values(int index);
  ::CoreML::Specification::MILSpec::Value* add_values();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value >*
      mutable_values();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value >&
      values() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.TupleValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value > values_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListValue : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.ListValue) */ {
 public:
  ListValue();
  virtual ~ListValue();

  ListValue(const ListValue& from);

  inline ListValue& operator=(const ListValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const ListValue& default_instance();

  static inline const ListValue* internal_default_instance() {
    return reinterpret_cast<const ListValue*>(
               &_ListValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(ListValue* other);

  // implements Message ----------------------------------------------

  inline ListValue* New() const PROTOBUF_FINAL { return New(NULL); }

  ListValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ListValue& from);
  void MergeFrom(const ListValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.MILSpec.Value values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  const ::CoreML::Specification::MILSpec::Value& values(int index) const;
  ::CoreML::Specification::MILSpec::Value* mutable_values(int index);
  ::CoreML::Specification::MILSpec::Value* add_values();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value >*
      mutable_values();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value >&
      values() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.ListValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value > values_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DictionaryValue_KeyValuePair : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair) */ {
 public:
  DictionaryValue_KeyValuePair();
  virtual ~DictionaryValue_KeyValuePair();

  DictionaryValue_KeyValuePair(const DictionaryValue_KeyValuePair& from);

  inline DictionaryValue_KeyValuePair& operator=(const DictionaryValue_KeyValuePair& from) {
    CopyFrom(from);
    return *this;
  }

  static const DictionaryValue_KeyValuePair& default_instance();

  static inline const DictionaryValue_KeyValuePair* internal_default_instance() {
    return reinterpret_cast<const DictionaryValue_KeyValuePair*>(
               &_DictionaryValue_KeyValuePair_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(DictionaryValue_KeyValuePair* other);

  // implements Message ----------------------------------------------

  inline DictionaryValue_KeyValuePair* New() const PROTOBUF_FINAL { return New(NULL); }

  DictionaryValue_KeyValuePair* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DictionaryValue_KeyValuePair& from);
  void MergeFrom(const DictionaryValue_KeyValuePair& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DictionaryValue_KeyValuePair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.MILSpec.Value key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::CoreML::Specification::MILSpec::Value& key() const;
  ::CoreML::Specification::MILSpec::Value* mutable_key();
  ::CoreML::Specification::MILSpec::Value* release_key();
  void set_allocated_key(::CoreML::Specification::MILSpec::Value* key);

  // .CoreML.Specification.MILSpec.Value value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::CoreML::Specification::MILSpec::Value& value() const;
  ::CoreML::Specification::MILSpec::Value* mutable_value();
  ::CoreML::Specification::MILSpec::Value* release_value();
  void set_allocated_value(::CoreML::Specification::MILSpec::Value* value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::CoreML::Specification::MILSpec::Value* key_;
  ::CoreML::Specification::MILSpec::Value* value_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DictionaryValue : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MILSpec.DictionaryValue) */ {
 public:
  DictionaryValue();
  virtual ~DictionaryValue();

  DictionaryValue(const DictionaryValue& from);

  inline DictionaryValue& operator=(const DictionaryValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const DictionaryValue& default_instance();

  static inline const DictionaryValue* internal_default_instance() {
    return reinterpret_cast<const DictionaryValue*>(
               &_DictionaryValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(DictionaryValue* other);

  // implements Message ----------------------------------------------

  inline DictionaryValue* New() const PROTOBUF_FINAL { return New(NULL); }

  DictionaryValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DictionaryValue& from);
  void MergeFrom(const DictionaryValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DictionaryValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DictionaryValue_KeyValuePair KeyValuePair;

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  const ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair& values(int index) const;
  ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair* mutable_values(int index);
  ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair* add_values();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair >*
      mutable_values();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair >&
      values() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MILSpec.DictionaryValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair > values_;
  mutable int _cached_size_;
  friend struct protobuf_MIL_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Program

// int64 version = 1;
inline void Program::clear_version() {
  version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Program::version() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Program.version)
  return version_;
}
inline void Program::set_version(::google::protobuf::int64 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Program.version)
}

// map<string, .CoreML.Specification.MILSpec.Function> functions = 2;
inline int Program::functions_size() const {
  return functions_.size();
}
inline void Program::clear_functions() {
  functions_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Function >&
Program::functions() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.MILSpec.Program.functions)
  return functions_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Function >*
Program::mutable_functions() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.MILSpec.Program.functions)
  return functions_.MutableMap();
}

// string docString = 3;
inline void Program::clear_docstring() {
  docstring_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Program::docstring() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Program.docString)
  return docstring_.GetNoArena();
}
inline void Program::set_docstring(const ::std::string& value) {
  
  docstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Program.docString)
}
#if LANG_CXX11
inline void Program::set_docstring(::std::string&& value) {
  
  docstring_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.MILSpec.Program.docString)
}
#endif
inline void Program::set_docstring(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  docstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.MILSpec.Program.docString)
}
inline void Program::set_docstring(const char* value, size_t size) {
  
  docstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.MILSpec.Program.docString)
}
inline ::std::string* Program::mutable_docstring() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Program.docString)
  return docstring_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Program::release_docstring() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Program.docString)
  
  return docstring_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Program::set_allocated_docstring(::std::string* docstring) {
  if (docstring != NULL) {
    
  } else {
    
  }
  docstring_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), docstring);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Program.docString)
}

// map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
inline int Program::attributes_size() const {
  return attributes_.size();
}
inline void Program::clear_attributes() {
  attributes_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >&
Program::attributes() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.MILSpec.Program.attributes)
  return attributes_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >*
Program::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.MILSpec.Program.attributes)
  return attributes_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Function

// repeated .CoreML.Specification.MILSpec.NamedValueType inputs = 1;
inline int Function::inputs_size() const {
  return inputs_.size();
}
inline void Function::clear_inputs() {
  inputs_.Clear();
}
inline const ::CoreML::Specification::MILSpec::NamedValueType& Function::inputs(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Function.inputs)
  return inputs_.Get(index);
}
inline ::CoreML::Specification::MILSpec::NamedValueType* Function::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Function.inputs)
  return inputs_.Mutable(index);
}
inline ::CoreML::Specification::MILSpec::NamedValueType* Function::add_inputs() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.Function.inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >*
Function::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.Function.inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >&
Function::inputs() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.Function.inputs)
  return inputs_;
}

// string opset = 2;
inline void Function::clear_opset() {
  opset_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Function::opset() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Function.opset)
  return opset_.GetNoArena();
}
inline void Function::set_opset(const ::std::string& value) {
  
  opset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Function.opset)
}
#if LANG_CXX11
inline void Function::set_opset(::std::string&& value) {
  
  opset_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.MILSpec.Function.opset)
}
#endif
inline void Function::set_opset(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  opset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.MILSpec.Function.opset)
}
inline void Function::set_opset(const char* value, size_t size) {
  
  opset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.MILSpec.Function.opset)
}
inline ::std::string* Function::mutable_opset() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Function.opset)
  return opset_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Function::release_opset() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Function.opset)
  
  return opset_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Function::set_allocated_opset(::std::string* opset) {
  if (opset != NULL) {
    
  } else {
    
  }
  opset_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), opset);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Function.opset)
}

// map<string, .CoreML.Specification.MILSpec.Block> block_specializations = 3;
inline int Function::block_specializations_size() const {
  return block_specializations_.size();
}
inline void Function::clear_block_specializations() {
  block_specializations_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Block >&
Function::block_specializations() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.MILSpec.Function.block_specializations)
  return block_specializations_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Block >*
Function::mutable_block_specializations() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.MILSpec.Function.block_specializations)
  return block_specializations_.MutableMap();
}

// map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
inline int Function::attributes_size() const {
  return attributes_.size();
}
inline void Function::clear_attributes() {
  attributes_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >&
Function::attributes() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.MILSpec.Function.attributes)
  return attributes_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >*
Function::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.MILSpec.Function.attributes)
  return attributes_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Block

// repeated .CoreML.Specification.MILSpec.NamedValueType inputs = 1;
inline int Block::inputs_size() const {
  return inputs_.size();
}
inline void Block::clear_inputs() {
  inputs_.Clear();
}
inline const ::CoreML::Specification::MILSpec::NamedValueType& Block::inputs(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Block.inputs)
  return inputs_.Get(index);
}
inline ::CoreML::Specification::MILSpec::NamedValueType* Block::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Block.inputs)
  return inputs_.Mutable(index);
}
inline ::CoreML::Specification::MILSpec::NamedValueType* Block::add_inputs() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.Block.inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >*
Block::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.Block.inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >&
Block::inputs() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.Block.inputs)
  return inputs_;
}

// repeated string outputs = 2;
inline int Block::outputs_size() const {
  return outputs_.size();
}
inline void Block::clear_outputs() {
  outputs_.Clear();
}
inline const ::std::string& Block::outputs(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Block.outputs)
  return outputs_.Get(index);
}
inline ::std::string* Block::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Block.outputs)
  return outputs_.Mutable(index);
}
inline void Block::set_outputs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Block.outputs)
  outputs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Block::set_outputs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Block.outputs)
  outputs_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Block::set_outputs(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  outputs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.MILSpec.Block.outputs)
}
inline void Block::set_outputs(int index, const char* value, size_t size) {
  outputs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.MILSpec.Block.outputs)
}
inline ::std::string* Block::add_outputs() {
  // @@protoc_insertion_point(field_add_mutable:CoreML.Specification.MILSpec.Block.outputs)
  return outputs_.Add();
}
inline void Block::add_outputs(const ::std::string& value) {
  outputs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.Block.outputs)
}
#if LANG_CXX11
inline void Block::add_outputs(::std::string&& value) {
  outputs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.Block.outputs)
}
#endif
inline void Block::add_outputs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  outputs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CoreML.Specification.MILSpec.Block.outputs)
}
inline void Block::add_outputs(const char* value, size_t size) {
  outputs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CoreML.Specification.MILSpec.Block.outputs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Block::outputs() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.Block.outputs)
  return outputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Block::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.Block.outputs)
  return &outputs_;
}

// repeated .CoreML.Specification.MILSpec.Operation operations = 3;
inline int Block::operations_size() const {
  return operations_.size();
}
inline void Block::clear_operations() {
  operations_.Clear();
}
inline const ::CoreML::Specification::MILSpec::Operation& Block::operations(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Block.operations)
  return operations_.Get(index);
}
inline ::CoreML::Specification::MILSpec::Operation* Block::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Block.operations)
  return operations_.Mutable(index);
}
inline ::CoreML::Specification::MILSpec::Operation* Block::add_operations() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.Block.operations)
  return operations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Operation >*
Block::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.Block.operations)
  return &operations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Operation >&
Block::operations() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.Block.operations)
  return operations_;
}

// map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
inline int Block::attributes_size() const {
  return attributes_.size();
}
inline void Block::clear_attributes() {
  attributes_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >&
Block::attributes() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.MILSpec.Block.attributes)
  return attributes_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >*
Block::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.MILSpec.Block.attributes)
  return attributes_.MutableMap();
}

// -------------------------------------------------------------------

// Argument_Binding

// string name = 1;
inline bool Argument_Binding::has_name() const {
  return binding_case() == kName;
}
inline void Argument_Binding::set_has_name() {
  _oneof_case_[0] = kName;
}
inline void Argument_Binding::clear_name() {
  if (has_name()) {
    binding_.name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_binding();
  }
}
inline const ::std::string& Argument_Binding::name() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Argument.Binding.name)
  if (has_name()) {
    return binding_.name_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Argument_Binding::set_name(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Argument.Binding.name)
  if (!has_name()) {
    clear_binding();
    set_has_name();
    binding_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  binding_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Argument.Binding.name)
}
#if LANG_CXX11
inline void Argument_Binding::set_name(::std::string&& value) {
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Argument.Binding.name)
  if (!has_name()) {
    clear_binding();
    set_has_name();
    binding_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  binding_.name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.MILSpec.Argument.Binding.name)
}
#endif
inline void Argument_Binding::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_name()) {
    clear_binding();
    set_has_name();
    binding_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  binding_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.MILSpec.Argument.Binding.name)
}
inline void Argument_Binding::set_name(const char* value, size_t size) {
  if (!has_name()) {
    clear_binding();
    set_has_name();
    binding_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  binding_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.MILSpec.Argument.Binding.name)
}
inline ::std::string* Argument_Binding::mutable_name() {
  if (!has_name()) {
    clear_binding();
    set_has_name();
    binding_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Argument.Binding.name)
  return binding_.name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Argument_Binding::release_name() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Argument.Binding.name)
  if (has_name()) {
    clear_has_binding();
    return binding_.name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Argument_Binding::set_allocated_name(::std::string* name) {
  if (!has_name()) {
    binding_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_binding();
  if (name != NULL) {
    set_has_name();
    binding_.name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        name);
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Argument.Binding.name)
}

// .CoreML.Specification.MILSpec.Value value = 2;
inline bool Argument_Binding::has_value() const {
  return binding_case() == kValue;
}
inline void Argument_Binding::set_has_value() {
  _oneof_case_[0] = kValue;
}
inline void Argument_Binding::clear_value() {
  if (has_value()) {
    delete binding_.value_;
    clear_has_binding();
  }
}
inline  const ::CoreML::Specification::MILSpec::Value& Argument_Binding::value() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Argument.Binding.value)
  return has_value()
      ? *binding_.value_
      : ::CoreML::Specification::MILSpec::Value::default_instance();
}
inline ::CoreML::Specification::MILSpec::Value* Argument_Binding::mutable_value() {
  if (!has_value()) {
    clear_binding();
    set_has_value();
    binding_.value_ = new ::CoreML::Specification::MILSpec::Value;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Argument.Binding.value)
  return binding_.value_;
}
inline ::CoreML::Specification::MILSpec::Value* Argument_Binding::release_value() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Argument.Binding.value)
  if (has_value()) {
    clear_has_binding();
    ::CoreML::Specification::MILSpec::Value* temp = binding_.value_;
    binding_.value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Argument_Binding::set_allocated_value(::CoreML::Specification::MILSpec::Value* value) {
  clear_binding();
  if (value) {
    set_has_value();
    binding_.value_ = value;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Argument.Binding.value)
}

inline bool Argument_Binding::has_binding() const {
  return binding_case() != BINDING_NOT_SET;
}
inline void Argument_Binding::clear_has_binding() {
  _oneof_case_[0] = BINDING_NOT_SET;
}
inline Argument_Binding::BindingCase Argument_Binding::binding_case() const {
  return Argument_Binding::BindingCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Argument

// repeated .CoreML.Specification.MILSpec.Argument.Binding arguments = 1;
inline int Argument::arguments_size() const {
  return arguments_.size();
}
inline void Argument::clear_arguments() {
  arguments_.Clear();
}
inline const ::CoreML::Specification::MILSpec::Argument_Binding& Argument::arguments(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Argument.arguments)
  return arguments_.Get(index);
}
inline ::CoreML::Specification::MILSpec::Argument_Binding* Argument::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Argument.arguments)
  return arguments_.Mutable(index);
}
inline ::CoreML::Specification::MILSpec::Argument_Binding* Argument::add_arguments() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.Argument.arguments)
  return arguments_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Argument_Binding >*
Argument::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.Argument.arguments)
  return &arguments_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Argument_Binding >&
Argument::arguments() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.Argument.arguments)
  return arguments_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Operation

// string type = 1;
inline void Operation::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Operation::type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Operation.type)
  return type_.GetNoArena();
}
inline void Operation::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Operation.type)
}
#if LANG_CXX11
inline void Operation::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.MILSpec.Operation.type)
}
#endif
inline void Operation::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.MILSpec.Operation.type)
}
inline void Operation::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.MILSpec.Operation.type)
}
inline ::std::string* Operation::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Operation.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Operation::release_type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Operation.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Operation::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Operation.type)
}

// map<string, .CoreML.Specification.MILSpec.Argument> inputs = 2;
inline int Operation::inputs_size() const {
  return inputs_.size();
}
inline void Operation::clear_inputs() {
  inputs_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Argument >&
Operation::inputs() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.MILSpec.Operation.inputs)
  return inputs_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Argument >*
Operation::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.MILSpec.Operation.inputs)
  return inputs_.MutableMap();
}

// repeated .CoreML.Specification.MILSpec.NamedValueType outputs = 3;
inline int Operation::outputs_size() const {
  return outputs_.size();
}
inline void Operation::clear_outputs() {
  outputs_.Clear();
}
inline const ::CoreML::Specification::MILSpec::NamedValueType& Operation::outputs(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Operation.outputs)
  return outputs_.Get(index);
}
inline ::CoreML::Specification::MILSpec::NamedValueType* Operation::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Operation.outputs)
  return outputs_.Mutable(index);
}
inline ::CoreML::Specification::MILSpec::NamedValueType* Operation::add_outputs() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.Operation.outputs)
  return outputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >*
Operation::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.Operation.outputs)
  return &outputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::NamedValueType >&
Operation::outputs() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.Operation.outputs)
  return outputs_;
}

// repeated .CoreML.Specification.MILSpec.Block blocks = 4;
inline int Operation::blocks_size() const {
  return blocks_.size();
}
inline void Operation::clear_blocks() {
  blocks_.Clear();
}
inline const ::CoreML::Specification::MILSpec::Block& Operation::blocks(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Operation.blocks)
  return blocks_.Get(index);
}
inline ::CoreML::Specification::MILSpec::Block* Operation::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Operation.blocks)
  return blocks_.Mutable(index);
}
inline ::CoreML::Specification::MILSpec::Block* Operation::add_blocks() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.Operation.blocks)
  return blocks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Block >*
Operation::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.Operation.blocks)
  return &blocks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Block >&
Operation::blocks() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.Operation.blocks)
  return blocks_;
}

// map<string, .CoreML.Specification.MILSpec.Value> attributes = 5;
inline int Operation::attributes_size() const {
  return attributes_.size();
}
inline void Operation::clear_attributes() {
  attributes_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >&
Operation::attributes() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.MILSpec.Operation.attributes)
  return attributes_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >*
Operation::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.MILSpec.Operation.attributes)
  return attributes_.MutableMap();
}

// -------------------------------------------------------------------

// NamedValueType

// string name = 1;
inline void NamedValueType::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NamedValueType::name() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.NamedValueType.name)
  return name_.GetNoArena();
}
inline void NamedValueType::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.NamedValueType.name)
}
#if LANG_CXX11
inline void NamedValueType::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.MILSpec.NamedValueType.name)
}
#endif
inline void NamedValueType::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.MILSpec.NamedValueType.name)
}
inline void NamedValueType::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.MILSpec.NamedValueType.name)
}
inline ::std::string* NamedValueType::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.NamedValueType.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NamedValueType::release_name() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.NamedValueType.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NamedValueType::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.NamedValueType.name)
}

// .CoreML.Specification.MILSpec.ValueType type = 2;
inline bool NamedValueType::has_type() const {
  return this != internal_default_instance() && type_ != NULL;
}
inline void NamedValueType::clear_type() {
  if (GetArenaNoVirtual() == NULL && type_ != NULL) delete type_;
  type_ = NULL;
}
inline const ::CoreML::Specification::MILSpec::ValueType& NamedValueType::type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.NamedValueType.type)
  return type_ != NULL ? *type_
                         : *::CoreML::Specification::MILSpec::ValueType::internal_default_instance();
}
inline ::CoreML::Specification::MILSpec::ValueType* NamedValueType::mutable_type() {
  
  if (type_ == NULL) {
    type_ = new ::CoreML::Specification::MILSpec::ValueType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.NamedValueType.type)
  return type_;
}
inline ::CoreML::Specification::MILSpec::ValueType* NamedValueType::release_type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.NamedValueType.type)
  
  ::CoreML::Specification::MILSpec::ValueType* temp = type_;
  type_ = NULL;
  return temp;
}
inline void NamedValueType::set_allocated_type(::CoreML::Specification::MILSpec::ValueType* type) {
  delete type_;
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.NamedValueType.type)
}

// -------------------------------------------------------------------

// ValueType

// .CoreML.Specification.MILSpec.TensorType tensorType = 1;
inline bool ValueType::has_tensortype() const {
  return type_case() == kTensorType;
}
inline void ValueType::set_has_tensortype() {
  _oneof_case_[0] = kTensorType;
}
inline void ValueType::clear_tensortype() {
  if (has_tensortype()) {
    delete type_.tensortype_;
    clear_has_type();
  }
}
inline  const ::CoreML::Specification::MILSpec::TensorType& ValueType::tensortype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.ValueType.tensorType)
  return has_tensortype()
      ? *type_.tensortype_
      : ::CoreML::Specification::MILSpec::TensorType::default_instance();
}
inline ::CoreML::Specification::MILSpec::TensorType* ValueType::mutable_tensortype() {
  if (!has_tensortype()) {
    clear_type();
    set_has_tensortype();
    type_.tensortype_ = new ::CoreML::Specification::MILSpec::TensorType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.ValueType.tensorType)
  return type_.tensortype_;
}
inline ::CoreML::Specification::MILSpec::TensorType* ValueType::release_tensortype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.ValueType.tensorType)
  if (has_tensortype()) {
    clear_has_type();
    ::CoreML::Specification::MILSpec::TensorType* temp = type_.tensortype_;
    type_.tensortype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ValueType::set_allocated_tensortype(::CoreML::Specification::MILSpec::TensorType* tensortype) {
  clear_type();
  if (tensortype) {
    set_has_tensortype();
    type_.tensortype_ = tensortype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.ValueType.tensorType)
}

// .CoreML.Specification.MILSpec.ListType listType = 2;
inline bool ValueType::has_listtype() const {
  return type_case() == kListType;
}
inline void ValueType::set_has_listtype() {
  _oneof_case_[0] = kListType;
}
inline void ValueType::clear_listtype() {
  if (has_listtype()) {
    delete type_.listtype_;
    clear_has_type();
  }
}
inline  const ::CoreML::Specification::MILSpec::ListType& ValueType::listtype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.ValueType.listType)
  return has_listtype()
      ? *type_.listtype_
      : ::CoreML::Specification::MILSpec::ListType::default_instance();
}
inline ::CoreML::Specification::MILSpec::ListType* ValueType::mutable_listtype() {
  if (!has_listtype()) {
    clear_type();
    set_has_listtype();
    type_.listtype_ = new ::CoreML::Specification::MILSpec::ListType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.ValueType.listType)
  return type_.listtype_;
}
inline ::CoreML::Specification::MILSpec::ListType* ValueType::release_listtype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.ValueType.listType)
  if (has_listtype()) {
    clear_has_type();
    ::CoreML::Specification::MILSpec::ListType* temp = type_.listtype_;
    type_.listtype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ValueType::set_allocated_listtype(::CoreML::Specification::MILSpec::ListType* listtype) {
  clear_type();
  if (listtype) {
    set_has_listtype();
    type_.listtype_ = listtype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.ValueType.listType)
}

// .CoreML.Specification.MILSpec.TupleType tupleType = 3;
inline bool ValueType::has_tupletype() const {
  return type_case() == kTupleType;
}
inline void ValueType::set_has_tupletype() {
  _oneof_case_[0] = kTupleType;
}
inline void ValueType::clear_tupletype() {
  if (has_tupletype()) {
    delete type_.tupletype_;
    clear_has_type();
  }
}
inline  const ::CoreML::Specification::MILSpec::TupleType& ValueType::tupletype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.ValueType.tupleType)
  return has_tupletype()
      ? *type_.tupletype_
      : ::CoreML::Specification::MILSpec::TupleType::default_instance();
}
inline ::CoreML::Specification::MILSpec::TupleType* ValueType::mutable_tupletype() {
  if (!has_tupletype()) {
    clear_type();
    set_has_tupletype();
    type_.tupletype_ = new ::CoreML::Specification::MILSpec::TupleType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.ValueType.tupleType)
  return type_.tupletype_;
}
inline ::CoreML::Specification::MILSpec::TupleType* ValueType::release_tupletype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.ValueType.tupleType)
  if (has_tupletype()) {
    clear_has_type();
    ::CoreML::Specification::MILSpec::TupleType* temp = type_.tupletype_;
    type_.tupletype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ValueType::set_allocated_tupletype(::CoreML::Specification::MILSpec::TupleType* tupletype) {
  clear_type();
  if (tupletype) {
    set_has_tupletype();
    type_.tupletype_ = tupletype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.ValueType.tupleType)
}

// .CoreML.Specification.MILSpec.DictionaryType dictionaryType = 4;
inline bool ValueType::has_dictionarytype() const {
  return type_case() == kDictionaryType;
}
inline void ValueType::set_has_dictionarytype() {
  _oneof_case_[0] = kDictionaryType;
}
inline void ValueType::clear_dictionarytype() {
  if (has_dictionarytype()) {
    delete type_.dictionarytype_;
    clear_has_type();
  }
}
inline  const ::CoreML::Specification::MILSpec::DictionaryType& ValueType::dictionarytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.ValueType.dictionaryType)
  return has_dictionarytype()
      ? *type_.dictionarytype_
      : ::CoreML::Specification::MILSpec::DictionaryType::default_instance();
}
inline ::CoreML::Specification::MILSpec::DictionaryType* ValueType::mutable_dictionarytype() {
  if (!has_dictionarytype()) {
    clear_type();
    set_has_dictionarytype();
    type_.dictionarytype_ = new ::CoreML::Specification::MILSpec::DictionaryType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.ValueType.dictionaryType)
  return type_.dictionarytype_;
}
inline ::CoreML::Specification::MILSpec::DictionaryType* ValueType::release_dictionarytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.ValueType.dictionaryType)
  if (has_dictionarytype()) {
    clear_has_type();
    ::CoreML::Specification::MILSpec::DictionaryType* temp = type_.dictionarytype_;
    type_.dictionarytype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ValueType::set_allocated_dictionarytype(::CoreML::Specification::MILSpec::DictionaryType* dictionarytype) {
  clear_type();
  if (dictionarytype) {
    set_has_dictionarytype();
    type_.dictionarytype_ = dictionarytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.ValueType.dictionaryType)
}

inline bool ValueType::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void ValueType::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline ValueType::TypeCase ValueType::type_case() const {
  return ValueType::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TensorType

// .CoreML.Specification.MILSpec.DataType dataType = 1;
inline void TensorType::clear_datatype() {
  datatype_ = 0;
}
inline ::CoreML::Specification::MILSpec::DataType TensorType::datatype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorType.dataType)
  return static_cast< ::CoreML::Specification::MILSpec::DataType >(datatype_);
}
inline void TensorType::set_datatype(::CoreML::Specification::MILSpec::DataType value) {
  
  datatype_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorType.dataType)
}

// int64 rank = 2;
inline void TensorType::clear_rank() {
  rank_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TensorType::rank() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorType.rank)
  return rank_;
}
inline void TensorType::set_rank(::google::protobuf::int64 value) {
  
  rank_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorType.rank)
}

// repeated .CoreML.Specification.MILSpec.Dimension dimensions = 3;
inline int TensorType::dimensions_size() const {
  return dimensions_.size();
}
inline void TensorType::clear_dimensions() {
  dimensions_.Clear();
}
inline const ::CoreML::Specification::MILSpec::Dimension& TensorType::dimensions(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorType.dimensions)
  return dimensions_.Get(index);
}
inline ::CoreML::Specification::MILSpec::Dimension* TensorType::mutable_dimensions(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorType.dimensions)
  return dimensions_.Mutable(index);
}
inline ::CoreML::Specification::MILSpec::Dimension* TensorType::add_dimensions() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TensorType.dimensions)
  return dimensions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Dimension >*
TensorType::mutable_dimensions() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.TensorType.dimensions)
  return &dimensions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Dimension >&
TensorType::dimensions() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.TensorType.dimensions)
  return dimensions_;
}

// map<string, .CoreML.Specification.MILSpec.Value> attributes = 4;
inline int TensorType::attributes_size() const {
  return attributes_.size();
}
inline void TensorType::clear_attributes() {
  attributes_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >&
TensorType::attributes() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.MILSpec.TensorType.attributes)
  return attributes_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::CoreML::Specification::MILSpec::Value >*
TensorType::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.MILSpec.TensorType.attributes)
  return attributes_.MutableMap();
}

// -------------------------------------------------------------------

// TupleType

// repeated .CoreML.Specification.MILSpec.ValueType types = 1;
inline int TupleType::types_size() const {
  return types_.size();
}
inline void TupleType::clear_types() {
  types_.Clear();
}
inline const ::CoreML::Specification::MILSpec::ValueType& TupleType::types(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TupleType.types)
  return types_.Get(index);
}
inline ::CoreML::Specification::MILSpec::ValueType* TupleType::mutable_types(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TupleType.types)
  return types_.Mutable(index);
}
inline ::CoreML::Specification::MILSpec::ValueType* TupleType::add_types() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TupleType.types)
  return types_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::ValueType >*
TupleType::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.TupleType.types)
  return &types_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::ValueType >&
TupleType::types() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.TupleType.types)
  return types_;
}

// -------------------------------------------------------------------

// ListType

// .CoreML.Specification.MILSpec.ValueType type = 1;
inline bool ListType::has_type() const {
  return this != internal_default_instance() && type_ != NULL;
}
inline void ListType::clear_type() {
  if (GetArenaNoVirtual() == NULL && type_ != NULL) delete type_;
  type_ = NULL;
}
inline const ::CoreML::Specification::MILSpec::ValueType& ListType::type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.ListType.type)
  return type_ != NULL ? *type_
                         : *::CoreML::Specification::MILSpec::ValueType::internal_default_instance();
}
inline ::CoreML::Specification::MILSpec::ValueType* ListType::mutable_type() {
  
  if (type_ == NULL) {
    type_ = new ::CoreML::Specification::MILSpec::ValueType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.ListType.type)
  return type_;
}
inline ::CoreML::Specification::MILSpec::ValueType* ListType::release_type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.ListType.type)
  
  ::CoreML::Specification::MILSpec::ValueType* temp = type_;
  type_ = NULL;
  return temp;
}
inline void ListType::set_allocated_type(::CoreML::Specification::MILSpec::ValueType* type) {
  delete type_;
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.ListType.type)
}

// .CoreML.Specification.MILSpec.Dimension length = 2;
inline bool ListType::has_length() const {
  return this != internal_default_instance() && length_ != NULL;
}
inline void ListType::clear_length() {
  if (GetArenaNoVirtual() == NULL && length_ != NULL) delete length_;
  length_ = NULL;
}
inline const ::CoreML::Specification::MILSpec::Dimension& ListType::length() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.ListType.length)
  return length_ != NULL ? *length_
                         : *::CoreML::Specification::MILSpec::Dimension::internal_default_instance();
}
inline ::CoreML::Specification::MILSpec::Dimension* ListType::mutable_length() {
  
  if (length_ == NULL) {
    length_ = new ::CoreML::Specification::MILSpec::Dimension;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.ListType.length)
  return length_;
}
inline ::CoreML::Specification::MILSpec::Dimension* ListType::release_length() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.ListType.length)
  
  ::CoreML::Specification::MILSpec::Dimension* temp = length_;
  length_ = NULL;
  return temp;
}
inline void ListType::set_allocated_length(::CoreML::Specification::MILSpec::Dimension* length) {
  delete length_;
  length_ = length;
  if (length) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.ListType.length)
}

// -------------------------------------------------------------------

// DictionaryType

// .CoreML.Specification.MILSpec.ValueType keyType = 1;
inline bool DictionaryType::has_keytype() const {
  return this != internal_default_instance() && keytype_ != NULL;
}
inline void DictionaryType::clear_keytype() {
  if (GetArenaNoVirtual() == NULL && keytype_ != NULL) delete keytype_;
  keytype_ = NULL;
}
inline const ::CoreML::Specification::MILSpec::ValueType& DictionaryType::keytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.DictionaryType.keyType)
  return keytype_ != NULL ? *keytype_
                         : *::CoreML::Specification::MILSpec::ValueType::internal_default_instance();
}
inline ::CoreML::Specification::MILSpec::ValueType* DictionaryType::mutable_keytype() {
  
  if (keytype_ == NULL) {
    keytype_ = new ::CoreML::Specification::MILSpec::ValueType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.DictionaryType.keyType)
  return keytype_;
}
inline ::CoreML::Specification::MILSpec::ValueType* DictionaryType::release_keytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.DictionaryType.keyType)
  
  ::CoreML::Specification::MILSpec::ValueType* temp = keytype_;
  keytype_ = NULL;
  return temp;
}
inline void DictionaryType::set_allocated_keytype(::CoreML::Specification::MILSpec::ValueType* keytype) {
  delete keytype_;
  keytype_ = keytype;
  if (keytype) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.DictionaryType.keyType)
}

// .CoreML.Specification.MILSpec.ValueType valueType = 2;
inline bool DictionaryType::has_valuetype() const {
  return this != internal_default_instance() && valuetype_ != NULL;
}
inline void DictionaryType::clear_valuetype() {
  if (GetArenaNoVirtual() == NULL && valuetype_ != NULL) delete valuetype_;
  valuetype_ = NULL;
}
inline const ::CoreML::Specification::MILSpec::ValueType& DictionaryType::valuetype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.DictionaryType.valueType)
  return valuetype_ != NULL ? *valuetype_
                         : *::CoreML::Specification::MILSpec::ValueType::internal_default_instance();
}
inline ::CoreML::Specification::MILSpec::ValueType* DictionaryType::mutable_valuetype() {
  
  if (valuetype_ == NULL) {
    valuetype_ = new ::CoreML::Specification::MILSpec::ValueType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.DictionaryType.valueType)
  return valuetype_;
}
inline ::CoreML::Specification::MILSpec::ValueType* DictionaryType::release_valuetype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.DictionaryType.valueType)
  
  ::CoreML::Specification::MILSpec::ValueType* temp = valuetype_;
  valuetype_ = NULL;
  return temp;
}
inline void DictionaryType::set_allocated_valuetype(::CoreML::Specification::MILSpec::ValueType* valuetype) {
  delete valuetype_;
  valuetype_ = valuetype;
  if (valuetype) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.DictionaryType.valueType)
}

// -------------------------------------------------------------------

// Dimension_ConstantDimension

// uint64 size = 1;
inline void Dimension_ConstantDimension::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Dimension_ConstantDimension::size() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Dimension.ConstantDimension.size)
  return size_;
}
inline void Dimension_ConstantDimension::set_size(::google::protobuf::uint64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Dimension.ConstantDimension.size)
}

// -------------------------------------------------------------------

// Dimension_UnknownDimension

// bool variadic = 1;
inline void Dimension_UnknownDimension::clear_variadic() {
  variadic_ = false;
}
inline bool Dimension_UnknownDimension::variadic() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Dimension.UnknownDimension.variadic)
  return variadic_;
}
inline void Dimension_UnknownDimension::set_variadic(bool value) {
  
  variadic_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Dimension.UnknownDimension.variadic)
}

// -------------------------------------------------------------------

// Dimension

// .CoreML.Specification.MILSpec.Dimension.ConstantDimension constant = 1;
inline bool Dimension::has_constant() const {
  return dimension_case() == kConstant;
}
inline void Dimension::set_has_constant() {
  _oneof_case_[0] = kConstant;
}
inline void Dimension::clear_constant() {
  if (has_constant()) {
    delete dimension_.constant_;
    clear_has_dimension();
  }
}
inline  const ::CoreML::Specification::MILSpec::Dimension_ConstantDimension& Dimension::constant() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Dimension.constant)
  return has_constant()
      ? *dimension_.constant_
      : ::CoreML::Specification::MILSpec::Dimension_ConstantDimension::default_instance();
}
inline ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* Dimension::mutable_constant() {
  if (!has_constant()) {
    clear_dimension();
    set_has_constant();
    dimension_.constant_ = new ::CoreML::Specification::MILSpec::Dimension_ConstantDimension;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Dimension.constant)
  return dimension_.constant_;
}
inline ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* Dimension::release_constant() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Dimension.constant)
  if (has_constant()) {
    clear_has_dimension();
    ::CoreML::Specification::MILSpec::Dimension_ConstantDimension* temp = dimension_.constant_;
    dimension_.constant_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Dimension::set_allocated_constant(::CoreML::Specification::MILSpec::Dimension_ConstantDimension* constant) {
  clear_dimension();
  if (constant) {
    set_has_constant();
    dimension_.constant_ = constant;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Dimension.constant)
}

// .CoreML.Specification.MILSpec.Dimension.UnknownDimension unknown = 2;
inline bool Dimension::has_unknown() const {
  return dimension_case() == kUnknown;
}
inline void Dimension::set_has_unknown() {
  _oneof_case_[0] = kUnknown;
}
inline void Dimension::clear_unknown() {
  if (has_unknown()) {
    delete dimension_.unknown_;
    clear_has_dimension();
  }
}
inline  const ::CoreML::Specification::MILSpec::Dimension_UnknownDimension& Dimension::unknown() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Dimension.unknown)
  return has_unknown()
      ? *dimension_.unknown_
      : ::CoreML::Specification::MILSpec::Dimension_UnknownDimension::default_instance();
}
inline ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* Dimension::mutable_unknown() {
  if (!has_unknown()) {
    clear_dimension();
    set_has_unknown();
    dimension_.unknown_ = new ::CoreML::Specification::MILSpec::Dimension_UnknownDimension;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Dimension.unknown)
  return dimension_.unknown_;
}
inline ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* Dimension::release_unknown() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Dimension.unknown)
  if (has_unknown()) {
    clear_has_dimension();
    ::CoreML::Specification::MILSpec::Dimension_UnknownDimension* temp = dimension_.unknown_;
    dimension_.unknown_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Dimension::set_allocated_unknown(::CoreML::Specification::MILSpec::Dimension_UnknownDimension* unknown) {
  clear_dimension();
  if (unknown) {
    set_has_unknown();
    dimension_.unknown_ = unknown;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Dimension.unknown)
}

inline bool Dimension::has_dimension() const {
  return dimension_case() != DIMENSION_NOT_SET;
}
inline void Dimension::clear_has_dimension() {
  _oneof_case_[0] = DIMENSION_NOT_SET;
}
inline Dimension::DimensionCase Dimension::dimension_case() const {
  return Dimension::DimensionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Value_ImmediateValue

// .CoreML.Specification.MILSpec.TensorValue tensor = 1;
inline bool Value_ImmediateValue::has_tensor() const {
  return value_case() == kTensor;
}
inline void Value_ImmediateValue::set_has_tensor() {
  _oneof_case_[0] = kTensor;
}
inline void Value_ImmediateValue::clear_tensor() {
  if (has_tensor()) {
    delete value_.tensor_;
    clear_has_value();
  }
}
inline  const ::CoreML::Specification::MILSpec::TensorValue& Value_ImmediateValue::tensor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.ImmediateValue.tensor)
  return has_tensor()
      ? *value_.tensor_
      : ::CoreML::Specification::MILSpec::TensorValue::default_instance();
}
inline ::CoreML::Specification::MILSpec::TensorValue* Value_ImmediateValue::mutable_tensor() {
  if (!has_tensor()) {
    clear_value();
    set_has_tensor();
    value_.tensor_ = new ::CoreML::Specification::MILSpec::TensorValue;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Value.ImmediateValue.tensor)
  return value_.tensor_;
}
inline ::CoreML::Specification::MILSpec::TensorValue* Value_ImmediateValue::release_tensor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Value.ImmediateValue.tensor)
  if (has_tensor()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::TensorValue* temp = value_.tensor_;
    value_.tensor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Value_ImmediateValue::set_allocated_tensor(::CoreML::Specification::MILSpec::TensorValue* tensor) {
  clear_value();
  if (tensor) {
    set_has_tensor();
    value_.tensor_ = tensor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Value.ImmediateValue.tensor)
}

// .CoreML.Specification.MILSpec.TupleValue tuple = 2;
inline bool Value_ImmediateValue::has_tuple() const {
  return value_case() == kTuple;
}
inline void Value_ImmediateValue::set_has_tuple() {
  _oneof_case_[0] = kTuple;
}
inline void Value_ImmediateValue::clear_tuple() {
  if (has_tuple()) {
    delete value_.tuple_;
    clear_has_value();
  }
}
inline  const ::CoreML::Specification::MILSpec::TupleValue& Value_ImmediateValue::tuple() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.ImmediateValue.tuple)
  return has_tuple()
      ? *value_.tuple_
      : ::CoreML::Specification::MILSpec::TupleValue::default_instance();
}
inline ::CoreML::Specification::MILSpec::TupleValue* Value_ImmediateValue::mutable_tuple() {
  if (!has_tuple()) {
    clear_value();
    set_has_tuple();
    value_.tuple_ = new ::CoreML::Specification::MILSpec::TupleValue;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Value.ImmediateValue.tuple)
  return value_.tuple_;
}
inline ::CoreML::Specification::MILSpec::TupleValue* Value_ImmediateValue::release_tuple() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Value.ImmediateValue.tuple)
  if (has_tuple()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::TupleValue* temp = value_.tuple_;
    value_.tuple_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Value_ImmediateValue::set_allocated_tuple(::CoreML::Specification::MILSpec::TupleValue* tuple) {
  clear_value();
  if (tuple) {
    set_has_tuple();
    value_.tuple_ = tuple;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Value.ImmediateValue.tuple)
}

// .CoreML.Specification.MILSpec.ListValue list = 3;
inline bool Value_ImmediateValue::has_list() const {
  return value_case() == kList;
}
inline void Value_ImmediateValue::set_has_list() {
  _oneof_case_[0] = kList;
}
inline void Value_ImmediateValue::clear_list() {
  if (has_list()) {
    delete value_.list_;
    clear_has_value();
  }
}
inline  const ::CoreML::Specification::MILSpec::ListValue& Value_ImmediateValue::list() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.ImmediateValue.list)
  return has_list()
      ? *value_.list_
      : ::CoreML::Specification::MILSpec::ListValue::default_instance();
}
inline ::CoreML::Specification::MILSpec::ListValue* Value_ImmediateValue::mutable_list() {
  if (!has_list()) {
    clear_value();
    set_has_list();
    value_.list_ = new ::CoreML::Specification::MILSpec::ListValue;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Value.ImmediateValue.list)
  return value_.list_;
}
inline ::CoreML::Specification::MILSpec::ListValue* Value_ImmediateValue::release_list() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Value.ImmediateValue.list)
  if (has_list()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::ListValue* temp = value_.list_;
    value_.list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Value_ImmediateValue::set_allocated_list(::CoreML::Specification::MILSpec::ListValue* list) {
  clear_value();
  if (list) {
    set_has_list();
    value_.list_ = list;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Value.ImmediateValue.list)
}

// .CoreML.Specification.MILSpec.DictionaryValue dictionary = 4;
inline bool Value_ImmediateValue::has_dictionary() const {
  return value_case() == kDictionary;
}
inline void Value_ImmediateValue::set_has_dictionary() {
  _oneof_case_[0] = kDictionary;
}
inline void Value_ImmediateValue::clear_dictionary() {
  if (has_dictionary()) {
    delete value_.dictionary_;
    clear_has_value();
  }
}
inline  const ::CoreML::Specification::MILSpec::DictionaryValue& Value_ImmediateValue::dictionary() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.ImmediateValue.dictionary)
  return has_dictionary()
      ? *value_.dictionary_
      : ::CoreML::Specification::MILSpec::DictionaryValue::default_instance();
}
inline ::CoreML::Specification::MILSpec::DictionaryValue* Value_ImmediateValue::mutable_dictionary() {
  if (!has_dictionary()) {
    clear_value();
    set_has_dictionary();
    value_.dictionary_ = new ::CoreML::Specification::MILSpec::DictionaryValue;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Value.ImmediateValue.dictionary)
  return value_.dictionary_;
}
inline ::CoreML::Specification::MILSpec::DictionaryValue* Value_ImmediateValue::release_dictionary() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Value.ImmediateValue.dictionary)
  if (has_dictionary()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::DictionaryValue* temp = value_.dictionary_;
    value_.dictionary_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Value_ImmediateValue::set_allocated_dictionary(::CoreML::Specification::MILSpec::DictionaryValue* dictionary) {
  clear_value();
  if (dictionary) {
    set_has_dictionary();
    value_.dictionary_ = dictionary;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Value.ImmediateValue.dictionary)
}

inline bool Value_ImmediateValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Value_ImmediateValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Value_ImmediateValue::ValueCase Value_ImmediateValue::value_case() const {
  return Value_ImmediateValue::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Value_BlobFileValue

// string fileName = 1;
inline void Value_BlobFileValue::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Value_BlobFileValue::filename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.BlobFileValue.fileName)
  return filename_.GetNoArena();
}
inline void Value_BlobFileValue::set_filename(const ::std::string& value) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Value.BlobFileValue.fileName)
}
#if LANG_CXX11
inline void Value_BlobFileValue::set_filename(::std::string&& value) {
  
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.MILSpec.Value.BlobFileValue.fileName)
}
#endif
inline void Value_BlobFileValue::set_filename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.MILSpec.Value.BlobFileValue.fileName)
}
inline void Value_BlobFileValue::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.MILSpec.Value.BlobFileValue.fileName)
}
inline ::std::string* Value_BlobFileValue::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Value.BlobFileValue.fileName)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Value_BlobFileValue::release_filename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Value.BlobFileValue.fileName)
  
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Value_BlobFileValue::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Value.BlobFileValue.fileName)
}

// uint64 offset = 2;
inline void Value_BlobFileValue::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Value_BlobFileValue::offset() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.BlobFileValue.offset)
  return offset_;
}
inline void Value_BlobFileValue::set_offset(::google::protobuf::uint64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Value.BlobFileValue.offset)
}

// -------------------------------------------------------------------

// Value

// string docString = 1;
inline void Value::clear_docstring() {
  docstring_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Value::docstring() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.docString)
  return docstring_.GetNoArena();
}
inline void Value::set_docstring(const ::std::string& value) {
  
  docstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.Value.docString)
}
#if LANG_CXX11
inline void Value::set_docstring(::std::string&& value) {
  
  docstring_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.MILSpec.Value.docString)
}
#endif
inline void Value::set_docstring(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  docstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.MILSpec.Value.docString)
}
inline void Value::set_docstring(const char* value, size_t size) {
  
  docstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.MILSpec.Value.docString)
}
inline ::std::string* Value::mutable_docstring() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Value.docString)
  return docstring_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Value::release_docstring() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Value.docString)
  
  return docstring_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Value::set_allocated_docstring(::std::string* docstring) {
  if (docstring != NULL) {
    
  } else {
    
  }
  docstring_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), docstring);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Value.docString)
}

// .CoreML.Specification.MILSpec.ValueType type = 2;
inline bool Value::has_type() const {
  return this != internal_default_instance() && type_ != NULL;
}
inline void Value::clear_type() {
  if (GetArenaNoVirtual() == NULL && type_ != NULL) delete type_;
  type_ = NULL;
}
inline const ::CoreML::Specification::MILSpec::ValueType& Value::type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.type)
  return type_ != NULL ? *type_
                         : *::CoreML::Specification::MILSpec::ValueType::internal_default_instance();
}
inline ::CoreML::Specification::MILSpec::ValueType* Value::mutable_type() {
  
  if (type_ == NULL) {
    type_ = new ::CoreML::Specification::MILSpec::ValueType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Value.type)
  return type_;
}
inline ::CoreML::Specification::MILSpec::ValueType* Value::release_type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Value.type)
  
  ::CoreML::Specification::MILSpec::ValueType* temp = type_;
  type_ = NULL;
  return temp;
}
inline void Value::set_allocated_type(::CoreML::Specification::MILSpec::ValueType* type) {
  delete type_;
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Value.type)
}

// .CoreML.Specification.MILSpec.Value.ImmediateValue immediateValue = 3;
inline bool Value::has_immediatevalue() const {
  return value_case() == kImmediateValue;
}
inline void Value::set_has_immediatevalue() {
  _oneof_case_[0] = kImmediateValue;
}
inline void Value::clear_immediatevalue() {
  if (has_immediatevalue()) {
    delete value_.immediatevalue_;
    clear_has_value();
  }
}
inline  const ::CoreML::Specification::MILSpec::Value_ImmediateValue& Value::immediatevalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.immediateValue)
  return has_immediatevalue()
      ? *value_.immediatevalue_
      : ::CoreML::Specification::MILSpec::Value_ImmediateValue::default_instance();
}
inline ::CoreML::Specification::MILSpec::Value_ImmediateValue* Value::mutable_immediatevalue() {
  if (!has_immediatevalue()) {
    clear_value();
    set_has_immediatevalue();
    value_.immediatevalue_ = new ::CoreML::Specification::MILSpec::Value_ImmediateValue;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Value.immediateValue)
  return value_.immediatevalue_;
}
inline ::CoreML::Specification::MILSpec::Value_ImmediateValue* Value::release_immediatevalue() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Value.immediateValue)
  if (has_immediatevalue()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::Value_ImmediateValue* temp = value_.immediatevalue_;
    value_.immediatevalue_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Value::set_allocated_immediatevalue(::CoreML::Specification::MILSpec::Value_ImmediateValue* immediatevalue) {
  clear_value();
  if (immediatevalue) {
    set_has_immediatevalue();
    value_.immediatevalue_ = immediatevalue;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Value.immediateValue)
}

// .CoreML.Specification.MILSpec.Value.BlobFileValue blobFileValue = 5;
inline bool Value::has_blobfilevalue() const {
  return value_case() == kBlobFileValue;
}
inline void Value::set_has_blobfilevalue() {
  _oneof_case_[0] = kBlobFileValue;
}
inline void Value::clear_blobfilevalue() {
  if (has_blobfilevalue()) {
    delete value_.blobfilevalue_;
    clear_has_value();
  }
}
inline  const ::CoreML::Specification::MILSpec::Value_BlobFileValue& Value::blobfilevalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.Value.blobFileValue)
  return has_blobfilevalue()
      ? *value_.blobfilevalue_
      : ::CoreML::Specification::MILSpec::Value_BlobFileValue::default_instance();
}
inline ::CoreML::Specification::MILSpec::Value_BlobFileValue* Value::mutable_blobfilevalue() {
  if (!has_blobfilevalue()) {
    clear_value();
    set_has_blobfilevalue();
    value_.blobfilevalue_ = new ::CoreML::Specification::MILSpec::Value_BlobFileValue;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.Value.blobFileValue)
  return value_.blobfilevalue_;
}
inline ::CoreML::Specification::MILSpec::Value_BlobFileValue* Value::release_blobfilevalue() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.Value.blobFileValue)
  if (has_blobfilevalue()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::Value_BlobFileValue* temp = value_.blobfilevalue_;
    value_.blobfilevalue_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Value::set_allocated_blobfilevalue(::CoreML::Specification::MILSpec::Value_BlobFileValue* blobfilevalue) {
  clear_value();
  if (blobfilevalue) {
    set_has_blobfilevalue();
    value_.blobfilevalue_ = blobfilevalue;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.Value.blobFileValue)
}

inline bool Value::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Value::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Value::ValueCase Value::value_case() const {
  return Value::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TensorValue_RepeatedFloats

// repeated float values = 1 [packed = true];
inline int TensorValue_RepeatedFloats::values_size() const {
  return values_.size();
}
inline void TensorValue_RepeatedFloats::clear_values() {
  values_.Clear();
}
inline float TensorValue_RepeatedFloats::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats.values)
  return values_.Get(index);
}
inline void TensorValue_RepeatedFloats::set_values(int index, float value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats.values)
}
inline void TensorValue_RepeatedFloats::add_values(float value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats.values)
}
inline const ::google::protobuf::RepeatedField< float >&
TensorValue_RepeatedFloats::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< float >*
TensorValue_RepeatedFloats::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.TensorValue.RepeatedFloats.values)
  return &values_;
}

// -------------------------------------------------------------------

// TensorValue_RepeatedDoubles

// repeated double values = 1 [packed = true];
inline int TensorValue_RepeatedDoubles::values_size() const {
  return values_.size();
}
inline void TensorValue_RepeatedDoubles::clear_values() {
  values_.Clear();
}
inline double TensorValue_RepeatedDoubles::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles.values)
  return values_.Get(index);
}
inline void TensorValue_RepeatedDoubles::set_values(int index, double value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles.values)
}
inline void TensorValue_RepeatedDoubles::add_values(double value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles.values)
}
inline const ::google::protobuf::RepeatedField< double >&
TensorValue_RepeatedDoubles::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< double >*
TensorValue_RepeatedDoubles::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles.values)
  return &values_;
}

// -------------------------------------------------------------------

// TensorValue_RepeatedInts

// repeated int32 values = 1 [packed = true];
inline int TensorValue_RepeatedInts::values_size() const {
  return values_.size();
}
inline void TensorValue_RepeatedInts::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::int32 TensorValue_RepeatedInts::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.RepeatedInts.values)
  return values_.Get(index);
}
inline void TensorValue_RepeatedInts::set_values(int index, ::google::protobuf::int32 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorValue.RepeatedInts.values)
}
inline void TensorValue_RepeatedInts::add_values(::google::protobuf::int32 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TensorValue.RepeatedInts.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TensorValue_RepeatedInts::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.TensorValue.RepeatedInts.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TensorValue_RepeatedInts::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.TensorValue.RepeatedInts.values)
  return &values_;
}

// -------------------------------------------------------------------

// TensorValue_RepeatedLongInts

// repeated int64 values = 1 [packed = true];
inline int TensorValue_RepeatedLongInts::values_size() const {
  return values_.size();
}
inline void TensorValue_RepeatedLongInts::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::int64 TensorValue_RepeatedLongInts::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts.values)
  return values_.Get(index);
}
inline void TensorValue_RepeatedLongInts::set_values(int index, ::google::protobuf::int64 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts.values)
}
inline void TensorValue_RepeatedLongInts::add_values(::google::protobuf::int64 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
TensorValue_RepeatedLongInts::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
TensorValue_RepeatedLongInts::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts.values)
  return &values_;
}

// -------------------------------------------------------------------

// TensorValue_RepeatedBools

// repeated bool values = 1 [packed = true];
inline int TensorValue_RepeatedBools::values_size() const {
  return values_.size();
}
inline void TensorValue_RepeatedBools::clear_values() {
  values_.Clear();
}
inline bool TensorValue_RepeatedBools::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.RepeatedBools.values)
  return values_.Get(index);
}
inline void TensorValue_RepeatedBools::set_values(int index, bool value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorValue.RepeatedBools.values)
}
inline void TensorValue_RepeatedBools::add_values(bool value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TensorValue.RepeatedBools.values)
}
inline const ::google::protobuf::RepeatedField< bool >&
TensorValue_RepeatedBools::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.TensorValue.RepeatedBools.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< bool >*
TensorValue_RepeatedBools::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.TensorValue.RepeatedBools.values)
  return &values_;
}

// -------------------------------------------------------------------

// TensorValue_RepeatedStrings

// repeated string values = 1;
inline int TensorValue_RepeatedStrings::values_size() const {
  return values_.size();
}
inline void TensorValue_RepeatedStrings::clear_values() {
  values_.Clear();
}
inline const ::std::string& TensorValue_RepeatedStrings::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
  return values_.Get(index);
}
inline ::std::string* TensorValue_RepeatedStrings::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
  return values_.Mutable(index);
}
inline void TensorValue_RepeatedStrings::set_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
  values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TensorValue_RepeatedStrings::set_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
  values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TensorValue_RepeatedStrings::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
}
inline void TensorValue_RepeatedStrings::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
}
inline ::std::string* TensorValue_RepeatedStrings::add_values() {
  // @@protoc_insertion_point(field_add_mutable:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
  return values_.Add();
}
inline void TensorValue_RepeatedStrings::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
}
#if LANG_CXX11
inline void TensorValue_RepeatedStrings::add_values(::std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
}
#endif
inline void TensorValue_RepeatedStrings::add_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
}
inline void TensorValue_RepeatedStrings::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TensorValue_RepeatedStrings::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TensorValue_RepeatedStrings::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.TensorValue.RepeatedStrings.values)
  return &values_;
}

// -------------------------------------------------------------------

// TensorValue_RepeatedBytes

// bytes values = 1;
inline void TensorValue_RepeatedBytes::clear_values() {
  values_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TensorValue_RepeatedBytes::values() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes.values)
  return values_.GetNoArena();
}
inline void TensorValue_RepeatedBytes::set_values(const ::std::string& value) {
  
  values_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes.values)
}
#if LANG_CXX11
inline void TensorValue_RepeatedBytes::set_values(::std::string&& value) {
  
  values_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes.values)
}
#endif
inline void TensorValue_RepeatedBytes::set_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  values_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes.values)
}
inline void TensorValue_RepeatedBytes::set_values(const void* value, size_t size) {
  
  values_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes.values)
}
inline ::std::string* TensorValue_RepeatedBytes::mutable_values() {
  
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes.values)
  return values_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TensorValue_RepeatedBytes::release_values() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes.values)
  
  return values_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TensorValue_RepeatedBytes::set_allocated_values(::std::string* values) {
  if (values != NULL) {
    
  } else {
    
  }
  values_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), values);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.TensorValue.RepeatedBytes.values)
}

// -------------------------------------------------------------------

// TensorValue

// .CoreML.Specification.MILSpec.TensorValue.RepeatedFloats floats = 1;
inline bool TensorValue::has_floats() const {
  return value_case() == kFloats;
}
inline void TensorValue::set_has_floats() {
  _oneof_case_[0] = kFloats;
}
inline void TensorValue::clear_floats() {
  if (has_floats()) {
    delete value_.floats_;
    clear_has_value();
  }
}
inline  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats& TensorValue::floats() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.floats)
  return has_floats()
      ? *value_.floats_
      : ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats::default_instance();
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* TensorValue::mutable_floats() {
  if (!has_floats()) {
    clear_value();
    set_has_floats();
    value_.floats_ = new ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorValue.floats)
  return value_.floats_;
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* TensorValue::release_floats() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.TensorValue.floats)
  if (has_floats()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* temp = value_.floats_;
    value_.floats_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TensorValue::set_allocated_floats(::CoreML::Specification::MILSpec::TensorValue_RepeatedFloats* floats) {
  clear_value();
  if (floats) {
    set_has_floats();
    value_.floats_ = floats;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.TensorValue.floats)
}

// .CoreML.Specification.MILSpec.TensorValue.RepeatedInts ints = 2;
inline bool TensorValue::has_ints() const {
  return value_case() == kInts;
}
inline void TensorValue::set_has_ints() {
  _oneof_case_[0] = kInts;
}
inline void TensorValue::clear_ints() {
  if (has_ints()) {
    delete value_.ints_;
    clear_has_value();
  }
}
inline  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts& TensorValue::ints() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.ints)
  return has_ints()
      ? *value_.ints_
      : ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts::default_instance();
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* TensorValue::mutable_ints() {
  if (!has_ints()) {
    clear_value();
    set_has_ints();
    value_.ints_ = new ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorValue.ints)
  return value_.ints_;
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* TensorValue::release_ints() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.TensorValue.ints)
  if (has_ints()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* temp = value_.ints_;
    value_.ints_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TensorValue::set_allocated_ints(::CoreML::Specification::MILSpec::TensorValue_RepeatedInts* ints) {
  clear_value();
  if (ints) {
    set_has_ints();
    value_.ints_ = ints;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.TensorValue.ints)
}

// .CoreML.Specification.MILSpec.TensorValue.RepeatedBools bools = 3;
inline bool TensorValue::has_bools() const {
  return value_case() == kBools;
}
inline void TensorValue::set_has_bools() {
  _oneof_case_[0] = kBools;
}
inline void TensorValue::clear_bools() {
  if (has_bools()) {
    delete value_.bools_;
    clear_has_value();
  }
}
inline  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools& TensorValue::bools() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.bools)
  return has_bools()
      ? *value_.bools_
      : ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools::default_instance();
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* TensorValue::mutable_bools() {
  if (!has_bools()) {
    clear_value();
    set_has_bools();
    value_.bools_ = new ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorValue.bools)
  return value_.bools_;
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* TensorValue::release_bools() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.TensorValue.bools)
  if (has_bools()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* temp = value_.bools_;
    value_.bools_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TensorValue::set_allocated_bools(::CoreML::Specification::MILSpec::TensorValue_RepeatedBools* bools) {
  clear_value();
  if (bools) {
    set_has_bools();
    value_.bools_ = bools;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.TensorValue.bools)
}

// .CoreML.Specification.MILSpec.TensorValue.RepeatedStrings strings = 4;
inline bool TensorValue::has_strings() const {
  return value_case() == kStrings;
}
inline void TensorValue::set_has_strings() {
  _oneof_case_[0] = kStrings;
}
inline void TensorValue::clear_strings() {
  if (has_strings()) {
    delete value_.strings_;
    clear_has_value();
  }
}
inline  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings& TensorValue::strings() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.strings)
  return has_strings()
      ? *value_.strings_
      : ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings::default_instance();
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* TensorValue::mutable_strings() {
  if (!has_strings()) {
    clear_value();
    set_has_strings();
    value_.strings_ = new ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorValue.strings)
  return value_.strings_;
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* TensorValue::release_strings() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.TensorValue.strings)
  if (has_strings()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* temp = value_.strings_;
    value_.strings_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TensorValue::set_allocated_strings(::CoreML::Specification::MILSpec::TensorValue_RepeatedStrings* strings) {
  clear_value();
  if (strings) {
    set_has_strings();
    value_.strings_ = strings;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.TensorValue.strings)
}

// .CoreML.Specification.MILSpec.TensorValue.RepeatedLongInts longInts = 5;
inline bool TensorValue::has_longints() const {
  return value_case() == kLongInts;
}
inline void TensorValue::set_has_longints() {
  _oneof_case_[0] = kLongInts;
}
inline void TensorValue::clear_longints() {
  if (has_longints()) {
    delete value_.longints_;
    clear_has_value();
  }
}
inline  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts& TensorValue::longints() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.longInts)
  return has_longints()
      ? *value_.longints_
      : ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts::default_instance();
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* TensorValue::mutable_longints() {
  if (!has_longints()) {
    clear_value();
    set_has_longints();
    value_.longints_ = new ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorValue.longInts)
  return value_.longints_;
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* TensorValue::release_longints() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.TensorValue.longInts)
  if (has_longints()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* temp = value_.longints_;
    value_.longints_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TensorValue::set_allocated_longints(::CoreML::Specification::MILSpec::TensorValue_RepeatedLongInts* longints) {
  clear_value();
  if (longints) {
    set_has_longints();
    value_.longints_ = longints;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.TensorValue.longInts)
}

// .CoreML.Specification.MILSpec.TensorValue.RepeatedDoubles doubles = 6;
inline bool TensorValue::has_doubles() const {
  return value_case() == kDoubles;
}
inline void TensorValue::set_has_doubles() {
  _oneof_case_[0] = kDoubles;
}
inline void TensorValue::clear_doubles() {
  if (has_doubles()) {
    delete value_.doubles_;
    clear_has_value();
  }
}
inline  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles& TensorValue::doubles() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.doubles)
  return has_doubles()
      ? *value_.doubles_
      : ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles::default_instance();
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* TensorValue::mutable_doubles() {
  if (!has_doubles()) {
    clear_value();
    set_has_doubles();
    value_.doubles_ = new ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorValue.doubles)
  return value_.doubles_;
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* TensorValue::release_doubles() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.TensorValue.doubles)
  if (has_doubles()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* temp = value_.doubles_;
    value_.doubles_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TensorValue::set_allocated_doubles(::CoreML::Specification::MILSpec::TensorValue_RepeatedDoubles* doubles) {
  clear_value();
  if (doubles) {
    set_has_doubles();
    value_.doubles_ = doubles;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.TensorValue.doubles)
}

// .CoreML.Specification.MILSpec.TensorValue.RepeatedBytes bytes = 7;
inline bool TensorValue::has_bytes() const {
  return value_case() == kBytes;
}
inline void TensorValue::set_has_bytes() {
  _oneof_case_[0] = kBytes;
}
inline void TensorValue::clear_bytes() {
  if (has_bytes()) {
    delete value_.bytes_;
    clear_has_value();
  }
}
inline  const ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes& TensorValue::bytes() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TensorValue.bytes)
  return has_bytes()
      ? *value_.bytes_
      : ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes::default_instance();
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* TensorValue::mutable_bytes() {
  if (!has_bytes()) {
    clear_value();
    set_has_bytes();
    value_.bytes_ = new ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TensorValue.bytes)
  return value_.bytes_;
}
inline ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* TensorValue::release_bytes() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.TensorValue.bytes)
  if (has_bytes()) {
    clear_has_value();
    ::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* temp = value_.bytes_;
    value_.bytes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TensorValue::set_allocated_bytes(::CoreML::Specification::MILSpec::TensorValue_RepeatedBytes* bytes) {
  clear_value();
  if (bytes) {
    set_has_bytes();
    value_.bytes_ = bytes;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.TensorValue.bytes)
}

inline bool TensorValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void TensorValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline TensorValue::ValueCase TensorValue::value_case() const {
  return TensorValue::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TupleValue

// repeated .CoreML.Specification.MILSpec.Value values = 1;
inline int TupleValue::values_size() const {
  return values_.size();
}
inline void TupleValue::clear_values() {
  values_.Clear();
}
inline const ::CoreML::Specification::MILSpec::Value& TupleValue::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.TupleValue.values)
  return values_.Get(index);
}
inline ::CoreML::Specification::MILSpec::Value* TupleValue::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.TupleValue.values)
  return values_.Mutable(index);
}
inline ::CoreML::Specification::MILSpec::Value* TupleValue::add_values() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.TupleValue.values)
  return values_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value >*
TupleValue::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.TupleValue.values)
  return &values_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value >&
TupleValue::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.TupleValue.values)
  return values_;
}

// -------------------------------------------------------------------

// ListValue

// repeated .CoreML.Specification.MILSpec.Value values = 1;
inline int ListValue::values_size() const {
  return values_.size();
}
inline void ListValue::clear_values() {
  values_.Clear();
}
inline const ::CoreML::Specification::MILSpec::Value& ListValue::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.ListValue.values)
  return values_.Get(index);
}
inline ::CoreML::Specification::MILSpec::Value* ListValue::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.ListValue.values)
  return values_.Mutable(index);
}
inline ::CoreML::Specification::MILSpec::Value* ListValue::add_values() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.ListValue.values)
  return values_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value >*
ListValue::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.ListValue.values)
  return &values_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::Value >&
ListValue::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.ListValue.values)
  return values_;
}

// -------------------------------------------------------------------

// DictionaryValue_KeyValuePair

// .CoreML.Specification.MILSpec.Value key = 1;
inline bool DictionaryValue_KeyValuePair::has_key() const {
  return this != internal_default_instance() && key_ != NULL;
}
inline void DictionaryValue_KeyValuePair::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::CoreML::Specification::MILSpec::Value& DictionaryValue_KeyValuePair::key() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair.key)
  return key_ != NULL ? *key_
                         : *::CoreML::Specification::MILSpec::Value::internal_default_instance();
}
inline ::CoreML::Specification::MILSpec::Value* DictionaryValue_KeyValuePair::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::CoreML::Specification::MILSpec::Value;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair.key)
  return key_;
}
inline ::CoreML::Specification::MILSpec::Value* DictionaryValue_KeyValuePair::release_key() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair.key)
  
  ::CoreML::Specification::MILSpec::Value* temp = key_;
  key_ = NULL;
  return temp;
}
inline void DictionaryValue_KeyValuePair::set_allocated_key(::CoreML::Specification::MILSpec::Value* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair.key)
}

// .CoreML.Specification.MILSpec.Value value = 2;
inline bool DictionaryValue_KeyValuePair::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void DictionaryValue_KeyValuePair::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::CoreML::Specification::MILSpec::Value& DictionaryValue_KeyValuePair::value() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair.value)
  return value_ != NULL ? *value_
                         : *::CoreML::Specification::MILSpec::Value::internal_default_instance();
}
inline ::CoreML::Specification::MILSpec::Value* DictionaryValue_KeyValuePair::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::CoreML::Specification::MILSpec::Value;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair.value)
  return value_;
}
inline ::CoreML::Specification::MILSpec::Value* DictionaryValue_KeyValuePair::release_value() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair.value)
  
  ::CoreML::Specification::MILSpec::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void DictionaryValue_KeyValuePair::set_allocated_value(::CoreML::Specification::MILSpec::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair.value)
}

// -------------------------------------------------------------------

// DictionaryValue

// repeated .CoreML.Specification.MILSpec.DictionaryValue.KeyValuePair values = 1;
inline int DictionaryValue::values_size() const {
  return values_.size();
}
inline void DictionaryValue::clear_values() {
  values_.Clear();
}
inline const ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair& DictionaryValue::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MILSpec.DictionaryValue.values)
  return values_.Get(index);
}
inline ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair* DictionaryValue::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.MILSpec.DictionaryValue.values)
  return values_.Mutable(index);
}
inline ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair* DictionaryValue::add_values() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.MILSpec.DictionaryValue.values)
  return values_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair >*
DictionaryValue::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.MILSpec.DictionaryValue.values)
  return &values_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::MILSpec::DictionaryValue_KeyValuePair >&
DictionaryValue::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.MILSpec.DictionaryValue.values)
  return values_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace MILSpec
}  // namespace Specification
}  // namespace CoreML

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::CoreML::Specification::MILSpec::DataType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MIL_2eproto__INCLUDED
