// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NeuralNetwork.proto

#include "NeuralNetwork.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace CoreML {
namespace Specification {
constexpr NeuralNetwork::NeuralNetwork(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : layers_()
  , preprocessing_()
  , updateparams_(nullptr)
  , arrayinputshapemapping_(0)

  , imageinputshapemapping_(0)
{}
struct NeuralNetworkDefaultTypeInternal {
  constexpr NeuralNetworkDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NeuralNetworkDefaultTypeInternal() {}
  union {
    NeuralNetwork _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NeuralNetworkDefaultTypeInternal _NeuralNetwork_default_instance_;
constexpr NeuralNetworkImageScaler::NeuralNetworkImageScaler(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : graybias_(0)
  , channelscale_(0)
  , bluebias_(0)
  , greenbias_(0)
  , redbias_(0){}
struct NeuralNetworkImageScalerDefaultTypeInternal {
  constexpr NeuralNetworkImageScalerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NeuralNetworkImageScalerDefaultTypeInternal() {}
  union {
    NeuralNetworkImageScaler _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NeuralNetworkImageScalerDefaultTypeInternal _NeuralNetworkImageScaler_default_instance_;
constexpr NeuralNetworkMeanImage::NeuralNetworkMeanImage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : meanimage_(){}
struct NeuralNetworkMeanImageDefaultTypeInternal {
  constexpr NeuralNetworkMeanImageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NeuralNetworkMeanImageDefaultTypeInternal() {}
  union {
    NeuralNetworkMeanImage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NeuralNetworkMeanImageDefaultTypeInternal _NeuralNetworkMeanImage_default_instance_;
constexpr NeuralNetworkPreprocessing::NeuralNetworkPreprocessing(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : featurename_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , _oneof_case_{}{}
struct NeuralNetworkPreprocessingDefaultTypeInternal {
  constexpr NeuralNetworkPreprocessingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NeuralNetworkPreprocessingDefaultTypeInternal() {}
  union {
    NeuralNetworkPreprocessing _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NeuralNetworkPreprocessingDefaultTypeInternal _NeuralNetworkPreprocessing_default_instance_;
constexpr ActivationReLU::ActivationReLU(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ActivationReLUDefaultTypeInternal {
  constexpr ActivationReLUDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ActivationReLUDefaultTypeInternal() {}
  union {
    ActivationReLU _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ActivationReLUDefaultTypeInternal _ActivationReLU_default_instance_;
constexpr ActivationLeakyReLU::ActivationLeakyReLU(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(0){}
struct ActivationLeakyReLUDefaultTypeInternal {
  constexpr ActivationLeakyReLUDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ActivationLeakyReLUDefaultTypeInternal() {}
  union {
    ActivationLeakyReLU _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ActivationLeakyReLUDefaultTypeInternal _ActivationLeakyReLU_default_instance_;
constexpr ActivationTanh::ActivationTanh(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ActivationTanhDefaultTypeInternal {
  constexpr ActivationTanhDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ActivationTanhDefaultTypeInternal() {}
  union {
    ActivationTanh _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ActivationTanhDefaultTypeInternal _ActivationTanh_default_instance_;
constexpr ActivationScaledTanh::ActivationScaledTanh(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(0)
  , beta_(0){}
struct ActivationScaledTanhDefaultTypeInternal {
  constexpr ActivationScaledTanhDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ActivationScaledTanhDefaultTypeInternal() {}
  union {
    ActivationScaledTanh _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ActivationScaledTanhDefaultTypeInternal _ActivationScaledTanh_default_instance_;
constexpr ActivationSigmoid::ActivationSigmoid(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ActivationSigmoidDefaultTypeInternal {
  constexpr ActivationSigmoidDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ActivationSigmoidDefaultTypeInternal() {}
  union {
    ActivationSigmoid _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ActivationSigmoidDefaultTypeInternal _ActivationSigmoid_default_instance_;
constexpr ActivationLinear::ActivationLinear(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(0)
  , beta_(0){}
struct ActivationLinearDefaultTypeInternal {
  constexpr ActivationLinearDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ActivationLinearDefaultTypeInternal() {}
  union {
    ActivationLinear _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ActivationLinearDefaultTypeInternal _ActivationLinear_default_instance_;
constexpr ActivationSigmoidHard::ActivationSigmoidHard(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(0)
  , beta_(0){}
struct ActivationSigmoidHardDefaultTypeInternal {
  constexpr ActivationSigmoidHardDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ActivationSigmoidHardDefaultTypeInternal() {}
  union {
    ActivationSigmoidHard _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ActivationSigmoidHardDefaultTypeInternal _ActivationSigmoidHard_default_instance_;
constexpr ActivationPReLU::ActivationPReLU(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(nullptr){}
struct ActivationPReLUDefaultTypeInternal {
  constexpr ActivationPReLUDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ActivationPReLUDefaultTypeInternal() {}
  union {
    ActivationPReLU _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ActivationPReLUDefaultTypeInternal _ActivationPReLU_default_instance_;
constexpr ActivationELU::ActivationELU(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(0){}
struct ActivationELUDefaultTypeInternal {
  constexpr ActivationELUDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ActivationELUDefaultTypeInternal() {}
  union {
    ActivationELU _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ActivationELUDefaultTypeInternal _ActivationELU_default_instance_;
constexpr ActivationThresholdedReLU::ActivationThresholdedReLU(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(0){}
struct ActivationThresholdedReLUDefaultTypeInternal {
  constexpr ActivationThresholdedReLUDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ActivationThresholdedReLUDefaultTypeInternal() {}
  union {
    ActivationThresholdedReLU _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ActivationThresholdedReLUDefaultTypeInternal _ActivationThresholdedReLU_default_instance_;
constexpr ActivationSoftsign::ActivationSoftsign(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ActivationSoftsignDefaultTypeInternal {
  constexpr ActivationSoftsignDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ActivationSoftsignDefaultTypeInternal() {}
  union {
    ActivationSoftsign _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ActivationSoftsignDefaultTypeInternal _ActivationSoftsign_default_instance_;
constexpr ActivationSoftplus::ActivationSoftplus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ActivationSoftplusDefaultTypeInternal {
  constexpr ActivationSoftplusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ActivationSoftplusDefaultTypeInternal() {}
  union {
    ActivationSoftplus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ActivationSoftplusDefaultTypeInternal _ActivationSoftplus_default_instance_;
constexpr ActivationParametricSoftplus::ActivationParametricSoftplus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(nullptr)
  , beta_(nullptr){}
struct ActivationParametricSoftplusDefaultTypeInternal {
  constexpr ActivationParametricSoftplusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ActivationParametricSoftplusDefaultTypeInternal() {}
  union {
    ActivationParametricSoftplus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ActivationParametricSoftplusDefaultTypeInternal _ActivationParametricSoftplus_default_instance_;
constexpr ActivationParams::ActivationParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct ActivationParamsDefaultTypeInternal {
  constexpr ActivationParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ActivationParamsDefaultTypeInternal() {}
  union {
    ActivationParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ActivationParamsDefaultTypeInternal _ActivationParams_default_instance_;
constexpr Tensor::Tensor(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dimvalue_()
  , _dimvalue_cached_byte_size_(0)
  , rank_(0u){}
struct TensorDefaultTypeInternal {
  constexpr TensorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TensorDefaultTypeInternal() {}
  union {
    Tensor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TensorDefaultTypeInternal _Tensor_default_instance_;
constexpr NeuralNetworkLayer::NeuralNetworkLayer(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : input_()
  , output_()
  , inputtensor_()
  , outputtensor_()
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , isupdatable_(false)
  , _oneof_case_{}{}
struct NeuralNetworkLayerDefaultTypeInternal {
  constexpr NeuralNetworkLayerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NeuralNetworkLayerDefaultTypeInternal() {}
  union {
    NeuralNetworkLayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NeuralNetworkLayerDefaultTypeInternal _NeuralNetworkLayer_default_instance_;
constexpr BranchLayerParams::BranchLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ifbranch_(nullptr)
  , elsebranch_(nullptr){}
struct BranchLayerParamsDefaultTypeInternal {
  constexpr BranchLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BranchLayerParamsDefaultTypeInternal() {}
  union {
    BranchLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BranchLayerParamsDefaultTypeInternal _BranchLayerParams_default_instance_;
constexpr LoopLayerParams::LoopLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : conditionvar_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , conditionnetwork_(nullptr)
  , bodynetwork_(nullptr)
  , maxloopiterations_(uint64_t{0u}){}
struct LoopLayerParamsDefaultTypeInternal {
  constexpr LoopLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LoopLayerParamsDefaultTypeInternal() {}
  union {
    LoopLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LoopLayerParamsDefaultTypeInternal _LoopLayerParams_default_instance_;
constexpr LoopBreakLayerParams::LoopBreakLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct LoopBreakLayerParamsDefaultTypeInternal {
  constexpr LoopBreakLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LoopBreakLayerParamsDefaultTypeInternal() {}
  union {
    LoopBreakLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LoopBreakLayerParamsDefaultTypeInternal _LoopBreakLayerParams_default_instance_;
constexpr LoopContinueLayerParams::LoopContinueLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct LoopContinueLayerParamsDefaultTypeInternal {
  constexpr LoopContinueLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LoopContinueLayerParamsDefaultTypeInternal() {}
  union {
    LoopContinueLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LoopContinueLayerParamsDefaultTypeInternal _LoopContinueLayerParams_default_instance_;
constexpr CopyLayerParams::CopyLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CopyLayerParamsDefaultTypeInternal {
  constexpr CopyLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CopyLayerParamsDefaultTypeInternal() {}
  union {
    CopyLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CopyLayerParamsDefaultTypeInternal _CopyLayerParams_default_instance_;
constexpr GreaterThanLayerParams::GreaterThanLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(0){}
struct GreaterThanLayerParamsDefaultTypeInternal {
  constexpr GreaterThanLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GreaterThanLayerParamsDefaultTypeInternal() {}
  union {
    GreaterThanLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GreaterThanLayerParamsDefaultTypeInternal _GreaterThanLayerParams_default_instance_;
constexpr GreaterEqualLayerParams::GreaterEqualLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(0){}
struct GreaterEqualLayerParamsDefaultTypeInternal {
  constexpr GreaterEqualLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GreaterEqualLayerParamsDefaultTypeInternal() {}
  union {
    GreaterEqualLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GreaterEqualLayerParamsDefaultTypeInternal _GreaterEqualLayerParams_default_instance_;
constexpr LessThanLayerParams::LessThanLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(0){}
struct LessThanLayerParamsDefaultTypeInternal {
  constexpr LessThanLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LessThanLayerParamsDefaultTypeInternal() {}
  union {
    LessThanLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LessThanLayerParamsDefaultTypeInternal _LessThanLayerParams_default_instance_;
constexpr LessEqualLayerParams::LessEqualLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(0){}
struct LessEqualLayerParamsDefaultTypeInternal {
  constexpr LessEqualLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LessEqualLayerParamsDefaultTypeInternal() {}
  union {
    LessEqualLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LessEqualLayerParamsDefaultTypeInternal _LessEqualLayerParams_default_instance_;
constexpr EqualLayerParams::EqualLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(0){}
struct EqualLayerParamsDefaultTypeInternal {
  constexpr EqualLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EqualLayerParamsDefaultTypeInternal() {}
  union {
    EqualLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EqualLayerParamsDefaultTypeInternal _EqualLayerParams_default_instance_;
constexpr NotEqualLayerParams::NotEqualLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(0){}
struct NotEqualLayerParamsDefaultTypeInternal {
  constexpr NotEqualLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NotEqualLayerParamsDefaultTypeInternal() {}
  union {
    NotEqualLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NotEqualLayerParamsDefaultTypeInternal _NotEqualLayerParams_default_instance_;
constexpr LogicalAndLayerParams::LogicalAndLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct LogicalAndLayerParamsDefaultTypeInternal {
  constexpr LogicalAndLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LogicalAndLayerParamsDefaultTypeInternal() {}
  union {
    LogicalAndLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LogicalAndLayerParamsDefaultTypeInternal _LogicalAndLayerParams_default_instance_;
constexpr LogicalOrLayerParams::LogicalOrLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct LogicalOrLayerParamsDefaultTypeInternal {
  constexpr LogicalOrLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LogicalOrLayerParamsDefaultTypeInternal() {}
  union {
    LogicalOrLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LogicalOrLayerParamsDefaultTypeInternal _LogicalOrLayerParams_default_instance_;
constexpr LogicalXorLayerParams::LogicalXorLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct LogicalXorLayerParamsDefaultTypeInternal {
  constexpr LogicalXorLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LogicalXorLayerParamsDefaultTypeInternal() {}
  union {
    LogicalXorLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LogicalXorLayerParamsDefaultTypeInternal _LogicalXorLayerParams_default_instance_;
constexpr LogicalNotLayerParams::LogicalNotLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct LogicalNotLayerParamsDefaultTypeInternal {
  constexpr LogicalNotLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LogicalNotLayerParamsDefaultTypeInternal() {}
  union {
    LogicalNotLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LogicalNotLayerParamsDefaultTypeInternal _LogicalNotLayerParams_default_instance_;
constexpr BorderAmounts_EdgeSizes::BorderAmounts_EdgeSizes(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : startedgesize_(uint64_t{0u})
  , endedgesize_(uint64_t{0u}){}
struct BorderAmounts_EdgeSizesDefaultTypeInternal {
  constexpr BorderAmounts_EdgeSizesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BorderAmounts_EdgeSizesDefaultTypeInternal() {}
  union {
    BorderAmounts_EdgeSizes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BorderAmounts_EdgeSizesDefaultTypeInternal _BorderAmounts_EdgeSizes_default_instance_;
constexpr BorderAmounts::BorderAmounts(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : borderamounts_(){}
struct BorderAmountsDefaultTypeInternal {
  constexpr BorderAmountsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BorderAmountsDefaultTypeInternal() {}
  union {
    BorderAmounts _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BorderAmountsDefaultTypeInternal _BorderAmounts_default_instance_;
constexpr ValidPadding::ValidPadding(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : paddingamounts_(nullptr){}
struct ValidPaddingDefaultTypeInternal {
  constexpr ValidPaddingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ValidPaddingDefaultTypeInternal() {}
  union {
    ValidPadding _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ValidPaddingDefaultTypeInternal _ValidPadding_default_instance_;
constexpr SamePadding::SamePadding(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : asymmetrymode_(0)
{}
struct SamePaddingDefaultTypeInternal {
  constexpr SamePaddingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SamePaddingDefaultTypeInternal() {}
  union {
    SamePadding _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SamePaddingDefaultTypeInternal _SamePadding_default_instance_;
constexpr SamplingMode::SamplingMode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : samplingmethod_(0)
{}
struct SamplingModeDefaultTypeInternal {
  constexpr SamplingModeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SamplingModeDefaultTypeInternal() {}
  union {
    SamplingMode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SamplingModeDefaultTypeInternal _SamplingMode_default_instance_;
constexpr BoxCoordinatesMode::BoxCoordinatesMode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : boxmode_(0)
{}
struct BoxCoordinatesModeDefaultTypeInternal {
  constexpr BoxCoordinatesModeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BoxCoordinatesModeDefaultTypeInternal() {}
  union {
    BoxCoordinatesMode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BoxCoordinatesModeDefaultTypeInternal _BoxCoordinatesMode_default_instance_;
constexpr WeightParams::WeightParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : floatvalue_()
  , float16value_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , rawvalue_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , int8rawvalue_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , quantization_(nullptr)
  , isupdatable_(false){}
struct WeightParamsDefaultTypeInternal {
  constexpr WeightParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WeightParamsDefaultTypeInternal() {}
  union {
    WeightParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WeightParamsDefaultTypeInternal _WeightParams_default_instance_;
constexpr QuantizationParams::QuantizationParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : numberofbits_(uint64_t{0u})
  , _oneof_case_{}{}
struct QuantizationParamsDefaultTypeInternal {
  constexpr QuantizationParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~QuantizationParamsDefaultTypeInternal() {}
  union {
    QuantizationParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT QuantizationParamsDefaultTypeInternal _QuantizationParams_default_instance_;
constexpr LinearQuantizationParams::LinearQuantizationParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : scale_()
  , bias_(){}
struct LinearQuantizationParamsDefaultTypeInternal {
  constexpr LinearQuantizationParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LinearQuantizationParamsDefaultTypeInternal() {}
  union {
    LinearQuantizationParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LinearQuantizationParamsDefaultTypeInternal _LinearQuantizationParams_default_instance_;
constexpr LookUpTableQuantizationParams::LookUpTableQuantizationParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : floatvalue_(){}
struct LookUpTableQuantizationParamsDefaultTypeInternal {
  constexpr LookUpTableQuantizationParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LookUpTableQuantizationParamsDefaultTypeInternal() {}
  union {
    LookUpTableQuantizationParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LookUpTableQuantizationParamsDefaultTypeInternal _LookUpTableQuantizationParams_default_instance_;
constexpr ConvolutionLayerParams::ConvolutionLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : kernelsize_()
  , _kernelsize_cached_byte_size_(0)
  , stride_()
  , _stride_cached_byte_size_(0)
  , dilationfactor_()
  , _dilationfactor_cached_byte_size_(0)
  , outputshape_()
  , _outputshape_cached_byte_size_(0)
  , weights_(nullptr)
  , bias_(nullptr)
  , outputchannels_(uint64_t{0u})
  , kernelchannels_(uint64_t{0u})
  , ngroups_(uint64_t{0u})
  , isdeconvolution_(false)
  , hasbias_(false)
  , _oneof_case_{}{}
struct ConvolutionLayerParamsDefaultTypeInternal {
  constexpr ConvolutionLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConvolutionLayerParamsDefaultTypeInternal() {}
  union {
    ConvolutionLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConvolutionLayerParamsDefaultTypeInternal _ConvolutionLayerParams_default_instance_;
constexpr Convolution3DLayerParams::Convolution3DLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : outputshape_()
  , _outputshape_cached_byte_size_(0)
  , weights_(nullptr)
  , bias_(nullptr)
  , outputchannels_(0)
  , inputchannels_(0)
  , ngroups_(0)
  , kerneldepth_(0)
  , kernelheight_(0)
  , kernelwidth_(0)
  , stridedepth_(0)
  , strideheight_(0)
  , stridewidth_(0)
  , dilationdepth_(0)
  , dilationheight_(0)
  , dilationwidth_(0)
  , hasbias_(false)
  , isdeconvolution_(false)
  , paddingtype_(0)

  , custompaddingfront_(0)
  , custompaddingback_(0)
  , custompaddingtop_(0)
  , custompaddingbottom_(0)
  , custompaddingleft_(0)
  , custompaddingright_(0){}
struct Convolution3DLayerParamsDefaultTypeInternal {
  constexpr Convolution3DLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Convolution3DLayerParamsDefaultTypeInternal() {}
  union {
    Convolution3DLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Convolution3DLayerParamsDefaultTypeInternal _Convolution3DLayerParams_default_instance_;
constexpr InnerProductLayerParams::InnerProductLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : weights_(nullptr)
  , bias_(nullptr)
  , inputchannels_(uint64_t{0u})
  , outputchannels_(uint64_t{0u})
  , hasbias_(false)
  , int8dynamicquantize_(false){}
struct InnerProductLayerParamsDefaultTypeInternal {
  constexpr InnerProductLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InnerProductLayerParamsDefaultTypeInternal() {}
  union {
    InnerProductLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InnerProductLayerParamsDefaultTypeInternal _InnerProductLayerParams_default_instance_;
constexpr EmbeddingLayerParams::EmbeddingLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : weights_(nullptr)
  , bias_(nullptr)
  , inputdim_(uint64_t{0u})
  , outputchannels_(uint64_t{0u})
  , hasbias_(false){}
struct EmbeddingLayerParamsDefaultTypeInternal {
  constexpr EmbeddingLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EmbeddingLayerParamsDefaultTypeInternal() {}
  union {
    EmbeddingLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EmbeddingLayerParamsDefaultTypeInternal _EmbeddingLayerParams_default_instance_;
constexpr EmbeddingNDLayerParams::EmbeddingNDLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : weights_(nullptr)
  , bias_(nullptr)
  , vocabsize_(uint64_t{0u})
  , embeddingsize_(uint64_t{0u})
  , hasbias_(false){}
struct EmbeddingNDLayerParamsDefaultTypeInternal {
  constexpr EmbeddingNDLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EmbeddingNDLayerParamsDefaultTypeInternal() {}
  union {
    EmbeddingNDLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EmbeddingNDLayerParamsDefaultTypeInternal _EmbeddingNDLayerParams_default_instance_;
constexpr BatchnormLayerParams::BatchnormLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gamma_(nullptr)
  , beta_(nullptr)
  , mean_(nullptr)
  , variance_(nullptr)
  , channels_(uint64_t{0u})
  , computemeanvar_(false)
  , instancenormalization_(false)
  , epsilon_(0){}
struct BatchnormLayerParamsDefaultTypeInternal {
  constexpr BatchnormLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BatchnormLayerParamsDefaultTypeInternal() {}
  union {
    BatchnormLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BatchnormLayerParamsDefaultTypeInternal _BatchnormLayerParams_default_instance_;
constexpr PoolingLayerParams_ValidCompletePadding::PoolingLayerParams_ValidCompletePadding(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : paddingamounts_()
  , _paddingamounts_cached_byte_size_(0){}
struct PoolingLayerParams_ValidCompletePaddingDefaultTypeInternal {
  constexpr PoolingLayerParams_ValidCompletePaddingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PoolingLayerParams_ValidCompletePaddingDefaultTypeInternal() {}
  union {
    PoolingLayerParams_ValidCompletePadding _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PoolingLayerParams_ValidCompletePaddingDefaultTypeInternal _PoolingLayerParams_ValidCompletePadding_default_instance_;
constexpr PoolingLayerParams::PoolingLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : kernelsize_()
  , _kernelsize_cached_byte_size_(0)
  , stride_()
  , _stride_cached_byte_size_(0)
  , type_(0)

  , avgpoolexcludepadding_(false)
  , globalpooling_(false)
  , _oneof_case_{}{}
struct PoolingLayerParamsDefaultTypeInternal {
  constexpr PoolingLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PoolingLayerParamsDefaultTypeInternal() {}
  union {
    PoolingLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PoolingLayerParamsDefaultTypeInternal _PoolingLayerParams_default_instance_;
constexpr Pooling3DLayerParams::Pooling3DLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : type_(0)

  , kerneldepth_(0)
  , kernelheight_(0)
  , kernelwidth_(0)
  , stridedepth_(0)
  , strideheight_(0)
  , stridewidth_(0)
  , custompaddingfront_(0)
  , custompaddingback_(0)
  , custompaddingtop_(0)
  , custompaddingbottom_(0)
  , custompaddingleft_(0)
  , custompaddingright_(0)
  , countexcludepadding_(false)
  , paddingtype_(0)
{}
struct Pooling3DLayerParamsDefaultTypeInternal {
  constexpr Pooling3DLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Pooling3DLayerParamsDefaultTypeInternal() {}
  union {
    Pooling3DLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Pooling3DLayerParamsDefaultTypeInternal _Pooling3DLayerParams_default_instance_;
constexpr GlobalPooling3DLayerParams::GlobalPooling3DLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : type_(0)
{}
struct GlobalPooling3DLayerParamsDefaultTypeInternal {
  constexpr GlobalPooling3DLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GlobalPooling3DLayerParamsDefaultTypeInternal() {}
  union {
    GlobalPooling3DLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GlobalPooling3DLayerParamsDefaultTypeInternal _GlobalPooling3DLayerParams_default_instance_;
constexpr PaddingLayerParams_PaddingConstant::PaddingLayerParams_PaddingConstant(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : value_(0){}
struct PaddingLayerParams_PaddingConstantDefaultTypeInternal {
  constexpr PaddingLayerParams_PaddingConstantDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PaddingLayerParams_PaddingConstantDefaultTypeInternal() {}
  union {
    PaddingLayerParams_PaddingConstant _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PaddingLayerParams_PaddingConstantDefaultTypeInternal _PaddingLayerParams_PaddingConstant_default_instance_;
constexpr PaddingLayerParams_PaddingReflection::PaddingLayerParams_PaddingReflection(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct PaddingLayerParams_PaddingReflectionDefaultTypeInternal {
  constexpr PaddingLayerParams_PaddingReflectionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PaddingLayerParams_PaddingReflectionDefaultTypeInternal() {}
  union {
    PaddingLayerParams_PaddingReflection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PaddingLayerParams_PaddingReflectionDefaultTypeInternal _PaddingLayerParams_PaddingReflection_default_instance_;
constexpr PaddingLayerParams_PaddingReplication::PaddingLayerParams_PaddingReplication(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct PaddingLayerParams_PaddingReplicationDefaultTypeInternal {
  constexpr PaddingLayerParams_PaddingReplicationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PaddingLayerParams_PaddingReplicationDefaultTypeInternal() {}
  union {
    PaddingLayerParams_PaddingReplication _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PaddingLayerParams_PaddingReplicationDefaultTypeInternal _PaddingLayerParams_PaddingReplication_default_instance_;
constexpr PaddingLayerParams::PaddingLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : paddingamounts_(nullptr)
  , _oneof_case_{}{}
struct PaddingLayerParamsDefaultTypeInternal {
  constexpr PaddingLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PaddingLayerParamsDefaultTypeInternal() {}
  union {
    PaddingLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PaddingLayerParamsDefaultTypeInternal _PaddingLayerParams_default_instance_;
constexpr ConcatLayerParams::ConcatLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sequenceconcat_(false){}
struct ConcatLayerParamsDefaultTypeInternal {
  constexpr ConcatLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConcatLayerParamsDefaultTypeInternal() {}
  union {
    ConcatLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConcatLayerParamsDefaultTypeInternal _ConcatLayerParams_default_instance_;
constexpr LRNLayerParams::LRNLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(0)
  , beta_(0)
  , localsize_(uint64_t{0u})
  , k_(0){}
struct LRNLayerParamsDefaultTypeInternal {
  constexpr LRNLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LRNLayerParamsDefaultTypeInternal() {}
  union {
    LRNLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LRNLayerParamsDefaultTypeInternal _LRNLayerParams_default_instance_;
constexpr SoftmaxLayerParams::SoftmaxLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct SoftmaxLayerParamsDefaultTypeInternal {
  constexpr SoftmaxLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SoftmaxLayerParamsDefaultTypeInternal() {}
  union {
    SoftmaxLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SoftmaxLayerParamsDefaultTypeInternal _SoftmaxLayerParams_default_instance_;
constexpr SplitLayerParams::SplitLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : noutputs_(uint64_t{0u}){}
struct SplitLayerParamsDefaultTypeInternal {
  constexpr SplitLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SplitLayerParamsDefaultTypeInternal() {}
  union {
    SplitLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SplitLayerParamsDefaultTypeInternal _SplitLayerParams_default_instance_;
constexpr AddLayerParams::AddLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(0){}
struct AddLayerParamsDefaultTypeInternal {
  constexpr AddLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AddLayerParamsDefaultTypeInternal() {}
  union {
    AddLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AddLayerParamsDefaultTypeInternal _AddLayerParams_default_instance_;
constexpr MultiplyLayerParams::MultiplyLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(0){}
struct MultiplyLayerParamsDefaultTypeInternal {
  constexpr MultiplyLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MultiplyLayerParamsDefaultTypeInternal() {}
  union {
    MultiplyLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MultiplyLayerParamsDefaultTypeInternal _MultiplyLayerParams_default_instance_;
constexpr UnaryFunctionLayerParams::UnaryFunctionLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : type_(0)

  , alpha_(0)
  , epsilon_(0)
  , shift_(0)
  , scale_(0){}
struct UnaryFunctionLayerParamsDefaultTypeInternal {
  constexpr UnaryFunctionLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UnaryFunctionLayerParamsDefaultTypeInternal() {}
  union {
    UnaryFunctionLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UnaryFunctionLayerParamsDefaultTypeInternal _UnaryFunctionLayerParams_default_instance_;
constexpr UpsampleLayerParams::UpsampleLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : scalingfactor_()
  , _scalingfactor_cached_byte_size_(0)
  , fractionalscalingfactor_()
  , mode_(0)

  , linearupsamplemode_(0)
{}
struct UpsampleLayerParamsDefaultTypeInternal {
  constexpr UpsampleLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UpsampleLayerParamsDefaultTypeInternal() {}
  union {
    UpsampleLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UpsampleLayerParamsDefaultTypeInternal _UpsampleLayerParams_default_instance_;
constexpr ResizeBilinearLayerParams::ResizeBilinearLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : targetsize_()
  , _targetsize_cached_byte_size_(0)
  , mode_(nullptr){}
struct ResizeBilinearLayerParamsDefaultTypeInternal {
  constexpr ResizeBilinearLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ResizeBilinearLayerParamsDefaultTypeInternal() {}
  union {
    ResizeBilinearLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ResizeBilinearLayerParamsDefaultTypeInternal _ResizeBilinearLayerParams_default_instance_;
constexpr CropResizeLayerParams::CropResizeLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : targetsize_()
  , _targetsize_cached_byte_size_(0)
  , mode_(nullptr)
  , boxindicesmode_(nullptr)
  , normalizedcoordinates_(false)
  , spatialscale_(0){}
struct CropResizeLayerParamsDefaultTypeInternal {
  constexpr CropResizeLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CropResizeLayerParamsDefaultTypeInternal() {}
  union {
    CropResizeLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CropResizeLayerParamsDefaultTypeInternal _CropResizeLayerParams_default_instance_;
constexpr BiasLayerParams::BiasLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : shape_()
  , _shape_cached_byte_size_(0)
  , bias_(nullptr){}
struct BiasLayerParamsDefaultTypeInternal {
  constexpr BiasLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BiasLayerParamsDefaultTypeInternal() {}
  union {
    BiasLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BiasLayerParamsDefaultTypeInternal _BiasLayerParams_default_instance_;
constexpr ScaleLayerParams::ScaleLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : shapescale_()
  , _shapescale_cached_byte_size_(0)
  , shapebias_()
  , _shapebias_cached_byte_size_(0)
  , scale_(nullptr)
  , bias_(nullptr)
  , hasbias_(false){}
struct ScaleLayerParamsDefaultTypeInternal {
  constexpr ScaleLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ScaleLayerParamsDefaultTypeInternal() {}
  union {
    ScaleLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ScaleLayerParamsDefaultTypeInternal _ScaleLayerParams_default_instance_;
constexpr LoadConstantLayerParams::LoadConstantLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : shape_()
  , _shape_cached_byte_size_(0)
  , data_(nullptr){}
struct LoadConstantLayerParamsDefaultTypeInternal {
  constexpr LoadConstantLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LoadConstantLayerParamsDefaultTypeInternal() {}
  union {
    LoadConstantLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LoadConstantLayerParamsDefaultTypeInternal _LoadConstantLayerParams_default_instance_;
constexpr L2NormalizeLayerParams::L2NormalizeLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : epsilon_(0){}
struct L2NormalizeLayerParamsDefaultTypeInternal {
  constexpr L2NormalizeLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~L2NormalizeLayerParamsDefaultTypeInternal() {}
  union {
    L2NormalizeLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT L2NormalizeLayerParamsDefaultTypeInternal _L2NormalizeLayerParams_default_instance_;
constexpr FlattenLayerParams::FlattenLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mode_(0)
{}
struct FlattenLayerParamsDefaultTypeInternal {
  constexpr FlattenLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FlattenLayerParamsDefaultTypeInternal() {}
  union {
    FlattenLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FlattenLayerParamsDefaultTypeInternal _FlattenLayerParams_default_instance_;
constexpr ReshapeLayerParams::ReshapeLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : targetshape_()
  , _targetshape_cached_byte_size_(0)
  , mode_(0)
{}
struct ReshapeLayerParamsDefaultTypeInternal {
  constexpr ReshapeLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReshapeLayerParamsDefaultTypeInternal() {}
  union {
    ReshapeLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReshapeLayerParamsDefaultTypeInternal _ReshapeLayerParams_default_instance_;
constexpr PermuteLayerParams::PermuteLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axis_()
  , _axis_cached_byte_size_(0){}
struct PermuteLayerParamsDefaultTypeInternal {
  constexpr PermuteLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PermuteLayerParamsDefaultTypeInternal() {}
  union {
    PermuteLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PermuteLayerParamsDefaultTypeInternal _PermuteLayerParams_default_instance_;
constexpr ReorganizeDataLayerParams::ReorganizeDataLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : blocksize_(uint64_t{0u})
  , mode_(0)
{}
struct ReorganizeDataLayerParamsDefaultTypeInternal {
  constexpr ReorganizeDataLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReorganizeDataLayerParamsDefaultTypeInternal() {}
  union {
    ReorganizeDataLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReorganizeDataLayerParamsDefaultTypeInternal _ReorganizeDataLayerParams_default_instance_;
constexpr SliceLayerParams::SliceLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : startindex_(int64_t{0})
  , endindex_(int64_t{0})
  , stride_(uint64_t{0u})
  , axis_(0)
{}
struct SliceLayerParamsDefaultTypeInternal {
  constexpr SliceLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SliceLayerParamsDefaultTypeInternal() {}
  union {
    SliceLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SliceLayerParamsDefaultTypeInternal _SliceLayerParams_default_instance_;
constexpr ReduceLayerParams::ReduceLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mode_(0)

  , epsilon_(0)
  , axis_(0)
{}
struct ReduceLayerParamsDefaultTypeInternal {
  constexpr ReduceLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReduceLayerParamsDefaultTypeInternal() {}
  union {
    ReduceLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReduceLayerParamsDefaultTypeInternal _ReduceLayerParams_default_instance_;
constexpr CropLayerParams::CropLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : offset_()
  , _offset_cached_byte_size_(0)
  , cropamounts_(nullptr){}
struct CropLayerParamsDefaultTypeInternal {
  constexpr CropLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CropLayerParamsDefaultTypeInternal() {}
  union {
    CropLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CropLayerParamsDefaultTypeInternal _CropLayerParams_default_instance_;
constexpr AverageLayerParams::AverageLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct AverageLayerParamsDefaultTypeInternal {
  constexpr AverageLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AverageLayerParamsDefaultTypeInternal() {}
  union {
    AverageLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AverageLayerParamsDefaultTypeInternal _AverageLayerParams_default_instance_;
constexpr MaxLayerParams::MaxLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct MaxLayerParamsDefaultTypeInternal {
  constexpr MaxLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MaxLayerParamsDefaultTypeInternal() {}
  union {
    MaxLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MaxLayerParamsDefaultTypeInternal _MaxLayerParams_default_instance_;
constexpr MinLayerParams::MinLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct MinLayerParamsDefaultTypeInternal {
  constexpr MinLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MinLayerParamsDefaultTypeInternal() {}
  union {
    MinLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MinLayerParamsDefaultTypeInternal _MinLayerParams_default_instance_;
constexpr DotProductLayerParams::DotProductLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : cosinesimilarity_(false){}
struct DotProductLayerParamsDefaultTypeInternal {
  constexpr DotProductLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DotProductLayerParamsDefaultTypeInternal() {}
  union {
    DotProductLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DotProductLayerParamsDefaultTypeInternal _DotProductLayerParams_default_instance_;
constexpr MeanVarianceNormalizeLayerParams::MeanVarianceNormalizeLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : acrosschannels_(false)
  , normalizevariance_(false)
  , epsilon_(0){}
struct MeanVarianceNormalizeLayerParamsDefaultTypeInternal {
  constexpr MeanVarianceNormalizeLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MeanVarianceNormalizeLayerParamsDefaultTypeInternal() {}
  union {
    MeanVarianceNormalizeLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MeanVarianceNormalizeLayerParamsDefaultTypeInternal _MeanVarianceNormalizeLayerParams_default_instance_;
constexpr SequenceRepeatLayerParams::SequenceRepeatLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nrepetitions_(uint64_t{0u}){}
struct SequenceRepeatLayerParamsDefaultTypeInternal {
  constexpr SequenceRepeatLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SequenceRepeatLayerParamsDefaultTypeInternal() {}
  union {
    SequenceRepeatLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SequenceRepeatLayerParamsDefaultTypeInternal _SequenceRepeatLayerParams_default_instance_;
constexpr SimpleRecurrentLayerParams::SimpleRecurrentLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : activation_(nullptr)
  , weightmatrix_(nullptr)
  , recursionmatrix_(nullptr)
  , biasvector_(nullptr)
  , inputvectorsize_(uint64_t{0u})
  , outputvectorsize_(uint64_t{0u})
  , sequenceoutput_(false)
  , hasbiasvector_(false)
  , reverseinput_(false){}
struct SimpleRecurrentLayerParamsDefaultTypeInternal {
  constexpr SimpleRecurrentLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SimpleRecurrentLayerParamsDefaultTypeInternal() {}
  union {
    SimpleRecurrentLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SimpleRecurrentLayerParamsDefaultTypeInternal _SimpleRecurrentLayerParams_default_instance_;
constexpr GRULayerParams::GRULayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : activations_()
  , updategateweightmatrix_(nullptr)
  , resetgateweightmatrix_(nullptr)
  , outputgateweightmatrix_(nullptr)
  , updategaterecursionmatrix_(nullptr)
  , resetgaterecursionmatrix_(nullptr)
  , outputgaterecursionmatrix_(nullptr)
  , updategatebiasvector_(nullptr)
  , resetgatebiasvector_(nullptr)
  , outputgatebiasvector_(nullptr)
  , inputvectorsize_(uint64_t{0u})
  , outputvectorsize_(uint64_t{0u})
  , sequenceoutput_(false)
  , hasbiasvectors_(false)
  , reverseinput_(false){}
struct GRULayerParamsDefaultTypeInternal {
  constexpr GRULayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GRULayerParamsDefaultTypeInternal() {}
  union {
    GRULayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GRULayerParamsDefaultTypeInternal _GRULayerParams_default_instance_;
constexpr LSTMParams::LSTMParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : cellclipthreshold_(0)
  , sequenceoutput_(false)
  , hasbiasvectors_(false)
  , forgetbias_(false)
  , haspeepholevectors_(false)
  , coupledinputandforgetgate_(false){}
struct LSTMParamsDefaultTypeInternal {
  constexpr LSTMParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LSTMParamsDefaultTypeInternal() {}
  union {
    LSTMParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LSTMParamsDefaultTypeInternal _LSTMParams_default_instance_;
constexpr LSTMWeightParams::LSTMWeightParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : inputgateweightmatrix_(nullptr)
  , forgetgateweightmatrix_(nullptr)
  , blockinputweightmatrix_(nullptr)
  , outputgateweightmatrix_(nullptr)
  , inputgaterecursionmatrix_(nullptr)
  , forgetgaterecursionmatrix_(nullptr)
  , blockinputrecursionmatrix_(nullptr)
  , outputgaterecursionmatrix_(nullptr)
  , inputgatebiasvector_(nullptr)
  , forgetgatebiasvector_(nullptr)
  , blockinputbiasvector_(nullptr)
  , outputgatebiasvector_(nullptr)
  , inputgatepeepholevector_(nullptr)
  , forgetgatepeepholevector_(nullptr)
  , outputgatepeepholevector_(nullptr){}
struct LSTMWeightParamsDefaultTypeInternal {
  constexpr LSTMWeightParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LSTMWeightParamsDefaultTypeInternal() {}
  union {
    LSTMWeightParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LSTMWeightParamsDefaultTypeInternal _LSTMWeightParams_default_instance_;
constexpr UniDirectionalLSTMLayerParams::UniDirectionalLSTMLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : activations_()
  , params_(nullptr)
  , weightparams_(nullptr)
  , inputvectorsize_(uint64_t{0u})
  , outputvectorsize_(uint64_t{0u})
  , reverseinput_(false){}
struct UniDirectionalLSTMLayerParamsDefaultTypeInternal {
  constexpr UniDirectionalLSTMLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UniDirectionalLSTMLayerParamsDefaultTypeInternal() {}
  union {
    UniDirectionalLSTMLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UniDirectionalLSTMLayerParamsDefaultTypeInternal _UniDirectionalLSTMLayerParams_default_instance_;
constexpr BiDirectionalLSTMLayerParams::BiDirectionalLSTMLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : activationsforwardlstm_()
  , activationsbackwardlstm_()
  , weightparams_()
  , params_(nullptr)
  , inputvectorsize_(uint64_t{0u})
  , outputvectorsize_(uint64_t{0u}){}
struct BiDirectionalLSTMLayerParamsDefaultTypeInternal {
  constexpr BiDirectionalLSTMLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BiDirectionalLSTMLayerParamsDefaultTypeInternal() {}
  union {
    BiDirectionalLSTMLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BiDirectionalLSTMLayerParamsDefaultTypeInternal _BiDirectionalLSTMLayerParams_default_instance_;
constexpr CustomLayerParams_CustomLayerParamValue::CustomLayerParams_CustomLayerParamValue(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct CustomLayerParams_CustomLayerParamValueDefaultTypeInternal {
  constexpr CustomLayerParams_CustomLayerParamValueDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CustomLayerParams_CustomLayerParamValueDefaultTypeInternal() {}
  union {
    CustomLayerParams_CustomLayerParamValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CustomLayerParams_CustomLayerParamValueDefaultTypeInternal _CustomLayerParams_CustomLayerParamValue_default_instance_;
constexpr CustomLayerParams_ParametersEntry_DoNotUse::CustomLayerParams_ParametersEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CustomLayerParams_ParametersEntry_DoNotUseDefaultTypeInternal {
  constexpr CustomLayerParams_ParametersEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CustomLayerParams_ParametersEntry_DoNotUseDefaultTypeInternal() {}
  union {
    CustomLayerParams_ParametersEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CustomLayerParams_ParametersEntry_DoNotUseDefaultTypeInternal _CustomLayerParams_ParametersEntry_DoNotUse_default_instance_;
constexpr CustomLayerParams::CustomLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : weights_()
  , parameters_()
  , classname_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , description_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CustomLayerParamsDefaultTypeInternal {
  constexpr CustomLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CustomLayerParamsDefaultTypeInternal() {}
  union {
    CustomLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CustomLayerParamsDefaultTypeInternal _CustomLayerParams_default_instance_;
constexpr TransposeLayerParams::TransposeLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axes_()
  , _axes_cached_byte_size_(0){}
struct TransposeLayerParamsDefaultTypeInternal {
  constexpr TransposeLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TransposeLayerParamsDefaultTypeInternal() {}
  union {
    TransposeLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TransposeLayerParamsDefaultTypeInternal _TransposeLayerParams_default_instance_;
constexpr BatchedMatMulLayerParams::BatchedMatMulLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : weights_(nullptr)
  , bias_(nullptr)
  , weightmatrixfirstdimension_(uint64_t{0u})
  , weightmatrixseconddimension_(uint64_t{0u})
  , transposea_(false)
  , transposeb_(false)
  , hasbias_(false)
  , int8dynamicquantize_(false){}
struct BatchedMatMulLayerParamsDefaultTypeInternal {
  constexpr BatchedMatMulLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BatchedMatMulLayerParamsDefaultTypeInternal() {}
  union {
    BatchedMatMulLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BatchedMatMulLayerParamsDefaultTypeInternal _BatchedMatMulLayerParams_default_instance_;
constexpr ConcatNDLayerParams::ConcatNDLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axis_(int64_t{0})
  , interleave_(false){}
struct ConcatNDLayerParamsDefaultTypeInternal {
  constexpr ConcatNDLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConcatNDLayerParamsDefaultTypeInternal() {}
  union {
    ConcatNDLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConcatNDLayerParamsDefaultTypeInternal _ConcatNDLayerParams_default_instance_;
constexpr SoftmaxNDLayerParams::SoftmaxNDLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axis_(int64_t{0}){}
struct SoftmaxNDLayerParamsDefaultTypeInternal {
  constexpr SoftmaxNDLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SoftmaxNDLayerParamsDefaultTypeInternal() {}
  union {
    SoftmaxNDLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SoftmaxNDLayerParamsDefaultTypeInternal _SoftmaxNDLayerParams_default_instance_;
constexpr ReverseLayerParams::ReverseLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : reversedim_(){}
struct ReverseLayerParamsDefaultTypeInternal {
  constexpr ReverseLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReverseLayerParamsDefaultTypeInternal() {}
  union {
    ReverseLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReverseLayerParamsDefaultTypeInternal _ReverseLayerParams_default_instance_;
constexpr ReverseSeqLayerParams::ReverseSeqLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : batchaxis_(int64_t{0})
  , sequenceaxis_(int64_t{0}){}
struct ReverseSeqLayerParamsDefaultTypeInternal {
  constexpr ReverseSeqLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReverseSeqLayerParamsDefaultTypeInternal() {}
  union {
    ReverseSeqLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReverseSeqLayerParamsDefaultTypeInternal _ReverseSeqLayerParams_default_instance_;
constexpr LoadConstantNDLayerParams::LoadConstantNDLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : shape_()
  , _shape_cached_byte_size_(0)
  , data_(nullptr){}
struct LoadConstantNDLayerParamsDefaultTypeInternal {
  constexpr LoadConstantNDLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LoadConstantNDLayerParamsDefaultTypeInternal() {}
  union {
    LoadConstantNDLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LoadConstantNDLayerParamsDefaultTypeInternal _LoadConstantNDLayerParams_default_instance_;
constexpr FillLikeLayerParams::FillLikeLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : value_(0){}
struct FillLikeLayerParamsDefaultTypeInternal {
  constexpr FillLikeLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FillLikeLayerParamsDefaultTypeInternal() {}
  union {
    FillLikeLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FillLikeLayerParamsDefaultTypeInternal _FillLikeLayerParams_default_instance_;
constexpr FillStaticLayerParams::FillStaticLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : targetshape_()
  , _targetshape_cached_byte_size_(0)
  , value_(0){}
struct FillStaticLayerParamsDefaultTypeInternal {
  constexpr FillStaticLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FillStaticLayerParamsDefaultTypeInternal() {}
  union {
    FillStaticLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FillStaticLayerParamsDefaultTypeInternal _FillStaticLayerParams_default_instance_;
constexpr FillDynamicLayerParams::FillDynamicLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : value_(0){}
struct FillDynamicLayerParamsDefaultTypeInternal {
  constexpr FillDynamicLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FillDynamicLayerParamsDefaultTypeInternal() {}
  union {
    FillDynamicLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FillDynamicLayerParamsDefaultTypeInternal _FillDynamicLayerParams_default_instance_;
constexpr WhereBroadcastableLayerParams::WhereBroadcastableLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct WhereBroadcastableLayerParamsDefaultTypeInternal {
  constexpr WhereBroadcastableLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WhereBroadcastableLayerParamsDefaultTypeInternal() {}
  union {
    WhereBroadcastableLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WhereBroadcastableLayerParamsDefaultTypeInternal _WhereBroadcastableLayerParams_default_instance_;
constexpr SinLayerParams::SinLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct SinLayerParamsDefaultTypeInternal {
  constexpr SinLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SinLayerParamsDefaultTypeInternal() {}
  union {
    SinLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SinLayerParamsDefaultTypeInternal _SinLayerParams_default_instance_;
constexpr CosLayerParams::CosLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CosLayerParamsDefaultTypeInternal {
  constexpr CosLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CosLayerParamsDefaultTypeInternal() {}
  union {
    CosLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CosLayerParamsDefaultTypeInternal _CosLayerParams_default_instance_;
constexpr TanLayerParams::TanLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct TanLayerParamsDefaultTypeInternal {
  constexpr TanLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TanLayerParamsDefaultTypeInternal() {}
  union {
    TanLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TanLayerParamsDefaultTypeInternal _TanLayerParams_default_instance_;
constexpr AsinLayerParams::AsinLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct AsinLayerParamsDefaultTypeInternal {
  constexpr AsinLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AsinLayerParamsDefaultTypeInternal() {}
  union {
    AsinLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AsinLayerParamsDefaultTypeInternal _AsinLayerParams_default_instance_;
constexpr AcosLayerParams::AcosLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct AcosLayerParamsDefaultTypeInternal {
  constexpr AcosLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AcosLayerParamsDefaultTypeInternal() {}
  union {
    AcosLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AcosLayerParamsDefaultTypeInternal _AcosLayerParams_default_instance_;
constexpr AtanLayerParams::AtanLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct AtanLayerParamsDefaultTypeInternal {
  constexpr AtanLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AtanLayerParamsDefaultTypeInternal() {}
  union {
    AtanLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AtanLayerParamsDefaultTypeInternal _AtanLayerParams_default_instance_;
constexpr SinhLayerParams::SinhLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct SinhLayerParamsDefaultTypeInternal {
  constexpr SinhLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SinhLayerParamsDefaultTypeInternal() {}
  union {
    SinhLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SinhLayerParamsDefaultTypeInternal _SinhLayerParams_default_instance_;
constexpr CoshLayerParams::CoshLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CoshLayerParamsDefaultTypeInternal {
  constexpr CoshLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CoshLayerParamsDefaultTypeInternal() {}
  union {
    CoshLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CoshLayerParamsDefaultTypeInternal _CoshLayerParams_default_instance_;
constexpr TanhLayerParams::TanhLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct TanhLayerParamsDefaultTypeInternal {
  constexpr TanhLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TanhLayerParamsDefaultTypeInternal() {}
  union {
    TanhLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TanhLayerParamsDefaultTypeInternal _TanhLayerParams_default_instance_;
constexpr AsinhLayerParams::AsinhLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct AsinhLayerParamsDefaultTypeInternal {
  constexpr AsinhLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AsinhLayerParamsDefaultTypeInternal() {}
  union {
    AsinhLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AsinhLayerParamsDefaultTypeInternal _AsinhLayerParams_default_instance_;
constexpr AcoshLayerParams::AcoshLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct AcoshLayerParamsDefaultTypeInternal {
  constexpr AcoshLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AcoshLayerParamsDefaultTypeInternal() {}
  union {
    AcoshLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AcoshLayerParamsDefaultTypeInternal _AcoshLayerParams_default_instance_;
constexpr AtanhLayerParams::AtanhLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct AtanhLayerParamsDefaultTypeInternal {
  constexpr AtanhLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AtanhLayerParamsDefaultTypeInternal() {}
  union {
    AtanhLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AtanhLayerParamsDefaultTypeInternal _AtanhLayerParams_default_instance_;
constexpr PowBroadcastableLayerParams::PowBroadcastableLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct PowBroadcastableLayerParamsDefaultTypeInternal {
  constexpr PowBroadcastableLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PowBroadcastableLayerParamsDefaultTypeInternal() {}
  union {
    PowBroadcastableLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PowBroadcastableLayerParamsDefaultTypeInternal _PowBroadcastableLayerParams_default_instance_;
constexpr Exp2LayerParams::Exp2LayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct Exp2LayerParamsDefaultTypeInternal {
  constexpr Exp2LayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Exp2LayerParamsDefaultTypeInternal() {}
  union {
    Exp2LayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Exp2LayerParamsDefaultTypeInternal _Exp2LayerParams_default_instance_;
constexpr WhereNonZeroLayerParams::WhereNonZeroLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct WhereNonZeroLayerParamsDefaultTypeInternal {
  constexpr WhereNonZeroLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WhereNonZeroLayerParamsDefaultTypeInternal() {}
  union {
    WhereNonZeroLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WhereNonZeroLayerParamsDefaultTypeInternal _WhereNonZeroLayerParams_default_instance_;
constexpr MatrixBandPartLayerParams::MatrixBandPartLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : numlower_(int64_t{0})
  , numupper_(int64_t{0}){}
struct MatrixBandPartLayerParamsDefaultTypeInternal {
  constexpr MatrixBandPartLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MatrixBandPartLayerParamsDefaultTypeInternal() {}
  union {
    MatrixBandPartLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MatrixBandPartLayerParamsDefaultTypeInternal _MatrixBandPartLayerParams_default_instance_;
constexpr UpperTriangularLayerParams::UpperTriangularLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : k_(int64_t{0}){}
struct UpperTriangularLayerParamsDefaultTypeInternal {
  constexpr UpperTriangularLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UpperTriangularLayerParamsDefaultTypeInternal() {}
  union {
    UpperTriangularLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UpperTriangularLayerParamsDefaultTypeInternal _UpperTriangularLayerParams_default_instance_;
constexpr LowerTriangularLayerParams::LowerTriangularLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : k_(int64_t{0}){}
struct LowerTriangularLayerParamsDefaultTypeInternal {
  constexpr LowerTriangularLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LowerTriangularLayerParamsDefaultTypeInternal() {}
  union {
    LowerTriangularLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LowerTriangularLayerParamsDefaultTypeInternal _LowerTriangularLayerParams_default_instance_;
constexpr BroadcastToLikeLayerParams::BroadcastToLikeLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct BroadcastToLikeLayerParamsDefaultTypeInternal {
  constexpr BroadcastToLikeLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BroadcastToLikeLayerParamsDefaultTypeInternal() {}
  union {
    BroadcastToLikeLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BroadcastToLikeLayerParamsDefaultTypeInternal _BroadcastToLikeLayerParams_default_instance_;
constexpr BroadcastToStaticLayerParams::BroadcastToStaticLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : targetshape_()
  , _targetshape_cached_byte_size_(0){}
struct BroadcastToStaticLayerParamsDefaultTypeInternal {
  constexpr BroadcastToStaticLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BroadcastToStaticLayerParamsDefaultTypeInternal() {}
  union {
    BroadcastToStaticLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BroadcastToStaticLayerParamsDefaultTypeInternal _BroadcastToStaticLayerParams_default_instance_;
constexpr BroadcastToDynamicLayerParams::BroadcastToDynamicLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct BroadcastToDynamicLayerParamsDefaultTypeInternal {
  constexpr BroadcastToDynamicLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BroadcastToDynamicLayerParamsDefaultTypeInternal() {}
  union {
    BroadcastToDynamicLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BroadcastToDynamicLayerParamsDefaultTypeInternal _BroadcastToDynamicLayerParams_default_instance_;
constexpr AddBroadcastableLayerParams::AddBroadcastableLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct AddBroadcastableLayerParamsDefaultTypeInternal {
  constexpr AddBroadcastableLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AddBroadcastableLayerParamsDefaultTypeInternal() {}
  union {
    AddBroadcastableLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AddBroadcastableLayerParamsDefaultTypeInternal _AddBroadcastableLayerParams_default_instance_;
constexpr MaxBroadcastableLayerParams::MaxBroadcastableLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct MaxBroadcastableLayerParamsDefaultTypeInternal {
  constexpr MaxBroadcastableLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MaxBroadcastableLayerParamsDefaultTypeInternal() {}
  union {
    MaxBroadcastableLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MaxBroadcastableLayerParamsDefaultTypeInternal _MaxBroadcastableLayerParams_default_instance_;
constexpr MinBroadcastableLayerParams::MinBroadcastableLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct MinBroadcastableLayerParamsDefaultTypeInternal {
  constexpr MinBroadcastableLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MinBroadcastableLayerParamsDefaultTypeInternal() {}
  union {
    MinBroadcastableLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MinBroadcastableLayerParamsDefaultTypeInternal _MinBroadcastableLayerParams_default_instance_;
constexpr ModBroadcastableLayerParams::ModBroadcastableLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ModBroadcastableLayerParamsDefaultTypeInternal {
  constexpr ModBroadcastableLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModBroadcastableLayerParamsDefaultTypeInternal() {}
  union {
    ModBroadcastableLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModBroadcastableLayerParamsDefaultTypeInternal _ModBroadcastableLayerParams_default_instance_;
constexpr FloorDivBroadcastableLayerParams::FloorDivBroadcastableLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct FloorDivBroadcastableLayerParamsDefaultTypeInternal {
  constexpr FloorDivBroadcastableLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FloorDivBroadcastableLayerParamsDefaultTypeInternal() {}
  union {
    FloorDivBroadcastableLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FloorDivBroadcastableLayerParamsDefaultTypeInternal _FloorDivBroadcastableLayerParams_default_instance_;
constexpr SubtractBroadcastableLayerParams::SubtractBroadcastableLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct SubtractBroadcastableLayerParamsDefaultTypeInternal {
  constexpr SubtractBroadcastableLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SubtractBroadcastableLayerParamsDefaultTypeInternal() {}
  union {
    SubtractBroadcastableLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SubtractBroadcastableLayerParamsDefaultTypeInternal _SubtractBroadcastableLayerParams_default_instance_;
constexpr MultiplyBroadcastableLayerParams::MultiplyBroadcastableLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct MultiplyBroadcastableLayerParamsDefaultTypeInternal {
  constexpr MultiplyBroadcastableLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MultiplyBroadcastableLayerParamsDefaultTypeInternal() {}
  union {
    MultiplyBroadcastableLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MultiplyBroadcastableLayerParamsDefaultTypeInternal _MultiplyBroadcastableLayerParams_default_instance_;
constexpr DivideBroadcastableLayerParams::DivideBroadcastableLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct DivideBroadcastableLayerParamsDefaultTypeInternal {
  constexpr DivideBroadcastableLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DivideBroadcastableLayerParamsDefaultTypeInternal() {}
  union {
    DivideBroadcastableLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DivideBroadcastableLayerParamsDefaultTypeInternal _DivideBroadcastableLayerParams_default_instance_;
constexpr GatherLayerParams::GatherLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axis_(int64_t{0}){}
struct GatherLayerParamsDefaultTypeInternal {
  constexpr GatherLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GatherLayerParamsDefaultTypeInternal() {}
  union {
    GatherLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GatherLayerParamsDefaultTypeInternal _GatherLayerParams_default_instance_;
constexpr ScatterLayerParams::ScatterLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axis_(int64_t{0})
  , mode_(0)
{}
struct ScatterLayerParamsDefaultTypeInternal {
  constexpr ScatterLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ScatterLayerParamsDefaultTypeInternal() {}
  union {
    ScatterLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ScatterLayerParamsDefaultTypeInternal _ScatterLayerParams_default_instance_;
constexpr GatherNDLayerParams::GatherNDLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct GatherNDLayerParamsDefaultTypeInternal {
  constexpr GatherNDLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GatherNDLayerParamsDefaultTypeInternal() {}
  union {
    GatherNDLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GatherNDLayerParamsDefaultTypeInternal _GatherNDLayerParams_default_instance_;
constexpr ScatterNDLayerParams::ScatterNDLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mode_(0)
{}
struct ScatterNDLayerParamsDefaultTypeInternal {
  constexpr ScatterNDLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ScatterNDLayerParamsDefaultTypeInternal() {}
  union {
    ScatterNDLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ScatterNDLayerParamsDefaultTypeInternal _ScatterNDLayerParams_default_instance_;
constexpr GatherAlongAxisLayerParams::GatherAlongAxisLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axis_(int64_t{0}){}
struct GatherAlongAxisLayerParamsDefaultTypeInternal {
  constexpr GatherAlongAxisLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GatherAlongAxisLayerParamsDefaultTypeInternal() {}
  union {
    GatherAlongAxisLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GatherAlongAxisLayerParamsDefaultTypeInternal _GatherAlongAxisLayerParams_default_instance_;
constexpr ScatterAlongAxisLayerParams::ScatterAlongAxisLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axis_(int64_t{0})
  , mode_(0)
{}
struct ScatterAlongAxisLayerParamsDefaultTypeInternal {
  constexpr ScatterAlongAxisLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ScatterAlongAxisLayerParamsDefaultTypeInternal() {}
  union {
    ScatterAlongAxisLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ScatterAlongAxisLayerParamsDefaultTypeInternal _ScatterAlongAxisLayerParams_default_instance_;
constexpr StackLayerParams::StackLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axis_(int64_t{0}){}
struct StackLayerParamsDefaultTypeInternal {
  constexpr StackLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StackLayerParamsDefaultTypeInternal() {}
  union {
    StackLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StackLayerParamsDefaultTypeInternal _StackLayerParams_default_instance_;
constexpr RankPreservingReshapeLayerParams::RankPreservingReshapeLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : targetshape_()
  , _targetshape_cached_byte_size_(0){}
struct RankPreservingReshapeLayerParamsDefaultTypeInternal {
  constexpr RankPreservingReshapeLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RankPreservingReshapeLayerParamsDefaultTypeInternal() {}
  union {
    RankPreservingReshapeLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RankPreservingReshapeLayerParamsDefaultTypeInternal _RankPreservingReshapeLayerParams_default_instance_;
constexpr ConstantPaddingLayerParams::ConstantPaddingLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : padamounts_()
  , _padamounts_cached_byte_size_(0)
  , value_(0)
  , padtogivenoutputsizemode_(false){}
struct ConstantPaddingLayerParamsDefaultTypeInternal {
  constexpr ConstantPaddingLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConstantPaddingLayerParamsDefaultTypeInternal() {}
  union {
    ConstantPaddingLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConstantPaddingLayerParamsDefaultTypeInternal _ConstantPaddingLayerParams_default_instance_;
constexpr RandomNormalLikeLayerParams::RandomNormalLikeLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : seed_(int64_t{0})
  , mean_(0)
  , stddev_(0){}
struct RandomNormalLikeLayerParamsDefaultTypeInternal {
  constexpr RandomNormalLikeLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RandomNormalLikeLayerParamsDefaultTypeInternal() {}
  union {
    RandomNormalLikeLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RandomNormalLikeLayerParamsDefaultTypeInternal _RandomNormalLikeLayerParams_default_instance_;
constexpr RandomNormalStaticLayerParams::RandomNormalStaticLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : outputshape_()
  , _outputshape_cached_byte_size_(0)
  , seed_(int64_t{0})
  , mean_(0)
  , stddev_(0){}
struct RandomNormalStaticLayerParamsDefaultTypeInternal {
  constexpr RandomNormalStaticLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RandomNormalStaticLayerParamsDefaultTypeInternal() {}
  union {
    RandomNormalStaticLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RandomNormalStaticLayerParamsDefaultTypeInternal _RandomNormalStaticLayerParams_default_instance_;
constexpr RandomNormalDynamicLayerParams::RandomNormalDynamicLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : seed_(int64_t{0})
  , mean_(0)
  , stddev_(0){}
struct RandomNormalDynamicLayerParamsDefaultTypeInternal {
  constexpr RandomNormalDynamicLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RandomNormalDynamicLayerParamsDefaultTypeInternal() {}
  union {
    RandomNormalDynamicLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RandomNormalDynamicLayerParamsDefaultTypeInternal _RandomNormalDynamicLayerParams_default_instance_;
constexpr RandomUniformLikeLayerParams::RandomUniformLikeLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : seed_(int64_t{0})
  , minval_(0)
  , maxval_(0){}
struct RandomUniformLikeLayerParamsDefaultTypeInternal {
  constexpr RandomUniformLikeLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RandomUniformLikeLayerParamsDefaultTypeInternal() {}
  union {
    RandomUniformLikeLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RandomUniformLikeLayerParamsDefaultTypeInternal _RandomUniformLikeLayerParams_default_instance_;
constexpr RandomUniformStaticLayerParams::RandomUniformStaticLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : outputshape_()
  , _outputshape_cached_byte_size_(0)
  , seed_(int64_t{0})
  , minval_(0)
  , maxval_(0){}
struct RandomUniformStaticLayerParamsDefaultTypeInternal {
  constexpr RandomUniformStaticLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RandomUniformStaticLayerParamsDefaultTypeInternal() {}
  union {
    RandomUniformStaticLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RandomUniformStaticLayerParamsDefaultTypeInternal _RandomUniformStaticLayerParams_default_instance_;
constexpr RandomUniformDynamicLayerParams::RandomUniformDynamicLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : seed_(int64_t{0})
  , minval_(0)
  , maxval_(0){}
struct RandomUniformDynamicLayerParamsDefaultTypeInternal {
  constexpr RandomUniformDynamicLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RandomUniformDynamicLayerParamsDefaultTypeInternal() {}
  union {
    RandomUniformDynamicLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RandomUniformDynamicLayerParamsDefaultTypeInternal _RandomUniformDynamicLayerParams_default_instance_;
constexpr RandomBernoulliLikeLayerParams::RandomBernoulliLikeLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : seed_(int64_t{0})
  , prob_(0){}
struct RandomBernoulliLikeLayerParamsDefaultTypeInternal {
  constexpr RandomBernoulliLikeLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RandomBernoulliLikeLayerParamsDefaultTypeInternal() {}
  union {
    RandomBernoulliLikeLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RandomBernoulliLikeLayerParamsDefaultTypeInternal _RandomBernoulliLikeLayerParams_default_instance_;
constexpr RandomBernoulliStaticLayerParams::RandomBernoulliStaticLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : outputshape_()
  , _outputshape_cached_byte_size_(0)
  , seed_(int64_t{0})
  , prob_(0){}
struct RandomBernoulliStaticLayerParamsDefaultTypeInternal {
  constexpr RandomBernoulliStaticLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RandomBernoulliStaticLayerParamsDefaultTypeInternal() {}
  union {
    RandomBernoulliStaticLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RandomBernoulliStaticLayerParamsDefaultTypeInternal _RandomBernoulliStaticLayerParams_default_instance_;
constexpr RandomBernoulliDynamicLayerParams::RandomBernoulliDynamicLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : seed_(int64_t{0})
  , prob_(0){}
struct RandomBernoulliDynamicLayerParamsDefaultTypeInternal {
  constexpr RandomBernoulliDynamicLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RandomBernoulliDynamicLayerParamsDefaultTypeInternal() {}
  union {
    RandomBernoulliDynamicLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RandomBernoulliDynamicLayerParamsDefaultTypeInternal _RandomBernoulliDynamicLayerParams_default_instance_;
constexpr CategoricalDistributionLayerParams::CategoricalDistributionLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : seed_(int64_t{0})
  , numsamples_(int64_t{0})
  , islogits_(false)
  , eps_(0)
  , temperature_(0){}
struct CategoricalDistributionLayerParamsDefaultTypeInternal {
  constexpr CategoricalDistributionLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CategoricalDistributionLayerParamsDefaultTypeInternal() {}
  union {
    CategoricalDistributionLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CategoricalDistributionLayerParamsDefaultTypeInternal _CategoricalDistributionLayerParams_default_instance_;
constexpr ReduceL1LayerParams::ReduceL1LayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axes_()
  , _axes_cached_byte_size_(0)
  , keepdims_(false)
  , reduceall_(false){}
struct ReduceL1LayerParamsDefaultTypeInternal {
  constexpr ReduceL1LayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReduceL1LayerParamsDefaultTypeInternal() {}
  union {
    ReduceL1LayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReduceL1LayerParamsDefaultTypeInternal _ReduceL1LayerParams_default_instance_;
constexpr ReduceL2LayerParams::ReduceL2LayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axes_()
  , _axes_cached_byte_size_(0)
  , keepdims_(false)
  , reduceall_(false){}
struct ReduceL2LayerParamsDefaultTypeInternal {
  constexpr ReduceL2LayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReduceL2LayerParamsDefaultTypeInternal() {}
  union {
    ReduceL2LayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReduceL2LayerParamsDefaultTypeInternal _ReduceL2LayerParams_default_instance_;
constexpr ReduceMaxLayerParams::ReduceMaxLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axes_()
  , _axes_cached_byte_size_(0)
  , keepdims_(false)
  , reduceall_(false){}
struct ReduceMaxLayerParamsDefaultTypeInternal {
  constexpr ReduceMaxLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReduceMaxLayerParamsDefaultTypeInternal() {}
  union {
    ReduceMaxLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReduceMaxLayerParamsDefaultTypeInternal _ReduceMaxLayerParams_default_instance_;
constexpr ReduceMinLayerParams::ReduceMinLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axes_()
  , _axes_cached_byte_size_(0)
  , keepdims_(false)
  , reduceall_(false){}
struct ReduceMinLayerParamsDefaultTypeInternal {
  constexpr ReduceMinLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReduceMinLayerParamsDefaultTypeInternal() {}
  union {
    ReduceMinLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReduceMinLayerParamsDefaultTypeInternal _ReduceMinLayerParams_default_instance_;
constexpr ReduceSumLayerParams::ReduceSumLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axes_()
  , _axes_cached_byte_size_(0)
  , keepdims_(false)
  , reduceall_(false){}
struct ReduceSumLayerParamsDefaultTypeInternal {
  constexpr ReduceSumLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReduceSumLayerParamsDefaultTypeInternal() {}
  union {
    ReduceSumLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReduceSumLayerParamsDefaultTypeInternal _ReduceSumLayerParams_default_instance_;
constexpr ReduceProdLayerParams::ReduceProdLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axes_()
  , _axes_cached_byte_size_(0)
  , keepdims_(false)
  , reduceall_(false){}
struct ReduceProdLayerParamsDefaultTypeInternal {
  constexpr ReduceProdLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReduceProdLayerParamsDefaultTypeInternal() {}
  union {
    ReduceProdLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReduceProdLayerParamsDefaultTypeInternal _ReduceProdLayerParams_default_instance_;
constexpr ReduceMeanLayerParams::ReduceMeanLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axes_()
  , _axes_cached_byte_size_(0)
  , keepdims_(false)
  , reduceall_(false){}
struct ReduceMeanLayerParamsDefaultTypeInternal {
  constexpr ReduceMeanLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReduceMeanLayerParamsDefaultTypeInternal() {}
  union {
    ReduceMeanLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReduceMeanLayerParamsDefaultTypeInternal _ReduceMeanLayerParams_default_instance_;
constexpr ReduceLogSumLayerParams::ReduceLogSumLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axes_()
  , _axes_cached_byte_size_(0)
  , keepdims_(false)
  , reduceall_(false){}
struct ReduceLogSumLayerParamsDefaultTypeInternal {
  constexpr ReduceLogSumLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReduceLogSumLayerParamsDefaultTypeInternal() {}
  union {
    ReduceLogSumLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReduceLogSumLayerParamsDefaultTypeInternal _ReduceLogSumLayerParams_default_instance_;
constexpr ReduceSumSquareLayerParams::ReduceSumSquareLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axes_()
  , _axes_cached_byte_size_(0)
  , keepdims_(false)
  , reduceall_(false){}
struct ReduceSumSquareLayerParamsDefaultTypeInternal {
  constexpr ReduceSumSquareLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReduceSumSquareLayerParamsDefaultTypeInternal() {}
  union {
    ReduceSumSquareLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReduceSumSquareLayerParamsDefaultTypeInternal _ReduceSumSquareLayerParams_default_instance_;
constexpr ReduceLogSumExpLayerParams::ReduceLogSumExpLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axes_()
  , _axes_cached_byte_size_(0)
  , keepdims_(false)
  , reduceall_(false){}
struct ReduceLogSumExpLayerParamsDefaultTypeInternal {
  constexpr ReduceLogSumExpLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReduceLogSumExpLayerParamsDefaultTypeInternal() {}
  union {
    ReduceLogSumExpLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReduceLogSumExpLayerParamsDefaultTypeInternal _ReduceLogSumExpLayerParams_default_instance_;
constexpr ExpandDimsLayerParams::ExpandDimsLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axes_()
  , _axes_cached_byte_size_(0){}
struct ExpandDimsLayerParamsDefaultTypeInternal {
  constexpr ExpandDimsLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ExpandDimsLayerParamsDefaultTypeInternal() {}
  union {
    ExpandDimsLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ExpandDimsLayerParamsDefaultTypeInternal _ExpandDimsLayerParams_default_instance_;
constexpr FlattenTo2DLayerParams::FlattenTo2DLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axis_(int64_t{0}){}
struct FlattenTo2DLayerParamsDefaultTypeInternal {
  constexpr FlattenTo2DLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FlattenTo2DLayerParamsDefaultTypeInternal() {}
  union {
    FlattenTo2DLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FlattenTo2DLayerParamsDefaultTypeInternal _FlattenTo2DLayerParams_default_instance_;
constexpr ReshapeStaticLayerParams::ReshapeStaticLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : targetshape_()
  , _targetshape_cached_byte_size_(0){}
struct ReshapeStaticLayerParamsDefaultTypeInternal {
  constexpr ReshapeStaticLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReshapeStaticLayerParamsDefaultTypeInternal() {}
  union {
    ReshapeStaticLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReshapeStaticLayerParamsDefaultTypeInternal _ReshapeStaticLayerParams_default_instance_;
constexpr ReshapeLikeLayerParams::ReshapeLikeLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ReshapeLikeLayerParamsDefaultTypeInternal {
  constexpr ReshapeLikeLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReshapeLikeLayerParamsDefaultTypeInternal() {}
  union {
    ReshapeLikeLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReshapeLikeLayerParamsDefaultTypeInternal _ReshapeLikeLayerParams_default_instance_;
constexpr ReshapeDynamicLayerParams::ReshapeDynamicLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ReshapeDynamicLayerParamsDefaultTypeInternal {
  constexpr ReshapeDynamicLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ReshapeDynamicLayerParamsDefaultTypeInternal() {}
  union {
    ReshapeDynamicLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ReshapeDynamicLayerParamsDefaultTypeInternal _ReshapeDynamicLayerParams_default_instance_;
constexpr SqueezeLayerParams::SqueezeLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axes_()
  , _axes_cached_byte_size_(0)
  , squeezeall_(false){}
struct SqueezeLayerParamsDefaultTypeInternal {
  constexpr SqueezeLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SqueezeLayerParamsDefaultTypeInternal() {}
  union {
    SqueezeLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SqueezeLayerParamsDefaultTypeInternal _SqueezeLayerParams_default_instance_;
constexpr TopKLayerParams::TopKLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axis_(int64_t{0})
  , k_(uint64_t{0u})
  , usebottomk_(false){}
struct TopKLayerParamsDefaultTypeInternal {
  constexpr TopKLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TopKLayerParamsDefaultTypeInternal() {}
  union {
    TopKLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TopKLayerParamsDefaultTypeInternal _TopKLayerParams_default_instance_;
constexpr ArgMaxLayerParams::ArgMaxLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axis_(int64_t{0})
  , removedim_(false){}
struct ArgMaxLayerParamsDefaultTypeInternal {
  constexpr ArgMaxLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ArgMaxLayerParamsDefaultTypeInternal() {}
  union {
    ArgMaxLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ArgMaxLayerParamsDefaultTypeInternal _ArgMaxLayerParams_default_instance_;
constexpr ArgMinLayerParams::ArgMinLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axis_(int64_t{0})
  , removedim_(false){}
struct ArgMinLayerParamsDefaultTypeInternal {
  constexpr ArgMinLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ArgMinLayerParamsDefaultTypeInternal() {}
  union {
    ArgMinLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ArgMinLayerParamsDefaultTypeInternal _ArgMinLayerParams_default_instance_;
constexpr SplitNDLayerParams::SplitNDLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : splitsizes_()
  , _splitsizes_cached_byte_size_(0)
  , axis_(int64_t{0})
  , numsplits_(uint64_t{0u}){}
struct SplitNDLayerParamsDefaultTypeInternal {
  constexpr SplitNDLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SplitNDLayerParamsDefaultTypeInternal() {}
  union {
    SplitNDLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SplitNDLayerParamsDefaultTypeInternal _SplitNDLayerParams_default_instance_;
constexpr CeilLayerParams::CeilLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CeilLayerParamsDefaultTypeInternal {
  constexpr CeilLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CeilLayerParamsDefaultTypeInternal() {}
  union {
    CeilLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CeilLayerParamsDefaultTypeInternal _CeilLayerParams_default_instance_;
constexpr RoundLayerParams::RoundLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct RoundLayerParamsDefaultTypeInternal {
  constexpr RoundLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RoundLayerParamsDefaultTypeInternal() {}
  union {
    RoundLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RoundLayerParamsDefaultTypeInternal _RoundLayerParams_default_instance_;
constexpr FloorLayerParams::FloorLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct FloorLayerParamsDefaultTypeInternal {
  constexpr FloorLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FloorLayerParamsDefaultTypeInternal() {}
  union {
    FloorLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FloorLayerParamsDefaultTypeInternal _FloorLayerParams_default_instance_;
constexpr SignLayerParams::SignLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct SignLayerParamsDefaultTypeInternal {
  constexpr SignLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SignLayerParamsDefaultTypeInternal() {}
  union {
    SignLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SignLayerParamsDefaultTypeInternal _SignLayerParams_default_instance_;
constexpr ClipLayerParams::ClipLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : minval_(0)
  , maxval_(0){}
struct ClipLayerParamsDefaultTypeInternal {
  constexpr ClipLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ClipLayerParamsDefaultTypeInternal() {}
  union {
    ClipLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ClipLayerParamsDefaultTypeInternal _ClipLayerParams_default_instance_;
constexpr SliceStaticLayerParams::SliceStaticLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : beginids_()
  , _beginids_cached_byte_size_(0)
  , beginmasks_()
  , endids_()
  , _endids_cached_byte_size_(0)
  , endmasks_()
  , strides_()
  , _strides_cached_byte_size_(0)
  , squeezemasks_(){}
struct SliceStaticLayerParamsDefaultTypeInternal {
  constexpr SliceStaticLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SliceStaticLayerParamsDefaultTypeInternal() {}
  union {
    SliceStaticLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SliceStaticLayerParamsDefaultTypeInternal _SliceStaticLayerParams_default_instance_;
constexpr SliceDynamicLayerParams::SliceDynamicLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : beginmasks_()
  , endids_()
  , _endids_cached_byte_size_(0)
  , endmasks_()
  , strides_()
  , _strides_cached_byte_size_(0)
  , squeezemasks_(){}
struct SliceDynamicLayerParamsDefaultTypeInternal {
  constexpr SliceDynamicLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SliceDynamicLayerParamsDefaultTypeInternal() {}
  union {
    SliceDynamicLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SliceDynamicLayerParamsDefaultTypeInternal _SliceDynamicLayerParams_default_instance_;
constexpr TileLayerParams::TileLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : reps_()
  , _reps_cached_byte_size_(0){}
struct TileLayerParamsDefaultTypeInternal {
  constexpr TileLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TileLayerParamsDefaultTypeInternal() {}
  union {
    TileLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TileLayerParamsDefaultTypeInternal _TileLayerParams_default_instance_;
constexpr GetShapeLayerParams::GetShapeLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct GetShapeLayerParamsDefaultTypeInternal {
  constexpr GetShapeLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetShapeLayerParamsDefaultTypeInternal() {}
  union {
    GetShapeLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetShapeLayerParamsDefaultTypeInternal _GetShapeLayerParams_default_instance_;
constexpr ErfLayerParams::ErfLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ErfLayerParamsDefaultTypeInternal {
  constexpr ErfLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ErfLayerParamsDefaultTypeInternal() {}
  union {
    ErfLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ErfLayerParamsDefaultTypeInternal _ErfLayerParams_default_instance_;
constexpr GeluLayerParams::GeluLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mode_(0)
{}
struct GeluLayerParamsDefaultTypeInternal {
  constexpr GeluLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GeluLayerParamsDefaultTypeInternal() {}
  union {
    GeluLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GeluLayerParamsDefaultTypeInternal _GeluLayerParams_default_instance_;
constexpr RangeStaticLayerParams::RangeStaticLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : endvalue_(0)
  , startvalue_(0)
  , stepsizevalue_(0){}
struct RangeStaticLayerParamsDefaultTypeInternal {
  constexpr RangeStaticLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RangeStaticLayerParamsDefaultTypeInternal() {}
  union {
    RangeStaticLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RangeStaticLayerParamsDefaultTypeInternal _RangeStaticLayerParams_default_instance_;
constexpr RangeDynamicLayerParams::RangeDynamicLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : startvalue_(0)
  , stepsizevalue_(0){}
struct RangeDynamicLayerParamsDefaultTypeInternal {
  constexpr RangeDynamicLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RangeDynamicLayerParamsDefaultTypeInternal() {}
  union {
    RangeDynamicLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RangeDynamicLayerParamsDefaultTypeInternal _RangeDynamicLayerParams_default_instance_;
constexpr SlidingWindowsLayerParams::SlidingWindowsLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axis_(int64_t{0})
  , windowsize_(uint64_t{0u})
  , step_(uint64_t{0u}){}
struct SlidingWindowsLayerParamsDefaultTypeInternal {
  constexpr SlidingWindowsLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SlidingWindowsLayerParamsDefaultTypeInternal() {}
  union {
    SlidingWindowsLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SlidingWindowsLayerParamsDefaultTypeInternal _SlidingWindowsLayerParams_default_instance_;
constexpr LayerNormalizationLayerParams::LayerNormalizationLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : normalizedshape_()
  , _normalizedshape_cached_byte_size_(0)
  , gamma_(nullptr)
  , beta_(nullptr)
  , eps_(0){}
struct LayerNormalizationLayerParamsDefaultTypeInternal {
  constexpr LayerNormalizationLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LayerNormalizationLayerParamsDefaultTypeInternal() {}
  union {
    LayerNormalizationLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LayerNormalizationLayerParamsDefaultTypeInternal _LayerNormalizationLayerParams_default_instance_;
constexpr NonMaximumSuppressionLayerParams::NonMaximumSuppressionLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : iouthreshold_(0)
  , scorethreshold_(0)
  , maxboxes_(uint64_t{0u})
  , perclasssuppression_(false){}
struct NonMaximumSuppressionLayerParamsDefaultTypeInternal {
  constexpr NonMaximumSuppressionLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NonMaximumSuppressionLayerParamsDefaultTypeInternal() {}
  union {
    NonMaximumSuppressionLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NonMaximumSuppressionLayerParamsDefaultTypeInternal _NonMaximumSuppressionLayerParams_default_instance_;
constexpr ClampedReLULayerParams::ClampedReLULayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : alpha_(0)
  , beta_(0){}
struct ClampedReLULayerParamsDefaultTypeInternal {
  constexpr ClampedReLULayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ClampedReLULayerParamsDefaultTypeInternal() {}
  union {
    ClampedReLULayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ClampedReLULayerParamsDefaultTypeInternal _ClampedReLULayerParams_default_instance_;
constexpr ArgSortLayerParams::ArgSortLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axis_(int64_t{0})
  , descending_(false){}
struct ArgSortLayerParamsDefaultTypeInternal {
  constexpr ArgSortLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ArgSortLayerParamsDefaultTypeInternal() {}
  union {
    ArgSortLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ArgSortLayerParamsDefaultTypeInternal _ArgSortLayerParams_default_instance_;
constexpr SliceBySizeLayerParams::SliceBySizeLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : size_(int64_t{0})
  , axis_(int64_t{0}){}
struct SliceBySizeLayerParamsDefaultTypeInternal {
  constexpr SliceBySizeLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SliceBySizeLayerParamsDefaultTypeInternal() {}
  union {
    SliceBySizeLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SliceBySizeLayerParamsDefaultTypeInternal _SliceBySizeLayerParams_default_instance_;
constexpr NeuralNetworkClassifier::NeuralNetworkClassifier(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : layers_()
  , preprocessing_()
  , labelprobabilitylayername_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , updateparams_(nullptr)
  , arrayinputshapemapping_(0)

  , imageinputshapemapping_(0)

  , _oneof_case_{}{}
struct NeuralNetworkClassifierDefaultTypeInternal {
  constexpr NeuralNetworkClassifierDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NeuralNetworkClassifierDefaultTypeInternal() {}
  union {
    NeuralNetworkClassifier _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NeuralNetworkClassifierDefaultTypeInternal _NeuralNetworkClassifier_default_instance_;
constexpr OneHotLayerParams::OneHotLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : onehotvectorsize_(uint64_t{0u})
  , axis_(int64_t{0})
  , onvalue_(0)
  , offvalue_(0){}
struct OneHotLayerParamsDefaultTypeInternal {
  constexpr OneHotLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~OneHotLayerParamsDefaultTypeInternal() {}
  union {
    OneHotLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OneHotLayerParamsDefaultTypeInternal _OneHotLayerParams_default_instance_;
constexpr CumSumLayerParams::CumSumLayerParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : axis_(int64_t{0})
  , excludefinalsum_(false)
  , reverse_(false){}
struct CumSumLayerParamsDefaultTypeInternal {
  constexpr CumSumLayerParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CumSumLayerParamsDefaultTypeInternal() {}
  union {
    CumSumLayerParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CumSumLayerParamsDefaultTypeInternal _CumSumLayerParams_default_instance_;
constexpr NeuralNetworkRegressor::NeuralNetworkRegressor(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : layers_()
  , preprocessing_()
  , updateparams_(nullptr)
  , arrayinputshapemapping_(0)

  , imageinputshapemapping_(0)
{}
struct NeuralNetworkRegressorDefaultTypeInternal {
  constexpr NeuralNetworkRegressorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NeuralNetworkRegressorDefaultTypeInternal() {}
  union {
    NeuralNetworkRegressor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NeuralNetworkRegressorDefaultTypeInternal _NeuralNetworkRegressor_default_instance_;
constexpr NetworkUpdateParameters::NetworkUpdateParameters(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : losslayers_()
  , optimizer_(nullptr)
  , epochs_(nullptr)
  , shuffle_(nullptr)
  , seed_(nullptr){}
struct NetworkUpdateParametersDefaultTypeInternal {
  constexpr NetworkUpdateParametersDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NetworkUpdateParametersDefaultTypeInternal() {}
  union {
    NetworkUpdateParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NetworkUpdateParametersDefaultTypeInternal _NetworkUpdateParameters_default_instance_;
constexpr LossLayer::LossLayer(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , _oneof_case_{}{}
struct LossLayerDefaultTypeInternal {
  constexpr LossLayerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LossLayerDefaultTypeInternal() {}
  union {
    LossLayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LossLayerDefaultTypeInternal _LossLayer_default_instance_;
constexpr CategoricalCrossEntropyLossLayer::CategoricalCrossEntropyLossLayer(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : input_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , target_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CategoricalCrossEntropyLossLayerDefaultTypeInternal {
  constexpr CategoricalCrossEntropyLossLayerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CategoricalCrossEntropyLossLayerDefaultTypeInternal() {}
  union {
    CategoricalCrossEntropyLossLayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CategoricalCrossEntropyLossLayerDefaultTypeInternal _CategoricalCrossEntropyLossLayer_default_instance_;
constexpr MeanSquaredErrorLossLayer::MeanSquaredErrorLossLayer(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : input_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , target_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct MeanSquaredErrorLossLayerDefaultTypeInternal {
  constexpr MeanSquaredErrorLossLayerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MeanSquaredErrorLossLayerDefaultTypeInternal() {}
  union {
    MeanSquaredErrorLossLayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MeanSquaredErrorLossLayerDefaultTypeInternal _MeanSquaredErrorLossLayer_default_instance_;
constexpr Optimizer::Optimizer(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct OptimizerDefaultTypeInternal {
  constexpr OptimizerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~OptimizerDefaultTypeInternal() {}
  union {
    Optimizer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OptimizerDefaultTypeInternal _Optimizer_default_instance_;
constexpr SGDOptimizer::SGDOptimizer(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : learningrate_(nullptr)
  , minibatchsize_(nullptr)
  , momentum_(nullptr){}
struct SGDOptimizerDefaultTypeInternal {
  constexpr SGDOptimizerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SGDOptimizerDefaultTypeInternal() {}
  union {
    SGDOptimizer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SGDOptimizerDefaultTypeInternal _SGDOptimizer_default_instance_;
constexpr AdamOptimizer::AdamOptimizer(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : learningrate_(nullptr)
  , minibatchsize_(nullptr)
  , beta1_(nullptr)
  , beta2_(nullptr)
  , eps_(nullptr){}
struct AdamOptimizerDefaultTypeInternal {
  constexpr AdamOptimizerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AdamOptimizerDefaultTypeInternal() {}
  union {
    AdamOptimizer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AdamOptimizerDefaultTypeInternal _AdamOptimizer_default_instance_;
}  // namespace Specification
}  // namespace CoreML
namespace CoreML {
namespace Specification {
bool SamePadding_SamePaddingMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SamePadding_SamePaddingMode_strings[2] = {};

static const char SamePadding_SamePaddingMode_names[] =
  "BOTTOM_RIGHT_HEAVY"
  "TOP_LEFT_HEAVY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SamePadding_SamePaddingMode_entries[] = {
  { {SamePadding_SamePaddingMode_names + 0, 18}, 0 },
  { {SamePadding_SamePaddingMode_names + 18, 14}, 1 },
};

static const int SamePadding_SamePaddingMode_entries_by_number[] = {
  0, // 0 -> BOTTOM_RIGHT_HEAVY
  1, // 1 -> TOP_LEFT_HEAVY
};

const std::string& SamePadding_SamePaddingMode_Name(
    SamePadding_SamePaddingMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SamePadding_SamePaddingMode_entries,
          SamePadding_SamePaddingMode_entries_by_number,
          2, SamePadding_SamePaddingMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SamePadding_SamePaddingMode_entries,
      SamePadding_SamePaddingMode_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SamePadding_SamePaddingMode_strings[idx].get();
}
bool SamePadding_SamePaddingMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SamePadding_SamePaddingMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SamePadding_SamePaddingMode_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<SamePadding_SamePaddingMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SamePadding_SamePaddingMode SamePadding::BOTTOM_RIGHT_HEAVY;
constexpr SamePadding_SamePaddingMode SamePadding::TOP_LEFT_HEAVY;
constexpr SamePadding_SamePaddingMode SamePadding::SamePaddingMode_MIN;
constexpr SamePadding_SamePaddingMode SamePadding::SamePaddingMode_MAX;
constexpr int SamePadding::SamePaddingMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SamplingMode_Method_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SamplingMode_Method_strings[4] = {};

static const char SamplingMode_Method_names[] =
  "ALIGN_ENDPOINTS_MODE"
  "ROI_ALIGN_MODE"
  "STRICT_ALIGN_ENDPOINTS_MODE"
  "UPSAMPLE_MODE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SamplingMode_Method_entries[] = {
  { {SamplingMode_Method_names + 0, 20}, 1 },
  { {SamplingMode_Method_names + 20, 14}, 3 },
  { {SamplingMode_Method_names + 34, 27}, 0 },
  { {SamplingMode_Method_names + 61, 13}, 2 },
};

static const int SamplingMode_Method_entries_by_number[] = {
  2, // 0 -> STRICT_ALIGN_ENDPOINTS_MODE
  0, // 1 -> ALIGN_ENDPOINTS_MODE
  3, // 2 -> UPSAMPLE_MODE
  1, // 3 -> ROI_ALIGN_MODE
};

const std::string& SamplingMode_Method_Name(
    SamplingMode_Method value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SamplingMode_Method_entries,
          SamplingMode_Method_entries_by_number,
          4, SamplingMode_Method_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SamplingMode_Method_entries,
      SamplingMode_Method_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SamplingMode_Method_strings[idx].get();
}
bool SamplingMode_Method_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SamplingMode_Method* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SamplingMode_Method_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<SamplingMode_Method>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SamplingMode_Method SamplingMode::STRICT_ALIGN_ENDPOINTS_MODE;
constexpr SamplingMode_Method SamplingMode::ALIGN_ENDPOINTS_MODE;
constexpr SamplingMode_Method SamplingMode::UPSAMPLE_MODE;
constexpr SamplingMode_Method SamplingMode::ROI_ALIGN_MODE;
constexpr SamplingMode_Method SamplingMode::Method_MIN;
constexpr SamplingMode_Method SamplingMode::Method_MAX;
constexpr int SamplingMode::Method_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool BoxCoordinatesMode_Coordinates_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BoxCoordinatesMode_Coordinates_strings[4] = {};

static const char BoxCoordinatesMode_Coordinates_names[] =
  "CENTER_SIZE_HEIGHT_FIRST"
  "CENTER_SIZE_WIDTH_FIRST"
  "CORNERS_HEIGHT_FIRST"
  "CORNERS_WIDTH_FIRST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BoxCoordinatesMode_Coordinates_entries[] = {
  { {BoxCoordinatesMode_Coordinates_names + 0, 24}, 2 },
  { {BoxCoordinatesMode_Coordinates_names + 24, 23}, 3 },
  { {BoxCoordinatesMode_Coordinates_names + 47, 20}, 0 },
  { {BoxCoordinatesMode_Coordinates_names + 67, 19}, 1 },
};

static const int BoxCoordinatesMode_Coordinates_entries_by_number[] = {
  2, // 0 -> CORNERS_HEIGHT_FIRST
  3, // 1 -> CORNERS_WIDTH_FIRST
  0, // 2 -> CENTER_SIZE_HEIGHT_FIRST
  1, // 3 -> CENTER_SIZE_WIDTH_FIRST
};

const std::string& BoxCoordinatesMode_Coordinates_Name(
    BoxCoordinatesMode_Coordinates value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BoxCoordinatesMode_Coordinates_entries,
          BoxCoordinatesMode_Coordinates_entries_by_number,
          4, BoxCoordinatesMode_Coordinates_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BoxCoordinatesMode_Coordinates_entries,
      BoxCoordinatesMode_Coordinates_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BoxCoordinatesMode_Coordinates_strings[idx].get();
}
bool BoxCoordinatesMode_Coordinates_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BoxCoordinatesMode_Coordinates* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BoxCoordinatesMode_Coordinates_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<BoxCoordinatesMode_Coordinates>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BoxCoordinatesMode_Coordinates BoxCoordinatesMode::CORNERS_HEIGHT_FIRST;
constexpr BoxCoordinatesMode_Coordinates BoxCoordinatesMode::CORNERS_WIDTH_FIRST;
constexpr BoxCoordinatesMode_Coordinates BoxCoordinatesMode::CENTER_SIZE_HEIGHT_FIRST;
constexpr BoxCoordinatesMode_Coordinates BoxCoordinatesMode::CENTER_SIZE_WIDTH_FIRST;
constexpr BoxCoordinatesMode_Coordinates BoxCoordinatesMode::Coordinates_MIN;
constexpr BoxCoordinatesMode_Coordinates BoxCoordinatesMode::Coordinates_MAX;
constexpr int BoxCoordinatesMode::Coordinates_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Convolution3DLayerParams_PaddingType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Convolution3DLayerParams_PaddingType_strings[3] = {};

static const char Convolution3DLayerParams_PaddingType_names[] =
  "CUSTOM"
  "SAME"
  "VALID";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Convolution3DLayerParams_PaddingType_entries[] = {
  { {Convolution3DLayerParams_PaddingType_names + 0, 6}, 0 },
  { {Convolution3DLayerParams_PaddingType_names + 6, 4}, 2 },
  { {Convolution3DLayerParams_PaddingType_names + 10, 5}, 1 },
};

static const int Convolution3DLayerParams_PaddingType_entries_by_number[] = {
  0, // 0 -> CUSTOM
  2, // 1 -> VALID
  1, // 2 -> SAME
};

const std::string& Convolution3DLayerParams_PaddingType_Name(
    Convolution3DLayerParams_PaddingType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Convolution3DLayerParams_PaddingType_entries,
          Convolution3DLayerParams_PaddingType_entries_by_number,
          3, Convolution3DLayerParams_PaddingType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Convolution3DLayerParams_PaddingType_entries,
      Convolution3DLayerParams_PaddingType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Convolution3DLayerParams_PaddingType_strings[idx].get();
}
bool Convolution3DLayerParams_PaddingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Convolution3DLayerParams_PaddingType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Convolution3DLayerParams_PaddingType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<Convolution3DLayerParams_PaddingType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Convolution3DLayerParams_PaddingType Convolution3DLayerParams::CUSTOM;
constexpr Convolution3DLayerParams_PaddingType Convolution3DLayerParams::VALID;
constexpr Convolution3DLayerParams_PaddingType Convolution3DLayerParams::SAME;
constexpr Convolution3DLayerParams_PaddingType Convolution3DLayerParams::PaddingType_MIN;
constexpr Convolution3DLayerParams_PaddingType Convolution3DLayerParams::PaddingType_MAX;
constexpr int Convolution3DLayerParams::PaddingType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PoolingLayerParams_PoolingType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PoolingLayerParams_PoolingType_strings[3] = {};

static const char PoolingLayerParams_PoolingType_names[] =
  "AVERAGE"
  "L2"
  "MAX";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PoolingLayerParams_PoolingType_entries[] = {
  { {PoolingLayerParams_PoolingType_names + 0, 7}, 1 },
  { {PoolingLayerParams_PoolingType_names + 7, 2}, 2 },
  { {PoolingLayerParams_PoolingType_names + 9, 3}, 0 },
};

static const int PoolingLayerParams_PoolingType_entries_by_number[] = {
  2, // 0 -> MAX
  0, // 1 -> AVERAGE
  1, // 2 -> L2
};

const std::string& PoolingLayerParams_PoolingType_Name(
    PoolingLayerParams_PoolingType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PoolingLayerParams_PoolingType_entries,
          PoolingLayerParams_PoolingType_entries_by_number,
          3, PoolingLayerParams_PoolingType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PoolingLayerParams_PoolingType_entries,
      PoolingLayerParams_PoolingType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PoolingLayerParams_PoolingType_strings[idx].get();
}
bool PoolingLayerParams_PoolingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PoolingLayerParams_PoolingType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PoolingLayerParams_PoolingType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PoolingLayerParams_PoolingType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PoolingLayerParams_PoolingType PoolingLayerParams::MAX;
constexpr PoolingLayerParams_PoolingType PoolingLayerParams::AVERAGE;
constexpr PoolingLayerParams_PoolingType PoolingLayerParams::L2;
constexpr PoolingLayerParams_PoolingType PoolingLayerParams::PoolingType_MIN;
constexpr PoolingLayerParams_PoolingType PoolingLayerParams::PoolingType_MAX;
constexpr int PoolingLayerParams::PoolingType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Pooling3DLayerParams_PoolingType3D_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Pooling3DLayerParams_PoolingType3D_strings[2] = {};

static const char Pooling3DLayerParams_PoolingType3D_names[] =
  "AVERAGE"
  "MAX";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Pooling3DLayerParams_PoolingType3D_entries[] = {
  { {Pooling3DLayerParams_PoolingType3D_names + 0, 7}, 1 },
  { {Pooling3DLayerParams_PoolingType3D_names + 7, 3}, 0 },
};

static const int Pooling3DLayerParams_PoolingType3D_entries_by_number[] = {
  1, // 0 -> MAX
  0, // 1 -> AVERAGE
};

const std::string& Pooling3DLayerParams_PoolingType3D_Name(
    Pooling3DLayerParams_PoolingType3D value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Pooling3DLayerParams_PoolingType3D_entries,
          Pooling3DLayerParams_PoolingType3D_entries_by_number,
          2, Pooling3DLayerParams_PoolingType3D_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Pooling3DLayerParams_PoolingType3D_entries,
      Pooling3DLayerParams_PoolingType3D_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Pooling3DLayerParams_PoolingType3D_strings[idx].get();
}
bool Pooling3DLayerParams_PoolingType3D_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Pooling3DLayerParams_PoolingType3D* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Pooling3DLayerParams_PoolingType3D_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Pooling3DLayerParams_PoolingType3D>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Pooling3DLayerParams_PoolingType3D Pooling3DLayerParams::MAX;
constexpr Pooling3DLayerParams_PoolingType3D Pooling3DLayerParams::AVERAGE;
constexpr Pooling3DLayerParams_PoolingType3D Pooling3DLayerParams::PoolingType3D_MIN;
constexpr Pooling3DLayerParams_PoolingType3D Pooling3DLayerParams::PoolingType3D_MAX;
constexpr int Pooling3DLayerParams::PoolingType3D_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Pooling3DLayerParams_Pooling3DPaddingType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Pooling3DLayerParams_Pooling3DPaddingType_strings[3] = {};

static const char Pooling3DLayerParams_Pooling3DPaddingType_names[] =
  "CUSTOM"
  "SAME"
  "VALID";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Pooling3DLayerParams_Pooling3DPaddingType_entries[] = {
  { {Pooling3DLayerParams_Pooling3DPaddingType_names + 0, 6}, 0 },
  { {Pooling3DLayerParams_Pooling3DPaddingType_names + 6, 4}, 2 },
  { {Pooling3DLayerParams_Pooling3DPaddingType_names + 10, 5}, 1 },
};

static const int Pooling3DLayerParams_Pooling3DPaddingType_entries_by_number[] = {
  0, // 0 -> CUSTOM
  2, // 1 -> VALID
  1, // 2 -> SAME
};

const std::string& Pooling3DLayerParams_Pooling3DPaddingType_Name(
    Pooling3DLayerParams_Pooling3DPaddingType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Pooling3DLayerParams_Pooling3DPaddingType_entries,
          Pooling3DLayerParams_Pooling3DPaddingType_entries_by_number,
          3, Pooling3DLayerParams_Pooling3DPaddingType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Pooling3DLayerParams_Pooling3DPaddingType_entries,
      Pooling3DLayerParams_Pooling3DPaddingType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Pooling3DLayerParams_Pooling3DPaddingType_strings[idx].get();
}
bool Pooling3DLayerParams_Pooling3DPaddingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Pooling3DLayerParams_Pooling3DPaddingType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Pooling3DLayerParams_Pooling3DPaddingType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<Pooling3DLayerParams_Pooling3DPaddingType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Pooling3DLayerParams_Pooling3DPaddingType Pooling3DLayerParams::CUSTOM;
constexpr Pooling3DLayerParams_Pooling3DPaddingType Pooling3DLayerParams::VALID;
constexpr Pooling3DLayerParams_Pooling3DPaddingType Pooling3DLayerParams::SAME;
constexpr Pooling3DLayerParams_Pooling3DPaddingType Pooling3DLayerParams::Pooling3DPaddingType_MIN;
constexpr Pooling3DLayerParams_Pooling3DPaddingType Pooling3DLayerParams::Pooling3DPaddingType_MAX;
constexpr int Pooling3DLayerParams::Pooling3DPaddingType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool GlobalPooling3DLayerParams_GlobalPoolingType3D_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GlobalPooling3DLayerParams_GlobalPoolingType3D_strings[2] = {};

static const char GlobalPooling3DLayerParams_GlobalPoolingType3D_names[] =
  "AVERAGE"
  "MAX";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GlobalPooling3DLayerParams_GlobalPoolingType3D_entries[] = {
  { {GlobalPooling3DLayerParams_GlobalPoolingType3D_names + 0, 7}, 1 },
  { {GlobalPooling3DLayerParams_GlobalPoolingType3D_names + 7, 3}, 0 },
};

static const int GlobalPooling3DLayerParams_GlobalPoolingType3D_entries_by_number[] = {
  1, // 0 -> MAX
  0, // 1 -> AVERAGE
};

const std::string& GlobalPooling3DLayerParams_GlobalPoolingType3D_Name(
    GlobalPooling3DLayerParams_GlobalPoolingType3D value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GlobalPooling3DLayerParams_GlobalPoolingType3D_entries,
          GlobalPooling3DLayerParams_GlobalPoolingType3D_entries_by_number,
          2, GlobalPooling3DLayerParams_GlobalPoolingType3D_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GlobalPooling3DLayerParams_GlobalPoolingType3D_entries,
      GlobalPooling3DLayerParams_GlobalPoolingType3D_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GlobalPooling3DLayerParams_GlobalPoolingType3D_strings[idx].get();
}
bool GlobalPooling3DLayerParams_GlobalPoolingType3D_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GlobalPooling3DLayerParams_GlobalPoolingType3D* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GlobalPooling3DLayerParams_GlobalPoolingType3D_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<GlobalPooling3DLayerParams_GlobalPoolingType3D>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GlobalPooling3DLayerParams_GlobalPoolingType3D GlobalPooling3DLayerParams::MAX;
constexpr GlobalPooling3DLayerParams_GlobalPoolingType3D GlobalPooling3DLayerParams::AVERAGE;
constexpr GlobalPooling3DLayerParams_GlobalPoolingType3D GlobalPooling3DLayerParams::GlobalPoolingType3D_MIN;
constexpr GlobalPooling3DLayerParams_GlobalPoolingType3D GlobalPooling3DLayerParams::GlobalPoolingType3D_MAX;
constexpr int GlobalPooling3DLayerParams::GlobalPoolingType3D_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool UnaryFunctionLayerParams_Operation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UnaryFunctionLayerParams_Operation_strings[8] = {};

static const char UnaryFunctionLayerParams_Operation_names[] =
  "ABS"
  "EXP"
  "INVERSE"
  "LOG"
  "POWER"
  "RSQRT"
  "SQRT"
  "THRESHOLD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UnaryFunctionLayerParams_Operation_entries[] = {
  { {UnaryFunctionLayerParams_Operation_names + 0, 3}, 6 },
  { {UnaryFunctionLayerParams_Operation_names + 3, 3}, 4 },
  { {UnaryFunctionLayerParams_Operation_names + 6, 7}, 2 },
  { {UnaryFunctionLayerParams_Operation_names + 13, 3}, 5 },
  { {UnaryFunctionLayerParams_Operation_names + 16, 5}, 3 },
  { {UnaryFunctionLayerParams_Operation_names + 21, 5}, 1 },
  { {UnaryFunctionLayerParams_Operation_names + 26, 4}, 0 },
  { {UnaryFunctionLayerParams_Operation_names + 30, 9}, 7 },
};

static const int UnaryFunctionLayerParams_Operation_entries_by_number[] = {
  6, // 0 -> SQRT
  5, // 1 -> RSQRT
  2, // 2 -> INVERSE
  4, // 3 -> POWER
  1, // 4 -> EXP
  3, // 5 -> LOG
  0, // 6 -> ABS
  7, // 7 -> THRESHOLD
};

const std::string& UnaryFunctionLayerParams_Operation_Name(
    UnaryFunctionLayerParams_Operation value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UnaryFunctionLayerParams_Operation_entries,
          UnaryFunctionLayerParams_Operation_entries_by_number,
          8, UnaryFunctionLayerParams_Operation_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UnaryFunctionLayerParams_Operation_entries,
      UnaryFunctionLayerParams_Operation_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UnaryFunctionLayerParams_Operation_strings[idx].get();
}
bool UnaryFunctionLayerParams_Operation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UnaryFunctionLayerParams_Operation* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UnaryFunctionLayerParams_Operation_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<UnaryFunctionLayerParams_Operation>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr UnaryFunctionLayerParams_Operation UnaryFunctionLayerParams::SQRT;
constexpr UnaryFunctionLayerParams_Operation UnaryFunctionLayerParams::RSQRT;
constexpr UnaryFunctionLayerParams_Operation UnaryFunctionLayerParams::INVERSE;
constexpr UnaryFunctionLayerParams_Operation UnaryFunctionLayerParams::POWER;
constexpr UnaryFunctionLayerParams_Operation UnaryFunctionLayerParams::EXP;
constexpr UnaryFunctionLayerParams_Operation UnaryFunctionLayerParams::LOG;
constexpr UnaryFunctionLayerParams_Operation UnaryFunctionLayerParams::ABS;
constexpr UnaryFunctionLayerParams_Operation UnaryFunctionLayerParams::THRESHOLD;
constexpr UnaryFunctionLayerParams_Operation UnaryFunctionLayerParams::Operation_MIN;
constexpr UnaryFunctionLayerParams_Operation UnaryFunctionLayerParams::Operation_MAX;
constexpr int UnaryFunctionLayerParams::Operation_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool UpsampleLayerParams_InterpolationMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UpsampleLayerParams_InterpolationMode_strings[2] = {};

static const char UpsampleLayerParams_InterpolationMode_names[] =
  "BILINEAR"
  "NN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UpsampleLayerParams_InterpolationMode_entries[] = {
  { {UpsampleLayerParams_InterpolationMode_names + 0, 8}, 1 },
  { {UpsampleLayerParams_InterpolationMode_names + 8, 2}, 0 },
};

static const int UpsampleLayerParams_InterpolationMode_entries_by_number[] = {
  1, // 0 -> NN
  0, // 1 -> BILINEAR
};

const std::string& UpsampleLayerParams_InterpolationMode_Name(
    UpsampleLayerParams_InterpolationMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UpsampleLayerParams_InterpolationMode_entries,
          UpsampleLayerParams_InterpolationMode_entries_by_number,
          2, UpsampleLayerParams_InterpolationMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UpsampleLayerParams_InterpolationMode_entries,
      UpsampleLayerParams_InterpolationMode_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UpsampleLayerParams_InterpolationMode_strings[idx].get();
}
bool UpsampleLayerParams_InterpolationMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UpsampleLayerParams_InterpolationMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UpsampleLayerParams_InterpolationMode_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<UpsampleLayerParams_InterpolationMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr UpsampleLayerParams_InterpolationMode UpsampleLayerParams::NN;
constexpr UpsampleLayerParams_InterpolationMode UpsampleLayerParams::BILINEAR;
constexpr UpsampleLayerParams_InterpolationMode UpsampleLayerParams::InterpolationMode_MIN;
constexpr UpsampleLayerParams_InterpolationMode UpsampleLayerParams::InterpolationMode_MAX;
constexpr int UpsampleLayerParams::InterpolationMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool UpsampleLayerParams_LinearUpsampleMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UpsampleLayerParams_LinearUpsampleMode_strings[3] = {};

static const char UpsampleLayerParams_LinearUpsampleMode_names[] =
  "ALIGN_CORNERS_FALSE"
  "ALIGN_CORNERS_TRUE"
  "DEFAULT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UpsampleLayerParams_LinearUpsampleMode_entries[] = {
  { {UpsampleLayerParams_LinearUpsampleMode_names + 0, 19}, 2 },
  { {UpsampleLayerParams_LinearUpsampleMode_names + 19, 18}, 1 },
  { {UpsampleLayerParams_LinearUpsampleMode_names + 37, 7}, 0 },
};

static const int UpsampleLayerParams_LinearUpsampleMode_entries_by_number[] = {
  2, // 0 -> DEFAULT
  1, // 1 -> ALIGN_CORNERS_TRUE
  0, // 2 -> ALIGN_CORNERS_FALSE
};

const std::string& UpsampleLayerParams_LinearUpsampleMode_Name(
    UpsampleLayerParams_LinearUpsampleMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UpsampleLayerParams_LinearUpsampleMode_entries,
          UpsampleLayerParams_LinearUpsampleMode_entries_by_number,
          3, UpsampleLayerParams_LinearUpsampleMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UpsampleLayerParams_LinearUpsampleMode_entries,
      UpsampleLayerParams_LinearUpsampleMode_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UpsampleLayerParams_LinearUpsampleMode_strings[idx].get();
}
bool UpsampleLayerParams_LinearUpsampleMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UpsampleLayerParams_LinearUpsampleMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UpsampleLayerParams_LinearUpsampleMode_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<UpsampleLayerParams_LinearUpsampleMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr UpsampleLayerParams_LinearUpsampleMode UpsampleLayerParams::DEFAULT;
constexpr UpsampleLayerParams_LinearUpsampleMode UpsampleLayerParams::ALIGN_CORNERS_TRUE;
constexpr UpsampleLayerParams_LinearUpsampleMode UpsampleLayerParams::ALIGN_CORNERS_FALSE;
constexpr UpsampleLayerParams_LinearUpsampleMode UpsampleLayerParams::LinearUpsampleMode_MIN;
constexpr UpsampleLayerParams_LinearUpsampleMode UpsampleLayerParams::LinearUpsampleMode_MAX;
constexpr int UpsampleLayerParams::LinearUpsampleMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool FlattenLayerParams_FlattenOrder_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FlattenLayerParams_FlattenOrder_strings[2] = {};

static const char FlattenLayerParams_FlattenOrder_names[] =
  "CHANNEL_FIRST"
  "CHANNEL_LAST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FlattenLayerParams_FlattenOrder_entries[] = {
  { {FlattenLayerParams_FlattenOrder_names + 0, 13}, 0 },
  { {FlattenLayerParams_FlattenOrder_names + 13, 12}, 1 },
};

static const int FlattenLayerParams_FlattenOrder_entries_by_number[] = {
  0, // 0 -> CHANNEL_FIRST
  1, // 1 -> CHANNEL_LAST
};

const std::string& FlattenLayerParams_FlattenOrder_Name(
    FlattenLayerParams_FlattenOrder value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FlattenLayerParams_FlattenOrder_entries,
          FlattenLayerParams_FlattenOrder_entries_by_number,
          2, FlattenLayerParams_FlattenOrder_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FlattenLayerParams_FlattenOrder_entries,
      FlattenLayerParams_FlattenOrder_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FlattenLayerParams_FlattenOrder_strings[idx].get();
}
bool FlattenLayerParams_FlattenOrder_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FlattenLayerParams_FlattenOrder* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FlattenLayerParams_FlattenOrder_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<FlattenLayerParams_FlattenOrder>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr FlattenLayerParams_FlattenOrder FlattenLayerParams::CHANNEL_FIRST;
constexpr FlattenLayerParams_FlattenOrder FlattenLayerParams::CHANNEL_LAST;
constexpr FlattenLayerParams_FlattenOrder FlattenLayerParams::FlattenOrder_MIN;
constexpr FlattenLayerParams_FlattenOrder FlattenLayerParams::FlattenOrder_MAX;
constexpr int FlattenLayerParams::FlattenOrder_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ReshapeLayerParams_ReshapeOrder_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ReshapeLayerParams_ReshapeOrder_strings[2] = {};

static const char ReshapeLayerParams_ReshapeOrder_names[] =
  "CHANNEL_FIRST"
  "CHANNEL_LAST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ReshapeLayerParams_ReshapeOrder_entries[] = {
  { {ReshapeLayerParams_ReshapeOrder_names + 0, 13}, 0 },
  { {ReshapeLayerParams_ReshapeOrder_names + 13, 12}, 1 },
};

static const int ReshapeLayerParams_ReshapeOrder_entries_by_number[] = {
  0, // 0 -> CHANNEL_FIRST
  1, // 1 -> CHANNEL_LAST
};

const std::string& ReshapeLayerParams_ReshapeOrder_Name(
    ReshapeLayerParams_ReshapeOrder value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ReshapeLayerParams_ReshapeOrder_entries,
          ReshapeLayerParams_ReshapeOrder_entries_by_number,
          2, ReshapeLayerParams_ReshapeOrder_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ReshapeLayerParams_ReshapeOrder_entries,
      ReshapeLayerParams_ReshapeOrder_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ReshapeLayerParams_ReshapeOrder_strings[idx].get();
}
bool ReshapeLayerParams_ReshapeOrder_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReshapeLayerParams_ReshapeOrder* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ReshapeLayerParams_ReshapeOrder_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ReshapeLayerParams_ReshapeOrder>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ReshapeLayerParams_ReshapeOrder ReshapeLayerParams::CHANNEL_FIRST;
constexpr ReshapeLayerParams_ReshapeOrder ReshapeLayerParams::CHANNEL_LAST;
constexpr ReshapeLayerParams_ReshapeOrder ReshapeLayerParams::ReshapeOrder_MIN;
constexpr ReshapeLayerParams_ReshapeOrder ReshapeLayerParams::ReshapeOrder_MAX;
constexpr int ReshapeLayerParams::ReshapeOrder_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ReorganizeDataLayerParams_ReorganizationType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ReorganizeDataLayerParams_ReorganizationType_strings[3] = {};

static const char ReorganizeDataLayerParams_ReorganizationType_names[] =
  "DEPTH_TO_SPACE"
  "PIXEL_SHUFFLE"
  "SPACE_TO_DEPTH";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ReorganizeDataLayerParams_ReorganizationType_entries[] = {
  { {ReorganizeDataLayerParams_ReorganizationType_names + 0, 14}, 1 },
  { {ReorganizeDataLayerParams_ReorganizationType_names + 14, 13}, 2 },
  { {ReorganizeDataLayerParams_ReorganizationType_names + 27, 14}, 0 },
};

static const int ReorganizeDataLayerParams_ReorganizationType_entries_by_number[] = {
  2, // 0 -> SPACE_TO_DEPTH
  0, // 1 -> DEPTH_TO_SPACE
  1, // 2 -> PIXEL_SHUFFLE
};

const std::string& ReorganizeDataLayerParams_ReorganizationType_Name(
    ReorganizeDataLayerParams_ReorganizationType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ReorganizeDataLayerParams_ReorganizationType_entries,
          ReorganizeDataLayerParams_ReorganizationType_entries_by_number,
          3, ReorganizeDataLayerParams_ReorganizationType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ReorganizeDataLayerParams_ReorganizationType_entries,
      ReorganizeDataLayerParams_ReorganizationType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ReorganizeDataLayerParams_ReorganizationType_strings[idx].get();
}
bool ReorganizeDataLayerParams_ReorganizationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReorganizeDataLayerParams_ReorganizationType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ReorganizeDataLayerParams_ReorganizationType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ReorganizeDataLayerParams_ReorganizationType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ReorganizeDataLayerParams_ReorganizationType ReorganizeDataLayerParams::SPACE_TO_DEPTH;
constexpr ReorganizeDataLayerParams_ReorganizationType ReorganizeDataLayerParams::DEPTH_TO_SPACE;
constexpr ReorganizeDataLayerParams_ReorganizationType ReorganizeDataLayerParams::PIXEL_SHUFFLE;
constexpr ReorganizeDataLayerParams_ReorganizationType ReorganizeDataLayerParams::ReorganizationType_MIN;
constexpr ReorganizeDataLayerParams_ReorganizationType ReorganizeDataLayerParams::ReorganizationType_MAX;
constexpr int ReorganizeDataLayerParams::ReorganizationType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SliceLayerParams_SliceAxis_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SliceLayerParams_SliceAxis_strings[3] = {};

static const char SliceLayerParams_SliceAxis_names[] =
  "CHANNEL_AXIS"
  "HEIGHT_AXIS"
  "WIDTH_AXIS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SliceLayerParams_SliceAxis_entries[] = {
  { {SliceLayerParams_SliceAxis_names + 0, 12}, 0 },
  { {SliceLayerParams_SliceAxis_names + 12, 11}, 1 },
  { {SliceLayerParams_SliceAxis_names + 23, 10}, 2 },
};

static const int SliceLayerParams_SliceAxis_entries_by_number[] = {
  0, // 0 -> CHANNEL_AXIS
  1, // 1 -> HEIGHT_AXIS
  2, // 2 -> WIDTH_AXIS
};

const std::string& SliceLayerParams_SliceAxis_Name(
    SliceLayerParams_SliceAxis value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SliceLayerParams_SliceAxis_entries,
          SliceLayerParams_SliceAxis_entries_by_number,
          3, SliceLayerParams_SliceAxis_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SliceLayerParams_SliceAxis_entries,
      SliceLayerParams_SliceAxis_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SliceLayerParams_SliceAxis_strings[idx].get();
}
bool SliceLayerParams_SliceAxis_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SliceLayerParams_SliceAxis* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SliceLayerParams_SliceAxis_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<SliceLayerParams_SliceAxis>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SliceLayerParams_SliceAxis SliceLayerParams::CHANNEL_AXIS;
constexpr SliceLayerParams_SliceAxis SliceLayerParams::HEIGHT_AXIS;
constexpr SliceLayerParams_SliceAxis SliceLayerParams::WIDTH_AXIS;
constexpr SliceLayerParams_SliceAxis SliceLayerParams::SliceAxis_MIN;
constexpr SliceLayerParams_SliceAxis SliceLayerParams::SliceAxis_MAX;
constexpr int SliceLayerParams::SliceAxis_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ReduceLayerParams_ReduceOperation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ReduceLayerParams_ReduceOperation_strings[10] = {};

static const char ReduceLayerParams_ReduceOperation_names[] =
  "ARGMAX"
  "AVG"
  "L1"
  "L2"
  "LOGSUM"
  "MAX"
  "MIN"
  "PROD"
  "SUM"
  "SUMSQUARE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ReduceLayerParams_ReduceOperation_entries[] = {
  { {ReduceLayerParams_ReduceOperation_names + 0, 6}, 9 },
  { {ReduceLayerParams_ReduceOperation_names + 6, 3}, 1 },
  { {ReduceLayerParams_ReduceOperation_names + 9, 2}, 5 },
  { {ReduceLayerParams_ReduceOperation_names + 11, 2}, 6 },
  { {ReduceLayerParams_ReduceOperation_names + 13, 6}, 3 },
  { {ReduceLayerParams_ReduceOperation_names + 19, 3}, 7 },
  { {ReduceLayerParams_ReduceOperation_names + 22, 3}, 8 },
  { {ReduceLayerParams_ReduceOperation_names + 25, 4}, 2 },
  { {ReduceLayerParams_ReduceOperation_names + 29, 3}, 0 },
  { {ReduceLayerParams_ReduceOperation_names + 32, 9}, 4 },
};

static const int ReduceLayerParams_ReduceOperation_entries_by_number[] = {
  8, // 0 -> SUM
  1, // 1 -> AVG
  7, // 2 -> PROD
  4, // 3 -> LOGSUM
  9, // 4 -> SUMSQUARE
  2, // 5 -> L1
  3, // 6 -> L2
  5, // 7 -> MAX
  6, // 8 -> MIN
  0, // 9 -> ARGMAX
};

const std::string& ReduceLayerParams_ReduceOperation_Name(
    ReduceLayerParams_ReduceOperation value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ReduceLayerParams_ReduceOperation_entries,
          ReduceLayerParams_ReduceOperation_entries_by_number,
          10, ReduceLayerParams_ReduceOperation_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ReduceLayerParams_ReduceOperation_entries,
      ReduceLayerParams_ReduceOperation_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ReduceLayerParams_ReduceOperation_strings[idx].get();
}
bool ReduceLayerParams_ReduceOperation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReduceLayerParams_ReduceOperation* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ReduceLayerParams_ReduceOperation_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<ReduceLayerParams_ReduceOperation>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ReduceLayerParams_ReduceOperation ReduceLayerParams::SUM;
constexpr ReduceLayerParams_ReduceOperation ReduceLayerParams::AVG;
constexpr ReduceLayerParams_ReduceOperation ReduceLayerParams::PROD;
constexpr ReduceLayerParams_ReduceOperation ReduceLayerParams::LOGSUM;
constexpr ReduceLayerParams_ReduceOperation ReduceLayerParams::SUMSQUARE;
constexpr ReduceLayerParams_ReduceOperation ReduceLayerParams::L1;
constexpr ReduceLayerParams_ReduceOperation ReduceLayerParams::L2;
constexpr ReduceLayerParams_ReduceOperation ReduceLayerParams::MAX;
constexpr ReduceLayerParams_ReduceOperation ReduceLayerParams::MIN;
constexpr ReduceLayerParams_ReduceOperation ReduceLayerParams::ARGMAX;
constexpr ReduceLayerParams_ReduceOperation ReduceLayerParams::ReduceOperation_MIN;
constexpr ReduceLayerParams_ReduceOperation ReduceLayerParams::ReduceOperation_MAX;
constexpr int ReduceLayerParams::ReduceOperation_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ReduceLayerParams_ReduceAxis_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ReduceLayerParams_ReduceAxis_strings[5] = {};

static const char ReduceLayerParams_ReduceAxis_names[] =
  "C"
  "CHW"
  "H"
  "HW"
  "W";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ReduceLayerParams_ReduceAxis_entries[] = {
  { {ReduceLayerParams_ReduceAxis_names + 0, 1}, 2 },
  { {ReduceLayerParams_ReduceAxis_names + 1, 3}, 0 },
  { {ReduceLayerParams_ReduceAxis_names + 4, 1}, 3 },
  { {ReduceLayerParams_ReduceAxis_names + 5, 2}, 1 },
  { {ReduceLayerParams_ReduceAxis_names + 7, 1}, 4 },
};

static const int ReduceLayerParams_ReduceAxis_entries_by_number[] = {
  1, // 0 -> CHW
  3, // 1 -> HW
  0, // 2 -> C
  2, // 3 -> H
  4, // 4 -> W
};

const std::string& ReduceLayerParams_ReduceAxis_Name(
    ReduceLayerParams_ReduceAxis value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ReduceLayerParams_ReduceAxis_entries,
          ReduceLayerParams_ReduceAxis_entries_by_number,
          5, ReduceLayerParams_ReduceAxis_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ReduceLayerParams_ReduceAxis_entries,
      ReduceLayerParams_ReduceAxis_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ReduceLayerParams_ReduceAxis_strings[idx].get();
}
bool ReduceLayerParams_ReduceAxis_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReduceLayerParams_ReduceAxis* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ReduceLayerParams_ReduceAxis_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ReduceLayerParams_ReduceAxis>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ReduceLayerParams_ReduceAxis ReduceLayerParams::CHW;
constexpr ReduceLayerParams_ReduceAxis ReduceLayerParams::HW;
constexpr ReduceLayerParams_ReduceAxis ReduceLayerParams::C;
constexpr ReduceLayerParams_ReduceAxis ReduceLayerParams::H;
constexpr ReduceLayerParams_ReduceAxis ReduceLayerParams::W;
constexpr ReduceLayerParams_ReduceAxis ReduceLayerParams::ReduceAxis_MIN;
constexpr ReduceLayerParams_ReduceAxis ReduceLayerParams::ReduceAxis_MAX;
constexpr int ReduceLayerParams::ReduceAxis_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool GeluLayerParams_GeluMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GeluLayerParams_GeluMode_strings[3] = {};

static const char GeluLayerParams_GeluMode_names[] =
  "EXACT"
  "SIGMOID_APPROXIMATION"
  "TANH_APPROXIMATION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GeluLayerParams_GeluMode_entries[] = {
  { {GeluLayerParams_GeluMode_names + 0, 5}, 0 },
  { {GeluLayerParams_GeluMode_names + 5, 21}, 2 },
  { {GeluLayerParams_GeluMode_names + 26, 18}, 1 },
};

static const int GeluLayerParams_GeluMode_entries_by_number[] = {
  0, // 0 -> EXACT
  2, // 1 -> TANH_APPROXIMATION
  1, // 2 -> SIGMOID_APPROXIMATION
};

const std::string& GeluLayerParams_GeluMode_Name(
    GeluLayerParams_GeluMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GeluLayerParams_GeluMode_entries,
          GeluLayerParams_GeluMode_entries_by_number,
          3, GeluLayerParams_GeluMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GeluLayerParams_GeluMode_entries,
      GeluLayerParams_GeluMode_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GeluLayerParams_GeluMode_strings[idx].get();
}
bool GeluLayerParams_GeluMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GeluLayerParams_GeluMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GeluLayerParams_GeluMode_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<GeluLayerParams_GeluMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GeluLayerParams_GeluMode GeluLayerParams::EXACT;
constexpr GeluLayerParams_GeluMode GeluLayerParams::TANH_APPROXIMATION;
constexpr GeluLayerParams_GeluMode GeluLayerParams::SIGMOID_APPROXIMATION;
constexpr GeluLayerParams_GeluMode GeluLayerParams::GeluMode_MIN;
constexpr GeluLayerParams_GeluMode GeluLayerParams::GeluMode_MAX;
constexpr int GeluLayerParams::GeluMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool NeuralNetworkMultiArrayShapeMapping_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NeuralNetworkMultiArrayShapeMapping_strings[2] = {};

static const char NeuralNetworkMultiArrayShapeMapping_names[] =
  "EXACT_ARRAY_MAPPING"
  "RANK5_ARRAY_MAPPING";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NeuralNetworkMultiArrayShapeMapping_entries[] = {
  { {NeuralNetworkMultiArrayShapeMapping_names + 0, 19}, 1 },
  { {NeuralNetworkMultiArrayShapeMapping_names + 19, 19}, 0 },
};

static const int NeuralNetworkMultiArrayShapeMapping_entries_by_number[] = {
  1, // 0 -> RANK5_ARRAY_MAPPING
  0, // 1 -> EXACT_ARRAY_MAPPING
};

const std::string& NeuralNetworkMultiArrayShapeMapping_Name(
    NeuralNetworkMultiArrayShapeMapping value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NeuralNetworkMultiArrayShapeMapping_entries,
          NeuralNetworkMultiArrayShapeMapping_entries_by_number,
          2, NeuralNetworkMultiArrayShapeMapping_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NeuralNetworkMultiArrayShapeMapping_entries,
      NeuralNetworkMultiArrayShapeMapping_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NeuralNetworkMultiArrayShapeMapping_strings[idx].get();
}
bool NeuralNetworkMultiArrayShapeMapping_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NeuralNetworkMultiArrayShapeMapping* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NeuralNetworkMultiArrayShapeMapping_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<NeuralNetworkMultiArrayShapeMapping>(int_value);
  }
  return success;
}
bool NeuralNetworkImageShapeMapping_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NeuralNetworkImageShapeMapping_strings[2] = {};

static const char NeuralNetworkImageShapeMapping_names[] =
  "RANK4_IMAGE_MAPPING"
  "RANK5_IMAGE_MAPPING";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NeuralNetworkImageShapeMapping_entries[] = {
  { {NeuralNetworkImageShapeMapping_names + 0, 19}, 1 },
  { {NeuralNetworkImageShapeMapping_names + 19, 19}, 0 },
};

static const int NeuralNetworkImageShapeMapping_entries_by_number[] = {
  1, // 0 -> RANK5_IMAGE_MAPPING
  0, // 1 -> RANK4_IMAGE_MAPPING
};

const std::string& NeuralNetworkImageShapeMapping_Name(
    NeuralNetworkImageShapeMapping value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NeuralNetworkImageShapeMapping_entries,
          NeuralNetworkImageShapeMapping_entries_by_number,
          2, NeuralNetworkImageShapeMapping_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NeuralNetworkImageShapeMapping_entries,
      NeuralNetworkImageShapeMapping_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NeuralNetworkImageShapeMapping_strings[idx].get();
}
bool NeuralNetworkImageShapeMapping_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NeuralNetworkImageShapeMapping* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NeuralNetworkImageShapeMapping_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<NeuralNetworkImageShapeMapping>(int_value);
  }
  return success;
}
bool ScatterMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ScatterMode_strings[7] = {};

static const char ScatterMode_names[] =
  "SCATTER_ADD"
  "SCATTER_DIV"
  "SCATTER_MAX"
  "SCATTER_MIN"
  "SCATTER_MUL"
  "SCATTER_SUB"
  "SCATTER_UPDATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ScatterMode_entries[] = {
  { {ScatterMode_names + 0, 11}, 1 },
  { {ScatterMode_names + 11, 11}, 4 },
  { {ScatterMode_names + 22, 11}, 5 },
  { {ScatterMode_names + 33, 11}, 6 },
  { {ScatterMode_names + 44, 11}, 3 },
  { {ScatterMode_names + 55, 11}, 2 },
  { {ScatterMode_names + 66, 14}, 0 },
};

static const int ScatterMode_entries_by_number[] = {
  6, // 0 -> SCATTER_UPDATE
  0, // 1 -> SCATTER_ADD
  5, // 2 -> SCATTER_SUB
  4, // 3 -> SCATTER_MUL
  1, // 4 -> SCATTER_DIV
  2, // 5 -> SCATTER_MAX
  3, // 6 -> SCATTER_MIN
};

const std::string& ScatterMode_Name(
    ScatterMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ScatterMode_entries,
          ScatterMode_entries_by_number,
          7, ScatterMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ScatterMode_entries,
      ScatterMode_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ScatterMode_strings[idx].get();
}
bool ScatterMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ScatterMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ScatterMode_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<ScatterMode>(int_value);
  }
  return success;
}

// ===================================================================

class NeuralNetwork::_Internal {
 public:
  static const ::CoreML::Specification::NetworkUpdateParameters& updateparams(const NeuralNetwork* msg);
};

const ::CoreML::Specification::NetworkUpdateParameters&
NeuralNetwork::_Internal::updateparams(const NeuralNetwork* msg) {
  return *msg->updateparams_;
}
NeuralNetwork::NeuralNetwork(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  layers_(arena),
  preprocessing_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.NeuralNetwork)
}
NeuralNetwork::NeuralNetwork(const NeuralNetwork& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      layers_(from.layers_),
      preprocessing_(from.preprocessing_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_updateparams()) {
    updateparams_ = new ::CoreML::Specification::NetworkUpdateParameters(*from.updateparams_);
  } else {
    updateparams_ = nullptr;
  }
  ::memcpy(&arrayinputshapemapping_, &from.arrayinputshapemapping_,
    static_cast<size_t>(reinterpret_cast<char*>(&imageinputshapemapping_) -
    reinterpret_cast<char*>(&arrayinputshapemapping_)) + sizeof(imageinputshapemapping_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.NeuralNetwork)
}

inline void NeuralNetwork::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&updateparams_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&imageinputshapemapping_) -
    reinterpret_cast<char*>(&updateparams_)) + sizeof(imageinputshapemapping_));
}

NeuralNetwork::~NeuralNetwork() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.NeuralNetwork)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void NeuralNetwork::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete updateparams_;
}

void NeuralNetwork::ArenaDtor(void* object) {
  NeuralNetwork* _this = reinterpret_cast< NeuralNetwork* >(object);
  (void)_this;
}
void NeuralNetwork::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NeuralNetwork::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NeuralNetwork::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.NeuralNetwork)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  layers_.Clear();
  preprocessing_.Clear();
  if (GetArenaForAllocation() == nullptr && updateparams_ != nullptr) {
    delete updateparams_;
  }
  updateparams_ = nullptr;
  ::memset(&arrayinputshapemapping_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&imageinputshapemapping_) -
      reinterpret_cast<char*>(&arrayinputshapemapping_)) + sizeof(imageinputshapemapping_));
  _internal_metadata_.Clear<std::string>();
}

const char* NeuralNetwork::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.NeuralNetworkLayer layers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_layers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.NeuralNetworkPreprocessing preprocessing = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_preprocessing(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NeuralNetworkMultiArrayShapeMapping arrayInputShapeMapping = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_arrayinputshapemapping(static_cast<::CoreML::Specification::NeuralNetworkMultiArrayShapeMapping>(val));
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NeuralNetworkImageShapeMapping imageInputShapeMapping = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_imageinputshapemapping(static_cast<::CoreML::Specification::NeuralNetworkImageShapeMapping>(val));
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NetworkUpdateParameters updateParams = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_updateparams(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NeuralNetwork::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.NeuralNetwork)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.NeuralNetworkLayer layers = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_layers_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_layers(i), target, stream);
  }

  // repeated .CoreML.Specification.NeuralNetworkPreprocessing preprocessing = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_preprocessing_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_preprocessing(i), target, stream);
  }

  // .CoreML.Specification.NeuralNetworkMultiArrayShapeMapping arrayInputShapeMapping = 5;
  if (this->_internal_arrayinputshapemapping() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_arrayinputshapemapping(), target);
  }

  // .CoreML.Specification.NeuralNetworkImageShapeMapping imageInputShapeMapping = 6;
  if (this->_internal_imageinputshapemapping() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_imageinputshapemapping(), target);
  }

  // .CoreML.Specification.NetworkUpdateParameters updateParams = 10;
  if (this->_internal_has_updateparams()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::updateparams(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.NeuralNetwork)
  return target;
}

size_t NeuralNetwork::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.NeuralNetwork)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.NeuralNetworkLayer layers = 1;
  total_size += 1UL * this->_internal_layers_size();
  for (const auto& msg : this->layers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CoreML.Specification.NeuralNetworkPreprocessing preprocessing = 2;
  total_size += 1UL * this->_internal_preprocessing_size();
  for (const auto& msg : this->preprocessing_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .CoreML.Specification.NetworkUpdateParameters updateParams = 10;
  if (this->_internal_has_updateparams()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *updateparams_);
  }

  // .CoreML.Specification.NeuralNetworkMultiArrayShapeMapping arrayInputShapeMapping = 5;
  if (this->_internal_arrayinputshapemapping() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_arrayinputshapemapping());
  }

  // .CoreML.Specification.NeuralNetworkImageShapeMapping imageInputShapeMapping = 6;
  if (this->_internal_imageinputshapemapping() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_imageinputshapemapping());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NeuralNetwork::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const NeuralNetwork*>(
      &from));
}

void NeuralNetwork::MergeFrom(const NeuralNetwork& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.NeuralNetwork)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  layers_.MergeFrom(from.layers_);
  preprocessing_.MergeFrom(from.preprocessing_);
  if (from._internal_has_updateparams()) {
    _internal_mutable_updateparams()->::CoreML::Specification::NetworkUpdateParameters::MergeFrom(from._internal_updateparams());
  }
  if (from._internal_arrayinputshapemapping() != 0) {
    _internal_set_arrayinputshapemapping(from._internal_arrayinputshapemapping());
  }
  if (from._internal_imageinputshapemapping() != 0) {
    _internal_set_imageinputshapemapping(from._internal_imageinputshapemapping());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NeuralNetwork::CopyFrom(const NeuralNetwork& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.NeuralNetwork)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NeuralNetwork::IsInitialized() const {
  return true;
}

void NeuralNetwork::InternalSwap(NeuralNetwork* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  layers_.InternalSwap(&other->layers_);
  preprocessing_.InternalSwap(&other->preprocessing_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NeuralNetwork, imageinputshapemapping_)
      + sizeof(NeuralNetwork::imageinputshapemapping_)
      - PROTOBUF_FIELD_OFFSET(NeuralNetwork, updateparams_)>(
          reinterpret_cast<char*>(&updateparams_),
          reinterpret_cast<char*>(&other->updateparams_));
}

std::string NeuralNetwork::GetTypeName() const {
  return "CoreML.Specification.NeuralNetwork";
}


// ===================================================================

class NeuralNetworkImageScaler::_Internal {
 public:
};

NeuralNetworkImageScaler::NeuralNetworkImageScaler(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.NeuralNetworkImageScaler)
}
NeuralNetworkImageScaler::NeuralNetworkImageScaler(const NeuralNetworkImageScaler& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&graybias_, &from.graybias_,
    static_cast<size_t>(reinterpret_cast<char*>(&redbias_) -
    reinterpret_cast<char*>(&graybias_)) + sizeof(redbias_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.NeuralNetworkImageScaler)
}

inline void NeuralNetworkImageScaler::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&graybias_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&redbias_) -
    reinterpret_cast<char*>(&graybias_)) + sizeof(redbias_));
}

NeuralNetworkImageScaler::~NeuralNetworkImageScaler() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.NeuralNetworkImageScaler)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void NeuralNetworkImageScaler::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NeuralNetworkImageScaler::ArenaDtor(void* object) {
  NeuralNetworkImageScaler* _this = reinterpret_cast< NeuralNetworkImageScaler* >(object);
  (void)_this;
}
void NeuralNetworkImageScaler::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NeuralNetworkImageScaler::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NeuralNetworkImageScaler::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.NeuralNetworkImageScaler)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&graybias_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&redbias_) -
      reinterpret_cast<char*>(&graybias_)) + sizeof(redbias_));
  _internal_metadata_.Clear<std::string>();
}

const char* NeuralNetworkImageScaler::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float channelScale = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          channelscale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float blueBias = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 165)) {
          bluebias_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float greenBias = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 173)) {
          greenbias_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float redBias = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 181)) {
          redbias_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float grayBias = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 245)) {
          graybias_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NeuralNetworkImageScaler::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.NeuralNetworkImageScaler)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float channelScale = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_channelscale = this->_internal_channelscale();
  uint32_t raw_channelscale;
  memcpy(&raw_channelscale, &tmp_channelscale, sizeof(tmp_channelscale));
  if (raw_channelscale != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_channelscale(), target);
  }

  // float blueBias = 20;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bluebias = this->_internal_bluebias();
  uint32_t raw_bluebias;
  memcpy(&raw_bluebias, &tmp_bluebias, sizeof(tmp_bluebias));
  if (raw_bluebias != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(20, this->_internal_bluebias(), target);
  }

  // float greenBias = 21;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_greenbias = this->_internal_greenbias();
  uint32_t raw_greenbias;
  memcpy(&raw_greenbias, &tmp_greenbias, sizeof(tmp_greenbias));
  if (raw_greenbias != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(21, this->_internal_greenbias(), target);
  }

  // float redBias = 22;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_redbias = this->_internal_redbias();
  uint32_t raw_redbias;
  memcpy(&raw_redbias, &tmp_redbias, sizeof(tmp_redbias));
  if (raw_redbias != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(22, this->_internal_redbias(), target);
  }

  // float grayBias = 30;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_graybias = this->_internal_graybias();
  uint32_t raw_graybias;
  memcpy(&raw_graybias, &tmp_graybias, sizeof(tmp_graybias));
  if (raw_graybias != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(30, this->_internal_graybias(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.NeuralNetworkImageScaler)
  return target;
}

size_t NeuralNetworkImageScaler::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.NeuralNetworkImageScaler)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float grayBias = 30;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_graybias = this->_internal_graybias();
  uint32_t raw_graybias;
  memcpy(&raw_graybias, &tmp_graybias, sizeof(tmp_graybias));
  if (raw_graybias != 0) {
    total_size += 2 + 4;
  }

  // float channelScale = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_channelscale = this->_internal_channelscale();
  uint32_t raw_channelscale;
  memcpy(&raw_channelscale, &tmp_channelscale, sizeof(tmp_channelscale));
  if (raw_channelscale != 0) {
    total_size += 1 + 4;
  }

  // float blueBias = 20;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bluebias = this->_internal_bluebias();
  uint32_t raw_bluebias;
  memcpy(&raw_bluebias, &tmp_bluebias, sizeof(tmp_bluebias));
  if (raw_bluebias != 0) {
    total_size += 2 + 4;
  }

  // float greenBias = 21;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_greenbias = this->_internal_greenbias();
  uint32_t raw_greenbias;
  memcpy(&raw_greenbias, &tmp_greenbias, sizeof(tmp_greenbias));
  if (raw_greenbias != 0) {
    total_size += 2 + 4;
  }

  // float redBias = 22;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_redbias = this->_internal_redbias();
  uint32_t raw_redbias;
  memcpy(&raw_redbias, &tmp_redbias, sizeof(tmp_redbias));
  if (raw_redbias != 0) {
    total_size += 2 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NeuralNetworkImageScaler::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const NeuralNetworkImageScaler*>(
      &from));
}

void NeuralNetworkImageScaler::MergeFrom(const NeuralNetworkImageScaler& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.NeuralNetworkImageScaler)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_graybias = from._internal_graybias();
  uint32_t raw_graybias;
  memcpy(&raw_graybias, &tmp_graybias, sizeof(tmp_graybias));
  if (raw_graybias != 0) {
    _internal_set_graybias(from._internal_graybias());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_channelscale = from._internal_channelscale();
  uint32_t raw_channelscale;
  memcpy(&raw_channelscale, &tmp_channelscale, sizeof(tmp_channelscale));
  if (raw_channelscale != 0) {
    _internal_set_channelscale(from._internal_channelscale());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bluebias = from._internal_bluebias();
  uint32_t raw_bluebias;
  memcpy(&raw_bluebias, &tmp_bluebias, sizeof(tmp_bluebias));
  if (raw_bluebias != 0) {
    _internal_set_bluebias(from._internal_bluebias());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_greenbias = from._internal_greenbias();
  uint32_t raw_greenbias;
  memcpy(&raw_greenbias, &tmp_greenbias, sizeof(tmp_greenbias));
  if (raw_greenbias != 0) {
    _internal_set_greenbias(from._internal_greenbias());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_redbias = from._internal_redbias();
  uint32_t raw_redbias;
  memcpy(&raw_redbias, &tmp_redbias, sizeof(tmp_redbias));
  if (raw_redbias != 0) {
    _internal_set_redbias(from._internal_redbias());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NeuralNetworkImageScaler::CopyFrom(const NeuralNetworkImageScaler& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.NeuralNetworkImageScaler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NeuralNetworkImageScaler::IsInitialized() const {
  return true;
}

void NeuralNetworkImageScaler::InternalSwap(NeuralNetworkImageScaler* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NeuralNetworkImageScaler, redbias_)
      + sizeof(NeuralNetworkImageScaler::redbias_)
      - PROTOBUF_FIELD_OFFSET(NeuralNetworkImageScaler, graybias_)>(
          reinterpret_cast<char*>(&graybias_),
          reinterpret_cast<char*>(&other->graybias_));
}

std::string NeuralNetworkImageScaler::GetTypeName() const {
  return "CoreML.Specification.NeuralNetworkImageScaler";
}


// ===================================================================

class NeuralNetworkMeanImage::_Internal {
 public:
};

NeuralNetworkMeanImage::NeuralNetworkMeanImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  meanimage_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.NeuralNetworkMeanImage)
}
NeuralNetworkMeanImage::NeuralNetworkMeanImage(const NeuralNetworkMeanImage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      meanimage_(from.meanimage_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.NeuralNetworkMeanImage)
}

inline void NeuralNetworkMeanImage::SharedCtor() {
}

NeuralNetworkMeanImage::~NeuralNetworkMeanImage() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.NeuralNetworkMeanImage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void NeuralNetworkMeanImage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NeuralNetworkMeanImage::ArenaDtor(void* object) {
  NeuralNetworkMeanImage* _this = reinterpret_cast< NeuralNetworkMeanImage* >(object);
  (void)_this;
}
void NeuralNetworkMeanImage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NeuralNetworkMeanImage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NeuralNetworkMeanImage::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.NeuralNetworkMeanImage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  meanimage_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NeuralNetworkMeanImage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float meanImage = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_meanimage(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 13) {
          _internal_add_meanimage(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NeuralNetworkMeanImage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.NeuralNetworkMeanImage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float meanImage = 1;
  if (this->_internal_meanimage_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_meanimage(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.NeuralNetworkMeanImage)
  return target;
}

size_t NeuralNetworkMeanImage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.NeuralNetworkMeanImage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float meanImage = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_meanimage_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NeuralNetworkMeanImage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const NeuralNetworkMeanImage*>(
      &from));
}

void NeuralNetworkMeanImage::MergeFrom(const NeuralNetworkMeanImage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.NeuralNetworkMeanImage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  meanimage_.MergeFrom(from.meanimage_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NeuralNetworkMeanImage::CopyFrom(const NeuralNetworkMeanImage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.NeuralNetworkMeanImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NeuralNetworkMeanImage::IsInitialized() const {
  return true;
}

void NeuralNetworkMeanImage::InternalSwap(NeuralNetworkMeanImage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  meanimage_.InternalSwap(&other->meanimage_);
}

std::string NeuralNetworkMeanImage::GetTypeName() const {
  return "CoreML.Specification.NeuralNetworkMeanImage";
}


// ===================================================================

class NeuralNetworkPreprocessing::_Internal {
 public:
  static const ::CoreML::Specification::NeuralNetworkImageScaler& scaler(const NeuralNetworkPreprocessing* msg);
  static const ::CoreML::Specification::NeuralNetworkMeanImage& meanimage(const NeuralNetworkPreprocessing* msg);
};

const ::CoreML::Specification::NeuralNetworkImageScaler&
NeuralNetworkPreprocessing::_Internal::scaler(const NeuralNetworkPreprocessing* msg) {
  return *msg->preprocessor_.scaler_;
}
const ::CoreML::Specification::NeuralNetworkMeanImage&
NeuralNetworkPreprocessing::_Internal::meanimage(const NeuralNetworkPreprocessing* msg) {
  return *msg->preprocessor_.meanimage_;
}
void NeuralNetworkPreprocessing::set_allocated_scaler(::CoreML::Specification::NeuralNetworkImageScaler* scaler) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_preprocessor();
  if (scaler) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::NeuralNetworkImageScaler>::GetOwningArena(scaler);
    if (message_arena != submessage_arena) {
      scaler = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scaler, submessage_arena);
    }
    set_has_scaler();
    preprocessor_.scaler_ = scaler;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkPreprocessing.scaler)
}
void NeuralNetworkPreprocessing::set_allocated_meanimage(::CoreML::Specification::NeuralNetworkMeanImage* meanimage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_preprocessor();
  if (meanimage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::NeuralNetworkMeanImage>::GetOwningArena(meanimage);
    if (message_arena != submessage_arena) {
      meanimage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meanimage, submessage_arena);
    }
    set_has_meanimage();
    preprocessor_.meanimage_ = meanimage;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkPreprocessing.meanImage)
}
NeuralNetworkPreprocessing::NeuralNetworkPreprocessing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.NeuralNetworkPreprocessing)
}
NeuralNetworkPreprocessing::NeuralNetworkPreprocessing(const NeuralNetworkPreprocessing& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  featurename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    featurename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_featurename().empty()) {
    featurename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_featurename(), 
      GetArenaForAllocation());
  }
  clear_has_preprocessor();
  switch (from.preprocessor_case()) {
    case kScaler: {
      _internal_mutable_scaler()->::CoreML::Specification::NeuralNetworkImageScaler::MergeFrom(from._internal_scaler());
      break;
    }
    case kMeanImage: {
      _internal_mutable_meanimage()->::CoreML::Specification::NeuralNetworkMeanImage::MergeFrom(from._internal_meanimage());
      break;
    }
    case PREPROCESSOR_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.NeuralNetworkPreprocessing)
}

inline void NeuralNetworkPreprocessing::SharedCtor() {
featurename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  featurename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
clear_has_preprocessor();
}

NeuralNetworkPreprocessing::~NeuralNetworkPreprocessing() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.NeuralNetworkPreprocessing)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void NeuralNetworkPreprocessing::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  featurename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (has_preprocessor()) {
    clear_preprocessor();
  }
}

void NeuralNetworkPreprocessing::ArenaDtor(void* object) {
  NeuralNetworkPreprocessing* _this = reinterpret_cast< NeuralNetworkPreprocessing* >(object);
  (void)_this;
}
void NeuralNetworkPreprocessing::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NeuralNetworkPreprocessing::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NeuralNetworkPreprocessing::clear_preprocessor() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.NeuralNetworkPreprocessing)
  switch (preprocessor_case()) {
    case kScaler: {
      if (GetArenaForAllocation() == nullptr) {
        delete preprocessor_.scaler_;
      }
      break;
    }
    case kMeanImage: {
      if (GetArenaForAllocation() == nullptr) {
        delete preprocessor_.meanimage_;
      }
      break;
    }
    case PREPROCESSOR_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = PREPROCESSOR_NOT_SET;
}


void NeuralNetworkPreprocessing::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.NeuralNetworkPreprocessing)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  featurename_.ClearToEmpty();
  clear_preprocessor();
  _internal_metadata_.Clear<std::string>();
}

const char* NeuralNetworkPreprocessing::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string featureName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_featurename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NeuralNetworkImageScaler scaler = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_scaler(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NeuralNetworkMeanImage meanImage = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_meanimage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NeuralNetworkPreprocessing::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.NeuralNetworkPreprocessing)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string featureName = 1;
  if (!this->_internal_featurename().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_featurename().data(), static_cast<int>(this->_internal_featurename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.NeuralNetworkPreprocessing.featureName");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_featurename(), target);
  }

  // .CoreML.Specification.NeuralNetworkImageScaler scaler = 10;
  if (_internal_has_scaler()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::scaler(this), target, stream);
  }

  // .CoreML.Specification.NeuralNetworkMeanImage meanImage = 11;
  if (_internal_has_meanimage()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::meanimage(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.NeuralNetworkPreprocessing)
  return target;
}

size_t NeuralNetworkPreprocessing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.NeuralNetworkPreprocessing)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string featureName = 1;
  if (!this->_internal_featurename().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_featurename());
  }

  switch (preprocessor_case()) {
    // .CoreML.Specification.NeuralNetworkImageScaler scaler = 10;
    case kScaler: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *preprocessor_.scaler_);
      break;
    }
    // .CoreML.Specification.NeuralNetworkMeanImage meanImage = 11;
    case kMeanImage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *preprocessor_.meanimage_);
      break;
    }
    case PREPROCESSOR_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NeuralNetworkPreprocessing::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const NeuralNetworkPreprocessing*>(
      &from));
}

void NeuralNetworkPreprocessing::MergeFrom(const NeuralNetworkPreprocessing& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.NeuralNetworkPreprocessing)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_featurename().empty()) {
    _internal_set_featurename(from._internal_featurename());
  }
  switch (from.preprocessor_case()) {
    case kScaler: {
      _internal_mutable_scaler()->::CoreML::Specification::NeuralNetworkImageScaler::MergeFrom(from._internal_scaler());
      break;
    }
    case kMeanImage: {
      _internal_mutable_meanimage()->::CoreML::Specification::NeuralNetworkMeanImage::MergeFrom(from._internal_meanimage());
      break;
    }
    case PREPROCESSOR_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NeuralNetworkPreprocessing::CopyFrom(const NeuralNetworkPreprocessing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.NeuralNetworkPreprocessing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NeuralNetworkPreprocessing::IsInitialized() const {
  return true;
}

void NeuralNetworkPreprocessing::InternalSwap(NeuralNetworkPreprocessing* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &featurename_, lhs_arena,
      &other->featurename_, rhs_arena
  );
  swap(preprocessor_, other->preprocessor_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string NeuralNetworkPreprocessing::GetTypeName() const {
  return "CoreML.Specification.NeuralNetworkPreprocessing";
}


// ===================================================================

class ActivationReLU::_Internal {
 public:
};

ActivationReLU::ActivationReLU(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ActivationReLU)
}
ActivationReLU::ActivationReLU(const ActivationReLU& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ActivationReLU)
}

inline void ActivationReLU::SharedCtor() {
}

ActivationReLU::~ActivationReLU() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ActivationReLU)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ActivationReLU::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ActivationReLU::ArenaDtor(void* object) {
  ActivationReLU* _this = reinterpret_cast< ActivationReLU* >(object);
  (void)_this;
}
void ActivationReLU::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ActivationReLU::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActivationReLU::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ActivationReLU)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ActivationReLU::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActivationReLU::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ActivationReLU)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ActivationReLU)
  return target;
}

size_t ActivationReLU::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ActivationReLU)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActivationReLU::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ActivationReLU*>(
      &from));
}

void ActivationReLU::MergeFrom(const ActivationReLU& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ActivationReLU)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActivationReLU::CopyFrom(const ActivationReLU& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ActivationReLU)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActivationReLU::IsInitialized() const {
  return true;
}

void ActivationReLU::InternalSwap(ActivationReLU* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ActivationReLU::GetTypeName() const {
  return "CoreML.Specification.ActivationReLU";
}


// ===================================================================

class ActivationLeakyReLU::_Internal {
 public:
};

ActivationLeakyReLU::ActivationLeakyReLU(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ActivationLeakyReLU)
}
ActivationLeakyReLU::ActivationLeakyReLU(const ActivationLeakyReLU& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  alpha_ = from.alpha_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ActivationLeakyReLU)
}

inline void ActivationLeakyReLU::SharedCtor() {
alpha_ = 0;
}

ActivationLeakyReLU::~ActivationLeakyReLU() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ActivationLeakyReLU)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ActivationLeakyReLU::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ActivationLeakyReLU::ArenaDtor(void* object) {
  ActivationLeakyReLU* _this = reinterpret_cast< ActivationLeakyReLU* >(object);
  (void)_this;
}
void ActivationLeakyReLU::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ActivationLeakyReLU::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActivationLeakyReLU::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ActivationLeakyReLU)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  alpha_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* ActivationLeakyReLU::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float alpha = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActivationLeakyReLU::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ActivationLeakyReLU)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_alpha(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ActivationLeakyReLU)
  return target;
}

size_t ActivationLeakyReLU::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ActivationLeakyReLU)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActivationLeakyReLU::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ActivationLeakyReLU*>(
      &from));
}

void ActivationLeakyReLU::MergeFrom(const ActivationLeakyReLU& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ActivationLeakyReLU)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = from._internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    _internal_set_alpha(from._internal_alpha());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActivationLeakyReLU::CopyFrom(const ActivationLeakyReLU& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ActivationLeakyReLU)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActivationLeakyReLU::IsInitialized() const {
  return true;
}

void ActivationLeakyReLU::InternalSwap(ActivationLeakyReLU* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(alpha_, other->alpha_);
}

std::string ActivationLeakyReLU::GetTypeName() const {
  return "CoreML.Specification.ActivationLeakyReLU";
}


// ===================================================================

class ActivationTanh::_Internal {
 public:
};

ActivationTanh::ActivationTanh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ActivationTanh)
}
ActivationTanh::ActivationTanh(const ActivationTanh& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ActivationTanh)
}

inline void ActivationTanh::SharedCtor() {
}

ActivationTanh::~ActivationTanh() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ActivationTanh)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ActivationTanh::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ActivationTanh::ArenaDtor(void* object) {
  ActivationTanh* _this = reinterpret_cast< ActivationTanh* >(object);
  (void)_this;
}
void ActivationTanh::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ActivationTanh::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActivationTanh::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ActivationTanh)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ActivationTanh::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActivationTanh::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ActivationTanh)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ActivationTanh)
  return target;
}

size_t ActivationTanh::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ActivationTanh)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActivationTanh::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ActivationTanh*>(
      &from));
}

void ActivationTanh::MergeFrom(const ActivationTanh& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ActivationTanh)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActivationTanh::CopyFrom(const ActivationTanh& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ActivationTanh)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActivationTanh::IsInitialized() const {
  return true;
}

void ActivationTanh::InternalSwap(ActivationTanh* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ActivationTanh::GetTypeName() const {
  return "CoreML.Specification.ActivationTanh";
}


// ===================================================================

class ActivationScaledTanh::_Internal {
 public:
};

ActivationScaledTanh::ActivationScaledTanh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ActivationScaledTanh)
}
ActivationScaledTanh::ActivationScaledTanh(const ActivationScaledTanh& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&alpha_, &from.alpha_,
    static_cast<size_t>(reinterpret_cast<char*>(&beta_) -
    reinterpret_cast<char*>(&alpha_)) + sizeof(beta_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ActivationScaledTanh)
}

inline void ActivationScaledTanh::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&alpha_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&beta_) -
    reinterpret_cast<char*>(&alpha_)) + sizeof(beta_));
}

ActivationScaledTanh::~ActivationScaledTanh() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ActivationScaledTanh)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ActivationScaledTanh::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ActivationScaledTanh::ArenaDtor(void* object) {
  ActivationScaledTanh* _this = reinterpret_cast< ActivationScaledTanh* >(object);
  (void)_this;
}
void ActivationScaledTanh::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ActivationScaledTanh::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActivationScaledTanh::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ActivationScaledTanh)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&alpha_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&beta_) -
      reinterpret_cast<char*>(&alpha_)) + sizeof(beta_));
  _internal_metadata_.Clear<std::string>();
}

const char* ActivationScaledTanh::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float alpha = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float beta = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          beta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActivationScaledTanh::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ActivationScaledTanh)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_alpha(), target);
  }

  // float beta = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_beta = this->_internal_beta();
  uint32_t raw_beta;
  memcpy(&raw_beta, &tmp_beta, sizeof(tmp_beta));
  if (raw_beta != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_beta(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ActivationScaledTanh)
  return target;
}

size_t ActivationScaledTanh::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ActivationScaledTanh)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    total_size += 1 + 4;
  }

  // float beta = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_beta = this->_internal_beta();
  uint32_t raw_beta;
  memcpy(&raw_beta, &tmp_beta, sizeof(tmp_beta));
  if (raw_beta != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActivationScaledTanh::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ActivationScaledTanh*>(
      &from));
}

void ActivationScaledTanh::MergeFrom(const ActivationScaledTanh& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ActivationScaledTanh)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = from._internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    _internal_set_alpha(from._internal_alpha());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_beta = from._internal_beta();
  uint32_t raw_beta;
  memcpy(&raw_beta, &tmp_beta, sizeof(tmp_beta));
  if (raw_beta != 0) {
    _internal_set_beta(from._internal_beta());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActivationScaledTanh::CopyFrom(const ActivationScaledTanh& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ActivationScaledTanh)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActivationScaledTanh::IsInitialized() const {
  return true;
}

void ActivationScaledTanh::InternalSwap(ActivationScaledTanh* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ActivationScaledTanh, beta_)
      + sizeof(ActivationScaledTanh::beta_)
      - PROTOBUF_FIELD_OFFSET(ActivationScaledTanh, alpha_)>(
          reinterpret_cast<char*>(&alpha_),
          reinterpret_cast<char*>(&other->alpha_));
}

std::string ActivationScaledTanh::GetTypeName() const {
  return "CoreML.Specification.ActivationScaledTanh";
}


// ===================================================================

class ActivationSigmoid::_Internal {
 public:
};

ActivationSigmoid::ActivationSigmoid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ActivationSigmoid)
}
ActivationSigmoid::ActivationSigmoid(const ActivationSigmoid& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ActivationSigmoid)
}

inline void ActivationSigmoid::SharedCtor() {
}

ActivationSigmoid::~ActivationSigmoid() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ActivationSigmoid)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ActivationSigmoid::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ActivationSigmoid::ArenaDtor(void* object) {
  ActivationSigmoid* _this = reinterpret_cast< ActivationSigmoid* >(object);
  (void)_this;
}
void ActivationSigmoid::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ActivationSigmoid::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActivationSigmoid::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ActivationSigmoid)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ActivationSigmoid::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActivationSigmoid::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ActivationSigmoid)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ActivationSigmoid)
  return target;
}

size_t ActivationSigmoid::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ActivationSigmoid)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActivationSigmoid::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ActivationSigmoid*>(
      &from));
}

void ActivationSigmoid::MergeFrom(const ActivationSigmoid& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ActivationSigmoid)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActivationSigmoid::CopyFrom(const ActivationSigmoid& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ActivationSigmoid)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActivationSigmoid::IsInitialized() const {
  return true;
}

void ActivationSigmoid::InternalSwap(ActivationSigmoid* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ActivationSigmoid::GetTypeName() const {
  return "CoreML.Specification.ActivationSigmoid";
}


// ===================================================================

class ActivationLinear::_Internal {
 public:
};

ActivationLinear::ActivationLinear(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ActivationLinear)
}
ActivationLinear::ActivationLinear(const ActivationLinear& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&alpha_, &from.alpha_,
    static_cast<size_t>(reinterpret_cast<char*>(&beta_) -
    reinterpret_cast<char*>(&alpha_)) + sizeof(beta_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ActivationLinear)
}

inline void ActivationLinear::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&alpha_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&beta_) -
    reinterpret_cast<char*>(&alpha_)) + sizeof(beta_));
}

ActivationLinear::~ActivationLinear() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ActivationLinear)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ActivationLinear::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ActivationLinear::ArenaDtor(void* object) {
  ActivationLinear* _this = reinterpret_cast< ActivationLinear* >(object);
  (void)_this;
}
void ActivationLinear::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ActivationLinear::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActivationLinear::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ActivationLinear)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&alpha_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&beta_) -
      reinterpret_cast<char*>(&alpha_)) + sizeof(beta_));
  _internal_metadata_.Clear<std::string>();
}

const char* ActivationLinear::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float alpha = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float beta = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          beta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActivationLinear::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ActivationLinear)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_alpha(), target);
  }

  // float beta = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_beta = this->_internal_beta();
  uint32_t raw_beta;
  memcpy(&raw_beta, &tmp_beta, sizeof(tmp_beta));
  if (raw_beta != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_beta(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ActivationLinear)
  return target;
}

size_t ActivationLinear::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ActivationLinear)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    total_size += 1 + 4;
  }

  // float beta = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_beta = this->_internal_beta();
  uint32_t raw_beta;
  memcpy(&raw_beta, &tmp_beta, sizeof(tmp_beta));
  if (raw_beta != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActivationLinear::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ActivationLinear*>(
      &from));
}

void ActivationLinear::MergeFrom(const ActivationLinear& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ActivationLinear)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = from._internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    _internal_set_alpha(from._internal_alpha());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_beta = from._internal_beta();
  uint32_t raw_beta;
  memcpy(&raw_beta, &tmp_beta, sizeof(tmp_beta));
  if (raw_beta != 0) {
    _internal_set_beta(from._internal_beta());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActivationLinear::CopyFrom(const ActivationLinear& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ActivationLinear)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActivationLinear::IsInitialized() const {
  return true;
}

void ActivationLinear::InternalSwap(ActivationLinear* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ActivationLinear, beta_)
      + sizeof(ActivationLinear::beta_)
      - PROTOBUF_FIELD_OFFSET(ActivationLinear, alpha_)>(
          reinterpret_cast<char*>(&alpha_),
          reinterpret_cast<char*>(&other->alpha_));
}

std::string ActivationLinear::GetTypeName() const {
  return "CoreML.Specification.ActivationLinear";
}


// ===================================================================

class ActivationSigmoidHard::_Internal {
 public:
};

ActivationSigmoidHard::ActivationSigmoidHard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ActivationSigmoidHard)
}
ActivationSigmoidHard::ActivationSigmoidHard(const ActivationSigmoidHard& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&alpha_, &from.alpha_,
    static_cast<size_t>(reinterpret_cast<char*>(&beta_) -
    reinterpret_cast<char*>(&alpha_)) + sizeof(beta_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ActivationSigmoidHard)
}

inline void ActivationSigmoidHard::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&alpha_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&beta_) -
    reinterpret_cast<char*>(&alpha_)) + sizeof(beta_));
}

ActivationSigmoidHard::~ActivationSigmoidHard() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ActivationSigmoidHard)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ActivationSigmoidHard::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ActivationSigmoidHard::ArenaDtor(void* object) {
  ActivationSigmoidHard* _this = reinterpret_cast< ActivationSigmoidHard* >(object);
  (void)_this;
}
void ActivationSigmoidHard::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ActivationSigmoidHard::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActivationSigmoidHard::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ActivationSigmoidHard)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&alpha_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&beta_) -
      reinterpret_cast<char*>(&alpha_)) + sizeof(beta_));
  _internal_metadata_.Clear<std::string>();
}

const char* ActivationSigmoidHard::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float alpha = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float beta = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          beta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActivationSigmoidHard::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ActivationSigmoidHard)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_alpha(), target);
  }

  // float beta = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_beta = this->_internal_beta();
  uint32_t raw_beta;
  memcpy(&raw_beta, &tmp_beta, sizeof(tmp_beta));
  if (raw_beta != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_beta(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ActivationSigmoidHard)
  return target;
}

size_t ActivationSigmoidHard::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ActivationSigmoidHard)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    total_size += 1 + 4;
  }

  // float beta = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_beta = this->_internal_beta();
  uint32_t raw_beta;
  memcpy(&raw_beta, &tmp_beta, sizeof(tmp_beta));
  if (raw_beta != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActivationSigmoidHard::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ActivationSigmoidHard*>(
      &from));
}

void ActivationSigmoidHard::MergeFrom(const ActivationSigmoidHard& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ActivationSigmoidHard)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = from._internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    _internal_set_alpha(from._internal_alpha());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_beta = from._internal_beta();
  uint32_t raw_beta;
  memcpy(&raw_beta, &tmp_beta, sizeof(tmp_beta));
  if (raw_beta != 0) {
    _internal_set_beta(from._internal_beta());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActivationSigmoidHard::CopyFrom(const ActivationSigmoidHard& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ActivationSigmoidHard)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActivationSigmoidHard::IsInitialized() const {
  return true;
}

void ActivationSigmoidHard::InternalSwap(ActivationSigmoidHard* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ActivationSigmoidHard, beta_)
      + sizeof(ActivationSigmoidHard::beta_)
      - PROTOBUF_FIELD_OFFSET(ActivationSigmoidHard, alpha_)>(
          reinterpret_cast<char*>(&alpha_),
          reinterpret_cast<char*>(&other->alpha_));
}

std::string ActivationSigmoidHard::GetTypeName() const {
  return "CoreML.Specification.ActivationSigmoidHard";
}


// ===================================================================

class ActivationPReLU::_Internal {
 public:
  static const ::CoreML::Specification::WeightParams& alpha(const ActivationPReLU* msg);
};

const ::CoreML::Specification::WeightParams&
ActivationPReLU::_Internal::alpha(const ActivationPReLU* msg) {
  return *msg->alpha_;
}
ActivationPReLU::ActivationPReLU(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ActivationPReLU)
}
ActivationPReLU::ActivationPReLU(const ActivationPReLU& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_alpha()) {
    alpha_ = new ::CoreML::Specification::WeightParams(*from.alpha_);
  } else {
    alpha_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ActivationPReLU)
}

inline void ActivationPReLU::SharedCtor() {
alpha_ = nullptr;
}

ActivationPReLU::~ActivationPReLU() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ActivationPReLU)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ActivationPReLU::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete alpha_;
}

void ActivationPReLU::ArenaDtor(void* object) {
  ActivationPReLU* _this = reinterpret_cast< ActivationPReLU* >(object);
  (void)_this;
}
void ActivationPReLU::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ActivationPReLU::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActivationPReLU::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ActivationPReLU)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && alpha_ != nullptr) {
    delete alpha_;
  }
  alpha_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* ActivationPReLU::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.WeightParams alpha = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_alpha(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActivationPReLU::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ActivationPReLU)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.WeightParams alpha = 1;
  if (this->_internal_has_alpha()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::alpha(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ActivationPReLU)
  return target;
}

size_t ActivationPReLU::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ActivationPReLU)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.WeightParams alpha = 1;
  if (this->_internal_has_alpha()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *alpha_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActivationPReLU::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ActivationPReLU*>(
      &from));
}

void ActivationPReLU::MergeFrom(const ActivationPReLU& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ActivationPReLU)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_alpha()) {
    _internal_mutable_alpha()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_alpha());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActivationPReLU::CopyFrom(const ActivationPReLU& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ActivationPReLU)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActivationPReLU::IsInitialized() const {
  return true;
}

void ActivationPReLU::InternalSwap(ActivationPReLU* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(alpha_, other->alpha_);
}

std::string ActivationPReLU::GetTypeName() const {
  return "CoreML.Specification.ActivationPReLU";
}


// ===================================================================

class ActivationELU::_Internal {
 public:
};

ActivationELU::ActivationELU(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ActivationELU)
}
ActivationELU::ActivationELU(const ActivationELU& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  alpha_ = from.alpha_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ActivationELU)
}

inline void ActivationELU::SharedCtor() {
alpha_ = 0;
}

ActivationELU::~ActivationELU() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ActivationELU)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ActivationELU::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ActivationELU::ArenaDtor(void* object) {
  ActivationELU* _this = reinterpret_cast< ActivationELU* >(object);
  (void)_this;
}
void ActivationELU::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ActivationELU::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActivationELU::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ActivationELU)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  alpha_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* ActivationELU::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float alpha = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActivationELU::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ActivationELU)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_alpha(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ActivationELU)
  return target;
}

size_t ActivationELU::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ActivationELU)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActivationELU::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ActivationELU*>(
      &from));
}

void ActivationELU::MergeFrom(const ActivationELU& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ActivationELU)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = from._internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    _internal_set_alpha(from._internal_alpha());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActivationELU::CopyFrom(const ActivationELU& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ActivationELU)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActivationELU::IsInitialized() const {
  return true;
}

void ActivationELU::InternalSwap(ActivationELU* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(alpha_, other->alpha_);
}

std::string ActivationELU::GetTypeName() const {
  return "CoreML.Specification.ActivationELU";
}


// ===================================================================

class ActivationThresholdedReLU::_Internal {
 public:
};

ActivationThresholdedReLU::ActivationThresholdedReLU(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ActivationThresholdedReLU)
}
ActivationThresholdedReLU::ActivationThresholdedReLU(const ActivationThresholdedReLU& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  alpha_ = from.alpha_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ActivationThresholdedReLU)
}

inline void ActivationThresholdedReLU::SharedCtor() {
alpha_ = 0;
}

ActivationThresholdedReLU::~ActivationThresholdedReLU() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ActivationThresholdedReLU)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ActivationThresholdedReLU::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ActivationThresholdedReLU::ArenaDtor(void* object) {
  ActivationThresholdedReLU* _this = reinterpret_cast< ActivationThresholdedReLU* >(object);
  (void)_this;
}
void ActivationThresholdedReLU::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ActivationThresholdedReLU::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActivationThresholdedReLU::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ActivationThresholdedReLU)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  alpha_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* ActivationThresholdedReLU::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float alpha = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActivationThresholdedReLU::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ActivationThresholdedReLU)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_alpha(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ActivationThresholdedReLU)
  return target;
}

size_t ActivationThresholdedReLU::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ActivationThresholdedReLU)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActivationThresholdedReLU::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ActivationThresholdedReLU*>(
      &from));
}

void ActivationThresholdedReLU::MergeFrom(const ActivationThresholdedReLU& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ActivationThresholdedReLU)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = from._internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    _internal_set_alpha(from._internal_alpha());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActivationThresholdedReLU::CopyFrom(const ActivationThresholdedReLU& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ActivationThresholdedReLU)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActivationThresholdedReLU::IsInitialized() const {
  return true;
}

void ActivationThresholdedReLU::InternalSwap(ActivationThresholdedReLU* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(alpha_, other->alpha_);
}

std::string ActivationThresholdedReLU::GetTypeName() const {
  return "CoreML.Specification.ActivationThresholdedReLU";
}


// ===================================================================

class ActivationSoftsign::_Internal {
 public:
};

ActivationSoftsign::ActivationSoftsign(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ActivationSoftsign)
}
ActivationSoftsign::ActivationSoftsign(const ActivationSoftsign& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ActivationSoftsign)
}

inline void ActivationSoftsign::SharedCtor() {
}

ActivationSoftsign::~ActivationSoftsign() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ActivationSoftsign)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ActivationSoftsign::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ActivationSoftsign::ArenaDtor(void* object) {
  ActivationSoftsign* _this = reinterpret_cast< ActivationSoftsign* >(object);
  (void)_this;
}
void ActivationSoftsign::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ActivationSoftsign::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActivationSoftsign::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ActivationSoftsign)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ActivationSoftsign::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActivationSoftsign::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ActivationSoftsign)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ActivationSoftsign)
  return target;
}

size_t ActivationSoftsign::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ActivationSoftsign)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActivationSoftsign::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ActivationSoftsign*>(
      &from));
}

void ActivationSoftsign::MergeFrom(const ActivationSoftsign& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ActivationSoftsign)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActivationSoftsign::CopyFrom(const ActivationSoftsign& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ActivationSoftsign)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActivationSoftsign::IsInitialized() const {
  return true;
}

void ActivationSoftsign::InternalSwap(ActivationSoftsign* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ActivationSoftsign::GetTypeName() const {
  return "CoreML.Specification.ActivationSoftsign";
}


// ===================================================================

class ActivationSoftplus::_Internal {
 public:
};

ActivationSoftplus::ActivationSoftplus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ActivationSoftplus)
}
ActivationSoftplus::ActivationSoftplus(const ActivationSoftplus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ActivationSoftplus)
}

inline void ActivationSoftplus::SharedCtor() {
}

ActivationSoftplus::~ActivationSoftplus() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ActivationSoftplus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ActivationSoftplus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ActivationSoftplus::ArenaDtor(void* object) {
  ActivationSoftplus* _this = reinterpret_cast< ActivationSoftplus* >(object);
  (void)_this;
}
void ActivationSoftplus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ActivationSoftplus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActivationSoftplus::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ActivationSoftplus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ActivationSoftplus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActivationSoftplus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ActivationSoftplus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ActivationSoftplus)
  return target;
}

size_t ActivationSoftplus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ActivationSoftplus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActivationSoftplus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ActivationSoftplus*>(
      &from));
}

void ActivationSoftplus::MergeFrom(const ActivationSoftplus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ActivationSoftplus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActivationSoftplus::CopyFrom(const ActivationSoftplus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ActivationSoftplus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActivationSoftplus::IsInitialized() const {
  return true;
}

void ActivationSoftplus::InternalSwap(ActivationSoftplus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ActivationSoftplus::GetTypeName() const {
  return "CoreML.Specification.ActivationSoftplus";
}


// ===================================================================

class ActivationParametricSoftplus::_Internal {
 public:
  static const ::CoreML::Specification::WeightParams& alpha(const ActivationParametricSoftplus* msg);
  static const ::CoreML::Specification::WeightParams& beta(const ActivationParametricSoftplus* msg);
};

const ::CoreML::Specification::WeightParams&
ActivationParametricSoftplus::_Internal::alpha(const ActivationParametricSoftplus* msg) {
  return *msg->alpha_;
}
const ::CoreML::Specification::WeightParams&
ActivationParametricSoftplus::_Internal::beta(const ActivationParametricSoftplus* msg) {
  return *msg->beta_;
}
ActivationParametricSoftplus::ActivationParametricSoftplus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ActivationParametricSoftplus)
}
ActivationParametricSoftplus::ActivationParametricSoftplus(const ActivationParametricSoftplus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_alpha()) {
    alpha_ = new ::CoreML::Specification::WeightParams(*from.alpha_);
  } else {
    alpha_ = nullptr;
  }
  if (from._internal_has_beta()) {
    beta_ = new ::CoreML::Specification::WeightParams(*from.beta_);
  } else {
    beta_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ActivationParametricSoftplus)
}

inline void ActivationParametricSoftplus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&alpha_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&beta_) -
    reinterpret_cast<char*>(&alpha_)) + sizeof(beta_));
}

ActivationParametricSoftplus::~ActivationParametricSoftplus() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ActivationParametricSoftplus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ActivationParametricSoftplus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete alpha_;
  if (this != internal_default_instance()) delete beta_;
}

void ActivationParametricSoftplus::ArenaDtor(void* object) {
  ActivationParametricSoftplus* _this = reinterpret_cast< ActivationParametricSoftplus* >(object);
  (void)_this;
}
void ActivationParametricSoftplus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ActivationParametricSoftplus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActivationParametricSoftplus::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ActivationParametricSoftplus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && alpha_ != nullptr) {
    delete alpha_;
  }
  alpha_ = nullptr;
  if (GetArenaForAllocation() == nullptr && beta_ != nullptr) {
    delete beta_;
  }
  beta_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* ActivationParametricSoftplus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.WeightParams alpha = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_alpha(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams beta = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_beta(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActivationParametricSoftplus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ActivationParametricSoftplus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.WeightParams alpha = 1;
  if (this->_internal_has_alpha()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::alpha(this), target, stream);
  }

  // .CoreML.Specification.WeightParams beta = 2;
  if (this->_internal_has_beta()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::beta(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ActivationParametricSoftplus)
  return target;
}

size_t ActivationParametricSoftplus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ActivationParametricSoftplus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.WeightParams alpha = 1;
  if (this->_internal_has_alpha()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *alpha_);
  }

  // .CoreML.Specification.WeightParams beta = 2;
  if (this->_internal_has_beta()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *beta_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActivationParametricSoftplus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ActivationParametricSoftplus*>(
      &from));
}

void ActivationParametricSoftplus::MergeFrom(const ActivationParametricSoftplus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ActivationParametricSoftplus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_alpha()) {
    _internal_mutable_alpha()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_alpha());
  }
  if (from._internal_has_beta()) {
    _internal_mutable_beta()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_beta());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActivationParametricSoftplus::CopyFrom(const ActivationParametricSoftplus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ActivationParametricSoftplus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActivationParametricSoftplus::IsInitialized() const {
  return true;
}

void ActivationParametricSoftplus::InternalSwap(ActivationParametricSoftplus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ActivationParametricSoftplus, beta_)
      + sizeof(ActivationParametricSoftplus::beta_)
      - PROTOBUF_FIELD_OFFSET(ActivationParametricSoftplus, alpha_)>(
          reinterpret_cast<char*>(&alpha_),
          reinterpret_cast<char*>(&other->alpha_));
}

std::string ActivationParametricSoftplus::GetTypeName() const {
  return "CoreML.Specification.ActivationParametricSoftplus";
}


// ===================================================================

class ActivationParams::_Internal {
 public:
  static const ::CoreML::Specification::ActivationLinear& linear(const ActivationParams* msg);
  static const ::CoreML::Specification::ActivationReLU& relu(const ActivationParams* msg);
  static const ::CoreML::Specification::ActivationLeakyReLU& leakyrelu(const ActivationParams* msg);
  static const ::CoreML::Specification::ActivationThresholdedReLU& thresholdedrelu(const ActivationParams* msg);
  static const ::CoreML::Specification::ActivationPReLU& prelu(const ActivationParams* msg);
  static const ::CoreML::Specification::ActivationTanh& tanh(const ActivationParams* msg);
  static const ::CoreML::Specification::ActivationScaledTanh& scaledtanh(const ActivationParams* msg);
  static const ::CoreML::Specification::ActivationSigmoid& sigmoid(const ActivationParams* msg);
  static const ::CoreML::Specification::ActivationSigmoidHard& sigmoidhard(const ActivationParams* msg);
  static const ::CoreML::Specification::ActivationELU& elu(const ActivationParams* msg);
  static const ::CoreML::Specification::ActivationSoftsign& softsign(const ActivationParams* msg);
  static const ::CoreML::Specification::ActivationSoftplus& softplus(const ActivationParams* msg);
  static const ::CoreML::Specification::ActivationParametricSoftplus& parametricsoftplus(const ActivationParams* msg);
};

const ::CoreML::Specification::ActivationLinear&
ActivationParams::_Internal::linear(const ActivationParams* msg) {
  return *msg->NonlinearityType_.linear_;
}
const ::CoreML::Specification::ActivationReLU&
ActivationParams::_Internal::relu(const ActivationParams* msg) {
  return *msg->NonlinearityType_.relu_;
}
const ::CoreML::Specification::ActivationLeakyReLU&
ActivationParams::_Internal::leakyrelu(const ActivationParams* msg) {
  return *msg->NonlinearityType_.leakyrelu_;
}
const ::CoreML::Specification::ActivationThresholdedReLU&
ActivationParams::_Internal::thresholdedrelu(const ActivationParams* msg) {
  return *msg->NonlinearityType_.thresholdedrelu_;
}
const ::CoreML::Specification::ActivationPReLU&
ActivationParams::_Internal::prelu(const ActivationParams* msg) {
  return *msg->NonlinearityType_.prelu_;
}
const ::CoreML::Specification::ActivationTanh&
ActivationParams::_Internal::tanh(const ActivationParams* msg) {
  return *msg->NonlinearityType_.tanh_;
}
const ::CoreML::Specification::ActivationScaledTanh&
ActivationParams::_Internal::scaledtanh(const ActivationParams* msg) {
  return *msg->NonlinearityType_.scaledtanh_;
}
const ::CoreML::Specification::ActivationSigmoid&
ActivationParams::_Internal::sigmoid(const ActivationParams* msg) {
  return *msg->NonlinearityType_.sigmoid_;
}
const ::CoreML::Specification::ActivationSigmoidHard&
ActivationParams::_Internal::sigmoidhard(const ActivationParams* msg) {
  return *msg->NonlinearityType_.sigmoidhard_;
}
const ::CoreML::Specification::ActivationELU&
ActivationParams::_Internal::elu(const ActivationParams* msg) {
  return *msg->NonlinearityType_.elu_;
}
const ::CoreML::Specification::ActivationSoftsign&
ActivationParams::_Internal::softsign(const ActivationParams* msg) {
  return *msg->NonlinearityType_.softsign_;
}
const ::CoreML::Specification::ActivationSoftplus&
ActivationParams::_Internal::softplus(const ActivationParams* msg) {
  return *msg->NonlinearityType_.softplus_;
}
const ::CoreML::Specification::ActivationParametricSoftplus&
ActivationParams::_Internal::parametricsoftplus(const ActivationParams* msg) {
  return *msg->NonlinearityType_.parametricsoftplus_;
}
void ActivationParams::set_allocated_linear(::CoreML::Specification::ActivationLinear* linear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_NonlinearityType();
  if (linear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ActivationLinear>::GetOwningArena(linear);
    if (message_arena != submessage_arena) {
      linear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear, submessage_arena);
    }
    set_has_linear();
    NonlinearityType_.linear_ = linear;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.linear)
}
void ActivationParams::set_allocated_relu(::CoreML::Specification::ActivationReLU* relu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_NonlinearityType();
  if (relu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ActivationReLU>::GetOwningArena(relu);
    if (message_arena != submessage_arena) {
      relu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relu, submessage_arena);
    }
    set_has_relu();
    NonlinearityType_.relu_ = relu;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.ReLU)
}
void ActivationParams::set_allocated_leakyrelu(::CoreML::Specification::ActivationLeakyReLU* leakyrelu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_NonlinearityType();
  if (leakyrelu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ActivationLeakyReLU>::GetOwningArena(leakyrelu);
    if (message_arena != submessage_arena) {
      leakyrelu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leakyrelu, submessage_arena);
    }
    set_has_leakyrelu();
    NonlinearityType_.leakyrelu_ = leakyrelu;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.leakyReLU)
}
void ActivationParams::set_allocated_thresholdedrelu(::CoreML::Specification::ActivationThresholdedReLU* thresholdedrelu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_NonlinearityType();
  if (thresholdedrelu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ActivationThresholdedReLU>::GetOwningArena(thresholdedrelu);
    if (message_arena != submessage_arena) {
      thresholdedrelu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, thresholdedrelu, submessage_arena);
    }
    set_has_thresholdedrelu();
    NonlinearityType_.thresholdedrelu_ = thresholdedrelu;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.thresholdedReLU)
}
void ActivationParams::set_allocated_prelu(::CoreML::Specification::ActivationPReLU* prelu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_NonlinearityType();
  if (prelu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ActivationPReLU>::GetOwningArena(prelu);
    if (message_arena != submessage_arena) {
      prelu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prelu, submessage_arena);
    }
    set_has_prelu();
    NonlinearityType_.prelu_ = prelu;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.PReLU)
}
void ActivationParams::set_allocated_tanh(::CoreML::Specification::ActivationTanh* tanh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_NonlinearityType();
  if (tanh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ActivationTanh>::GetOwningArena(tanh);
    if (message_arena != submessage_arena) {
      tanh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tanh, submessage_arena);
    }
    set_has_tanh();
    NonlinearityType_.tanh_ = tanh;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.tanh)
}
void ActivationParams::set_allocated_scaledtanh(::CoreML::Specification::ActivationScaledTanh* scaledtanh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_NonlinearityType();
  if (scaledtanh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ActivationScaledTanh>::GetOwningArena(scaledtanh);
    if (message_arena != submessage_arena) {
      scaledtanh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scaledtanh, submessage_arena);
    }
    set_has_scaledtanh();
    NonlinearityType_.scaledtanh_ = scaledtanh;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.scaledTanh)
}
void ActivationParams::set_allocated_sigmoid(::CoreML::Specification::ActivationSigmoid* sigmoid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_NonlinearityType();
  if (sigmoid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ActivationSigmoid>::GetOwningArena(sigmoid);
    if (message_arena != submessage_arena) {
      sigmoid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sigmoid, submessage_arena);
    }
    set_has_sigmoid();
    NonlinearityType_.sigmoid_ = sigmoid;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.sigmoid)
}
void ActivationParams::set_allocated_sigmoidhard(::CoreML::Specification::ActivationSigmoidHard* sigmoidhard) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_NonlinearityType();
  if (sigmoidhard) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ActivationSigmoidHard>::GetOwningArena(sigmoidhard);
    if (message_arena != submessage_arena) {
      sigmoidhard = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sigmoidhard, submessage_arena);
    }
    set_has_sigmoidhard();
    NonlinearityType_.sigmoidhard_ = sigmoidhard;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.sigmoidHard)
}
void ActivationParams::set_allocated_elu(::CoreML::Specification::ActivationELU* elu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_NonlinearityType();
  if (elu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ActivationELU>::GetOwningArena(elu);
    if (message_arena != submessage_arena) {
      elu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, elu, submessage_arena);
    }
    set_has_elu();
    NonlinearityType_.elu_ = elu;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.ELU)
}
void ActivationParams::set_allocated_softsign(::CoreML::Specification::ActivationSoftsign* softsign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_NonlinearityType();
  if (softsign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ActivationSoftsign>::GetOwningArena(softsign);
    if (message_arena != submessage_arena) {
      softsign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, softsign, submessage_arena);
    }
    set_has_softsign();
    NonlinearityType_.softsign_ = softsign;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.softsign)
}
void ActivationParams::set_allocated_softplus(::CoreML::Specification::ActivationSoftplus* softplus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_NonlinearityType();
  if (softplus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ActivationSoftplus>::GetOwningArena(softplus);
    if (message_arena != submessage_arena) {
      softplus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, softplus, submessage_arena);
    }
    set_has_softplus();
    NonlinearityType_.softplus_ = softplus;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.softplus)
}
void ActivationParams::set_allocated_parametricsoftplus(::CoreML::Specification::ActivationParametricSoftplus* parametricsoftplus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_NonlinearityType();
  if (parametricsoftplus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ActivationParametricSoftplus>::GetOwningArena(parametricsoftplus);
    if (message_arena != submessage_arena) {
      parametricsoftplus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parametricsoftplus, submessage_arena);
    }
    set_has_parametricsoftplus();
    NonlinearityType_.parametricsoftplus_ = parametricsoftplus;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.parametricSoftplus)
}
ActivationParams::ActivationParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ActivationParams)
}
ActivationParams::ActivationParams(const ActivationParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_NonlinearityType();
  switch (from.NonlinearityType_case()) {
    case kLinear: {
      _internal_mutable_linear()->::CoreML::Specification::ActivationLinear::MergeFrom(from._internal_linear());
      break;
    }
    case kReLU: {
      _internal_mutable_relu()->::CoreML::Specification::ActivationReLU::MergeFrom(from._internal_relu());
      break;
    }
    case kLeakyReLU: {
      _internal_mutable_leakyrelu()->::CoreML::Specification::ActivationLeakyReLU::MergeFrom(from._internal_leakyrelu());
      break;
    }
    case kThresholdedReLU: {
      _internal_mutable_thresholdedrelu()->::CoreML::Specification::ActivationThresholdedReLU::MergeFrom(from._internal_thresholdedrelu());
      break;
    }
    case kPReLU: {
      _internal_mutable_prelu()->::CoreML::Specification::ActivationPReLU::MergeFrom(from._internal_prelu());
      break;
    }
    case kTanh: {
      _internal_mutable_tanh()->::CoreML::Specification::ActivationTanh::MergeFrom(from._internal_tanh());
      break;
    }
    case kScaledTanh: {
      _internal_mutable_scaledtanh()->::CoreML::Specification::ActivationScaledTanh::MergeFrom(from._internal_scaledtanh());
      break;
    }
    case kSigmoid: {
      _internal_mutable_sigmoid()->::CoreML::Specification::ActivationSigmoid::MergeFrom(from._internal_sigmoid());
      break;
    }
    case kSigmoidHard: {
      _internal_mutable_sigmoidhard()->::CoreML::Specification::ActivationSigmoidHard::MergeFrom(from._internal_sigmoidhard());
      break;
    }
    case kELU: {
      _internal_mutable_elu()->::CoreML::Specification::ActivationELU::MergeFrom(from._internal_elu());
      break;
    }
    case kSoftsign: {
      _internal_mutable_softsign()->::CoreML::Specification::ActivationSoftsign::MergeFrom(from._internal_softsign());
      break;
    }
    case kSoftplus: {
      _internal_mutable_softplus()->::CoreML::Specification::ActivationSoftplus::MergeFrom(from._internal_softplus());
      break;
    }
    case kParametricSoftplus: {
      _internal_mutable_parametricsoftplus()->::CoreML::Specification::ActivationParametricSoftplus::MergeFrom(from._internal_parametricsoftplus());
      break;
    }
    case NONLINEARITYTYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ActivationParams)
}

inline void ActivationParams::SharedCtor() {
clear_has_NonlinearityType();
}

ActivationParams::~ActivationParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ActivationParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ActivationParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_NonlinearityType()) {
    clear_NonlinearityType();
  }
}

void ActivationParams::ArenaDtor(void* object) {
  ActivationParams* _this = reinterpret_cast< ActivationParams* >(object);
  (void)_this;
}
void ActivationParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ActivationParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActivationParams::clear_NonlinearityType() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.ActivationParams)
  switch (NonlinearityType_case()) {
    case kLinear: {
      if (GetArenaForAllocation() == nullptr) {
        delete NonlinearityType_.linear_;
      }
      break;
    }
    case kReLU: {
      if (GetArenaForAllocation() == nullptr) {
        delete NonlinearityType_.relu_;
      }
      break;
    }
    case kLeakyReLU: {
      if (GetArenaForAllocation() == nullptr) {
        delete NonlinearityType_.leakyrelu_;
      }
      break;
    }
    case kThresholdedReLU: {
      if (GetArenaForAllocation() == nullptr) {
        delete NonlinearityType_.thresholdedrelu_;
      }
      break;
    }
    case kPReLU: {
      if (GetArenaForAllocation() == nullptr) {
        delete NonlinearityType_.prelu_;
      }
      break;
    }
    case kTanh: {
      if (GetArenaForAllocation() == nullptr) {
        delete NonlinearityType_.tanh_;
      }
      break;
    }
    case kScaledTanh: {
      if (GetArenaForAllocation() == nullptr) {
        delete NonlinearityType_.scaledtanh_;
      }
      break;
    }
    case kSigmoid: {
      if (GetArenaForAllocation() == nullptr) {
        delete NonlinearityType_.sigmoid_;
      }
      break;
    }
    case kSigmoidHard: {
      if (GetArenaForAllocation() == nullptr) {
        delete NonlinearityType_.sigmoidhard_;
      }
      break;
    }
    case kELU: {
      if (GetArenaForAllocation() == nullptr) {
        delete NonlinearityType_.elu_;
      }
      break;
    }
    case kSoftsign: {
      if (GetArenaForAllocation() == nullptr) {
        delete NonlinearityType_.softsign_;
      }
      break;
    }
    case kSoftplus: {
      if (GetArenaForAllocation() == nullptr) {
        delete NonlinearityType_.softplus_;
      }
      break;
    }
    case kParametricSoftplus: {
      if (GetArenaForAllocation() == nullptr) {
        delete NonlinearityType_.parametricsoftplus_;
      }
      break;
    }
    case NONLINEARITYTYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = NONLINEARITYTYPE_NOT_SET;
}


void ActivationParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ActivationParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_NonlinearityType();
  _internal_metadata_.Clear<std::string>();
}

const char* ActivationParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.ActivationLinear linear = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_linear(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ActivationReLU ReLU = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_relu(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ActivationLeakyReLU leakyReLU = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_leakyrelu(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ActivationThresholdedReLU thresholdedReLU = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_thresholdedrelu(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ActivationPReLU PReLU = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_prelu(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ActivationTanh tanh = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_tanh(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ActivationScaledTanh scaledTanh = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_scaledtanh(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ActivationSigmoid sigmoid = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_sigmoid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ActivationSigmoidHard sigmoidHard = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_sigmoidhard(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ActivationELU ELU = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_elu(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ActivationSoftsign softsign = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_softsign(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ActivationSoftplus softplus = 70;
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_softplus(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ActivationParametricSoftplus parametricSoftplus = 71;
      case 71:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_parametricsoftplus(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActivationParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ActivationParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.ActivationLinear linear = 5;
  if (_internal_has_linear()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::linear(this), target, stream);
  }

  // .CoreML.Specification.ActivationReLU ReLU = 10;
  if (_internal_has_relu()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::relu(this), target, stream);
  }

  // .CoreML.Specification.ActivationLeakyReLU leakyReLU = 15;
  if (_internal_has_leakyrelu()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        15, _Internal::leakyrelu(this), target, stream);
  }

  // .CoreML.Specification.ActivationThresholdedReLU thresholdedReLU = 20;
  if (_internal_has_thresholdedrelu()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::thresholdedrelu(this), target, stream);
  }

  // .CoreML.Specification.ActivationPReLU PReLU = 25;
  if (_internal_has_prelu()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        25, _Internal::prelu(this), target, stream);
  }

  // .CoreML.Specification.ActivationTanh tanh = 30;
  if (_internal_has_tanh()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        30, _Internal::tanh(this), target, stream);
  }

  // .CoreML.Specification.ActivationScaledTanh scaledTanh = 31;
  if (_internal_has_scaledtanh()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        31, _Internal::scaledtanh(this), target, stream);
  }

  // .CoreML.Specification.ActivationSigmoid sigmoid = 40;
  if (_internal_has_sigmoid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        40, _Internal::sigmoid(this), target, stream);
  }

  // .CoreML.Specification.ActivationSigmoidHard sigmoidHard = 41;
  if (_internal_has_sigmoidhard()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        41, _Internal::sigmoidhard(this), target, stream);
  }

  // .CoreML.Specification.ActivationELU ELU = 50;
  if (_internal_has_elu()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        50, _Internal::elu(this), target, stream);
  }

  // .CoreML.Specification.ActivationSoftsign softsign = 60;
  if (_internal_has_softsign()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        60, _Internal::softsign(this), target, stream);
  }

  // .CoreML.Specification.ActivationSoftplus softplus = 70;
  if (_internal_has_softplus()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        70, _Internal::softplus(this), target, stream);
  }

  // .CoreML.Specification.ActivationParametricSoftplus parametricSoftplus = 71;
  if (_internal_has_parametricsoftplus()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        71, _Internal::parametricsoftplus(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ActivationParams)
  return target;
}

size_t ActivationParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ActivationParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (NonlinearityType_case()) {
    // .CoreML.Specification.ActivationLinear linear = 5;
    case kLinear: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *NonlinearityType_.linear_);
      break;
    }
    // .CoreML.Specification.ActivationReLU ReLU = 10;
    case kReLU: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *NonlinearityType_.relu_);
      break;
    }
    // .CoreML.Specification.ActivationLeakyReLU leakyReLU = 15;
    case kLeakyReLU: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *NonlinearityType_.leakyrelu_);
      break;
    }
    // .CoreML.Specification.ActivationThresholdedReLU thresholdedReLU = 20;
    case kThresholdedReLU: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *NonlinearityType_.thresholdedrelu_);
      break;
    }
    // .CoreML.Specification.ActivationPReLU PReLU = 25;
    case kPReLU: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *NonlinearityType_.prelu_);
      break;
    }
    // .CoreML.Specification.ActivationTanh tanh = 30;
    case kTanh: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *NonlinearityType_.tanh_);
      break;
    }
    // .CoreML.Specification.ActivationScaledTanh scaledTanh = 31;
    case kScaledTanh: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *NonlinearityType_.scaledtanh_);
      break;
    }
    // .CoreML.Specification.ActivationSigmoid sigmoid = 40;
    case kSigmoid: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *NonlinearityType_.sigmoid_);
      break;
    }
    // .CoreML.Specification.ActivationSigmoidHard sigmoidHard = 41;
    case kSigmoidHard: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *NonlinearityType_.sigmoidhard_);
      break;
    }
    // .CoreML.Specification.ActivationELU ELU = 50;
    case kELU: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *NonlinearityType_.elu_);
      break;
    }
    // .CoreML.Specification.ActivationSoftsign softsign = 60;
    case kSoftsign: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *NonlinearityType_.softsign_);
      break;
    }
    // .CoreML.Specification.ActivationSoftplus softplus = 70;
    case kSoftplus: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *NonlinearityType_.softplus_);
      break;
    }
    // .CoreML.Specification.ActivationParametricSoftplus parametricSoftplus = 71;
    case kParametricSoftplus: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *NonlinearityType_.parametricsoftplus_);
      break;
    }
    case NONLINEARITYTYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActivationParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ActivationParams*>(
      &from));
}

void ActivationParams::MergeFrom(const ActivationParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ActivationParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.NonlinearityType_case()) {
    case kLinear: {
      _internal_mutable_linear()->::CoreML::Specification::ActivationLinear::MergeFrom(from._internal_linear());
      break;
    }
    case kReLU: {
      _internal_mutable_relu()->::CoreML::Specification::ActivationReLU::MergeFrom(from._internal_relu());
      break;
    }
    case kLeakyReLU: {
      _internal_mutable_leakyrelu()->::CoreML::Specification::ActivationLeakyReLU::MergeFrom(from._internal_leakyrelu());
      break;
    }
    case kThresholdedReLU: {
      _internal_mutable_thresholdedrelu()->::CoreML::Specification::ActivationThresholdedReLU::MergeFrom(from._internal_thresholdedrelu());
      break;
    }
    case kPReLU: {
      _internal_mutable_prelu()->::CoreML::Specification::ActivationPReLU::MergeFrom(from._internal_prelu());
      break;
    }
    case kTanh: {
      _internal_mutable_tanh()->::CoreML::Specification::ActivationTanh::MergeFrom(from._internal_tanh());
      break;
    }
    case kScaledTanh: {
      _internal_mutable_scaledtanh()->::CoreML::Specification::ActivationScaledTanh::MergeFrom(from._internal_scaledtanh());
      break;
    }
    case kSigmoid: {
      _internal_mutable_sigmoid()->::CoreML::Specification::ActivationSigmoid::MergeFrom(from._internal_sigmoid());
      break;
    }
    case kSigmoidHard: {
      _internal_mutable_sigmoidhard()->::CoreML::Specification::ActivationSigmoidHard::MergeFrom(from._internal_sigmoidhard());
      break;
    }
    case kELU: {
      _internal_mutable_elu()->::CoreML::Specification::ActivationELU::MergeFrom(from._internal_elu());
      break;
    }
    case kSoftsign: {
      _internal_mutable_softsign()->::CoreML::Specification::ActivationSoftsign::MergeFrom(from._internal_softsign());
      break;
    }
    case kSoftplus: {
      _internal_mutable_softplus()->::CoreML::Specification::ActivationSoftplus::MergeFrom(from._internal_softplus());
      break;
    }
    case kParametricSoftplus: {
      _internal_mutable_parametricsoftplus()->::CoreML::Specification::ActivationParametricSoftplus::MergeFrom(from._internal_parametricsoftplus());
      break;
    }
    case NONLINEARITYTYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActivationParams::CopyFrom(const ActivationParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ActivationParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActivationParams::IsInitialized() const {
  return true;
}

void ActivationParams::InternalSwap(ActivationParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(NonlinearityType_, other->NonlinearityType_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ActivationParams::GetTypeName() const {
  return "CoreML.Specification.ActivationParams";
}


// ===================================================================

class Tensor::_Internal {
 public:
};

Tensor::Tensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  dimvalue_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.Tensor)
}
Tensor::Tensor(const Tensor& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      dimvalue_(from.dimvalue_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  rank_ = from.rank_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Tensor)
}

inline void Tensor::SharedCtor() {
rank_ = 0u;
}

Tensor::~Tensor() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Tensor)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Tensor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Tensor::ArenaDtor(void* object) {
  Tensor* _this = reinterpret_cast< Tensor* >(object);
  (void)_this;
}
void Tensor::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Tensor::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Tensor::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Tensor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dimvalue_.Clear();
  rank_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

const char* Tensor::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 rank = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          rank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 dimValue = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_dimvalue(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_dimvalue(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Tensor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.Tensor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 rank = 1;
  if (this->_internal_rank() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_rank(), target);
  }

  // repeated int64 dimValue = 2;
  {
    int byte_size = _dimvalue_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          2, _internal_dimvalue(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.Tensor)
  return target;
}

size_t Tensor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Tensor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 dimValue = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->dimvalue_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _dimvalue_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // uint32 rank = 1;
  if (this->_internal_rank() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_rank());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Tensor::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Tensor*>(
      &from));
}

void Tensor::MergeFrom(const Tensor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Tensor)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  dimvalue_.MergeFrom(from.dimvalue_);
  if (from._internal_rank() != 0) {
    _internal_set_rank(from._internal_rank());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Tensor::CopyFrom(const Tensor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Tensor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Tensor::IsInitialized() const {
  return true;
}

void Tensor::InternalSwap(Tensor* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  dimvalue_.InternalSwap(&other->dimvalue_);
  swap(rank_, other->rank_);
}

std::string Tensor::GetTypeName() const {
  return "CoreML.Specification.Tensor";
}


// ===================================================================

class NeuralNetworkLayer::_Internal {
 public:
  static const ::CoreML::Specification::ConvolutionLayerParams& convolution(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::PoolingLayerParams& pooling(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ActivationParams& activation(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::InnerProductLayerParams& innerproduct(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::EmbeddingLayerParams& embedding(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::BatchnormLayerParams& batchnorm(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::MeanVarianceNormalizeLayerParams& mvn(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::L2NormalizeLayerParams& l2normalize(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::SoftmaxLayerParams& softmax(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::LRNLayerParams& lrn(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::CropLayerParams& crop(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::PaddingLayerParams& padding(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::UpsampleLayerParams& upsample(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ResizeBilinearLayerParams& resizebilinear(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::CropResizeLayerParams& cropresize(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::UnaryFunctionLayerParams& unary(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::AddLayerParams& add(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::MultiplyLayerParams& multiply(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::AverageLayerParams& average(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ScaleLayerParams& scale(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::BiasLayerParams& bias(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::MaxLayerParams& max(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::MinLayerParams& min(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::DotProductLayerParams& dot(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ReduceLayerParams& reduce(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::LoadConstantLayerParams& loadconstant(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ReshapeLayerParams& reshape(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::FlattenLayerParams& flatten(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::PermuteLayerParams& permute(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ConcatLayerParams& concat(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::SplitLayerParams& split(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::SequenceRepeatLayerParams& sequencerepeat(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ReorganizeDataLayerParams& reorganizedata(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::SliceLayerParams& slice(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::SimpleRecurrentLayerParams& simplerecurrent(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::GRULayerParams& gru(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::UniDirectionalLSTMLayerParams& unidirectionallstm(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::BiDirectionalLSTMLayerParams& bidirectionallstm(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::CustomLayerParams& custom(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::CopyLayerParams& copy(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::BranchLayerParams& branch(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::LoopLayerParams& loop(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::LoopBreakLayerParams& loopbreak(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::LoopContinueLayerParams& loopcontinue(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::RangeStaticLayerParams& rangestatic(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::RangeDynamicLayerParams& rangedynamic(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ClipLayerParams& clip(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::CeilLayerParams& ceil(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::FloorLayerParams& floor(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::SignLayerParams& sign(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::RoundLayerParams& round(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::Exp2LayerParams& exp2(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::SinLayerParams& sin(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::CosLayerParams& cos(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::TanLayerParams& tan(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::AsinLayerParams& asin(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::AcosLayerParams& acos(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::AtanLayerParams& atan(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::SinhLayerParams& sinh(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::CoshLayerParams& cosh(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::TanhLayerParams& tanh(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::AsinhLayerParams& asinh(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::AcoshLayerParams& acosh(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::AtanhLayerParams& atanh(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ErfLayerParams& erf(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::GeluLayerParams& gelu(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::EqualLayerParams& equal(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::NotEqualLayerParams& notequal(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::LessThanLayerParams& lessthan(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::LessEqualLayerParams& lessequal(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::GreaterThanLayerParams& greaterthan(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::GreaterEqualLayerParams& greaterequal(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::LogicalOrLayerParams& logicalor(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::LogicalXorLayerParams& logicalxor(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::LogicalNotLayerParams& logicalnot(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::LogicalAndLayerParams& logicaland(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ModBroadcastableLayerParams& modbroadcastable(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::MinBroadcastableLayerParams& minbroadcastable(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::MaxBroadcastableLayerParams& maxbroadcastable(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::AddBroadcastableLayerParams& addbroadcastable(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::PowBroadcastableLayerParams& powbroadcastable(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::DivideBroadcastableLayerParams& dividebroadcastable(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::FloorDivBroadcastableLayerParams& floordivbroadcastable(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::MultiplyBroadcastableLayerParams& multiplybroadcastable(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::SubtractBroadcastableLayerParams& subtractbroadcastable(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::TileLayerParams& tile(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::StackLayerParams& stack(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::GatherLayerParams& gather(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ScatterLayerParams& scatter(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::GatherNDLayerParams& gathernd(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ScatterNDLayerParams& scatternd(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::SoftmaxNDLayerParams& softmaxnd(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::GatherAlongAxisLayerParams& gatheralongaxis(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ScatterAlongAxisLayerParams& scatteralongaxis(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ReverseLayerParams& reverse(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ReverseSeqLayerParams& reverseseq(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::SplitNDLayerParams& splitnd(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ConcatNDLayerParams& concatnd(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::TransposeLayerParams& transpose(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::SliceStaticLayerParams& slicestatic(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::SliceDynamicLayerParams& slicedynamic(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::SlidingWindowsLayerParams& slidingwindows(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::TopKLayerParams& topk(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ArgMinLayerParams& argmin(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ArgMaxLayerParams& argmax(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::EmbeddingNDLayerParams& embeddingnd(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::BatchedMatMulLayerParams& batchedmatmul(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::GetShapeLayerParams& getshape(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::LoadConstantNDLayerParams& loadconstantnd(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::FillLikeLayerParams& filllike(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::FillStaticLayerParams& fillstatic(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::FillDynamicLayerParams& filldynamic(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::BroadcastToLikeLayerParams& broadcasttolike(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::BroadcastToStaticLayerParams& broadcasttostatic(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::BroadcastToDynamicLayerParams& broadcasttodynamic(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::SqueezeLayerParams& squeeze(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ExpandDimsLayerParams& expanddims(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::FlattenTo2DLayerParams& flattento2d(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ReshapeLikeLayerParams& reshapelike(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ReshapeStaticLayerParams& reshapestatic(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ReshapeDynamicLayerParams& reshapedynamic(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::RankPreservingReshapeLayerParams& rankpreservingreshape(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ConstantPaddingLayerParams& constantpad(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::RandomNormalLikeLayerParams& randomnormallike(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::RandomNormalStaticLayerParams& randomnormalstatic(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::RandomNormalDynamicLayerParams& randomnormaldynamic(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::RandomUniformLikeLayerParams& randomuniformlike(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::RandomUniformStaticLayerParams& randomuniformstatic(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::RandomUniformDynamicLayerParams& randomuniformdynamic(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::RandomBernoulliLikeLayerParams& randombernoullilike(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::RandomBernoulliStaticLayerParams& randombernoullistatic(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::RandomBernoulliDynamicLayerParams& randombernoullidynamic(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::CategoricalDistributionLayerParams& categoricaldistribution(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ReduceL1LayerParams& reducel1(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ReduceL2LayerParams& reducel2(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ReduceMaxLayerParams& reducemax(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ReduceMinLayerParams& reducemin(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ReduceSumLayerParams& reducesum(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ReduceProdLayerParams& reduceprod(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ReduceMeanLayerParams& reducemean(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ReduceLogSumLayerParams& reducelogsum(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ReduceSumSquareLayerParams& reducesumsquare(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ReduceLogSumExpLayerParams& reducelogsumexp(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::WhereNonZeroLayerParams& wherenonzero(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::MatrixBandPartLayerParams& matrixbandpart(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::LowerTriangularLayerParams& lowertriangular(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::UpperTriangularLayerParams& uppertriangular(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::WhereBroadcastableLayerParams& wherebroadcastable(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::LayerNormalizationLayerParams& layernormalization(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::NonMaximumSuppressionLayerParams& nonmaximumsuppression(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::OneHotLayerParams& onehot(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::CumSumLayerParams& cumsum(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ClampedReLULayerParams& clampedrelu(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::ArgSortLayerParams& argsort(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::Pooling3DLayerParams& pooling3d(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::GlobalPooling3DLayerParams& globalpooling3d(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::SliceBySizeLayerParams& slicebysize(const NeuralNetworkLayer* msg);
  static const ::CoreML::Specification::Convolution3DLayerParams& convolution3d(const NeuralNetworkLayer* msg);
};

const ::CoreML::Specification::ConvolutionLayerParams&
NeuralNetworkLayer::_Internal::convolution(const NeuralNetworkLayer* msg) {
  return *msg->layer_.convolution_;
}
const ::CoreML::Specification::PoolingLayerParams&
NeuralNetworkLayer::_Internal::pooling(const NeuralNetworkLayer* msg) {
  return *msg->layer_.pooling_;
}
const ::CoreML::Specification::ActivationParams&
NeuralNetworkLayer::_Internal::activation(const NeuralNetworkLayer* msg) {
  return *msg->layer_.activation_;
}
const ::CoreML::Specification::InnerProductLayerParams&
NeuralNetworkLayer::_Internal::innerproduct(const NeuralNetworkLayer* msg) {
  return *msg->layer_.innerproduct_;
}
const ::CoreML::Specification::EmbeddingLayerParams&
NeuralNetworkLayer::_Internal::embedding(const NeuralNetworkLayer* msg) {
  return *msg->layer_.embedding_;
}
const ::CoreML::Specification::BatchnormLayerParams&
NeuralNetworkLayer::_Internal::batchnorm(const NeuralNetworkLayer* msg) {
  return *msg->layer_.batchnorm_;
}
const ::CoreML::Specification::MeanVarianceNormalizeLayerParams&
NeuralNetworkLayer::_Internal::mvn(const NeuralNetworkLayer* msg) {
  return *msg->layer_.mvn_;
}
const ::CoreML::Specification::L2NormalizeLayerParams&
NeuralNetworkLayer::_Internal::l2normalize(const NeuralNetworkLayer* msg) {
  return *msg->layer_.l2normalize_;
}
const ::CoreML::Specification::SoftmaxLayerParams&
NeuralNetworkLayer::_Internal::softmax(const NeuralNetworkLayer* msg) {
  return *msg->layer_.softmax_;
}
const ::CoreML::Specification::LRNLayerParams&
NeuralNetworkLayer::_Internal::lrn(const NeuralNetworkLayer* msg) {
  return *msg->layer_.lrn_;
}
const ::CoreML::Specification::CropLayerParams&
NeuralNetworkLayer::_Internal::crop(const NeuralNetworkLayer* msg) {
  return *msg->layer_.crop_;
}
const ::CoreML::Specification::PaddingLayerParams&
NeuralNetworkLayer::_Internal::padding(const NeuralNetworkLayer* msg) {
  return *msg->layer_.padding_;
}
const ::CoreML::Specification::UpsampleLayerParams&
NeuralNetworkLayer::_Internal::upsample(const NeuralNetworkLayer* msg) {
  return *msg->layer_.upsample_;
}
const ::CoreML::Specification::ResizeBilinearLayerParams&
NeuralNetworkLayer::_Internal::resizebilinear(const NeuralNetworkLayer* msg) {
  return *msg->layer_.resizebilinear_;
}
const ::CoreML::Specification::CropResizeLayerParams&
NeuralNetworkLayer::_Internal::cropresize(const NeuralNetworkLayer* msg) {
  return *msg->layer_.cropresize_;
}
const ::CoreML::Specification::UnaryFunctionLayerParams&
NeuralNetworkLayer::_Internal::unary(const NeuralNetworkLayer* msg) {
  return *msg->layer_.unary_;
}
const ::CoreML::Specification::AddLayerParams&
NeuralNetworkLayer::_Internal::add(const NeuralNetworkLayer* msg) {
  return *msg->layer_.add_;
}
const ::CoreML::Specification::MultiplyLayerParams&
NeuralNetworkLayer::_Internal::multiply(const NeuralNetworkLayer* msg) {
  return *msg->layer_.multiply_;
}
const ::CoreML::Specification::AverageLayerParams&
NeuralNetworkLayer::_Internal::average(const NeuralNetworkLayer* msg) {
  return *msg->layer_.average_;
}
const ::CoreML::Specification::ScaleLayerParams&
NeuralNetworkLayer::_Internal::scale(const NeuralNetworkLayer* msg) {
  return *msg->layer_.scale_;
}
const ::CoreML::Specification::BiasLayerParams&
NeuralNetworkLayer::_Internal::bias(const NeuralNetworkLayer* msg) {
  return *msg->layer_.bias_;
}
const ::CoreML::Specification::MaxLayerParams&
NeuralNetworkLayer::_Internal::max(const NeuralNetworkLayer* msg) {
  return *msg->layer_.max_;
}
const ::CoreML::Specification::MinLayerParams&
NeuralNetworkLayer::_Internal::min(const NeuralNetworkLayer* msg) {
  return *msg->layer_.min_;
}
const ::CoreML::Specification::DotProductLayerParams&
NeuralNetworkLayer::_Internal::dot(const NeuralNetworkLayer* msg) {
  return *msg->layer_.dot_;
}
const ::CoreML::Specification::ReduceLayerParams&
NeuralNetworkLayer::_Internal::reduce(const NeuralNetworkLayer* msg) {
  return *msg->layer_.reduce_;
}
const ::CoreML::Specification::LoadConstantLayerParams&
NeuralNetworkLayer::_Internal::loadconstant(const NeuralNetworkLayer* msg) {
  return *msg->layer_.loadconstant_;
}
const ::CoreML::Specification::ReshapeLayerParams&
NeuralNetworkLayer::_Internal::reshape(const NeuralNetworkLayer* msg) {
  return *msg->layer_.reshape_;
}
const ::CoreML::Specification::FlattenLayerParams&
NeuralNetworkLayer::_Internal::flatten(const NeuralNetworkLayer* msg) {
  return *msg->layer_.flatten_;
}
const ::CoreML::Specification::PermuteLayerParams&
NeuralNetworkLayer::_Internal::permute(const NeuralNetworkLayer* msg) {
  return *msg->layer_.permute_;
}
const ::CoreML::Specification::ConcatLayerParams&
NeuralNetworkLayer::_Internal::concat(const NeuralNetworkLayer* msg) {
  return *msg->layer_.concat_;
}
const ::CoreML::Specification::SplitLayerParams&
NeuralNetworkLayer::_Internal::split(const NeuralNetworkLayer* msg) {
  return *msg->layer_.split_;
}
const ::CoreML::Specification::SequenceRepeatLayerParams&
NeuralNetworkLayer::_Internal::sequencerepeat(const NeuralNetworkLayer* msg) {
  return *msg->layer_.sequencerepeat_;
}
const ::CoreML::Specification::ReorganizeDataLayerParams&
NeuralNetworkLayer::_Internal::reorganizedata(const NeuralNetworkLayer* msg) {
  return *msg->layer_.reorganizedata_;
}
const ::CoreML::Specification::SliceLayerParams&
NeuralNetworkLayer::_Internal::slice(const NeuralNetworkLayer* msg) {
  return *msg->layer_.slice_;
}
const ::CoreML::Specification::SimpleRecurrentLayerParams&
NeuralNetworkLayer::_Internal::simplerecurrent(const NeuralNetworkLayer* msg) {
  return *msg->layer_.simplerecurrent_;
}
const ::CoreML::Specification::GRULayerParams&
NeuralNetworkLayer::_Internal::gru(const NeuralNetworkLayer* msg) {
  return *msg->layer_.gru_;
}
const ::CoreML::Specification::UniDirectionalLSTMLayerParams&
NeuralNetworkLayer::_Internal::unidirectionallstm(const NeuralNetworkLayer* msg) {
  return *msg->layer_.unidirectionallstm_;
}
const ::CoreML::Specification::BiDirectionalLSTMLayerParams&
NeuralNetworkLayer::_Internal::bidirectionallstm(const NeuralNetworkLayer* msg) {
  return *msg->layer_.bidirectionallstm_;
}
const ::CoreML::Specification::CustomLayerParams&
NeuralNetworkLayer::_Internal::custom(const NeuralNetworkLayer* msg) {
  return *msg->layer_.custom_;
}
const ::CoreML::Specification::CopyLayerParams&
NeuralNetworkLayer::_Internal::copy(const NeuralNetworkLayer* msg) {
  return *msg->layer_.copy_;
}
const ::CoreML::Specification::BranchLayerParams&
NeuralNetworkLayer::_Internal::branch(const NeuralNetworkLayer* msg) {
  return *msg->layer_.branch_;
}
const ::CoreML::Specification::LoopLayerParams&
NeuralNetworkLayer::_Internal::loop(const NeuralNetworkLayer* msg) {
  return *msg->layer_.loop_;
}
const ::CoreML::Specification::LoopBreakLayerParams&
NeuralNetworkLayer::_Internal::loopbreak(const NeuralNetworkLayer* msg) {
  return *msg->layer_.loopbreak_;
}
const ::CoreML::Specification::LoopContinueLayerParams&
NeuralNetworkLayer::_Internal::loopcontinue(const NeuralNetworkLayer* msg) {
  return *msg->layer_.loopcontinue_;
}
const ::CoreML::Specification::RangeStaticLayerParams&
NeuralNetworkLayer::_Internal::rangestatic(const NeuralNetworkLayer* msg) {
  return *msg->layer_.rangestatic_;
}
const ::CoreML::Specification::RangeDynamicLayerParams&
NeuralNetworkLayer::_Internal::rangedynamic(const NeuralNetworkLayer* msg) {
  return *msg->layer_.rangedynamic_;
}
const ::CoreML::Specification::ClipLayerParams&
NeuralNetworkLayer::_Internal::clip(const NeuralNetworkLayer* msg) {
  return *msg->layer_.clip_;
}
const ::CoreML::Specification::CeilLayerParams&
NeuralNetworkLayer::_Internal::ceil(const NeuralNetworkLayer* msg) {
  return *msg->layer_.ceil_;
}
const ::CoreML::Specification::FloorLayerParams&
NeuralNetworkLayer::_Internal::floor(const NeuralNetworkLayer* msg) {
  return *msg->layer_.floor_;
}
const ::CoreML::Specification::SignLayerParams&
NeuralNetworkLayer::_Internal::sign(const NeuralNetworkLayer* msg) {
  return *msg->layer_.sign_;
}
const ::CoreML::Specification::RoundLayerParams&
NeuralNetworkLayer::_Internal::round(const NeuralNetworkLayer* msg) {
  return *msg->layer_.round_;
}
const ::CoreML::Specification::Exp2LayerParams&
NeuralNetworkLayer::_Internal::exp2(const NeuralNetworkLayer* msg) {
  return *msg->layer_.exp2_;
}
const ::CoreML::Specification::SinLayerParams&
NeuralNetworkLayer::_Internal::sin(const NeuralNetworkLayer* msg) {
  return *msg->layer_.sin_;
}
const ::CoreML::Specification::CosLayerParams&
NeuralNetworkLayer::_Internal::cos(const NeuralNetworkLayer* msg) {
  return *msg->layer_.cos_;
}
const ::CoreML::Specification::TanLayerParams&
NeuralNetworkLayer::_Internal::tan(const NeuralNetworkLayer* msg) {
  return *msg->layer_.tan_;
}
const ::CoreML::Specification::AsinLayerParams&
NeuralNetworkLayer::_Internal::asin(const NeuralNetworkLayer* msg) {
  return *msg->layer_.asin_;
}
const ::CoreML::Specification::AcosLayerParams&
NeuralNetworkLayer::_Internal::acos(const NeuralNetworkLayer* msg) {
  return *msg->layer_.acos_;
}
const ::CoreML::Specification::AtanLayerParams&
NeuralNetworkLayer::_Internal::atan(const NeuralNetworkLayer* msg) {
  return *msg->layer_.atan_;
}
const ::CoreML::Specification::SinhLayerParams&
NeuralNetworkLayer::_Internal::sinh(const NeuralNetworkLayer* msg) {
  return *msg->layer_.sinh_;
}
const ::CoreML::Specification::CoshLayerParams&
NeuralNetworkLayer::_Internal::cosh(const NeuralNetworkLayer* msg) {
  return *msg->layer_.cosh_;
}
const ::CoreML::Specification::TanhLayerParams&
NeuralNetworkLayer::_Internal::tanh(const NeuralNetworkLayer* msg) {
  return *msg->layer_.tanh_;
}
const ::CoreML::Specification::AsinhLayerParams&
NeuralNetworkLayer::_Internal::asinh(const NeuralNetworkLayer* msg) {
  return *msg->layer_.asinh_;
}
const ::CoreML::Specification::AcoshLayerParams&
NeuralNetworkLayer::_Internal::acosh(const NeuralNetworkLayer* msg) {
  return *msg->layer_.acosh_;
}
const ::CoreML::Specification::AtanhLayerParams&
NeuralNetworkLayer::_Internal::atanh(const NeuralNetworkLayer* msg) {
  return *msg->layer_.atanh_;
}
const ::CoreML::Specification::ErfLayerParams&
NeuralNetworkLayer::_Internal::erf(const NeuralNetworkLayer* msg) {
  return *msg->layer_.erf_;
}
const ::CoreML::Specification::GeluLayerParams&
NeuralNetworkLayer::_Internal::gelu(const NeuralNetworkLayer* msg) {
  return *msg->layer_.gelu_;
}
const ::CoreML::Specification::EqualLayerParams&
NeuralNetworkLayer::_Internal::equal(const NeuralNetworkLayer* msg) {
  return *msg->layer_.equal_;
}
const ::CoreML::Specification::NotEqualLayerParams&
NeuralNetworkLayer::_Internal::notequal(const NeuralNetworkLayer* msg) {
  return *msg->layer_.notequal_;
}
const ::CoreML::Specification::LessThanLayerParams&
NeuralNetworkLayer::_Internal::lessthan(const NeuralNetworkLayer* msg) {
  return *msg->layer_.lessthan_;
}
const ::CoreML::Specification::LessEqualLayerParams&
NeuralNetworkLayer::_Internal::lessequal(const NeuralNetworkLayer* msg) {
  return *msg->layer_.lessequal_;
}
const ::CoreML::Specification::GreaterThanLayerParams&
NeuralNetworkLayer::_Internal::greaterthan(const NeuralNetworkLayer* msg) {
  return *msg->layer_.greaterthan_;
}
const ::CoreML::Specification::GreaterEqualLayerParams&
NeuralNetworkLayer::_Internal::greaterequal(const NeuralNetworkLayer* msg) {
  return *msg->layer_.greaterequal_;
}
const ::CoreML::Specification::LogicalOrLayerParams&
NeuralNetworkLayer::_Internal::logicalor(const NeuralNetworkLayer* msg) {
  return *msg->layer_.logicalor_;
}
const ::CoreML::Specification::LogicalXorLayerParams&
NeuralNetworkLayer::_Internal::logicalxor(const NeuralNetworkLayer* msg) {
  return *msg->layer_.logicalxor_;
}
const ::CoreML::Specification::LogicalNotLayerParams&
NeuralNetworkLayer::_Internal::logicalnot(const NeuralNetworkLayer* msg) {
  return *msg->layer_.logicalnot_;
}
const ::CoreML::Specification::LogicalAndLayerParams&
NeuralNetworkLayer::_Internal::logicaland(const NeuralNetworkLayer* msg) {
  return *msg->layer_.logicaland_;
}
const ::CoreML::Specification::ModBroadcastableLayerParams&
NeuralNetworkLayer::_Internal::modbroadcastable(const NeuralNetworkLayer* msg) {
  return *msg->layer_.modbroadcastable_;
}
const ::CoreML::Specification::MinBroadcastableLayerParams&
NeuralNetworkLayer::_Internal::minbroadcastable(const NeuralNetworkLayer* msg) {
  return *msg->layer_.minbroadcastable_;
}
const ::CoreML::Specification::MaxBroadcastableLayerParams&
NeuralNetworkLayer::_Internal::maxbroadcastable(const NeuralNetworkLayer* msg) {
  return *msg->layer_.maxbroadcastable_;
}
const ::CoreML::Specification::AddBroadcastableLayerParams&
NeuralNetworkLayer::_Internal::addbroadcastable(const NeuralNetworkLayer* msg) {
  return *msg->layer_.addbroadcastable_;
}
const ::CoreML::Specification::PowBroadcastableLayerParams&
NeuralNetworkLayer::_Internal::powbroadcastable(const NeuralNetworkLayer* msg) {
  return *msg->layer_.powbroadcastable_;
}
const ::CoreML::Specification::DivideBroadcastableLayerParams&
NeuralNetworkLayer::_Internal::dividebroadcastable(const NeuralNetworkLayer* msg) {
  return *msg->layer_.dividebroadcastable_;
}
const ::CoreML::Specification::FloorDivBroadcastableLayerParams&
NeuralNetworkLayer::_Internal::floordivbroadcastable(const NeuralNetworkLayer* msg) {
  return *msg->layer_.floordivbroadcastable_;
}
const ::CoreML::Specification::MultiplyBroadcastableLayerParams&
NeuralNetworkLayer::_Internal::multiplybroadcastable(const NeuralNetworkLayer* msg) {
  return *msg->layer_.multiplybroadcastable_;
}
const ::CoreML::Specification::SubtractBroadcastableLayerParams&
NeuralNetworkLayer::_Internal::subtractbroadcastable(const NeuralNetworkLayer* msg) {
  return *msg->layer_.subtractbroadcastable_;
}
const ::CoreML::Specification::TileLayerParams&
NeuralNetworkLayer::_Internal::tile(const NeuralNetworkLayer* msg) {
  return *msg->layer_.tile_;
}
const ::CoreML::Specification::StackLayerParams&
NeuralNetworkLayer::_Internal::stack(const NeuralNetworkLayer* msg) {
  return *msg->layer_.stack_;
}
const ::CoreML::Specification::GatherLayerParams&
NeuralNetworkLayer::_Internal::gather(const NeuralNetworkLayer* msg) {
  return *msg->layer_.gather_;
}
const ::CoreML::Specification::ScatterLayerParams&
NeuralNetworkLayer::_Internal::scatter(const NeuralNetworkLayer* msg) {
  return *msg->layer_.scatter_;
}
const ::CoreML::Specification::GatherNDLayerParams&
NeuralNetworkLayer::_Internal::gathernd(const NeuralNetworkLayer* msg) {
  return *msg->layer_.gathernd_;
}
const ::CoreML::Specification::ScatterNDLayerParams&
NeuralNetworkLayer::_Internal::scatternd(const NeuralNetworkLayer* msg) {
  return *msg->layer_.scatternd_;
}
const ::CoreML::Specification::SoftmaxNDLayerParams&
NeuralNetworkLayer::_Internal::softmaxnd(const NeuralNetworkLayer* msg) {
  return *msg->layer_.softmaxnd_;
}
const ::CoreML::Specification::GatherAlongAxisLayerParams&
NeuralNetworkLayer::_Internal::gatheralongaxis(const NeuralNetworkLayer* msg) {
  return *msg->layer_.gatheralongaxis_;
}
const ::CoreML::Specification::ScatterAlongAxisLayerParams&
NeuralNetworkLayer::_Internal::scatteralongaxis(const NeuralNetworkLayer* msg) {
  return *msg->layer_.scatteralongaxis_;
}
const ::CoreML::Specification::ReverseLayerParams&
NeuralNetworkLayer::_Internal::reverse(const NeuralNetworkLayer* msg) {
  return *msg->layer_.reverse_;
}
const ::CoreML::Specification::ReverseSeqLayerParams&
NeuralNetworkLayer::_Internal::reverseseq(const NeuralNetworkLayer* msg) {
  return *msg->layer_.reverseseq_;
}
const ::CoreML::Specification::SplitNDLayerParams&
NeuralNetworkLayer::_Internal::splitnd(const NeuralNetworkLayer* msg) {
  return *msg->layer_.splitnd_;
}
const ::CoreML::Specification::ConcatNDLayerParams&
NeuralNetworkLayer::_Internal::concatnd(const NeuralNetworkLayer* msg) {
  return *msg->layer_.concatnd_;
}
const ::CoreML::Specification::TransposeLayerParams&
NeuralNetworkLayer::_Internal::transpose(const NeuralNetworkLayer* msg) {
  return *msg->layer_.transpose_;
}
const ::CoreML::Specification::SliceStaticLayerParams&
NeuralNetworkLayer::_Internal::slicestatic(const NeuralNetworkLayer* msg) {
  return *msg->layer_.slicestatic_;
}
const ::CoreML::Specification::SliceDynamicLayerParams&
NeuralNetworkLayer::_Internal::slicedynamic(const NeuralNetworkLayer* msg) {
  return *msg->layer_.slicedynamic_;
}
const ::CoreML::Specification::SlidingWindowsLayerParams&
NeuralNetworkLayer::_Internal::slidingwindows(const NeuralNetworkLayer* msg) {
  return *msg->layer_.slidingwindows_;
}
const ::CoreML::Specification::TopKLayerParams&
NeuralNetworkLayer::_Internal::topk(const NeuralNetworkLayer* msg) {
  return *msg->layer_.topk_;
}
const ::CoreML::Specification::ArgMinLayerParams&
NeuralNetworkLayer::_Internal::argmin(const NeuralNetworkLayer* msg) {
  return *msg->layer_.argmin_;
}
const ::CoreML::Specification::ArgMaxLayerParams&
NeuralNetworkLayer::_Internal::argmax(const NeuralNetworkLayer* msg) {
  return *msg->layer_.argmax_;
}
const ::CoreML::Specification::EmbeddingNDLayerParams&
NeuralNetworkLayer::_Internal::embeddingnd(const NeuralNetworkLayer* msg) {
  return *msg->layer_.embeddingnd_;
}
const ::CoreML::Specification::BatchedMatMulLayerParams&
NeuralNetworkLayer::_Internal::batchedmatmul(const NeuralNetworkLayer* msg) {
  return *msg->layer_.batchedmatmul_;
}
const ::CoreML::Specification::GetShapeLayerParams&
NeuralNetworkLayer::_Internal::getshape(const NeuralNetworkLayer* msg) {
  return *msg->layer_.getshape_;
}
const ::CoreML::Specification::LoadConstantNDLayerParams&
NeuralNetworkLayer::_Internal::loadconstantnd(const NeuralNetworkLayer* msg) {
  return *msg->layer_.loadconstantnd_;
}
const ::CoreML::Specification::FillLikeLayerParams&
NeuralNetworkLayer::_Internal::filllike(const NeuralNetworkLayer* msg) {
  return *msg->layer_.filllike_;
}
const ::CoreML::Specification::FillStaticLayerParams&
NeuralNetworkLayer::_Internal::fillstatic(const NeuralNetworkLayer* msg) {
  return *msg->layer_.fillstatic_;
}
const ::CoreML::Specification::FillDynamicLayerParams&
NeuralNetworkLayer::_Internal::filldynamic(const NeuralNetworkLayer* msg) {
  return *msg->layer_.filldynamic_;
}
const ::CoreML::Specification::BroadcastToLikeLayerParams&
NeuralNetworkLayer::_Internal::broadcasttolike(const NeuralNetworkLayer* msg) {
  return *msg->layer_.broadcasttolike_;
}
const ::CoreML::Specification::BroadcastToStaticLayerParams&
NeuralNetworkLayer::_Internal::broadcasttostatic(const NeuralNetworkLayer* msg) {
  return *msg->layer_.broadcasttostatic_;
}
const ::CoreML::Specification::BroadcastToDynamicLayerParams&
NeuralNetworkLayer::_Internal::broadcasttodynamic(const NeuralNetworkLayer* msg) {
  return *msg->layer_.broadcasttodynamic_;
}
const ::CoreML::Specification::SqueezeLayerParams&
NeuralNetworkLayer::_Internal::squeeze(const NeuralNetworkLayer* msg) {
  return *msg->layer_.squeeze_;
}
const ::CoreML::Specification::ExpandDimsLayerParams&
NeuralNetworkLayer::_Internal::expanddims(const NeuralNetworkLayer* msg) {
  return *msg->layer_.expanddims_;
}
const ::CoreML::Specification::FlattenTo2DLayerParams&
NeuralNetworkLayer::_Internal::flattento2d(const NeuralNetworkLayer* msg) {
  return *msg->layer_.flattento2d_;
}
const ::CoreML::Specification::ReshapeLikeLayerParams&
NeuralNetworkLayer::_Internal::reshapelike(const NeuralNetworkLayer* msg) {
  return *msg->layer_.reshapelike_;
}
const ::CoreML::Specification::ReshapeStaticLayerParams&
NeuralNetworkLayer::_Internal::reshapestatic(const NeuralNetworkLayer* msg) {
  return *msg->layer_.reshapestatic_;
}
const ::CoreML::Specification::ReshapeDynamicLayerParams&
NeuralNetworkLayer::_Internal::reshapedynamic(const NeuralNetworkLayer* msg) {
  return *msg->layer_.reshapedynamic_;
}
const ::CoreML::Specification::RankPreservingReshapeLayerParams&
NeuralNetworkLayer::_Internal::rankpreservingreshape(const NeuralNetworkLayer* msg) {
  return *msg->layer_.rankpreservingreshape_;
}
const ::CoreML::Specification::ConstantPaddingLayerParams&
NeuralNetworkLayer::_Internal::constantpad(const NeuralNetworkLayer* msg) {
  return *msg->layer_.constantpad_;
}
const ::CoreML::Specification::RandomNormalLikeLayerParams&
NeuralNetworkLayer::_Internal::randomnormallike(const NeuralNetworkLayer* msg) {
  return *msg->layer_.randomnormallike_;
}
const ::CoreML::Specification::RandomNormalStaticLayerParams&
NeuralNetworkLayer::_Internal::randomnormalstatic(const NeuralNetworkLayer* msg) {
  return *msg->layer_.randomnormalstatic_;
}
const ::CoreML::Specification::RandomNormalDynamicLayerParams&
NeuralNetworkLayer::_Internal::randomnormaldynamic(const NeuralNetworkLayer* msg) {
  return *msg->layer_.randomnormaldynamic_;
}
const ::CoreML::Specification::RandomUniformLikeLayerParams&
NeuralNetworkLayer::_Internal::randomuniformlike(const NeuralNetworkLayer* msg) {
  return *msg->layer_.randomuniformlike_;
}
const ::CoreML::Specification::RandomUniformStaticLayerParams&
NeuralNetworkLayer::_Internal::randomuniformstatic(const NeuralNetworkLayer* msg) {
  return *msg->layer_.randomuniformstatic_;
}
const ::CoreML::Specification::RandomUniformDynamicLayerParams&
NeuralNetworkLayer::_Internal::randomuniformdynamic(const NeuralNetworkLayer* msg) {
  return *msg->layer_.randomuniformdynamic_;
}
const ::CoreML::Specification::RandomBernoulliLikeLayerParams&
NeuralNetworkLayer::_Internal::randombernoullilike(const NeuralNetworkLayer* msg) {
  return *msg->layer_.randombernoullilike_;
}
const ::CoreML::Specification::RandomBernoulliStaticLayerParams&
NeuralNetworkLayer::_Internal::randombernoullistatic(const NeuralNetworkLayer* msg) {
  return *msg->layer_.randombernoullistatic_;
}
const ::CoreML::Specification::RandomBernoulliDynamicLayerParams&
NeuralNetworkLayer::_Internal::randombernoullidynamic(const NeuralNetworkLayer* msg) {
  return *msg->layer_.randombernoullidynamic_;
}
const ::CoreML::Specification::CategoricalDistributionLayerParams&
NeuralNetworkLayer::_Internal::categoricaldistribution(const NeuralNetworkLayer* msg) {
  return *msg->layer_.categoricaldistribution_;
}
const ::CoreML::Specification::ReduceL1LayerParams&
NeuralNetworkLayer::_Internal::reducel1(const NeuralNetworkLayer* msg) {
  return *msg->layer_.reducel1_;
}
const ::CoreML::Specification::ReduceL2LayerParams&
NeuralNetworkLayer::_Internal::reducel2(const NeuralNetworkLayer* msg) {
  return *msg->layer_.reducel2_;
}
const ::CoreML::Specification::ReduceMaxLayerParams&
NeuralNetworkLayer::_Internal::reducemax(const NeuralNetworkLayer* msg) {
  return *msg->layer_.reducemax_;
}
const ::CoreML::Specification::ReduceMinLayerParams&
NeuralNetworkLayer::_Internal::reducemin(const NeuralNetworkLayer* msg) {
  return *msg->layer_.reducemin_;
}
const ::CoreML::Specification::ReduceSumLayerParams&
NeuralNetworkLayer::_Internal::reducesum(const NeuralNetworkLayer* msg) {
  return *msg->layer_.reducesum_;
}
const ::CoreML::Specification::ReduceProdLayerParams&
NeuralNetworkLayer::_Internal::reduceprod(const NeuralNetworkLayer* msg) {
  return *msg->layer_.reduceprod_;
}
const ::CoreML::Specification::ReduceMeanLayerParams&
NeuralNetworkLayer::_Internal::reducemean(const NeuralNetworkLayer* msg) {
  return *msg->layer_.reducemean_;
}
const ::CoreML::Specification::ReduceLogSumLayerParams&
NeuralNetworkLayer::_Internal::reducelogsum(const NeuralNetworkLayer* msg) {
  return *msg->layer_.reducelogsum_;
}
const ::CoreML::Specification::ReduceSumSquareLayerParams&
NeuralNetworkLayer::_Internal::reducesumsquare(const NeuralNetworkLayer* msg) {
  return *msg->layer_.reducesumsquare_;
}
const ::CoreML::Specification::ReduceLogSumExpLayerParams&
NeuralNetworkLayer::_Internal::reducelogsumexp(const NeuralNetworkLayer* msg) {
  return *msg->layer_.reducelogsumexp_;
}
const ::CoreML::Specification::WhereNonZeroLayerParams&
NeuralNetworkLayer::_Internal::wherenonzero(const NeuralNetworkLayer* msg) {
  return *msg->layer_.wherenonzero_;
}
const ::CoreML::Specification::MatrixBandPartLayerParams&
NeuralNetworkLayer::_Internal::matrixbandpart(const NeuralNetworkLayer* msg) {
  return *msg->layer_.matrixbandpart_;
}
const ::CoreML::Specification::LowerTriangularLayerParams&
NeuralNetworkLayer::_Internal::lowertriangular(const NeuralNetworkLayer* msg) {
  return *msg->layer_.lowertriangular_;
}
const ::CoreML::Specification::UpperTriangularLayerParams&
NeuralNetworkLayer::_Internal::uppertriangular(const NeuralNetworkLayer* msg) {
  return *msg->layer_.uppertriangular_;
}
const ::CoreML::Specification::WhereBroadcastableLayerParams&
NeuralNetworkLayer::_Internal::wherebroadcastable(const NeuralNetworkLayer* msg) {
  return *msg->layer_.wherebroadcastable_;
}
const ::CoreML::Specification::LayerNormalizationLayerParams&
NeuralNetworkLayer::_Internal::layernormalization(const NeuralNetworkLayer* msg) {
  return *msg->layer_.layernormalization_;
}
const ::CoreML::Specification::NonMaximumSuppressionLayerParams&
NeuralNetworkLayer::_Internal::nonmaximumsuppression(const NeuralNetworkLayer* msg) {
  return *msg->layer_.nonmaximumsuppression_;
}
const ::CoreML::Specification::OneHotLayerParams&
NeuralNetworkLayer::_Internal::onehot(const NeuralNetworkLayer* msg) {
  return *msg->layer_.onehot_;
}
const ::CoreML::Specification::CumSumLayerParams&
NeuralNetworkLayer::_Internal::cumsum(const NeuralNetworkLayer* msg) {
  return *msg->layer_.cumsum_;
}
const ::CoreML::Specification::ClampedReLULayerParams&
NeuralNetworkLayer::_Internal::clampedrelu(const NeuralNetworkLayer* msg) {
  return *msg->layer_.clampedrelu_;
}
const ::CoreML::Specification::ArgSortLayerParams&
NeuralNetworkLayer::_Internal::argsort(const NeuralNetworkLayer* msg) {
  return *msg->layer_.argsort_;
}
const ::CoreML::Specification::Pooling3DLayerParams&
NeuralNetworkLayer::_Internal::pooling3d(const NeuralNetworkLayer* msg) {
  return *msg->layer_.pooling3d_;
}
const ::CoreML::Specification::GlobalPooling3DLayerParams&
NeuralNetworkLayer::_Internal::globalpooling3d(const NeuralNetworkLayer* msg) {
  return *msg->layer_.globalpooling3d_;
}
const ::CoreML::Specification::SliceBySizeLayerParams&
NeuralNetworkLayer::_Internal::slicebysize(const NeuralNetworkLayer* msg) {
  return *msg->layer_.slicebysize_;
}
const ::CoreML::Specification::Convolution3DLayerParams&
NeuralNetworkLayer::_Internal::convolution3d(const NeuralNetworkLayer* msg) {
  return *msg->layer_.convolution3d_;
}
void NeuralNetworkLayer::set_allocated_convolution(::CoreML::Specification::ConvolutionLayerParams* convolution) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (convolution) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ConvolutionLayerParams>::GetOwningArena(convolution);
    if (message_arena != submessage_arena) {
      convolution = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, convolution, submessage_arena);
    }
    set_has_convolution();
    layer_.convolution_ = convolution;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.convolution)
}
void NeuralNetworkLayer::set_allocated_pooling(::CoreML::Specification::PoolingLayerParams* pooling) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (pooling) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::PoolingLayerParams>::GetOwningArena(pooling);
    if (message_arena != submessage_arena) {
      pooling = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pooling, submessage_arena);
    }
    set_has_pooling();
    layer_.pooling_ = pooling;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.pooling)
}
void NeuralNetworkLayer::set_allocated_activation(::CoreML::Specification::ActivationParams* activation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (activation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ActivationParams>::GetOwningArena(activation);
    if (message_arena != submessage_arena) {
      activation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activation, submessage_arena);
    }
    set_has_activation();
    layer_.activation_ = activation;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.activation)
}
void NeuralNetworkLayer::set_allocated_innerproduct(::CoreML::Specification::InnerProductLayerParams* innerproduct) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (innerproduct) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::InnerProductLayerParams>::GetOwningArena(innerproduct);
    if (message_arena != submessage_arena) {
      innerproduct = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, innerproduct, submessage_arena);
    }
    set_has_innerproduct();
    layer_.innerproduct_ = innerproduct;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.innerProduct)
}
void NeuralNetworkLayer::set_allocated_embedding(::CoreML::Specification::EmbeddingLayerParams* embedding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (embedding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::EmbeddingLayerParams>::GetOwningArena(embedding);
    if (message_arena != submessage_arena) {
      embedding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, embedding, submessage_arena);
    }
    set_has_embedding();
    layer_.embedding_ = embedding;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.embedding)
}
void NeuralNetworkLayer::set_allocated_batchnorm(::CoreML::Specification::BatchnormLayerParams* batchnorm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (batchnorm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::BatchnormLayerParams>::GetOwningArena(batchnorm);
    if (message_arena != submessage_arena) {
      batchnorm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batchnorm, submessage_arena);
    }
    set_has_batchnorm();
    layer_.batchnorm_ = batchnorm;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.batchnorm)
}
void NeuralNetworkLayer::set_allocated_mvn(::CoreML::Specification::MeanVarianceNormalizeLayerParams* mvn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (mvn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MeanVarianceNormalizeLayerParams>::GetOwningArena(mvn);
    if (message_arena != submessage_arena) {
      mvn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mvn, submessage_arena);
    }
    set_has_mvn();
    layer_.mvn_ = mvn;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.mvn)
}
void NeuralNetworkLayer::set_allocated_l2normalize(::CoreML::Specification::L2NormalizeLayerParams* l2normalize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (l2normalize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::L2NormalizeLayerParams>::GetOwningArena(l2normalize);
    if (message_arena != submessage_arena) {
      l2normalize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, l2normalize, submessage_arena);
    }
    set_has_l2normalize();
    layer_.l2normalize_ = l2normalize;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.l2normalize)
}
void NeuralNetworkLayer::set_allocated_softmax(::CoreML::Specification::SoftmaxLayerParams* softmax) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (softmax) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SoftmaxLayerParams>::GetOwningArena(softmax);
    if (message_arena != submessage_arena) {
      softmax = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, softmax, submessage_arena);
    }
    set_has_softmax();
    layer_.softmax_ = softmax;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.softmax)
}
void NeuralNetworkLayer::set_allocated_lrn(::CoreML::Specification::LRNLayerParams* lrn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (lrn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::LRNLayerParams>::GetOwningArena(lrn);
    if (message_arena != submessage_arena) {
      lrn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lrn, submessage_arena);
    }
    set_has_lrn();
    layer_.lrn_ = lrn;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.lrn)
}
void NeuralNetworkLayer::set_allocated_crop(::CoreML::Specification::CropLayerParams* crop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (crop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::CropLayerParams>::GetOwningArena(crop);
    if (message_arena != submessage_arena) {
      crop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, crop, submessage_arena);
    }
    set_has_crop();
    layer_.crop_ = crop;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.crop)
}
void NeuralNetworkLayer::set_allocated_padding(::CoreML::Specification::PaddingLayerParams* padding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (padding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::PaddingLayerParams>::GetOwningArena(padding);
    if (message_arena != submessage_arena) {
      padding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, padding, submessage_arena);
    }
    set_has_padding();
    layer_.padding_ = padding;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.padding)
}
void NeuralNetworkLayer::set_allocated_upsample(::CoreML::Specification::UpsampleLayerParams* upsample) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (upsample) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::UpsampleLayerParams>::GetOwningArena(upsample);
    if (message_arena != submessage_arena) {
      upsample = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upsample, submessage_arena);
    }
    set_has_upsample();
    layer_.upsample_ = upsample;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.upsample)
}
void NeuralNetworkLayer::set_allocated_resizebilinear(::CoreML::Specification::ResizeBilinearLayerParams* resizebilinear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (resizebilinear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ResizeBilinearLayerParams>::GetOwningArena(resizebilinear);
    if (message_arena != submessage_arena) {
      resizebilinear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resizebilinear, submessage_arena);
    }
    set_has_resizebilinear();
    layer_.resizebilinear_ = resizebilinear;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.resizeBilinear)
}
void NeuralNetworkLayer::set_allocated_cropresize(::CoreML::Specification::CropResizeLayerParams* cropresize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (cropresize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::CropResizeLayerParams>::GetOwningArena(cropresize);
    if (message_arena != submessage_arena) {
      cropresize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cropresize, submessage_arena);
    }
    set_has_cropresize();
    layer_.cropresize_ = cropresize;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.cropResize)
}
void NeuralNetworkLayer::set_allocated_unary(::CoreML::Specification::UnaryFunctionLayerParams* unary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (unary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::UnaryFunctionLayerParams>::GetOwningArena(unary);
    if (message_arena != submessage_arena) {
      unary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unary, submessage_arena);
    }
    set_has_unary();
    layer_.unary_ = unary;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.unary)
}
void NeuralNetworkLayer::set_allocated_add(::CoreML::Specification::AddLayerParams* add) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (add) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::AddLayerParams>::GetOwningArena(add);
    if (message_arena != submessage_arena) {
      add = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add, submessage_arena);
    }
    set_has_add();
    layer_.add_ = add;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.add)
}
void NeuralNetworkLayer::set_allocated_multiply(::CoreML::Specification::MultiplyLayerParams* multiply) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (multiply) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MultiplyLayerParams>::GetOwningArena(multiply);
    if (message_arena != submessage_arena) {
      multiply = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multiply, submessage_arena);
    }
    set_has_multiply();
    layer_.multiply_ = multiply;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.multiply)
}
void NeuralNetworkLayer::set_allocated_average(::CoreML::Specification::AverageLayerParams* average) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (average) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::AverageLayerParams>::GetOwningArena(average);
    if (message_arena != submessage_arena) {
      average = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, average, submessage_arena);
    }
    set_has_average();
    layer_.average_ = average;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.average)
}
void NeuralNetworkLayer::set_allocated_scale(::CoreML::Specification::ScaleLayerParams* scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ScaleLayerParams>::GetOwningArena(scale);
    if (message_arena != submessage_arena) {
      scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scale, submessage_arena);
    }
    set_has_scale();
    layer_.scale_ = scale;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.scale)
}
void NeuralNetworkLayer::set_allocated_bias(::CoreML::Specification::BiasLayerParams* bias) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (bias) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::BiasLayerParams>::GetOwningArena(bias);
    if (message_arena != submessage_arena) {
      bias = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bias, submessage_arena);
    }
    set_has_bias();
    layer_.bias_ = bias;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.bias)
}
void NeuralNetworkLayer::set_allocated_max(::CoreML::Specification::MaxLayerParams* max) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (max) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MaxLayerParams>::GetOwningArena(max);
    if (message_arena != submessage_arena) {
      max = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max, submessage_arena);
    }
    set_has_max();
    layer_.max_ = max;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.max)
}
void NeuralNetworkLayer::set_allocated_min(::CoreML::Specification::MinLayerParams* min) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (min) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MinLayerParams>::GetOwningArena(min);
    if (message_arena != submessage_arena) {
      min = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min, submessage_arena);
    }
    set_has_min();
    layer_.min_ = min;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.min)
}
void NeuralNetworkLayer::set_allocated_dot(::CoreML::Specification::DotProductLayerParams* dot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (dot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::DotProductLayerParams>::GetOwningArena(dot);
    if (message_arena != submessage_arena) {
      dot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dot, submessage_arena);
    }
    set_has_dot();
    layer_.dot_ = dot;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.dot)
}
void NeuralNetworkLayer::set_allocated_reduce(::CoreML::Specification::ReduceLayerParams* reduce) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (reduce) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ReduceLayerParams>::GetOwningArena(reduce);
    if (message_arena != submessage_arena) {
      reduce = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reduce, submessage_arena);
    }
    set_has_reduce();
    layer_.reduce_ = reduce;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reduce)
}
void NeuralNetworkLayer::set_allocated_loadconstant(::CoreML::Specification::LoadConstantLayerParams* loadconstant) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (loadconstant) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::LoadConstantLayerParams>::GetOwningArena(loadconstant);
    if (message_arena != submessage_arena) {
      loadconstant = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loadconstant, submessage_arena);
    }
    set_has_loadconstant();
    layer_.loadconstant_ = loadconstant;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.loadConstant)
}
void NeuralNetworkLayer::set_allocated_reshape(::CoreML::Specification::ReshapeLayerParams* reshape) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (reshape) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ReshapeLayerParams>::GetOwningArena(reshape);
    if (message_arena != submessage_arena) {
      reshape = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reshape, submessage_arena);
    }
    set_has_reshape();
    layer_.reshape_ = reshape;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reshape)
}
void NeuralNetworkLayer::set_allocated_flatten(::CoreML::Specification::FlattenLayerParams* flatten) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (flatten) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::FlattenLayerParams>::GetOwningArena(flatten);
    if (message_arena != submessage_arena) {
      flatten = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flatten, submessage_arena);
    }
    set_has_flatten();
    layer_.flatten_ = flatten;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.flatten)
}
void NeuralNetworkLayer::set_allocated_permute(::CoreML::Specification::PermuteLayerParams* permute) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (permute) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::PermuteLayerParams>::GetOwningArena(permute);
    if (message_arena != submessage_arena) {
      permute = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permute, submessage_arena);
    }
    set_has_permute();
    layer_.permute_ = permute;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.permute)
}
void NeuralNetworkLayer::set_allocated_concat(::CoreML::Specification::ConcatLayerParams* concat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (concat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ConcatLayerParams>::GetOwningArena(concat);
    if (message_arena != submessage_arena) {
      concat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, concat, submessage_arena);
    }
    set_has_concat();
    layer_.concat_ = concat;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.concat)
}
void NeuralNetworkLayer::set_allocated_split(::CoreML::Specification::SplitLayerParams* split) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (split) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SplitLayerParams>::GetOwningArena(split);
    if (message_arena != submessage_arena) {
      split = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, split, submessage_arena);
    }
    set_has_split();
    layer_.split_ = split;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.split)
}
void NeuralNetworkLayer::set_allocated_sequencerepeat(::CoreML::Specification::SequenceRepeatLayerParams* sequencerepeat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (sequencerepeat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SequenceRepeatLayerParams>::GetOwningArena(sequencerepeat);
    if (message_arena != submessage_arena) {
      sequencerepeat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sequencerepeat, submessage_arena);
    }
    set_has_sequencerepeat();
    layer_.sequencerepeat_ = sequencerepeat;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.sequenceRepeat)
}
void NeuralNetworkLayer::set_allocated_reorganizedata(::CoreML::Specification::ReorganizeDataLayerParams* reorganizedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (reorganizedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ReorganizeDataLayerParams>::GetOwningArena(reorganizedata);
    if (message_arena != submessage_arena) {
      reorganizedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reorganizedata, submessage_arena);
    }
    set_has_reorganizedata();
    layer_.reorganizedata_ = reorganizedata;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reorganizeData)
}
void NeuralNetworkLayer::set_allocated_slice(::CoreML::Specification::SliceLayerParams* slice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (slice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SliceLayerParams>::GetOwningArena(slice);
    if (message_arena != submessage_arena) {
      slice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, slice, submessage_arena);
    }
    set_has_slice();
    layer_.slice_ = slice;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.slice)
}
void NeuralNetworkLayer::set_allocated_simplerecurrent(::CoreML::Specification::SimpleRecurrentLayerParams* simplerecurrent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (simplerecurrent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SimpleRecurrentLayerParams>::GetOwningArena(simplerecurrent);
    if (message_arena != submessage_arena) {
      simplerecurrent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, simplerecurrent, submessage_arena);
    }
    set_has_simplerecurrent();
    layer_.simplerecurrent_ = simplerecurrent;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.simpleRecurrent)
}
void NeuralNetworkLayer::set_allocated_gru(::CoreML::Specification::GRULayerParams* gru) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (gru) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::GRULayerParams>::GetOwningArena(gru);
    if (message_arena != submessage_arena) {
      gru = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gru, submessage_arena);
    }
    set_has_gru();
    layer_.gru_ = gru;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.gru)
}
void NeuralNetworkLayer::set_allocated_unidirectionallstm(::CoreML::Specification::UniDirectionalLSTMLayerParams* unidirectionallstm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (unidirectionallstm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::UniDirectionalLSTMLayerParams>::GetOwningArena(unidirectionallstm);
    if (message_arena != submessage_arena) {
      unidirectionallstm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unidirectionallstm, submessage_arena);
    }
    set_has_unidirectionallstm();
    layer_.unidirectionallstm_ = unidirectionallstm;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.uniDirectionalLSTM)
}
void NeuralNetworkLayer::set_allocated_bidirectionallstm(::CoreML::Specification::BiDirectionalLSTMLayerParams* bidirectionallstm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (bidirectionallstm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::BiDirectionalLSTMLayerParams>::GetOwningArena(bidirectionallstm);
    if (message_arena != submessage_arena) {
      bidirectionallstm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bidirectionallstm, submessage_arena);
    }
    set_has_bidirectionallstm();
    layer_.bidirectionallstm_ = bidirectionallstm;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.biDirectionalLSTM)
}
void NeuralNetworkLayer::set_allocated_custom(::CoreML::Specification::CustomLayerParams* custom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (custom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::CustomLayerParams>::GetOwningArena(custom);
    if (message_arena != submessage_arena) {
      custom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, custom, submessage_arena);
    }
    set_has_custom();
    layer_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.custom)
}
void NeuralNetworkLayer::set_allocated_copy(::CoreML::Specification::CopyLayerParams* copy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (copy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::CopyLayerParams>::GetOwningArena(copy);
    if (message_arena != submessage_arena) {
      copy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, copy, submessage_arena);
    }
    set_has_copy();
    layer_.copy_ = copy;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.copy)
}
void NeuralNetworkLayer::set_allocated_branch(::CoreML::Specification::BranchLayerParams* branch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (branch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::BranchLayerParams>::GetOwningArena(branch);
    if (message_arena != submessage_arena) {
      branch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, branch, submessage_arena);
    }
    set_has_branch();
    layer_.branch_ = branch;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.branch)
}
void NeuralNetworkLayer::set_allocated_loop(::CoreML::Specification::LoopLayerParams* loop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (loop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::LoopLayerParams>::GetOwningArena(loop);
    if (message_arena != submessage_arena) {
      loop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loop, submessage_arena);
    }
    set_has_loop();
    layer_.loop_ = loop;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.loop)
}
void NeuralNetworkLayer::set_allocated_loopbreak(::CoreML::Specification::LoopBreakLayerParams* loopbreak) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (loopbreak) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::LoopBreakLayerParams>::GetOwningArena(loopbreak);
    if (message_arena != submessage_arena) {
      loopbreak = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loopbreak, submessage_arena);
    }
    set_has_loopbreak();
    layer_.loopbreak_ = loopbreak;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.loopBreak)
}
void NeuralNetworkLayer::set_allocated_loopcontinue(::CoreML::Specification::LoopContinueLayerParams* loopcontinue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (loopcontinue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::LoopContinueLayerParams>::GetOwningArena(loopcontinue);
    if (message_arena != submessage_arena) {
      loopcontinue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loopcontinue, submessage_arena);
    }
    set_has_loopcontinue();
    layer_.loopcontinue_ = loopcontinue;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.loopContinue)
}
void NeuralNetworkLayer::set_allocated_rangestatic(::CoreML::Specification::RangeStaticLayerParams* rangestatic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (rangestatic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::RangeStaticLayerParams>::GetOwningArena(rangestatic);
    if (message_arena != submessage_arena) {
      rangestatic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rangestatic, submessage_arena);
    }
    set_has_rangestatic();
    layer_.rangestatic_ = rangestatic;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.rangeStatic)
}
void NeuralNetworkLayer::set_allocated_rangedynamic(::CoreML::Specification::RangeDynamicLayerParams* rangedynamic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (rangedynamic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::RangeDynamicLayerParams>::GetOwningArena(rangedynamic);
    if (message_arena != submessage_arena) {
      rangedynamic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rangedynamic, submessage_arena);
    }
    set_has_rangedynamic();
    layer_.rangedynamic_ = rangedynamic;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.rangeDynamic)
}
void NeuralNetworkLayer::set_allocated_clip(::CoreML::Specification::ClipLayerParams* clip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (clip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ClipLayerParams>::GetOwningArena(clip);
    if (message_arena != submessage_arena) {
      clip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clip, submessage_arena);
    }
    set_has_clip();
    layer_.clip_ = clip;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.clip)
}
void NeuralNetworkLayer::set_allocated_ceil(::CoreML::Specification::CeilLayerParams* ceil) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (ceil) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::CeilLayerParams>::GetOwningArena(ceil);
    if (message_arena != submessage_arena) {
      ceil = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ceil, submessage_arena);
    }
    set_has_ceil();
    layer_.ceil_ = ceil;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.ceil)
}
void NeuralNetworkLayer::set_allocated_floor(::CoreML::Specification::FloorLayerParams* floor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (floor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::FloorLayerParams>::GetOwningArena(floor);
    if (message_arena != submessage_arena) {
      floor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, floor, submessage_arena);
    }
    set_has_floor();
    layer_.floor_ = floor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.floor)
}
void NeuralNetworkLayer::set_allocated_sign(::CoreML::Specification::SignLayerParams* sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SignLayerParams>::GetOwningArena(sign);
    if (message_arena != submessage_arena) {
      sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sign, submessage_arena);
    }
    set_has_sign();
    layer_.sign_ = sign;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.sign)
}
void NeuralNetworkLayer::set_allocated_round(::CoreML::Specification::RoundLayerParams* round) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (round) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::RoundLayerParams>::GetOwningArena(round);
    if (message_arena != submessage_arena) {
      round = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, round, submessage_arena);
    }
    set_has_round();
    layer_.round_ = round;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.round)
}
void NeuralNetworkLayer::set_allocated_exp2(::CoreML::Specification::Exp2LayerParams* exp2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (exp2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::Exp2LayerParams>::GetOwningArena(exp2);
    if (message_arena != submessage_arena) {
      exp2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exp2, submessage_arena);
    }
    set_has_exp2();
    layer_.exp2_ = exp2;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.exp2)
}
void NeuralNetworkLayer::set_allocated_sin(::CoreML::Specification::SinLayerParams* sin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (sin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SinLayerParams>::GetOwningArena(sin);
    if (message_arena != submessage_arena) {
      sin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sin, submessage_arena);
    }
    set_has_sin();
    layer_.sin_ = sin;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.sin)
}
void NeuralNetworkLayer::set_allocated_cos(::CoreML::Specification::CosLayerParams* cos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (cos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::CosLayerParams>::GetOwningArena(cos);
    if (message_arena != submessage_arena) {
      cos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cos, submessage_arena);
    }
    set_has_cos();
    layer_.cos_ = cos;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.cos)
}
void NeuralNetworkLayer::set_allocated_tan(::CoreML::Specification::TanLayerParams* tan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (tan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::TanLayerParams>::GetOwningArena(tan);
    if (message_arena != submessage_arena) {
      tan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tan, submessage_arena);
    }
    set_has_tan();
    layer_.tan_ = tan;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.tan)
}
void NeuralNetworkLayer::set_allocated_asin(::CoreML::Specification::AsinLayerParams* asin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (asin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::AsinLayerParams>::GetOwningArena(asin);
    if (message_arena != submessage_arena) {
      asin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, asin, submessage_arena);
    }
    set_has_asin();
    layer_.asin_ = asin;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.asin)
}
void NeuralNetworkLayer::set_allocated_acos(::CoreML::Specification::AcosLayerParams* acos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (acos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::AcosLayerParams>::GetOwningArena(acos);
    if (message_arena != submessage_arena) {
      acos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acos, submessage_arena);
    }
    set_has_acos();
    layer_.acos_ = acos;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.acos)
}
void NeuralNetworkLayer::set_allocated_atan(::CoreML::Specification::AtanLayerParams* atan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (atan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::AtanLayerParams>::GetOwningArena(atan);
    if (message_arena != submessage_arena) {
      atan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, atan, submessage_arena);
    }
    set_has_atan();
    layer_.atan_ = atan;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.atan)
}
void NeuralNetworkLayer::set_allocated_sinh(::CoreML::Specification::SinhLayerParams* sinh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (sinh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SinhLayerParams>::GetOwningArena(sinh);
    if (message_arena != submessage_arena) {
      sinh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sinh, submessage_arena);
    }
    set_has_sinh();
    layer_.sinh_ = sinh;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.sinh)
}
void NeuralNetworkLayer::set_allocated_cosh(::CoreML::Specification::CoshLayerParams* cosh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (cosh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::CoshLayerParams>::GetOwningArena(cosh);
    if (message_arena != submessage_arena) {
      cosh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cosh, submessage_arena);
    }
    set_has_cosh();
    layer_.cosh_ = cosh;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.cosh)
}
void NeuralNetworkLayer::set_allocated_tanh(::CoreML::Specification::TanhLayerParams* tanh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (tanh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::TanhLayerParams>::GetOwningArena(tanh);
    if (message_arena != submessage_arena) {
      tanh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tanh, submessage_arena);
    }
    set_has_tanh();
    layer_.tanh_ = tanh;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.tanh)
}
void NeuralNetworkLayer::set_allocated_asinh(::CoreML::Specification::AsinhLayerParams* asinh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (asinh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::AsinhLayerParams>::GetOwningArena(asinh);
    if (message_arena != submessage_arena) {
      asinh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, asinh, submessage_arena);
    }
    set_has_asinh();
    layer_.asinh_ = asinh;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.asinh)
}
void NeuralNetworkLayer::set_allocated_acosh(::CoreML::Specification::AcoshLayerParams* acosh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (acosh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::AcoshLayerParams>::GetOwningArena(acosh);
    if (message_arena != submessage_arena) {
      acosh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acosh, submessage_arena);
    }
    set_has_acosh();
    layer_.acosh_ = acosh;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.acosh)
}
void NeuralNetworkLayer::set_allocated_atanh(::CoreML::Specification::AtanhLayerParams* atanh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (atanh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::AtanhLayerParams>::GetOwningArena(atanh);
    if (message_arena != submessage_arena) {
      atanh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, atanh, submessage_arena);
    }
    set_has_atanh();
    layer_.atanh_ = atanh;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.atanh)
}
void NeuralNetworkLayer::set_allocated_erf(::CoreML::Specification::ErfLayerParams* erf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (erf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ErfLayerParams>::GetOwningArena(erf);
    if (message_arena != submessage_arena) {
      erf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, erf, submessage_arena);
    }
    set_has_erf();
    layer_.erf_ = erf;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.erf)
}
void NeuralNetworkLayer::set_allocated_gelu(::CoreML::Specification::GeluLayerParams* gelu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (gelu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::GeluLayerParams>::GetOwningArena(gelu);
    if (message_arena != submessage_arena) {
      gelu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gelu, submessage_arena);
    }
    set_has_gelu();
    layer_.gelu_ = gelu;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.gelu)
}
void NeuralNetworkLayer::set_allocated_equal(::CoreML::Specification::EqualLayerParams* equal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (equal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::EqualLayerParams>::GetOwningArena(equal);
    if (message_arena != submessage_arena) {
      equal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, equal, submessage_arena);
    }
    set_has_equal();
    layer_.equal_ = equal;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.equal)
}
void NeuralNetworkLayer::set_allocated_notequal(::CoreML::Specification::NotEqualLayerParams* notequal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (notequal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::NotEqualLayerParams>::GetOwningArena(notequal);
    if (message_arena != submessage_arena) {
      notequal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, notequal, submessage_arena);
    }
    set_has_notequal();
    layer_.notequal_ = notequal;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.notEqual)
}
void NeuralNetworkLayer::set_allocated_lessthan(::CoreML::Specification::LessThanLayerParams* lessthan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (lessthan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::LessThanLayerParams>::GetOwningArena(lessthan);
    if (message_arena != submessage_arena) {
      lessthan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lessthan, submessage_arena);
    }
    set_has_lessthan();
    layer_.lessthan_ = lessthan;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.lessThan)
}
void NeuralNetworkLayer::set_allocated_lessequal(::CoreML::Specification::LessEqualLayerParams* lessequal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (lessequal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::LessEqualLayerParams>::GetOwningArena(lessequal);
    if (message_arena != submessage_arena) {
      lessequal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lessequal, submessage_arena);
    }
    set_has_lessequal();
    layer_.lessequal_ = lessequal;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.lessEqual)
}
void NeuralNetworkLayer::set_allocated_greaterthan(::CoreML::Specification::GreaterThanLayerParams* greaterthan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (greaterthan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::GreaterThanLayerParams>::GetOwningArena(greaterthan);
    if (message_arena != submessage_arena) {
      greaterthan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, greaterthan, submessage_arena);
    }
    set_has_greaterthan();
    layer_.greaterthan_ = greaterthan;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.greaterThan)
}
void NeuralNetworkLayer::set_allocated_greaterequal(::CoreML::Specification::GreaterEqualLayerParams* greaterequal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (greaterequal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::GreaterEqualLayerParams>::GetOwningArena(greaterequal);
    if (message_arena != submessage_arena) {
      greaterequal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, greaterequal, submessage_arena);
    }
    set_has_greaterequal();
    layer_.greaterequal_ = greaterequal;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.greaterEqual)
}
void NeuralNetworkLayer::set_allocated_logicalor(::CoreML::Specification::LogicalOrLayerParams* logicalor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (logicalor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::LogicalOrLayerParams>::GetOwningArena(logicalor);
    if (message_arena != submessage_arena) {
      logicalor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalor, submessage_arena);
    }
    set_has_logicalor();
    layer_.logicalor_ = logicalor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.logicalOr)
}
void NeuralNetworkLayer::set_allocated_logicalxor(::CoreML::Specification::LogicalXorLayerParams* logicalxor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (logicalxor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::LogicalXorLayerParams>::GetOwningArena(logicalxor);
    if (message_arena != submessage_arena) {
      logicalxor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalxor, submessage_arena);
    }
    set_has_logicalxor();
    layer_.logicalxor_ = logicalxor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.logicalXor)
}
void NeuralNetworkLayer::set_allocated_logicalnot(::CoreML::Specification::LogicalNotLayerParams* logicalnot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (logicalnot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::LogicalNotLayerParams>::GetOwningArena(logicalnot);
    if (message_arena != submessage_arena) {
      logicalnot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnot, submessage_arena);
    }
    set_has_logicalnot();
    layer_.logicalnot_ = logicalnot;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.logicalNot)
}
void NeuralNetworkLayer::set_allocated_logicaland(::CoreML::Specification::LogicalAndLayerParams* logicaland) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (logicaland) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::LogicalAndLayerParams>::GetOwningArena(logicaland);
    if (message_arena != submessage_arena) {
      logicaland = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicaland, submessage_arena);
    }
    set_has_logicaland();
    layer_.logicaland_ = logicaland;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.logicalAnd)
}
void NeuralNetworkLayer::set_allocated_modbroadcastable(::CoreML::Specification::ModBroadcastableLayerParams* modbroadcastable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (modbroadcastable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ModBroadcastableLayerParams>::GetOwningArena(modbroadcastable);
    if (message_arena != submessage_arena) {
      modbroadcastable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modbroadcastable, submessage_arena);
    }
    set_has_modbroadcastable();
    layer_.modbroadcastable_ = modbroadcastable;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.modBroadcastable)
}
void NeuralNetworkLayer::set_allocated_minbroadcastable(::CoreML::Specification::MinBroadcastableLayerParams* minbroadcastable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (minbroadcastable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MinBroadcastableLayerParams>::GetOwningArena(minbroadcastable);
    if (message_arena != submessage_arena) {
      minbroadcastable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minbroadcastable, submessage_arena);
    }
    set_has_minbroadcastable();
    layer_.minbroadcastable_ = minbroadcastable;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.minBroadcastable)
}
void NeuralNetworkLayer::set_allocated_maxbroadcastable(::CoreML::Specification::MaxBroadcastableLayerParams* maxbroadcastable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (maxbroadcastable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MaxBroadcastableLayerParams>::GetOwningArena(maxbroadcastable);
    if (message_arena != submessage_arena) {
      maxbroadcastable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maxbroadcastable, submessage_arena);
    }
    set_has_maxbroadcastable();
    layer_.maxbroadcastable_ = maxbroadcastable;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.maxBroadcastable)
}
void NeuralNetworkLayer::set_allocated_addbroadcastable(::CoreML::Specification::AddBroadcastableLayerParams* addbroadcastable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (addbroadcastable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::AddBroadcastableLayerParams>::GetOwningArena(addbroadcastable);
    if (message_arena != submessage_arena) {
      addbroadcastable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, addbroadcastable, submessage_arena);
    }
    set_has_addbroadcastable();
    layer_.addbroadcastable_ = addbroadcastable;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.addBroadcastable)
}
void NeuralNetworkLayer::set_allocated_powbroadcastable(::CoreML::Specification::PowBroadcastableLayerParams* powbroadcastable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (powbroadcastable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::PowBroadcastableLayerParams>::GetOwningArena(powbroadcastable);
    if (message_arena != submessage_arena) {
      powbroadcastable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, powbroadcastable, submessage_arena);
    }
    set_has_powbroadcastable();
    layer_.powbroadcastable_ = powbroadcastable;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.powBroadcastable)
}
void NeuralNetworkLayer::set_allocated_dividebroadcastable(::CoreML::Specification::DivideBroadcastableLayerParams* dividebroadcastable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (dividebroadcastable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::DivideBroadcastableLayerParams>::GetOwningArena(dividebroadcastable);
    if (message_arena != submessage_arena) {
      dividebroadcastable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dividebroadcastable, submessage_arena);
    }
    set_has_dividebroadcastable();
    layer_.dividebroadcastable_ = dividebroadcastable;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.divideBroadcastable)
}
void NeuralNetworkLayer::set_allocated_floordivbroadcastable(::CoreML::Specification::FloorDivBroadcastableLayerParams* floordivbroadcastable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (floordivbroadcastable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::FloorDivBroadcastableLayerParams>::GetOwningArena(floordivbroadcastable);
    if (message_arena != submessage_arena) {
      floordivbroadcastable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, floordivbroadcastable, submessage_arena);
    }
    set_has_floordivbroadcastable();
    layer_.floordivbroadcastable_ = floordivbroadcastable;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.floorDivBroadcastable)
}
void NeuralNetworkLayer::set_allocated_multiplybroadcastable(::CoreML::Specification::MultiplyBroadcastableLayerParams* multiplybroadcastable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (multiplybroadcastable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MultiplyBroadcastableLayerParams>::GetOwningArena(multiplybroadcastable);
    if (message_arena != submessage_arena) {
      multiplybroadcastable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multiplybroadcastable, submessage_arena);
    }
    set_has_multiplybroadcastable();
    layer_.multiplybroadcastable_ = multiplybroadcastable;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.multiplyBroadcastable)
}
void NeuralNetworkLayer::set_allocated_subtractbroadcastable(::CoreML::Specification::SubtractBroadcastableLayerParams* subtractbroadcastable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (subtractbroadcastable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SubtractBroadcastableLayerParams>::GetOwningArena(subtractbroadcastable);
    if (message_arena != submessage_arena) {
      subtractbroadcastable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subtractbroadcastable, submessage_arena);
    }
    set_has_subtractbroadcastable();
    layer_.subtractbroadcastable_ = subtractbroadcastable;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.subtractBroadcastable)
}
void NeuralNetworkLayer::set_allocated_tile(::CoreML::Specification::TileLayerParams* tile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (tile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::TileLayerParams>::GetOwningArena(tile);
    if (message_arena != submessage_arena) {
      tile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tile, submessage_arena);
    }
    set_has_tile();
    layer_.tile_ = tile;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.tile)
}
void NeuralNetworkLayer::set_allocated_stack(::CoreML::Specification::StackLayerParams* stack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (stack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::StackLayerParams>::GetOwningArena(stack);
    if (message_arena != submessage_arena) {
      stack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stack, submessage_arena);
    }
    set_has_stack();
    layer_.stack_ = stack;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.stack)
}
void NeuralNetworkLayer::set_allocated_gather(::CoreML::Specification::GatherLayerParams* gather) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (gather) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::GatherLayerParams>::GetOwningArena(gather);
    if (message_arena != submessage_arena) {
      gather = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gather, submessage_arena);
    }
    set_has_gather();
    layer_.gather_ = gather;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.gather)
}
void NeuralNetworkLayer::set_allocated_scatter(::CoreML::Specification::ScatterLayerParams* scatter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (scatter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ScatterLayerParams>::GetOwningArena(scatter);
    if (message_arena != submessage_arena) {
      scatter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scatter, submessage_arena);
    }
    set_has_scatter();
    layer_.scatter_ = scatter;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.scatter)
}
void NeuralNetworkLayer::set_allocated_gathernd(::CoreML::Specification::GatherNDLayerParams* gathernd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (gathernd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::GatherNDLayerParams>::GetOwningArena(gathernd);
    if (message_arena != submessage_arena) {
      gathernd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gathernd, submessage_arena);
    }
    set_has_gathernd();
    layer_.gathernd_ = gathernd;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.gatherND)
}
void NeuralNetworkLayer::set_allocated_scatternd(::CoreML::Specification::ScatterNDLayerParams* scatternd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (scatternd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ScatterNDLayerParams>::GetOwningArena(scatternd);
    if (message_arena != submessage_arena) {
      scatternd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scatternd, submessage_arena);
    }
    set_has_scatternd();
    layer_.scatternd_ = scatternd;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.scatterND)
}
void NeuralNetworkLayer::set_allocated_softmaxnd(::CoreML::Specification::SoftmaxNDLayerParams* softmaxnd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (softmaxnd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SoftmaxNDLayerParams>::GetOwningArena(softmaxnd);
    if (message_arena != submessage_arena) {
      softmaxnd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, softmaxnd, submessage_arena);
    }
    set_has_softmaxnd();
    layer_.softmaxnd_ = softmaxnd;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.softmaxND)
}
void NeuralNetworkLayer::set_allocated_gatheralongaxis(::CoreML::Specification::GatherAlongAxisLayerParams* gatheralongaxis) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (gatheralongaxis) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::GatherAlongAxisLayerParams>::GetOwningArena(gatheralongaxis);
    if (message_arena != submessage_arena) {
      gatheralongaxis = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gatheralongaxis, submessage_arena);
    }
    set_has_gatheralongaxis();
    layer_.gatheralongaxis_ = gatheralongaxis;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.gatherAlongAxis)
}
void NeuralNetworkLayer::set_allocated_scatteralongaxis(::CoreML::Specification::ScatterAlongAxisLayerParams* scatteralongaxis) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (scatteralongaxis) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ScatterAlongAxisLayerParams>::GetOwningArena(scatteralongaxis);
    if (message_arena != submessage_arena) {
      scatteralongaxis = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scatteralongaxis, submessage_arena);
    }
    set_has_scatteralongaxis();
    layer_.scatteralongaxis_ = scatteralongaxis;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.scatterAlongAxis)
}
void NeuralNetworkLayer::set_allocated_reverse(::CoreML::Specification::ReverseLayerParams* reverse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (reverse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ReverseLayerParams>::GetOwningArena(reverse);
    if (message_arena != submessage_arena) {
      reverse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reverse, submessage_arena);
    }
    set_has_reverse();
    layer_.reverse_ = reverse;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reverse)
}
void NeuralNetworkLayer::set_allocated_reverseseq(::CoreML::Specification::ReverseSeqLayerParams* reverseseq) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (reverseseq) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ReverseSeqLayerParams>::GetOwningArena(reverseseq);
    if (message_arena != submessage_arena) {
      reverseseq = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reverseseq, submessage_arena);
    }
    set_has_reverseseq();
    layer_.reverseseq_ = reverseseq;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reverseSeq)
}
void NeuralNetworkLayer::set_allocated_splitnd(::CoreML::Specification::SplitNDLayerParams* splitnd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (splitnd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SplitNDLayerParams>::GetOwningArena(splitnd);
    if (message_arena != submessage_arena) {
      splitnd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, splitnd, submessage_arena);
    }
    set_has_splitnd();
    layer_.splitnd_ = splitnd;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.splitND)
}
void NeuralNetworkLayer::set_allocated_concatnd(::CoreML::Specification::ConcatNDLayerParams* concatnd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (concatnd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ConcatNDLayerParams>::GetOwningArena(concatnd);
    if (message_arena != submessage_arena) {
      concatnd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, concatnd, submessage_arena);
    }
    set_has_concatnd();
    layer_.concatnd_ = concatnd;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.concatND)
}
void NeuralNetworkLayer::set_allocated_transpose(::CoreML::Specification::TransposeLayerParams* transpose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (transpose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::TransposeLayerParams>::GetOwningArena(transpose);
    if (message_arena != submessage_arena) {
      transpose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transpose, submessage_arena);
    }
    set_has_transpose();
    layer_.transpose_ = transpose;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.transpose)
}
void NeuralNetworkLayer::set_allocated_slicestatic(::CoreML::Specification::SliceStaticLayerParams* slicestatic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (slicestatic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SliceStaticLayerParams>::GetOwningArena(slicestatic);
    if (message_arena != submessage_arena) {
      slicestatic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, slicestatic, submessage_arena);
    }
    set_has_slicestatic();
    layer_.slicestatic_ = slicestatic;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.sliceStatic)
}
void NeuralNetworkLayer::set_allocated_slicedynamic(::CoreML::Specification::SliceDynamicLayerParams* slicedynamic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (slicedynamic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SliceDynamicLayerParams>::GetOwningArena(slicedynamic);
    if (message_arena != submessage_arena) {
      slicedynamic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, slicedynamic, submessage_arena);
    }
    set_has_slicedynamic();
    layer_.slicedynamic_ = slicedynamic;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.sliceDynamic)
}
void NeuralNetworkLayer::set_allocated_slidingwindows(::CoreML::Specification::SlidingWindowsLayerParams* slidingwindows) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (slidingwindows) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SlidingWindowsLayerParams>::GetOwningArena(slidingwindows);
    if (message_arena != submessage_arena) {
      slidingwindows = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, slidingwindows, submessage_arena);
    }
    set_has_slidingwindows();
    layer_.slidingwindows_ = slidingwindows;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.slidingWindows)
}
void NeuralNetworkLayer::set_allocated_topk(::CoreML::Specification::TopKLayerParams* topk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (topk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::TopKLayerParams>::GetOwningArena(topk);
    if (message_arena != submessage_arena) {
      topk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topk, submessage_arena);
    }
    set_has_topk();
    layer_.topk_ = topk;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.topK)
}
void NeuralNetworkLayer::set_allocated_argmin(::CoreML::Specification::ArgMinLayerParams* argmin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (argmin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ArgMinLayerParams>::GetOwningArena(argmin);
    if (message_arena != submessage_arena) {
      argmin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, argmin, submessage_arena);
    }
    set_has_argmin();
    layer_.argmin_ = argmin;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.argMin)
}
void NeuralNetworkLayer::set_allocated_argmax(::CoreML::Specification::ArgMaxLayerParams* argmax) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (argmax) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ArgMaxLayerParams>::GetOwningArena(argmax);
    if (message_arena != submessage_arena) {
      argmax = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, argmax, submessage_arena);
    }
    set_has_argmax();
    layer_.argmax_ = argmax;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.argMax)
}
void NeuralNetworkLayer::set_allocated_embeddingnd(::CoreML::Specification::EmbeddingNDLayerParams* embeddingnd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (embeddingnd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::EmbeddingNDLayerParams>::GetOwningArena(embeddingnd);
    if (message_arena != submessage_arena) {
      embeddingnd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, embeddingnd, submessage_arena);
    }
    set_has_embeddingnd();
    layer_.embeddingnd_ = embeddingnd;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.embeddingND)
}
void NeuralNetworkLayer::set_allocated_batchedmatmul(::CoreML::Specification::BatchedMatMulLayerParams* batchedmatmul) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (batchedmatmul) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::BatchedMatMulLayerParams>::GetOwningArena(batchedmatmul);
    if (message_arena != submessage_arena) {
      batchedmatmul = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batchedmatmul, submessage_arena);
    }
    set_has_batchedmatmul();
    layer_.batchedmatmul_ = batchedmatmul;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.batchedMatmul)
}
void NeuralNetworkLayer::set_allocated_getshape(::CoreML::Specification::GetShapeLayerParams* getshape) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (getshape) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::GetShapeLayerParams>::GetOwningArena(getshape);
    if (message_arena != submessage_arena) {
      getshape = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getshape, submessage_arena);
    }
    set_has_getshape();
    layer_.getshape_ = getshape;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.getShape)
}
void NeuralNetworkLayer::set_allocated_loadconstantnd(::CoreML::Specification::LoadConstantNDLayerParams* loadconstantnd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (loadconstantnd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::LoadConstantNDLayerParams>::GetOwningArena(loadconstantnd);
    if (message_arena != submessage_arena) {
      loadconstantnd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loadconstantnd, submessage_arena);
    }
    set_has_loadconstantnd();
    layer_.loadconstantnd_ = loadconstantnd;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.loadConstantND)
}
void NeuralNetworkLayer::set_allocated_filllike(::CoreML::Specification::FillLikeLayerParams* filllike) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (filllike) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::FillLikeLayerParams>::GetOwningArena(filllike);
    if (message_arena != submessage_arena) {
      filllike = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filllike, submessage_arena);
    }
    set_has_filllike();
    layer_.filllike_ = filllike;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.fillLike)
}
void NeuralNetworkLayer::set_allocated_fillstatic(::CoreML::Specification::FillStaticLayerParams* fillstatic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (fillstatic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::FillStaticLayerParams>::GetOwningArena(fillstatic);
    if (message_arena != submessage_arena) {
      fillstatic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fillstatic, submessage_arena);
    }
    set_has_fillstatic();
    layer_.fillstatic_ = fillstatic;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.fillStatic)
}
void NeuralNetworkLayer::set_allocated_filldynamic(::CoreML::Specification::FillDynamicLayerParams* filldynamic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (filldynamic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::FillDynamicLayerParams>::GetOwningArena(filldynamic);
    if (message_arena != submessage_arena) {
      filldynamic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filldynamic, submessage_arena);
    }
    set_has_filldynamic();
    layer_.filldynamic_ = filldynamic;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.fillDynamic)
}
void NeuralNetworkLayer::set_allocated_broadcasttolike(::CoreML::Specification::BroadcastToLikeLayerParams* broadcasttolike) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (broadcasttolike) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::BroadcastToLikeLayerParams>::GetOwningArena(broadcasttolike);
    if (message_arena != submessage_arena) {
      broadcasttolike = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, broadcasttolike, submessage_arena);
    }
    set_has_broadcasttolike();
    layer_.broadcasttolike_ = broadcasttolike;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.broadcastToLike)
}
void NeuralNetworkLayer::set_allocated_broadcasttostatic(::CoreML::Specification::BroadcastToStaticLayerParams* broadcasttostatic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (broadcasttostatic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::BroadcastToStaticLayerParams>::GetOwningArena(broadcasttostatic);
    if (message_arena != submessage_arena) {
      broadcasttostatic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, broadcasttostatic, submessage_arena);
    }
    set_has_broadcasttostatic();
    layer_.broadcasttostatic_ = broadcasttostatic;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.broadcastToStatic)
}
void NeuralNetworkLayer::set_allocated_broadcasttodynamic(::CoreML::Specification::BroadcastToDynamicLayerParams* broadcasttodynamic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (broadcasttodynamic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::BroadcastToDynamicLayerParams>::GetOwningArena(broadcasttodynamic);
    if (message_arena != submessage_arena) {
      broadcasttodynamic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, broadcasttodynamic, submessage_arena);
    }
    set_has_broadcasttodynamic();
    layer_.broadcasttodynamic_ = broadcasttodynamic;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.broadcastToDynamic)
}
void NeuralNetworkLayer::set_allocated_squeeze(::CoreML::Specification::SqueezeLayerParams* squeeze) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (squeeze) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SqueezeLayerParams>::GetOwningArena(squeeze);
    if (message_arena != submessage_arena) {
      squeeze = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, squeeze, submessage_arena);
    }
    set_has_squeeze();
    layer_.squeeze_ = squeeze;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.squeeze)
}
void NeuralNetworkLayer::set_allocated_expanddims(::CoreML::Specification::ExpandDimsLayerParams* expanddims) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (expanddims) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ExpandDimsLayerParams>::GetOwningArena(expanddims);
    if (message_arena != submessage_arena) {
      expanddims = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expanddims, submessage_arena);
    }
    set_has_expanddims();
    layer_.expanddims_ = expanddims;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.expandDims)
}
void NeuralNetworkLayer::set_allocated_flattento2d(::CoreML::Specification::FlattenTo2DLayerParams* flattento2d) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (flattento2d) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::FlattenTo2DLayerParams>::GetOwningArena(flattento2d);
    if (message_arena != submessage_arena) {
      flattento2d = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flattento2d, submessage_arena);
    }
    set_has_flattento2d();
    layer_.flattento2d_ = flattento2d;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.flattenTo2D)
}
void NeuralNetworkLayer::set_allocated_reshapelike(::CoreML::Specification::ReshapeLikeLayerParams* reshapelike) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (reshapelike) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ReshapeLikeLayerParams>::GetOwningArena(reshapelike);
    if (message_arena != submessage_arena) {
      reshapelike = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reshapelike, submessage_arena);
    }
    set_has_reshapelike();
    layer_.reshapelike_ = reshapelike;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reshapeLike)
}
void NeuralNetworkLayer::set_allocated_reshapestatic(::CoreML::Specification::ReshapeStaticLayerParams* reshapestatic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (reshapestatic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ReshapeStaticLayerParams>::GetOwningArena(reshapestatic);
    if (message_arena != submessage_arena) {
      reshapestatic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reshapestatic, submessage_arena);
    }
    set_has_reshapestatic();
    layer_.reshapestatic_ = reshapestatic;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reshapeStatic)
}
void NeuralNetworkLayer::set_allocated_reshapedynamic(::CoreML::Specification::ReshapeDynamicLayerParams* reshapedynamic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (reshapedynamic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ReshapeDynamicLayerParams>::GetOwningArena(reshapedynamic);
    if (message_arena != submessage_arena) {
      reshapedynamic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reshapedynamic, submessage_arena);
    }
    set_has_reshapedynamic();
    layer_.reshapedynamic_ = reshapedynamic;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reshapeDynamic)
}
void NeuralNetworkLayer::set_allocated_rankpreservingreshape(::CoreML::Specification::RankPreservingReshapeLayerParams* rankpreservingreshape) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (rankpreservingreshape) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::RankPreservingReshapeLayerParams>::GetOwningArena(rankpreservingreshape);
    if (message_arena != submessage_arena) {
      rankpreservingreshape = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rankpreservingreshape, submessage_arena);
    }
    set_has_rankpreservingreshape();
    layer_.rankpreservingreshape_ = rankpreservingreshape;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.rankPreservingReshape)
}
void NeuralNetworkLayer::set_allocated_constantpad(::CoreML::Specification::ConstantPaddingLayerParams* constantpad) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (constantpad) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ConstantPaddingLayerParams>::GetOwningArena(constantpad);
    if (message_arena != submessage_arena) {
      constantpad = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, constantpad, submessage_arena);
    }
    set_has_constantpad();
    layer_.constantpad_ = constantpad;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.constantPad)
}
void NeuralNetworkLayer::set_allocated_randomnormallike(::CoreML::Specification::RandomNormalLikeLayerParams* randomnormallike) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (randomnormallike) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::RandomNormalLikeLayerParams>::GetOwningArena(randomnormallike);
    if (message_arena != submessage_arena) {
      randomnormallike = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, randomnormallike, submessage_arena);
    }
    set_has_randomnormallike();
    layer_.randomnormallike_ = randomnormallike;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.randomNormalLike)
}
void NeuralNetworkLayer::set_allocated_randomnormalstatic(::CoreML::Specification::RandomNormalStaticLayerParams* randomnormalstatic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (randomnormalstatic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::RandomNormalStaticLayerParams>::GetOwningArena(randomnormalstatic);
    if (message_arena != submessage_arena) {
      randomnormalstatic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, randomnormalstatic, submessage_arena);
    }
    set_has_randomnormalstatic();
    layer_.randomnormalstatic_ = randomnormalstatic;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.randomNormalStatic)
}
void NeuralNetworkLayer::set_allocated_randomnormaldynamic(::CoreML::Specification::RandomNormalDynamicLayerParams* randomnormaldynamic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (randomnormaldynamic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::RandomNormalDynamicLayerParams>::GetOwningArena(randomnormaldynamic);
    if (message_arena != submessage_arena) {
      randomnormaldynamic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, randomnormaldynamic, submessage_arena);
    }
    set_has_randomnormaldynamic();
    layer_.randomnormaldynamic_ = randomnormaldynamic;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.randomNormalDynamic)
}
void NeuralNetworkLayer::set_allocated_randomuniformlike(::CoreML::Specification::RandomUniformLikeLayerParams* randomuniformlike) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (randomuniformlike) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::RandomUniformLikeLayerParams>::GetOwningArena(randomuniformlike);
    if (message_arena != submessage_arena) {
      randomuniformlike = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, randomuniformlike, submessage_arena);
    }
    set_has_randomuniformlike();
    layer_.randomuniformlike_ = randomuniformlike;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.randomUniformLike)
}
void NeuralNetworkLayer::set_allocated_randomuniformstatic(::CoreML::Specification::RandomUniformStaticLayerParams* randomuniformstatic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (randomuniformstatic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::RandomUniformStaticLayerParams>::GetOwningArena(randomuniformstatic);
    if (message_arena != submessage_arena) {
      randomuniformstatic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, randomuniformstatic, submessage_arena);
    }
    set_has_randomuniformstatic();
    layer_.randomuniformstatic_ = randomuniformstatic;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.randomUniformStatic)
}
void NeuralNetworkLayer::set_allocated_randomuniformdynamic(::CoreML::Specification::RandomUniformDynamicLayerParams* randomuniformdynamic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (randomuniformdynamic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::RandomUniformDynamicLayerParams>::GetOwningArena(randomuniformdynamic);
    if (message_arena != submessage_arena) {
      randomuniformdynamic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, randomuniformdynamic, submessage_arena);
    }
    set_has_randomuniformdynamic();
    layer_.randomuniformdynamic_ = randomuniformdynamic;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.randomUniformDynamic)
}
void NeuralNetworkLayer::set_allocated_randombernoullilike(::CoreML::Specification::RandomBernoulliLikeLayerParams* randombernoullilike) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (randombernoullilike) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::RandomBernoulliLikeLayerParams>::GetOwningArena(randombernoullilike);
    if (message_arena != submessage_arena) {
      randombernoullilike = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, randombernoullilike, submessage_arena);
    }
    set_has_randombernoullilike();
    layer_.randombernoullilike_ = randombernoullilike;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.randomBernoulliLike)
}
void NeuralNetworkLayer::set_allocated_randombernoullistatic(::CoreML::Specification::RandomBernoulliStaticLayerParams* randombernoullistatic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (randombernoullistatic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::RandomBernoulliStaticLayerParams>::GetOwningArena(randombernoullistatic);
    if (message_arena != submessage_arena) {
      randombernoullistatic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, randombernoullistatic, submessage_arena);
    }
    set_has_randombernoullistatic();
    layer_.randombernoullistatic_ = randombernoullistatic;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.randomBernoulliStatic)
}
void NeuralNetworkLayer::set_allocated_randombernoullidynamic(::CoreML::Specification::RandomBernoulliDynamicLayerParams* randombernoullidynamic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (randombernoullidynamic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::RandomBernoulliDynamicLayerParams>::GetOwningArena(randombernoullidynamic);
    if (message_arena != submessage_arena) {
      randombernoullidynamic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, randombernoullidynamic, submessage_arena);
    }
    set_has_randombernoullidynamic();
    layer_.randombernoullidynamic_ = randombernoullidynamic;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.randomBernoulliDynamic)
}
void NeuralNetworkLayer::set_allocated_categoricaldistribution(::CoreML::Specification::CategoricalDistributionLayerParams* categoricaldistribution) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (categoricaldistribution) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::CategoricalDistributionLayerParams>::GetOwningArena(categoricaldistribution);
    if (message_arena != submessage_arena) {
      categoricaldistribution = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, categoricaldistribution, submessage_arena);
    }
    set_has_categoricaldistribution();
    layer_.categoricaldistribution_ = categoricaldistribution;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.categoricalDistribution)
}
void NeuralNetworkLayer::set_allocated_reducel1(::CoreML::Specification::ReduceL1LayerParams* reducel1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (reducel1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ReduceL1LayerParams>::GetOwningArena(reducel1);
    if (message_arena != submessage_arena) {
      reducel1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reducel1, submessage_arena);
    }
    set_has_reducel1();
    layer_.reducel1_ = reducel1;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reduceL1)
}
void NeuralNetworkLayer::set_allocated_reducel2(::CoreML::Specification::ReduceL2LayerParams* reducel2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (reducel2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ReduceL2LayerParams>::GetOwningArena(reducel2);
    if (message_arena != submessage_arena) {
      reducel2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reducel2, submessage_arena);
    }
    set_has_reducel2();
    layer_.reducel2_ = reducel2;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reduceL2)
}
void NeuralNetworkLayer::set_allocated_reducemax(::CoreML::Specification::ReduceMaxLayerParams* reducemax) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (reducemax) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ReduceMaxLayerParams>::GetOwningArena(reducemax);
    if (message_arena != submessage_arena) {
      reducemax = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reducemax, submessage_arena);
    }
    set_has_reducemax();
    layer_.reducemax_ = reducemax;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reduceMax)
}
void NeuralNetworkLayer::set_allocated_reducemin(::CoreML::Specification::ReduceMinLayerParams* reducemin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (reducemin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ReduceMinLayerParams>::GetOwningArena(reducemin);
    if (message_arena != submessage_arena) {
      reducemin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reducemin, submessage_arena);
    }
    set_has_reducemin();
    layer_.reducemin_ = reducemin;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reduceMin)
}
void NeuralNetworkLayer::set_allocated_reducesum(::CoreML::Specification::ReduceSumLayerParams* reducesum) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (reducesum) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ReduceSumLayerParams>::GetOwningArena(reducesum);
    if (message_arena != submessage_arena) {
      reducesum = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reducesum, submessage_arena);
    }
    set_has_reducesum();
    layer_.reducesum_ = reducesum;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reduceSum)
}
void NeuralNetworkLayer::set_allocated_reduceprod(::CoreML::Specification::ReduceProdLayerParams* reduceprod) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (reduceprod) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ReduceProdLayerParams>::GetOwningArena(reduceprod);
    if (message_arena != submessage_arena) {
      reduceprod = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reduceprod, submessage_arena);
    }
    set_has_reduceprod();
    layer_.reduceprod_ = reduceprod;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reduceProd)
}
void NeuralNetworkLayer::set_allocated_reducemean(::CoreML::Specification::ReduceMeanLayerParams* reducemean) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (reducemean) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ReduceMeanLayerParams>::GetOwningArena(reducemean);
    if (message_arena != submessage_arena) {
      reducemean = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reducemean, submessage_arena);
    }
    set_has_reducemean();
    layer_.reducemean_ = reducemean;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reduceMean)
}
void NeuralNetworkLayer::set_allocated_reducelogsum(::CoreML::Specification::ReduceLogSumLayerParams* reducelogsum) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (reducelogsum) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ReduceLogSumLayerParams>::GetOwningArena(reducelogsum);
    if (message_arena != submessage_arena) {
      reducelogsum = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reducelogsum, submessage_arena);
    }
    set_has_reducelogsum();
    layer_.reducelogsum_ = reducelogsum;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reduceLogSum)
}
void NeuralNetworkLayer::set_allocated_reducesumsquare(::CoreML::Specification::ReduceSumSquareLayerParams* reducesumsquare) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (reducesumsquare) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ReduceSumSquareLayerParams>::GetOwningArena(reducesumsquare);
    if (message_arena != submessage_arena) {
      reducesumsquare = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reducesumsquare, submessage_arena);
    }
    set_has_reducesumsquare();
    layer_.reducesumsquare_ = reducesumsquare;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reduceSumSquare)
}
void NeuralNetworkLayer::set_allocated_reducelogsumexp(::CoreML::Specification::ReduceLogSumExpLayerParams* reducelogsumexp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (reducelogsumexp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ReduceLogSumExpLayerParams>::GetOwningArena(reducelogsumexp);
    if (message_arena != submessage_arena) {
      reducelogsumexp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reducelogsumexp, submessage_arena);
    }
    set_has_reducelogsumexp();
    layer_.reducelogsumexp_ = reducelogsumexp;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reduceLogSumExp)
}
void NeuralNetworkLayer::set_allocated_wherenonzero(::CoreML::Specification::WhereNonZeroLayerParams* wherenonzero) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (wherenonzero) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::WhereNonZeroLayerParams>::GetOwningArena(wherenonzero);
    if (message_arena != submessage_arena) {
      wherenonzero = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wherenonzero, submessage_arena);
    }
    set_has_wherenonzero();
    layer_.wherenonzero_ = wherenonzero;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.whereNonZero)
}
void NeuralNetworkLayer::set_allocated_matrixbandpart(::CoreML::Specification::MatrixBandPartLayerParams* matrixbandpart) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (matrixbandpart) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MatrixBandPartLayerParams>::GetOwningArena(matrixbandpart);
    if (message_arena != submessage_arena) {
      matrixbandpart = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, matrixbandpart, submessage_arena);
    }
    set_has_matrixbandpart();
    layer_.matrixbandpart_ = matrixbandpart;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.matrixBandPart)
}
void NeuralNetworkLayer::set_allocated_lowertriangular(::CoreML::Specification::LowerTriangularLayerParams* lowertriangular) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (lowertriangular) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::LowerTriangularLayerParams>::GetOwningArena(lowertriangular);
    if (message_arena != submessage_arena) {
      lowertriangular = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lowertriangular, submessage_arena);
    }
    set_has_lowertriangular();
    layer_.lowertriangular_ = lowertriangular;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.lowerTriangular)
}
void NeuralNetworkLayer::set_allocated_uppertriangular(::CoreML::Specification::UpperTriangularLayerParams* uppertriangular) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (uppertriangular) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::UpperTriangularLayerParams>::GetOwningArena(uppertriangular);
    if (message_arena != submessage_arena) {
      uppertriangular = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uppertriangular, submessage_arena);
    }
    set_has_uppertriangular();
    layer_.uppertriangular_ = uppertriangular;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.upperTriangular)
}
void NeuralNetworkLayer::set_allocated_wherebroadcastable(::CoreML::Specification::WhereBroadcastableLayerParams* wherebroadcastable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (wherebroadcastable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::WhereBroadcastableLayerParams>::GetOwningArena(wherebroadcastable);
    if (message_arena != submessage_arena) {
      wherebroadcastable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wherebroadcastable, submessage_arena);
    }
    set_has_wherebroadcastable();
    layer_.wherebroadcastable_ = wherebroadcastable;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.whereBroadcastable)
}
void NeuralNetworkLayer::set_allocated_layernormalization(::CoreML::Specification::LayerNormalizationLayerParams* layernormalization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (layernormalization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::LayerNormalizationLayerParams>::GetOwningArena(layernormalization);
    if (message_arena != submessage_arena) {
      layernormalization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, layernormalization, submessage_arena);
    }
    set_has_layernormalization();
    layer_.layernormalization_ = layernormalization;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.layerNormalization)
}
void NeuralNetworkLayer::set_allocated_nonmaximumsuppression(::CoreML::Specification::NonMaximumSuppressionLayerParams* nonmaximumsuppression) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (nonmaximumsuppression) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::NonMaximumSuppressionLayerParams>::GetOwningArena(nonmaximumsuppression);
    if (message_arena != submessage_arena) {
      nonmaximumsuppression = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nonmaximumsuppression, submessage_arena);
    }
    set_has_nonmaximumsuppression();
    layer_.nonmaximumsuppression_ = nonmaximumsuppression;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.NonMaximumSuppression)
}
void NeuralNetworkLayer::set_allocated_onehot(::CoreML::Specification::OneHotLayerParams* onehot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (onehot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::OneHotLayerParams>::GetOwningArena(onehot);
    if (message_arena != submessage_arena) {
      onehot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, onehot, submessage_arena);
    }
    set_has_onehot();
    layer_.onehot_ = onehot;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.oneHot)
}
void NeuralNetworkLayer::set_allocated_cumsum(::CoreML::Specification::CumSumLayerParams* cumsum) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (cumsum) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::CumSumLayerParams>::GetOwningArena(cumsum);
    if (message_arena != submessage_arena) {
      cumsum = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cumsum, submessage_arena);
    }
    set_has_cumsum();
    layer_.cumsum_ = cumsum;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.cumSum)
}
void NeuralNetworkLayer::set_allocated_clampedrelu(::CoreML::Specification::ClampedReLULayerParams* clampedrelu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (clampedrelu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ClampedReLULayerParams>::GetOwningArena(clampedrelu);
    if (message_arena != submessage_arena) {
      clampedrelu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clampedrelu, submessage_arena);
    }
    set_has_clampedrelu();
    layer_.clampedrelu_ = clampedrelu;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.clampedReLU)
}
void NeuralNetworkLayer::set_allocated_argsort(::CoreML::Specification::ArgSortLayerParams* argsort) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (argsort) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ArgSortLayerParams>::GetOwningArena(argsort);
    if (message_arena != submessage_arena) {
      argsort = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, argsort, submessage_arena);
    }
    set_has_argsort();
    layer_.argsort_ = argsort;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.argSort)
}
void NeuralNetworkLayer::set_allocated_pooling3d(::CoreML::Specification::Pooling3DLayerParams* pooling3d) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (pooling3d) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::Pooling3DLayerParams>::GetOwningArena(pooling3d);
    if (message_arena != submessage_arena) {
      pooling3d = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pooling3d, submessage_arena);
    }
    set_has_pooling3d();
    layer_.pooling3d_ = pooling3d;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.pooling3d)
}
void NeuralNetworkLayer::set_allocated_globalpooling3d(::CoreML::Specification::GlobalPooling3DLayerParams* globalpooling3d) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (globalpooling3d) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::GlobalPooling3DLayerParams>::GetOwningArena(globalpooling3d);
    if (message_arena != submessage_arena) {
      globalpooling3d = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, globalpooling3d, submessage_arena);
    }
    set_has_globalpooling3d();
    layer_.globalpooling3d_ = globalpooling3d;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.globalPooling3d)
}
void NeuralNetworkLayer::set_allocated_slicebysize(::CoreML::Specification::SliceBySizeLayerParams* slicebysize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (slicebysize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SliceBySizeLayerParams>::GetOwningArena(slicebysize);
    if (message_arena != submessage_arena) {
      slicebysize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, slicebysize, submessage_arena);
    }
    set_has_slicebysize();
    layer_.slicebysize_ = slicebysize;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.sliceBySize)
}
void NeuralNetworkLayer::set_allocated_convolution3d(::CoreML::Specification::Convolution3DLayerParams* convolution3d) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_layer();
  if (convolution3d) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::Convolution3DLayerParams>::GetOwningArena(convolution3d);
    if (message_arena != submessage_arena) {
      convolution3d = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, convolution3d, submessage_arena);
    }
    set_has_convolution3d();
    layer_.convolution3d_ = convolution3d;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.convolution3d)
}
NeuralNetworkLayer::NeuralNetworkLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  input_(arena),
  output_(arena),
  inputtensor_(arena),
  outputtensor_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.NeuralNetworkLayer)
}
NeuralNetworkLayer::NeuralNetworkLayer(const NeuralNetworkLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      input_(from.input_),
      output_(from.output_),
      inputtensor_(from.inputtensor_),
      outputtensor_(from.outputtensor_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  isupdatable_ = from.isupdatable_;
  clear_has_layer();
  switch (from.layer_case()) {
    case kConvolution: {
      _internal_mutable_convolution()->::CoreML::Specification::ConvolutionLayerParams::MergeFrom(from._internal_convolution());
      break;
    }
    case kPooling: {
      _internal_mutable_pooling()->::CoreML::Specification::PoolingLayerParams::MergeFrom(from._internal_pooling());
      break;
    }
    case kActivation: {
      _internal_mutable_activation()->::CoreML::Specification::ActivationParams::MergeFrom(from._internal_activation());
      break;
    }
    case kInnerProduct: {
      _internal_mutable_innerproduct()->::CoreML::Specification::InnerProductLayerParams::MergeFrom(from._internal_innerproduct());
      break;
    }
    case kEmbedding: {
      _internal_mutable_embedding()->::CoreML::Specification::EmbeddingLayerParams::MergeFrom(from._internal_embedding());
      break;
    }
    case kBatchnorm: {
      _internal_mutable_batchnorm()->::CoreML::Specification::BatchnormLayerParams::MergeFrom(from._internal_batchnorm());
      break;
    }
    case kMvn: {
      _internal_mutable_mvn()->::CoreML::Specification::MeanVarianceNormalizeLayerParams::MergeFrom(from._internal_mvn());
      break;
    }
    case kL2Normalize: {
      _internal_mutable_l2normalize()->::CoreML::Specification::L2NormalizeLayerParams::MergeFrom(from._internal_l2normalize());
      break;
    }
    case kSoftmax: {
      _internal_mutable_softmax()->::CoreML::Specification::SoftmaxLayerParams::MergeFrom(from._internal_softmax());
      break;
    }
    case kLrn: {
      _internal_mutable_lrn()->::CoreML::Specification::LRNLayerParams::MergeFrom(from._internal_lrn());
      break;
    }
    case kCrop: {
      _internal_mutable_crop()->::CoreML::Specification::CropLayerParams::MergeFrom(from._internal_crop());
      break;
    }
    case kPadding: {
      _internal_mutable_padding()->::CoreML::Specification::PaddingLayerParams::MergeFrom(from._internal_padding());
      break;
    }
    case kUpsample: {
      _internal_mutable_upsample()->::CoreML::Specification::UpsampleLayerParams::MergeFrom(from._internal_upsample());
      break;
    }
    case kResizeBilinear: {
      _internal_mutable_resizebilinear()->::CoreML::Specification::ResizeBilinearLayerParams::MergeFrom(from._internal_resizebilinear());
      break;
    }
    case kCropResize: {
      _internal_mutable_cropresize()->::CoreML::Specification::CropResizeLayerParams::MergeFrom(from._internal_cropresize());
      break;
    }
    case kUnary: {
      _internal_mutable_unary()->::CoreML::Specification::UnaryFunctionLayerParams::MergeFrom(from._internal_unary());
      break;
    }
    case kAdd: {
      _internal_mutable_add()->::CoreML::Specification::AddLayerParams::MergeFrom(from._internal_add());
      break;
    }
    case kMultiply: {
      _internal_mutable_multiply()->::CoreML::Specification::MultiplyLayerParams::MergeFrom(from._internal_multiply());
      break;
    }
    case kAverage: {
      _internal_mutable_average()->::CoreML::Specification::AverageLayerParams::MergeFrom(from._internal_average());
      break;
    }
    case kScale: {
      _internal_mutable_scale()->::CoreML::Specification::ScaleLayerParams::MergeFrom(from._internal_scale());
      break;
    }
    case kBias: {
      _internal_mutable_bias()->::CoreML::Specification::BiasLayerParams::MergeFrom(from._internal_bias());
      break;
    }
    case kMax: {
      _internal_mutable_max()->::CoreML::Specification::MaxLayerParams::MergeFrom(from._internal_max());
      break;
    }
    case kMin: {
      _internal_mutable_min()->::CoreML::Specification::MinLayerParams::MergeFrom(from._internal_min());
      break;
    }
    case kDot: {
      _internal_mutable_dot()->::CoreML::Specification::DotProductLayerParams::MergeFrom(from._internal_dot());
      break;
    }
    case kReduce: {
      _internal_mutable_reduce()->::CoreML::Specification::ReduceLayerParams::MergeFrom(from._internal_reduce());
      break;
    }
    case kLoadConstant: {
      _internal_mutable_loadconstant()->::CoreML::Specification::LoadConstantLayerParams::MergeFrom(from._internal_loadconstant());
      break;
    }
    case kReshape: {
      _internal_mutable_reshape()->::CoreML::Specification::ReshapeLayerParams::MergeFrom(from._internal_reshape());
      break;
    }
    case kFlatten: {
      _internal_mutable_flatten()->::CoreML::Specification::FlattenLayerParams::MergeFrom(from._internal_flatten());
      break;
    }
    case kPermute: {
      _internal_mutable_permute()->::CoreML::Specification::PermuteLayerParams::MergeFrom(from._internal_permute());
      break;
    }
    case kConcat: {
      _internal_mutable_concat()->::CoreML::Specification::ConcatLayerParams::MergeFrom(from._internal_concat());
      break;
    }
    case kSplit: {
      _internal_mutable_split()->::CoreML::Specification::SplitLayerParams::MergeFrom(from._internal_split());
      break;
    }
    case kSequenceRepeat: {
      _internal_mutable_sequencerepeat()->::CoreML::Specification::SequenceRepeatLayerParams::MergeFrom(from._internal_sequencerepeat());
      break;
    }
    case kReorganizeData: {
      _internal_mutable_reorganizedata()->::CoreML::Specification::ReorganizeDataLayerParams::MergeFrom(from._internal_reorganizedata());
      break;
    }
    case kSlice: {
      _internal_mutable_slice()->::CoreML::Specification::SliceLayerParams::MergeFrom(from._internal_slice());
      break;
    }
    case kSimpleRecurrent: {
      _internal_mutable_simplerecurrent()->::CoreML::Specification::SimpleRecurrentLayerParams::MergeFrom(from._internal_simplerecurrent());
      break;
    }
    case kGru: {
      _internal_mutable_gru()->::CoreML::Specification::GRULayerParams::MergeFrom(from._internal_gru());
      break;
    }
    case kUniDirectionalLSTM: {
      _internal_mutable_unidirectionallstm()->::CoreML::Specification::UniDirectionalLSTMLayerParams::MergeFrom(from._internal_unidirectionallstm());
      break;
    }
    case kBiDirectionalLSTM: {
      _internal_mutable_bidirectionallstm()->::CoreML::Specification::BiDirectionalLSTMLayerParams::MergeFrom(from._internal_bidirectionallstm());
      break;
    }
    case kCustom: {
      _internal_mutable_custom()->::CoreML::Specification::CustomLayerParams::MergeFrom(from._internal_custom());
      break;
    }
    case kCopy: {
      _internal_mutable_copy()->::CoreML::Specification::CopyLayerParams::MergeFrom(from._internal_copy());
      break;
    }
    case kBranch: {
      _internal_mutable_branch()->::CoreML::Specification::BranchLayerParams::MergeFrom(from._internal_branch());
      break;
    }
    case kLoop: {
      _internal_mutable_loop()->::CoreML::Specification::LoopLayerParams::MergeFrom(from._internal_loop());
      break;
    }
    case kLoopBreak: {
      _internal_mutable_loopbreak()->::CoreML::Specification::LoopBreakLayerParams::MergeFrom(from._internal_loopbreak());
      break;
    }
    case kLoopContinue: {
      _internal_mutable_loopcontinue()->::CoreML::Specification::LoopContinueLayerParams::MergeFrom(from._internal_loopcontinue());
      break;
    }
    case kRangeStatic: {
      _internal_mutable_rangestatic()->::CoreML::Specification::RangeStaticLayerParams::MergeFrom(from._internal_rangestatic());
      break;
    }
    case kRangeDynamic: {
      _internal_mutable_rangedynamic()->::CoreML::Specification::RangeDynamicLayerParams::MergeFrom(from._internal_rangedynamic());
      break;
    }
    case kClip: {
      _internal_mutable_clip()->::CoreML::Specification::ClipLayerParams::MergeFrom(from._internal_clip());
      break;
    }
    case kCeil: {
      _internal_mutable_ceil()->::CoreML::Specification::CeilLayerParams::MergeFrom(from._internal_ceil());
      break;
    }
    case kFloor: {
      _internal_mutable_floor()->::CoreML::Specification::FloorLayerParams::MergeFrom(from._internal_floor());
      break;
    }
    case kSign: {
      _internal_mutable_sign()->::CoreML::Specification::SignLayerParams::MergeFrom(from._internal_sign());
      break;
    }
    case kRound: {
      _internal_mutable_round()->::CoreML::Specification::RoundLayerParams::MergeFrom(from._internal_round());
      break;
    }
    case kExp2: {
      _internal_mutable_exp2()->::CoreML::Specification::Exp2LayerParams::MergeFrom(from._internal_exp2());
      break;
    }
    case kSin: {
      _internal_mutable_sin()->::CoreML::Specification::SinLayerParams::MergeFrom(from._internal_sin());
      break;
    }
    case kCos: {
      _internal_mutable_cos()->::CoreML::Specification::CosLayerParams::MergeFrom(from._internal_cos());
      break;
    }
    case kTan: {
      _internal_mutable_tan()->::CoreML::Specification::TanLayerParams::MergeFrom(from._internal_tan());
      break;
    }
    case kAsin: {
      _internal_mutable_asin()->::CoreML::Specification::AsinLayerParams::MergeFrom(from._internal_asin());
      break;
    }
    case kAcos: {
      _internal_mutable_acos()->::CoreML::Specification::AcosLayerParams::MergeFrom(from._internal_acos());
      break;
    }
    case kAtan: {
      _internal_mutable_atan()->::CoreML::Specification::AtanLayerParams::MergeFrom(from._internal_atan());
      break;
    }
    case kSinh: {
      _internal_mutable_sinh()->::CoreML::Specification::SinhLayerParams::MergeFrom(from._internal_sinh());
      break;
    }
    case kCosh: {
      _internal_mutable_cosh()->::CoreML::Specification::CoshLayerParams::MergeFrom(from._internal_cosh());
      break;
    }
    case kTanh: {
      _internal_mutable_tanh()->::CoreML::Specification::TanhLayerParams::MergeFrom(from._internal_tanh());
      break;
    }
    case kAsinh: {
      _internal_mutable_asinh()->::CoreML::Specification::AsinhLayerParams::MergeFrom(from._internal_asinh());
      break;
    }
    case kAcosh: {
      _internal_mutable_acosh()->::CoreML::Specification::AcoshLayerParams::MergeFrom(from._internal_acosh());
      break;
    }
    case kAtanh: {
      _internal_mutable_atanh()->::CoreML::Specification::AtanhLayerParams::MergeFrom(from._internal_atanh());
      break;
    }
    case kErf: {
      _internal_mutable_erf()->::CoreML::Specification::ErfLayerParams::MergeFrom(from._internal_erf());
      break;
    }
    case kGelu: {
      _internal_mutable_gelu()->::CoreML::Specification::GeluLayerParams::MergeFrom(from._internal_gelu());
      break;
    }
    case kEqual: {
      _internal_mutable_equal()->::CoreML::Specification::EqualLayerParams::MergeFrom(from._internal_equal());
      break;
    }
    case kNotEqual: {
      _internal_mutable_notequal()->::CoreML::Specification::NotEqualLayerParams::MergeFrom(from._internal_notequal());
      break;
    }
    case kLessThan: {
      _internal_mutable_lessthan()->::CoreML::Specification::LessThanLayerParams::MergeFrom(from._internal_lessthan());
      break;
    }
    case kLessEqual: {
      _internal_mutable_lessequal()->::CoreML::Specification::LessEqualLayerParams::MergeFrom(from._internal_lessequal());
      break;
    }
    case kGreaterThan: {
      _internal_mutable_greaterthan()->::CoreML::Specification::GreaterThanLayerParams::MergeFrom(from._internal_greaterthan());
      break;
    }
    case kGreaterEqual: {
      _internal_mutable_greaterequal()->::CoreML::Specification::GreaterEqualLayerParams::MergeFrom(from._internal_greaterequal());
      break;
    }
    case kLogicalOr: {
      _internal_mutable_logicalor()->::CoreML::Specification::LogicalOrLayerParams::MergeFrom(from._internal_logicalor());
      break;
    }
    case kLogicalXor: {
      _internal_mutable_logicalxor()->::CoreML::Specification::LogicalXorLayerParams::MergeFrom(from._internal_logicalxor());
      break;
    }
    case kLogicalNot: {
      _internal_mutable_logicalnot()->::CoreML::Specification::LogicalNotLayerParams::MergeFrom(from._internal_logicalnot());
      break;
    }
    case kLogicalAnd: {
      _internal_mutable_logicaland()->::CoreML::Specification::LogicalAndLayerParams::MergeFrom(from._internal_logicaland());
      break;
    }
    case kModBroadcastable: {
      _internal_mutable_modbroadcastable()->::CoreML::Specification::ModBroadcastableLayerParams::MergeFrom(from._internal_modbroadcastable());
      break;
    }
    case kMinBroadcastable: {
      _internal_mutable_minbroadcastable()->::CoreML::Specification::MinBroadcastableLayerParams::MergeFrom(from._internal_minbroadcastable());
      break;
    }
    case kMaxBroadcastable: {
      _internal_mutable_maxbroadcastable()->::CoreML::Specification::MaxBroadcastableLayerParams::MergeFrom(from._internal_maxbroadcastable());
      break;
    }
    case kAddBroadcastable: {
      _internal_mutable_addbroadcastable()->::CoreML::Specification::AddBroadcastableLayerParams::MergeFrom(from._internal_addbroadcastable());
      break;
    }
    case kPowBroadcastable: {
      _internal_mutable_powbroadcastable()->::CoreML::Specification::PowBroadcastableLayerParams::MergeFrom(from._internal_powbroadcastable());
      break;
    }
    case kDivideBroadcastable: {
      _internal_mutable_dividebroadcastable()->::CoreML::Specification::DivideBroadcastableLayerParams::MergeFrom(from._internal_dividebroadcastable());
      break;
    }
    case kFloorDivBroadcastable: {
      _internal_mutable_floordivbroadcastable()->::CoreML::Specification::FloorDivBroadcastableLayerParams::MergeFrom(from._internal_floordivbroadcastable());
      break;
    }
    case kMultiplyBroadcastable: {
      _internal_mutable_multiplybroadcastable()->::CoreML::Specification::MultiplyBroadcastableLayerParams::MergeFrom(from._internal_multiplybroadcastable());
      break;
    }
    case kSubtractBroadcastable: {
      _internal_mutable_subtractbroadcastable()->::CoreML::Specification::SubtractBroadcastableLayerParams::MergeFrom(from._internal_subtractbroadcastable());
      break;
    }
    case kTile: {
      _internal_mutable_tile()->::CoreML::Specification::TileLayerParams::MergeFrom(from._internal_tile());
      break;
    }
    case kStack: {
      _internal_mutable_stack()->::CoreML::Specification::StackLayerParams::MergeFrom(from._internal_stack());
      break;
    }
    case kGather: {
      _internal_mutable_gather()->::CoreML::Specification::GatherLayerParams::MergeFrom(from._internal_gather());
      break;
    }
    case kScatter: {
      _internal_mutable_scatter()->::CoreML::Specification::ScatterLayerParams::MergeFrom(from._internal_scatter());
      break;
    }
    case kGatherND: {
      _internal_mutable_gathernd()->::CoreML::Specification::GatherNDLayerParams::MergeFrom(from._internal_gathernd());
      break;
    }
    case kScatterND: {
      _internal_mutable_scatternd()->::CoreML::Specification::ScatterNDLayerParams::MergeFrom(from._internal_scatternd());
      break;
    }
    case kSoftmaxND: {
      _internal_mutable_softmaxnd()->::CoreML::Specification::SoftmaxNDLayerParams::MergeFrom(from._internal_softmaxnd());
      break;
    }
    case kGatherAlongAxis: {
      _internal_mutable_gatheralongaxis()->::CoreML::Specification::GatherAlongAxisLayerParams::MergeFrom(from._internal_gatheralongaxis());
      break;
    }
    case kScatterAlongAxis: {
      _internal_mutable_scatteralongaxis()->::CoreML::Specification::ScatterAlongAxisLayerParams::MergeFrom(from._internal_scatteralongaxis());
      break;
    }
    case kReverse: {
      _internal_mutable_reverse()->::CoreML::Specification::ReverseLayerParams::MergeFrom(from._internal_reverse());
      break;
    }
    case kReverseSeq: {
      _internal_mutable_reverseseq()->::CoreML::Specification::ReverseSeqLayerParams::MergeFrom(from._internal_reverseseq());
      break;
    }
    case kSplitND: {
      _internal_mutable_splitnd()->::CoreML::Specification::SplitNDLayerParams::MergeFrom(from._internal_splitnd());
      break;
    }
    case kConcatND: {
      _internal_mutable_concatnd()->::CoreML::Specification::ConcatNDLayerParams::MergeFrom(from._internal_concatnd());
      break;
    }
    case kTranspose: {
      _internal_mutable_transpose()->::CoreML::Specification::TransposeLayerParams::MergeFrom(from._internal_transpose());
      break;
    }
    case kSliceStatic: {
      _internal_mutable_slicestatic()->::CoreML::Specification::SliceStaticLayerParams::MergeFrom(from._internal_slicestatic());
      break;
    }
    case kSliceDynamic: {
      _internal_mutable_slicedynamic()->::CoreML::Specification::SliceDynamicLayerParams::MergeFrom(from._internal_slicedynamic());
      break;
    }
    case kSlidingWindows: {
      _internal_mutable_slidingwindows()->::CoreML::Specification::SlidingWindowsLayerParams::MergeFrom(from._internal_slidingwindows());
      break;
    }
    case kTopK: {
      _internal_mutable_topk()->::CoreML::Specification::TopKLayerParams::MergeFrom(from._internal_topk());
      break;
    }
    case kArgMin: {
      _internal_mutable_argmin()->::CoreML::Specification::ArgMinLayerParams::MergeFrom(from._internal_argmin());
      break;
    }
    case kArgMax: {
      _internal_mutable_argmax()->::CoreML::Specification::ArgMaxLayerParams::MergeFrom(from._internal_argmax());
      break;
    }
    case kEmbeddingND: {
      _internal_mutable_embeddingnd()->::CoreML::Specification::EmbeddingNDLayerParams::MergeFrom(from._internal_embeddingnd());
      break;
    }
    case kBatchedMatmul: {
      _internal_mutable_batchedmatmul()->::CoreML::Specification::BatchedMatMulLayerParams::MergeFrom(from._internal_batchedmatmul());
      break;
    }
    case kGetShape: {
      _internal_mutable_getshape()->::CoreML::Specification::GetShapeLayerParams::MergeFrom(from._internal_getshape());
      break;
    }
    case kLoadConstantND: {
      _internal_mutable_loadconstantnd()->::CoreML::Specification::LoadConstantNDLayerParams::MergeFrom(from._internal_loadconstantnd());
      break;
    }
    case kFillLike: {
      _internal_mutable_filllike()->::CoreML::Specification::FillLikeLayerParams::MergeFrom(from._internal_filllike());
      break;
    }
    case kFillStatic: {
      _internal_mutable_fillstatic()->::CoreML::Specification::FillStaticLayerParams::MergeFrom(from._internal_fillstatic());
      break;
    }
    case kFillDynamic: {
      _internal_mutable_filldynamic()->::CoreML::Specification::FillDynamicLayerParams::MergeFrom(from._internal_filldynamic());
      break;
    }
    case kBroadcastToLike: {
      _internal_mutable_broadcasttolike()->::CoreML::Specification::BroadcastToLikeLayerParams::MergeFrom(from._internal_broadcasttolike());
      break;
    }
    case kBroadcastToStatic: {
      _internal_mutable_broadcasttostatic()->::CoreML::Specification::BroadcastToStaticLayerParams::MergeFrom(from._internal_broadcasttostatic());
      break;
    }
    case kBroadcastToDynamic: {
      _internal_mutable_broadcasttodynamic()->::CoreML::Specification::BroadcastToDynamicLayerParams::MergeFrom(from._internal_broadcasttodynamic());
      break;
    }
    case kSqueeze: {
      _internal_mutable_squeeze()->::CoreML::Specification::SqueezeLayerParams::MergeFrom(from._internal_squeeze());
      break;
    }
    case kExpandDims: {
      _internal_mutable_expanddims()->::CoreML::Specification::ExpandDimsLayerParams::MergeFrom(from._internal_expanddims());
      break;
    }
    case kFlattenTo2D: {
      _internal_mutable_flattento2d()->::CoreML::Specification::FlattenTo2DLayerParams::MergeFrom(from._internal_flattento2d());
      break;
    }
    case kReshapeLike: {
      _internal_mutable_reshapelike()->::CoreML::Specification::ReshapeLikeLayerParams::MergeFrom(from._internal_reshapelike());
      break;
    }
    case kReshapeStatic: {
      _internal_mutable_reshapestatic()->::CoreML::Specification::ReshapeStaticLayerParams::MergeFrom(from._internal_reshapestatic());
      break;
    }
    case kReshapeDynamic: {
      _internal_mutable_reshapedynamic()->::CoreML::Specification::ReshapeDynamicLayerParams::MergeFrom(from._internal_reshapedynamic());
      break;
    }
    case kRankPreservingReshape: {
      _internal_mutable_rankpreservingreshape()->::CoreML::Specification::RankPreservingReshapeLayerParams::MergeFrom(from._internal_rankpreservingreshape());
      break;
    }
    case kConstantPad: {
      _internal_mutable_constantpad()->::CoreML::Specification::ConstantPaddingLayerParams::MergeFrom(from._internal_constantpad());
      break;
    }
    case kRandomNormalLike: {
      _internal_mutable_randomnormallike()->::CoreML::Specification::RandomNormalLikeLayerParams::MergeFrom(from._internal_randomnormallike());
      break;
    }
    case kRandomNormalStatic: {
      _internal_mutable_randomnormalstatic()->::CoreML::Specification::RandomNormalStaticLayerParams::MergeFrom(from._internal_randomnormalstatic());
      break;
    }
    case kRandomNormalDynamic: {
      _internal_mutable_randomnormaldynamic()->::CoreML::Specification::RandomNormalDynamicLayerParams::MergeFrom(from._internal_randomnormaldynamic());
      break;
    }
    case kRandomUniformLike: {
      _internal_mutable_randomuniformlike()->::CoreML::Specification::RandomUniformLikeLayerParams::MergeFrom(from._internal_randomuniformlike());
      break;
    }
    case kRandomUniformStatic: {
      _internal_mutable_randomuniformstatic()->::CoreML::Specification::RandomUniformStaticLayerParams::MergeFrom(from._internal_randomuniformstatic());
      break;
    }
    case kRandomUniformDynamic: {
      _internal_mutable_randomuniformdynamic()->::CoreML::Specification::RandomUniformDynamicLayerParams::MergeFrom(from._internal_randomuniformdynamic());
      break;
    }
    case kRandomBernoulliLike: {
      _internal_mutable_randombernoullilike()->::CoreML::Specification::RandomBernoulliLikeLayerParams::MergeFrom(from._internal_randombernoullilike());
      break;
    }
    case kRandomBernoulliStatic: {
      _internal_mutable_randombernoullistatic()->::CoreML::Specification::RandomBernoulliStaticLayerParams::MergeFrom(from._internal_randombernoullistatic());
      break;
    }
    case kRandomBernoulliDynamic: {
      _internal_mutable_randombernoullidynamic()->::CoreML::Specification::RandomBernoulliDynamicLayerParams::MergeFrom(from._internal_randombernoullidynamic());
      break;
    }
    case kCategoricalDistribution: {
      _internal_mutable_categoricaldistribution()->::CoreML::Specification::CategoricalDistributionLayerParams::MergeFrom(from._internal_categoricaldistribution());
      break;
    }
    case kReduceL1: {
      _internal_mutable_reducel1()->::CoreML::Specification::ReduceL1LayerParams::MergeFrom(from._internal_reducel1());
      break;
    }
    case kReduceL2: {
      _internal_mutable_reducel2()->::CoreML::Specification::ReduceL2LayerParams::MergeFrom(from._internal_reducel2());
      break;
    }
    case kReduceMax: {
      _internal_mutable_reducemax()->::CoreML::Specification::ReduceMaxLayerParams::MergeFrom(from._internal_reducemax());
      break;
    }
    case kReduceMin: {
      _internal_mutable_reducemin()->::CoreML::Specification::ReduceMinLayerParams::MergeFrom(from._internal_reducemin());
      break;
    }
    case kReduceSum: {
      _internal_mutable_reducesum()->::CoreML::Specification::ReduceSumLayerParams::MergeFrom(from._internal_reducesum());
      break;
    }
    case kReduceProd: {
      _internal_mutable_reduceprod()->::CoreML::Specification::ReduceProdLayerParams::MergeFrom(from._internal_reduceprod());
      break;
    }
    case kReduceMean: {
      _internal_mutable_reducemean()->::CoreML::Specification::ReduceMeanLayerParams::MergeFrom(from._internal_reducemean());
      break;
    }
    case kReduceLogSum: {
      _internal_mutable_reducelogsum()->::CoreML::Specification::ReduceLogSumLayerParams::MergeFrom(from._internal_reducelogsum());
      break;
    }
    case kReduceSumSquare: {
      _internal_mutable_reducesumsquare()->::CoreML::Specification::ReduceSumSquareLayerParams::MergeFrom(from._internal_reducesumsquare());
      break;
    }
    case kReduceLogSumExp: {
      _internal_mutable_reducelogsumexp()->::CoreML::Specification::ReduceLogSumExpLayerParams::MergeFrom(from._internal_reducelogsumexp());
      break;
    }
    case kWhereNonZero: {
      _internal_mutable_wherenonzero()->::CoreML::Specification::WhereNonZeroLayerParams::MergeFrom(from._internal_wherenonzero());
      break;
    }
    case kMatrixBandPart: {
      _internal_mutable_matrixbandpart()->::CoreML::Specification::MatrixBandPartLayerParams::MergeFrom(from._internal_matrixbandpart());
      break;
    }
    case kLowerTriangular: {
      _internal_mutable_lowertriangular()->::CoreML::Specification::LowerTriangularLayerParams::MergeFrom(from._internal_lowertriangular());
      break;
    }
    case kUpperTriangular: {
      _internal_mutable_uppertriangular()->::CoreML::Specification::UpperTriangularLayerParams::MergeFrom(from._internal_uppertriangular());
      break;
    }
    case kWhereBroadcastable: {
      _internal_mutable_wherebroadcastable()->::CoreML::Specification::WhereBroadcastableLayerParams::MergeFrom(from._internal_wherebroadcastable());
      break;
    }
    case kLayerNormalization: {
      _internal_mutable_layernormalization()->::CoreML::Specification::LayerNormalizationLayerParams::MergeFrom(from._internal_layernormalization());
      break;
    }
    case kNonMaximumSuppression: {
      _internal_mutable_nonmaximumsuppression()->::CoreML::Specification::NonMaximumSuppressionLayerParams::MergeFrom(from._internal_nonmaximumsuppression());
      break;
    }
    case kOneHot: {
      _internal_mutable_onehot()->::CoreML::Specification::OneHotLayerParams::MergeFrom(from._internal_onehot());
      break;
    }
    case kCumSum: {
      _internal_mutable_cumsum()->::CoreML::Specification::CumSumLayerParams::MergeFrom(from._internal_cumsum());
      break;
    }
    case kClampedReLU: {
      _internal_mutable_clampedrelu()->::CoreML::Specification::ClampedReLULayerParams::MergeFrom(from._internal_clampedrelu());
      break;
    }
    case kArgSort: {
      _internal_mutable_argsort()->::CoreML::Specification::ArgSortLayerParams::MergeFrom(from._internal_argsort());
      break;
    }
    case kPooling3D: {
      _internal_mutable_pooling3d()->::CoreML::Specification::Pooling3DLayerParams::MergeFrom(from._internal_pooling3d());
      break;
    }
    case kGlobalPooling3D: {
      _internal_mutable_globalpooling3d()->::CoreML::Specification::GlobalPooling3DLayerParams::MergeFrom(from._internal_globalpooling3d());
      break;
    }
    case kSliceBySize: {
      _internal_mutable_slicebysize()->::CoreML::Specification::SliceBySizeLayerParams::MergeFrom(from._internal_slicebysize());
      break;
    }
    case kConvolution3D: {
      _internal_mutable_convolution3d()->::CoreML::Specification::Convolution3DLayerParams::MergeFrom(from._internal_convolution3d());
      break;
    }
    case LAYER_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.NeuralNetworkLayer)
}

inline void NeuralNetworkLayer::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
isupdatable_ = false;
clear_has_layer();
}

NeuralNetworkLayer::~NeuralNetworkLayer() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.NeuralNetworkLayer)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void NeuralNetworkLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (has_layer()) {
    clear_layer();
  }
}

void NeuralNetworkLayer::ArenaDtor(void* object) {
  NeuralNetworkLayer* _this = reinterpret_cast< NeuralNetworkLayer* >(object);
  (void)_this;
}
void NeuralNetworkLayer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NeuralNetworkLayer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NeuralNetworkLayer::clear_layer() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.NeuralNetworkLayer)
  switch (layer_case()) {
    case kConvolution: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.convolution_;
      }
      break;
    }
    case kPooling: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.pooling_;
      }
      break;
    }
    case kActivation: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.activation_;
      }
      break;
    }
    case kInnerProduct: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.innerproduct_;
      }
      break;
    }
    case kEmbedding: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.embedding_;
      }
      break;
    }
    case kBatchnorm: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.batchnorm_;
      }
      break;
    }
    case kMvn: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.mvn_;
      }
      break;
    }
    case kL2Normalize: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.l2normalize_;
      }
      break;
    }
    case kSoftmax: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.softmax_;
      }
      break;
    }
    case kLrn: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.lrn_;
      }
      break;
    }
    case kCrop: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.crop_;
      }
      break;
    }
    case kPadding: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.padding_;
      }
      break;
    }
    case kUpsample: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.upsample_;
      }
      break;
    }
    case kResizeBilinear: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.resizebilinear_;
      }
      break;
    }
    case kCropResize: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.cropresize_;
      }
      break;
    }
    case kUnary: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.unary_;
      }
      break;
    }
    case kAdd: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.add_;
      }
      break;
    }
    case kMultiply: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.multiply_;
      }
      break;
    }
    case kAverage: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.average_;
      }
      break;
    }
    case kScale: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.scale_;
      }
      break;
    }
    case kBias: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.bias_;
      }
      break;
    }
    case kMax: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.max_;
      }
      break;
    }
    case kMin: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.min_;
      }
      break;
    }
    case kDot: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.dot_;
      }
      break;
    }
    case kReduce: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.reduce_;
      }
      break;
    }
    case kLoadConstant: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.loadconstant_;
      }
      break;
    }
    case kReshape: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.reshape_;
      }
      break;
    }
    case kFlatten: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.flatten_;
      }
      break;
    }
    case kPermute: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.permute_;
      }
      break;
    }
    case kConcat: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.concat_;
      }
      break;
    }
    case kSplit: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.split_;
      }
      break;
    }
    case kSequenceRepeat: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.sequencerepeat_;
      }
      break;
    }
    case kReorganizeData: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.reorganizedata_;
      }
      break;
    }
    case kSlice: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.slice_;
      }
      break;
    }
    case kSimpleRecurrent: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.simplerecurrent_;
      }
      break;
    }
    case kGru: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.gru_;
      }
      break;
    }
    case kUniDirectionalLSTM: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.unidirectionallstm_;
      }
      break;
    }
    case kBiDirectionalLSTM: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.bidirectionallstm_;
      }
      break;
    }
    case kCustom: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.custom_;
      }
      break;
    }
    case kCopy: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.copy_;
      }
      break;
    }
    case kBranch: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.branch_;
      }
      break;
    }
    case kLoop: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.loop_;
      }
      break;
    }
    case kLoopBreak: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.loopbreak_;
      }
      break;
    }
    case kLoopContinue: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.loopcontinue_;
      }
      break;
    }
    case kRangeStatic: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.rangestatic_;
      }
      break;
    }
    case kRangeDynamic: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.rangedynamic_;
      }
      break;
    }
    case kClip: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.clip_;
      }
      break;
    }
    case kCeil: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.ceil_;
      }
      break;
    }
    case kFloor: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.floor_;
      }
      break;
    }
    case kSign: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.sign_;
      }
      break;
    }
    case kRound: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.round_;
      }
      break;
    }
    case kExp2: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.exp2_;
      }
      break;
    }
    case kSin: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.sin_;
      }
      break;
    }
    case kCos: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.cos_;
      }
      break;
    }
    case kTan: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.tan_;
      }
      break;
    }
    case kAsin: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.asin_;
      }
      break;
    }
    case kAcos: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.acos_;
      }
      break;
    }
    case kAtan: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.atan_;
      }
      break;
    }
    case kSinh: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.sinh_;
      }
      break;
    }
    case kCosh: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.cosh_;
      }
      break;
    }
    case kTanh: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.tanh_;
      }
      break;
    }
    case kAsinh: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.asinh_;
      }
      break;
    }
    case kAcosh: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.acosh_;
      }
      break;
    }
    case kAtanh: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.atanh_;
      }
      break;
    }
    case kErf: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.erf_;
      }
      break;
    }
    case kGelu: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.gelu_;
      }
      break;
    }
    case kEqual: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.equal_;
      }
      break;
    }
    case kNotEqual: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.notequal_;
      }
      break;
    }
    case kLessThan: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.lessthan_;
      }
      break;
    }
    case kLessEqual: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.lessequal_;
      }
      break;
    }
    case kGreaterThan: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.greaterthan_;
      }
      break;
    }
    case kGreaterEqual: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.greaterequal_;
      }
      break;
    }
    case kLogicalOr: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.logicalor_;
      }
      break;
    }
    case kLogicalXor: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.logicalxor_;
      }
      break;
    }
    case kLogicalNot: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.logicalnot_;
      }
      break;
    }
    case kLogicalAnd: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.logicaland_;
      }
      break;
    }
    case kModBroadcastable: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.modbroadcastable_;
      }
      break;
    }
    case kMinBroadcastable: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.minbroadcastable_;
      }
      break;
    }
    case kMaxBroadcastable: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.maxbroadcastable_;
      }
      break;
    }
    case kAddBroadcastable: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.addbroadcastable_;
      }
      break;
    }
    case kPowBroadcastable: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.powbroadcastable_;
      }
      break;
    }
    case kDivideBroadcastable: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.dividebroadcastable_;
      }
      break;
    }
    case kFloorDivBroadcastable: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.floordivbroadcastable_;
      }
      break;
    }
    case kMultiplyBroadcastable: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.multiplybroadcastable_;
      }
      break;
    }
    case kSubtractBroadcastable: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.subtractbroadcastable_;
      }
      break;
    }
    case kTile: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.tile_;
      }
      break;
    }
    case kStack: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.stack_;
      }
      break;
    }
    case kGather: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.gather_;
      }
      break;
    }
    case kScatter: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.scatter_;
      }
      break;
    }
    case kGatherND: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.gathernd_;
      }
      break;
    }
    case kScatterND: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.scatternd_;
      }
      break;
    }
    case kSoftmaxND: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.softmaxnd_;
      }
      break;
    }
    case kGatherAlongAxis: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.gatheralongaxis_;
      }
      break;
    }
    case kScatterAlongAxis: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.scatteralongaxis_;
      }
      break;
    }
    case kReverse: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.reverse_;
      }
      break;
    }
    case kReverseSeq: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.reverseseq_;
      }
      break;
    }
    case kSplitND: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.splitnd_;
      }
      break;
    }
    case kConcatND: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.concatnd_;
      }
      break;
    }
    case kTranspose: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.transpose_;
      }
      break;
    }
    case kSliceStatic: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.slicestatic_;
      }
      break;
    }
    case kSliceDynamic: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.slicedynamic_;
      }
      break;
    }
    case kSlidingWindows: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.slidingwindows_;
      }
      break;
    }
    case kTopK: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.topk_;
      }
      break;
    }
    case kArgMin: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.argmin_;
      }
      break;
    }
    case kArgMax: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.argmax_;
      }
      break;
    }
    case kEmbeddingND: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.embeddingnd_;
      }
      break;
    }
    case kBatchedMatmul: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.batchedmatmul_;
      }
      break;
    }
    case kGetShape: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.getshape_;
      }
      break;
    }
    case kLoadConstantND: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.loadconstantnd_;
      }
      break;
    }
    case kFillLike: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.filllike_;
      }
      break;
    }
    case kFillStatic: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.fillstatic_;
      }
      break;
    }
    case kFillDynamic: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.filldynamic_;
      }
      break;
    }
    case kBroadcastToLike: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.broadcasttolike_;
      }
      break;
    }
    case kBroadcastToStatic: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.broadcasttostatic_;
      }
      break;
    }
    case kBroadcastToDynamic: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.broadcasttodynamic_;
      }
      break;
    }
    case kSqueeze: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.squeeze_;
      }
      break;
    }
    case kExpandDims: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.expanddims_;
      }
      break;
    }
    case kFlattenTo2D: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.flattento2d_;
      }
      break;
    }
    case kReshapeLike: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.reshapelike_;
      }
      break;
    }
    case kReshapeStatic: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.reshapestatic_;
      }
      break;
    }
    case kReshapeDynamic: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.reshapedynamic_;
      }
      break;
    }
    case kRankPreservingReshape: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.rankpreservingreshape_;
      }
      break;
    }
    case kConstantPad: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.constantpad_;
      }
      break;
    }
    case kRandomNormalLike: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.randomnormallike_;
      }
      break;
    }
    case kRandomNormalStatic: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.randomnormalstatic_;
      }
      break;
    }
    case kRandomNormalDynamic: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.randomnormaldynamic_;
      }
      break;
    }
    case kRandomUniformLike: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.randomuniformlike_;
      }
      break;
    }
    case kRandomUniformStatic: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.randomuniformstatic_;
      }
      break;
    }
    case kRandomUniformDynamic: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.randomuniformdynamic_;
      }
      break;
    }
    case kRandomBernoulliLike: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.randombernoullilike_;
      }
      break;
    }
    case kRandomBernoulliStatic: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.randombernoullistatic_;
      }
      break;
    }
    case kRandomBernoulliDynamic: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.randombernoullidynamic_;
      }
      break;
    }
    case kCategoricalDistribution: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.categoricaldistribution_;
      }
      break;
    }
    case kReduceL1: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.reducel1_;
      }
      break;
    }
    case kReduceL2: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.reducel2_;
      }
      break;
    }
    case kReduceMax: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.reducemax_;
      }
      break;
    }
    case kReduceMin: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.reducemin_;
      }
      break;
    }
    case kReduceSum: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.reducesum_;
      }
      break;
    }
    case kReduceProd: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.reduceprod_;
      }
      break;
    }
    case kReduceMean: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.reducemean_;
      }
      break;
    }
    case kReduceLogSum: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.reducelogsum_;
      }
      break;
    }
    case kReduceSumSquare: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.reducesumsquare_;
      }
      break;
    }
    case kReduceLogSumExp: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.reducelogsumexp_;
      }
      break;
    }
    case kWhereNonZero: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.wherenonzero_;
      }
      break;
    }
    case kMatrixBandPart: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.matrixbandpart_;
      }
      break;
    }
    case kLowerTriangular: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.lowertriangular_;
      }
      break;
    }
    case kUpperTriangular: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.uppertriangular_;
      }
      break;
    }
    case kWhereBroadcastable: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.wherebroadcastable_;
      }
      break;
    }
    case kLayerNormalization: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.layernormalization_;
      }
      break;
    }
    case kNonMaximumSuppression: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.nonmaximumsuppression_;
      }
      break;
    }
    case kOneHot: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.onehot_;
      }
      break;
    }
    case kCumSum: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.cumsum_;
      }
      break;
    }
    case kClampedReLU: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.clampedrelu_;
      }
      break;
    }
    case kArgSort: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.argsort_;
      }
      break;
    }
    case kPooling3D: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.pooling3d_;
      }
      break;
    }
    case kGlobalPooling3D: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.globalpooling3d_;
      }
      break;
    }
    case kSliceBySize: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.slicebysize_;
      }
      break;
    }
    case kConvolution3D: {
      if (GetArenaForAllocation() == nullptr) {
        delete layer_.convolution3d_;
      }
      break;
    }
    case LAYER_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = LAYER_NOT_SET;
}


void NeuralNetworkLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.NeuralNetworkLayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  input_.Clear();
  output_.Clear();
  inputtensor_.Clear();
  outputtensor_.Clear();
  name_.ClearToEmpty();
  isupdatable_ = false;
  clear_layer();
  _internal_metadata_.Clear<std::string>();
}

const char* NeuralNetworkLayer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string input = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_input();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string output = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_output();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.Tensor inputTensor = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_inputtensor(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.Tensor outputTensor = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_outputtensor(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool isUpdatable = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          isupdatable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ConvolutionLayerParams convolution = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_convolution(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.PoolingLayerParams pooling = 120;
      case 120:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_pooling(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ActivationParams activation = 130;
      case 130:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_activation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.InnerProductLayerParams innerProduct = 140;
      case 140:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_innerproduct(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.EmbeddingLayerParams embedding = 150;
      case 150:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_embedding(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.BatchnormLayerParams batchnorm = 160;
      case 160:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_batchnorm(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MeanVarianceNormalizeLayerParams mvn = 165;
      case 165:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_mvn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.L2NormalizeLayerParams l2normalize = 170;
      case 170:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_l2normalize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SoftmaxLayerParams softmax = 175;
      case 175:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_softmax(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LRNLayerParams lrn = 180;
      case 180:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_lrn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CropLayerParams crop = 190;
      case 190:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_crop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.PaddingLayerParams padding = 200;
      case 200:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_padding(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.UpsampleLayerParams upsample = 210;
      case 210:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_upsample(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ResizeBilinearLayerParams resizeBilinear = 211;
      case 211:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_resizebilinear(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CropResizeLayerParams cropResize = 212;
      case 212:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_cropresize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.UnaryFunctionLayerParams unary = 220;
      case 220:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_unary(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.AddLayerParams add = 230;
      case 230:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_add(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MultiplyLayerParams multiply = 231;
      case 231:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_multiply(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.AverageLayerParams average = 240;
      case 240:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_average(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ScaleLayerParams scale = 245;
      case 245:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_scale(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.BiasLayerParams bias = 250;
      case 250:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_bias(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MaxLayerParams max = 260;
      case 260:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_max(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MinLayerParams min = 261;
      case 261:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_min(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.DotProductLayerParams dot = 270;
      case 270:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_dot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReduceLayerParams reduce = 280;
      case 280:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_reduce(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LoadConstantLayerParams loadConstant = 290;
      case 290:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_loadconstant(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReshapeLayerParams reshape = 300;
      case 300:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_reshape(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.FlattenLayerParams flatten = 301;
      case 301:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_flatten(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.PermuteLayerParams permute = 310;
      case 310:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_permute(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ConcatLayerParams concat = 320;
      case 320:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_concat(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SplitLayerParams split = 330;
      case 330:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_split(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SequenceRepeatLayerParams sequenceRepeat = 340;
      case 340:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_sequencerepeat(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReorganizeDataLayerParams reorganizeData = 345;
      case 345:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_reorganizedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SliceLayerParams slice = 350;
      case 350:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_slice(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SimpleRecurrentLayerParams simpleRecurrent = 400;
      case 400:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_simplerecurrent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.GRULayerParams gru = 410;
      case 410:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_gru(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.UniDirectionalLSTMLayerParams uniDirectionalLSTM = 420;
      case 420:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_unidirectionallstm(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.BiDirectionalLSTMLayerParams biDirectionalLSTM = 430;
      case 430:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_bidirectionallstm(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CustomLayerParams custom = 500;
      case 500:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_custom(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CopyLayerParams copy = 600;
      case 600:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_copy(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.BranchLayerParams branch = 605;
      case 605:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_branch(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LoopLayerParams loop = 615;
      case 615:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_loop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LoopBreakLayerParams loopBreak = 620;
      case 620:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_loopbreak(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LoopContinueLayerParams loopContinue = 625;
      case 625:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_loopcontinue(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.RangeStaticLayerParams rangeStatic = 635;
      case 635:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_rangestatic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.RangeDynamicLayerParams rangeDynamic = 640;
      case 640:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_rangedynamic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ClipLayerParams clip = 660;
      case 660:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_clip(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CeilLayerParams ceil = 665;
      case 665:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_ceil(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.FloorLayerParams floor = 670;
      case 670:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_floor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SignLayerParams sign = 680;
      case 680:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_sign(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.RoundLayerParams round = 685;
      case 685:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_round(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Exp2LayerParams exp2 = 700;
      case 700:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_exp2(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SinLayerParams sin = 710;
      case 710:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_sin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CosLayerParams cos = 715;
      case 715:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_cos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.TanLayerParams tan = 720;
      case 720:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_tan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.AsinLayerParams asin = 730;
      case 730:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_asin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.AcosLayerParams acos = 735;
      case 735:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_acos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.AtanLayerParams atan = 740;
      case 740:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_atan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SinhLayerParams sinh = 750;
      case 750:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_sinh(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CoshLayerParams cosh = 755;
      case 755:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_cosh(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.TanhLayerParams tanh = 760;
      case 760:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_tanh(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.AsinhLayerParams asinh = 770;
      case 770:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_asinh(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.AcoshLayerParams acosh = 775;
      case 775:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_acosh(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.AtanhLayerParams atanh = 780;
      case 780:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_atanh(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ErfLayerParams erf = 790;
      case 790:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_erf(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.GeluLayerParams gelu = 795;
      case 795:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_gelu(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.EqualLayerParams equal = 815;
      case 815:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_equal(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NotEqualLayerParams notEqual = 820;
      case 820:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_notequal(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LessThanLayerParams lessThan = 825;
      case 825:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_lessthan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LessEqualLayerParams lessEqual = 827;
      case 827:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_lessequal(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.GreaterThanLayerParams greaterThan = 830;
      case 830:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_greaterthan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.GreaterEqualLayerParams greaterEqual = 832;
      case 832:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_greaterequal(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LogicalOrLayerParams logicalOr = 840;
      case 840:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_logicalor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LogicalXorLayerParams logicalXor = 845;
      case 845:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_logicalxor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LogicalNotLayerParams logicalNot = 850;
      case 850:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_logicalnot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LogicalAndLayerParams logicalAnd = 855;
      case 855:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_logicaland(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ModBroadcastableLayerParams modBroadcastable = 865;
      case 865:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_modbroadcastable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MinBroadcastableLayerParams minBroadcastable = 870;
      case 870:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_minbroadcastable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MaxBroadcastableLayerParams maxBroadcastable = 875;
      case 875:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_maxbroadcastable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.AddBroadcastableLayerParams addBroadcastable = 880;
      case 880:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_addbroadcastable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.PowBroadcastableLayerParams powBroadcastable = 885;
      case 885:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_powbroadcastable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.DivideBroadcastableLayerParams divideBroadcastable = 890;
      case 890:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_dividebroadcastable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.FloorDivBroadcastableLayerParams floorDivBroadcastable = 895;
      case 895:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_floordivbroadcastable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MultiplyBroadcastableLayerParams multiplyBroadcastable = 900;
      case 900:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_multiplybroadcastable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SubtractBroadcastableLayerParams subtractBroadcastable = 905;
      case 905:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_subtractbroadcastable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.TileLayerParams tile = 920;
      case 920:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_tile(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.StackLayerParams stack = 925;
      case 925:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_stack(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.GatherLayerParams gather = 930;
      case 930:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_gather(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ScatterLayerParams scatter = 935;
      case 935:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_scatter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.GatherNDLayerParams gatherND = 940;
      case 940:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_gathernd(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ScatterNDLayerParams scatterND = 945;
      case 945:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_scatternd(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SoftmaxNDLayerParams softmaxND = 950;
      case 950:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_softmaxnd(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.GatherAlongAxisLayerParams gatherAlongAxis = 952;
      case 952:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_gatheralongaxis(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ScatterAlongAxisLayerParams scatterAlongAxis = 954;
      case 954:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_scatteralongaxis(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReverseLayerParams reverse = 960;
      case 960:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_reverse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReverseSeqLayerParams reverseSeq = 965;
      case 965:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_reverseseq(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SplitNDLayerParams splitND = 975;
      case 975:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_splitnd(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ConcatNDLayerParams concatND = 980;
      case 980:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_concatnd(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.TransposeLayerParams transpose = 985;
      case 985:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_transpose(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SliceStaticLayerParams sliceStatic = 995;
      case 995:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_slicestatic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SliceDynamicLayerParams sliceDynamic = 1000;
      case 1000:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_slicedynamic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SlidingWindowsLayerParams slidingWindows = 1005;
      case 1005:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_slidingwindows(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.TopKLayerParams topK = 1015;
      case 1015:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_topk(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ArgMinLayerParams argMin = 1020;
      case 1020:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_argmin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ArgMaxLayerParams argMax = 1025;
      case 1025:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_argmax(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.EmbeddingNDLayerParams embeddingND = 1040;
      case 1040:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_embeddingnd(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.BatchedMatMulLayerParams batchedMatmul = 1045;
      case 1045:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_batchedmatmul(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.GetShapeLayerParams getShape = 1065;
      case 1065:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_getshape(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LoadConstantNDLayerParams loadConstantND = 1070;
      case 1070:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_loadconstantnd(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.FillLikeLayerParams fillLike = 1080;
      case 1080:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_filllike(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.FillStaticLayerParams fillStatic = 1085;
      case 1085:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_fillstatic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.FillDynamicLayerParams fillDynamic = 1090;
      case 1090:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_filldynamic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.BroadcastToLikeLayerParams broadcastToLike = 1100;
      case 1100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_broadcasttolike(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.BroadcastToStaticLayerParams broadcastToStatic = 1105;
      case 1105:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_broadcasttostatic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.BroadcastToDynamicLayerParams broadcastToDynamic = 1110;
      case 1110:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_broadcasttodynamic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SqueezeLayerParams squeeze = 1120;
      case 1120:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_squeeze(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ExpandDimsLayerParams expandDims = 1125;
      case 1125:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_expanddims(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.FlattenTo2DLayerParams flattenTo2D = 1130;
      case 1130:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_flattento2d(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReshapeLikeLayerParams reshapeLike = 1135;
      case 1135:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_reshapelike(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReshapeStaticLayerParams reshapeStatic = 1140;
      case 1140:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_reshapestatic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReshapeDynamicLayerParams reshapeDynamic = 1145;
      case 1145:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_reshapedynamic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.RankPreservingReshapeLayerParams rankPreservingReshape = 1150;
      case 1150:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_rankpreservingreshape(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ConstantPaddingLayerParams constantPad = 1155;
      case 1155:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_constantpad(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.RandomNormalLikeLayerParams randomNormalLike = 1170;
      case 1170:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_randomnormallike(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.RandomNormalStaticLayerParams randomNormalStatic = 1175;
      case 1175:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_randomnormalstatic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.RandomNormalDynamicLayerParams randomNormalDynamic = 1180;
      case 1180:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_randomnormaldynamic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.RandomUniformLikeLayerParams randomUniformLike = 1190;
      case 1190:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_randomuniformlike(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.RandomUniformStaticLayerParams randomUniformStatic = 1195;
      case 1195:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_randomuniformstatic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.RandomUniformDynamicLayerParams randomUniformDynamic = 1200;
      case 1200:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_randomuniformdynamic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.RandomBernoulliLikeLayerParams randomBernoulliLike = 1210;
      case 1210:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_randombernoullilike(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.RandomBernoulliStaticLayerParams randomBernoulliStatic = 1215;
      case 1215:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_randombernoullistatic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.RandomBernoulliDynamicLayerParams randomBernoulliDynamic = 1220;
      case 1220:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_randombernoullidynamic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CategoricalDistributionLayerParams categoricalDistribution = 1230;
      case 1230:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_categoricaldistribution(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReduceL1LayerParams reduceL1 = 1250;
      case 1250:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_reducel1(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReduceL2LayerParams reduceL2 = 1255;
      case 1255:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_reducel2(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReduceMaxLayerParams reduceMax = 1260;
      case 1260:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_reducemax(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReduceMinLayerParams reduceMin = 1265;
      case 1265:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_reducemin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReduceSumLayerParams reduceSum = 1270;
      case 1270:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_reducesum(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReduceProdLayerParams reduceProd = 1275;
      case 1275:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_reduceprod(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReduceMeanLayerParams reduceMean = 1280;
      case 1280:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_reducemean(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReduceLogSumLayerParams reduceLogSum = 1285;
      case 1285:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_reducelogsum(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReduceSumSquareLayerParams reduceSumSquare = 1290;
      case 1290:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_reducesumsquare(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReduceLogSumExpLayerParams reduceLogSumExp = 1295;
      case 1295:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_reducelogsumexp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WhereNonZeroLayerParams whereNonZero = 1313;
      case 1313:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_wherenonzero(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MatrixBandPartLayerParams matrixBandPart = 1315;
      case 1315:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_matrixbandpart(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LowerTriangularLayerParams lowerTriangular = 1320;
      case 1320:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_lowertriangular(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.UpperTriangularLayerParams upperTriangular = 1325;
      case 1325:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_uppertriangular(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WhereBroadcastableLayerParams whereBroadcastable = 1330;
      case 1330:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_wherebroadcastable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LayerNormalizationLayerParams layerNormalization = 1350;
      case 1350:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_layernormalization(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NonMaximumSuppressionLayerParams NonMaximumSuppression = 1400;
      case 1400:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_nonmaximumsuppression(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.OneHotLayerParams oneHot = 1450;
      case 1450:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_onehot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CumSumLayerParams cumSum = 1455;
      case 1455:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_cumsum(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ClampedReLULayerParams clampedReLU = 1460;
      case 1460:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_clampedrelu(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ArgSortLayerParams argSort = 1461;
      case 1461:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_argsort(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Pooling3DLayerParams pooling3d = 1465;
      case 1465:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_pooling3d(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.GlobalPooling3DLayerParams globalPooling3d = 1466;
      case 1466:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_globalpooling3d(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SliceBySizeLayerParams sliceBySize = 1470;
      case 1470:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_slicebysize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Convolution3DLayerParams convolution3d = 1471;
      case 1471:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_convolution3d(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NeuralNetworkLayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.NeuralNetworkLayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.NeuralNetworkLayer.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated string input = 2;
  for (int i = 0, n = this->_internal_input_size(); i < n; i++) {
    const auto& s = this->_internal_input(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.NeuralNetworkLayer.input");
    target = stream->WriteString(2, s, target);
  }

  // repeated string output = 3;
  for (int i = 0, n = this->_internal_output_size(); i < n; i++) {
    const auto& s = this->_internal_output(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.NeuralNetworkLayer.output");
    target = stream->WriteString(3, s, target);
  }

  // repeated .CoreML.Specification.Tensor inputTensor = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_inputtensor_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_inputtensor(i), target, stream);
  }

  // repeated .CoreML.Specification.Tensor outputTensor = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_outputtensor_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_outputtensor(i), target, stream);
  }

  // bool isUpdatable = 10;
  if (this->_internal_isupdatable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_isupdatable(), target);
  }

  // .CoreML.Specification.ConvolutionLayerParams convolution = 100;
  if (_internal_has_convolution()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        100, _Internal::convolution(this), target, stream);
  }

  // .CoreML.Specification.PoolingLayerParams pooling = 120;
  if (_internal_has_pooling()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        120, _Internal::pooling(this), target, stream);
  }

  // .CoreML.Specification.ActivationParams activation = 130;
  if (_internal_has_activation()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        130, _Internal::activation(this), target, stream);
  }

  // .CoreML.Specification.InnerProductLayerParams innerProduct = 140;
  if (_internal_has_innerproduct()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        140, _Internal::innerproduct(this), target, stream);
  }

  // .CoreML.Specification.EmbeddingLayerParams embedding = 150;
  if (_internal_has_embedding()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        150, _Internal::embedding(this), target, stream);
  }

  // .CoreML.Specification.BatchnormLayerParams batchnorm = 160;
  if (_internal_has_batchnorm()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        160, _Internal::batchnorm(this), target, stream);
  }

  // .CoreML.Specification.MeanVarianceNormalizeLayerParams mvn = 165;
  if (_internal_has_mvn()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        165, _Internal::mvn(this), target, stream);
  }

  // .CoreML.Specification.L2NormalizeLayerParams l2normalize = 170;
  if (_internal_has_l2normalize()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        170, _Internal::l2normalize(this), target, stream);
  }

  // .CoreML.Specification.SoftmaxLayerParams softmax = 175;
  if (_internal_has_softmax()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        175, _Internal::softmax(this), target, stream);
  }

  // .CoreML.Specification.LRNLayerParams lrn = 180;
  if (_internal_has_lrn()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        180, _Internal::lrn(this), target, stream);
  }

  // .CoreML.Specification.CropLayerParams crop = 190;
  if (_internal_has_crop()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        190, _Internal::crop(this), target, stream);
  }

  // .CoreML.Specification.PaddingLayerParams padding = 200;
  if (_internal_has_padding()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        200, _Internal::padding(this), target, stream);
  }

  // .CoreML.Specification.UpsampleLayerParams upsample = 210;
  if (_internal_has_upsample()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        210, _Internal::upsample(this), target, stream);
  }

  // .CoreML.Specification.ResizeBilinearLayerParams resizeBilinear = 211;
  if (_internal_has_resizebilinear()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        211, _Internal::resizebilinear(this), target, stream);
  }

  // .CoreML.Specification.CropResizeLayerParams cropResize = 212;
  if (_internal_has_cropresize()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        212, _Internal::cropresize(this), target, stream);
  }

  // .CoreML.Specification.UnaryFunctionLayerParams unary = 220;
  if (_internal_has_unary()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        220, _Internal::unary(this), target, stream);
  }

  // .CoreML.Specification.AddLayerParams add = 230;
  if (_internal_has_add()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        230, _Internal::add(this), target, stream);
  }

  // .CoreML.Specification.MultiplyLayerParams multiply = 231;
  if (_internal_has_multiply()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        231, _Internal::multiply(this), target, stream);
  }

  // .CoreML.Specification.AverageLayerParams average = 240;
  if (_internal_has_average()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        240, _Internal::average(this), target, stream);
  }

  // .CoreML.Specification.ScaleLayerParams scale = 245;
  if (_internal_has_scale()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        245, _Internal::scale(this), target, stream);
  }

  // .CoreML.Specification.BiasLayerParams bias = 250;
  if (_internal_has_bias()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        250, _Internal::bias(this), target, stream);
  }

  // .CoreML.Specification.MaxLayerParams max = 260;
  if (_internal_has_max()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        260, _Internal::max(this), target, stream);
  }

  // .CoreML.Specification.MinLayerParams min = 261;
  if (_internal_has_min()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        261, _Internal::min(this), target, stream);
  }

  // .CoreML.Specification.DotProductLayerParams dot = 270;
  if (_internal_has_dot()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        270, _Internal::dot(this), target, stream);
  }

  // .CoreML.Specification.ReduceLayerParams reduce = 280;
  if (_internal_has_reduce()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        280, _Internal::reduce(this), target, stream);
  }

  // .CoreML.Specification.LoadConstantLayerParams loadConstant = 290;
  if (_internal_has_loadconstant()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        290, _Internal::loadconstant(this), target, stream);
  }

  // .CoreML.Specification.ReshapeLayerParams reshape = 300;
  if (_internal_has_reshape()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        300, _Internal::reshape(this), target, stream);
  }

  // .CoreML.Specification.FlattenLayerParams flatten = 301;
  if (_internal_has_flatten()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        301, _Internal::flatten(this), target, stream);
  }

  // .CoreML.Specification.PermuteLayerParams permute = 310;
  if (_internal_has_permute()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        310, _Internal::permute(this), target, stream);
  }

  // .CoreML.Specification.ConcatLayerParams concat = 320;
  if (_internal_has_concat()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        320, _Internal::concat(this), target, stream);
  }

  // .CoreML.Specification.SplitLayerParams split = 330;
  if (_internal_has_split()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        330, _Internal::split(this), target, stream);
  }

  // .CoreML.Specification.SequenceRepeatLayerParams sequenceRepeat = 340;
  if (_internal_has_sequencerepeat()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        340, _Internal::sequencerepeat(this), target, stream);
  }

  // .CoreML.Specification.ReorganizeDataLayerParams reorganizeData = 345;
  if (_internal_has_reorganizedata()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        345, _Internal::reorganizedata(this), target, stream);
  }

  // .CoreML.Specification.SliceLayerParams slice = 350;
  if (_internal_has_slice()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        350, _Internal::slice(this), target, stream);
  }

  // .CoreML.Specification.SimpleRecurrentLayerParams simpleRecurrent = 400;
  if (_internal_has_simplerecurrent()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        400, _Internal::simplerecurrent(this), target, stream);
  }

  // .CoreML.Specification.GRULayerParams gru = 410;
  if (_internal_has_gru()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        410, _Internal::gru(this), target, stream);
  }

  // .CoreML.Specification.UniDirectionalLSTMLayerParams uniDirectionalLSTM = 420;
  if (_internal_has_unidirectionallstm()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        420, _Internal::unidirectionallstm(this), target, stream);
  }

  // .CoreML.Specification.BiDirectionalLSTMLayerParams biDirectionalLSTM = 430;
  if (_internal_has_bidirectionallstm()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        430, _Internal::bidirectionallstm(this), target, stream);
  }

  // .CoreML.Specification.CustomLayerParams custom = 500;
  if (_internal_has_custom()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        500, _Internal::custom(this), target, stream);
  }

  // .CoreML.Specification.CopyLayerParams copy = 600;
  if (_internal_has_copy()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        600, _Internal::copy(this), target, stream);
  }

  // .CoreML.Specification.BranchLayerParams branch = 605;
  if (_internal_has_branch()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        605, _Internal::branch(this), target, stream);
  }

  // .CoreML.Specification.LoopLayerParams loop = 615;
  if (_internal_has_loop()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        615, _Internal::loop(this), target, stream);
  }

  // .CoreML.Specification.LoopBreakLayerParams loopBreak = 620;
  if (_internal_has_loopbreak()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        620, _Internal::loopbreak(this), target, stream);
  }

  // .CoreML.Specification.LoopContinueLayerParams loopContinue = 625;
  if (_internal_has_loopcontinue()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        625, _Internal::loopcontinue(this), target, stream);
  }

  // .CoreML.Specification.RangeStaticLayerParams rangeStatic = 635;
  if (_internal_has_rangestatic()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        635, _Internal::rangestatic(this), target, stream);
  }

  // .CoreML.Specification.RangeDynamicLayerParams rangeDynamic = 640;
  if (_internal_has_rangedynamic()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        640, _Internal::rangedynamic(this), target, stream);
  }

  // .CoreML.Specification.ClipLayerParams clip = 660;
  if (_internal_has_clip()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        660, _Internal::clip(this), target, stream);
  }

  // .CoreML.Specification.CeilLayerParams ceil = 665;
  if (_internal_has_ceil()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        665, _Internal::ceil(this), target, stream);
  }

  // .CoreML.Specification.FloorLayerParams floor = 670;
  if (_internal_has_floor()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        670, _Internal::floor(this), target, stream);
  }

  // .CoreML.Specification.SignLayerParams sign = 680;
  if (_internal_has_sign()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        680, _Internal::sign(this), target, stream);
  }

  // .CoreML.Specification.RoundLayerParams round = 685;
  if (_internal_has_round()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        685, _Internal::round(this), target, stream);
  }

  // .CoreML.Specification.Exp2LayerParams exp2 = 700;
  if (_internal_has_exp2()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        700, _Internal::exp2(this), target, stream);
  }

  // .CoreML.Specification.SinLayerParams sin = 710;
  if (_internal_has_sin()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        710, _Internal::sin(this), target, stream);
  }

  // .CoreML.Specification.CosLayerParams cos = 715;
  if (_internal_has_cos()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        715, _Internal::cos(this), target, stream);
  }

  // .CoreML.Specification.TanLayerParams tan = 720;
  if (_internal_has_tan()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        720, _Internal::tan(this), target, stream);
  }

  // .CoreML.Specification.AsinLayerParams asin = 730;
  if (_internal_has_asin()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        730, _Internal::asin(this), target, stream);
  }

  // .CoreML.Specification.AcosLayerParams acos = 735;
  if (_internal_has_acos()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        735, _Internal::acos(this), target, stream);
  }

  // .CoreML.Specification.AtanLayerParams atan = 740;
  if (_internal_has_atan()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        740, _Internal::atan(this), target, stream);
  }

  // .CoreML.Specification.SinhLayerParams sinh = 750;
  if (_internal_has_sinh()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        750, _Internal::sinh(this), target, stream);
  }

  // .CoreML.Specification.CoshLayerParams cosh = 755;
  if (_internal_has_cosh()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        755, _Internal::cosh(this), target, stream);
  }

  // .CoreML.Specification.TanhLayerParams tanh = 760;
  if (_internal_has_tanh()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        760, _Internal::tanh(this), target, stream);
  }

  // .CoreML.Specification.AsinhLayerParams asinh = 770;
  if (_internal_has_asinh()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        770, _Internal::asinh(this), target, stream);
  }

  // .CoreML.Specification.AcoshLayerParams acosh = 775;
  if (_internal_has_acosh()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        775, _Internal::acosh(this), target, stream);
  }

  // .CoreML.Specification.AtanhLayerParams atanh = 780;
  if (_internal_has_atanh()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        780, _Internal::atanh(this), target, stream);
  }

  // .CoreML.Specification.ErfLayerParams erf = 790;
  if (_internal_has_erf()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        790, _Internal::erf(this), target, stream);
  }

  // .CoreML.Specification.GeluLayerParams gelu = 795;
  if (_internal_has_gelu()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        795, _Internal::gelu(this), target, stream);
  }

  // .CoreML.Specification.EqualLayerParams equal = 815;
  if (_internal_has_equal()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        815, _Internal::equal(this), target, stream);
  }

  // .CoreML.Specification.NotEqualLayerParams notEqual = 820;
  if (_internal_has_notequal()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        820, _Internal::notequal(this), target, stream);
  }

  // .CoreML.Specification.LessThanLayerParams lessThan = 825;
  if (_internal_has_lessthan()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        825, _Internal::lessthan(this), target, stream);
  }

  // .CoreML.Specification.LessEqualLayerParams lessEqual = 827;
  if (_internal_has_lessequal()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        827, _Internal::lessequal(this), target, stream);
  }

  // .CoreML.Specification.GreaterThanLayerParams greaterThan = 830;
  if (_internal_has_greaterthan()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        830, _Internal::greaterthan(this), target, stream);
  }

  // .CoreML.Specification.GreaterEqualLayerParams greaterEqual = 832;
  if (_internal_has_greaterequal()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        832, _Internal::greaterequal(this), target, stream);
  }

  // .CoreML.Specification.LogicalOrLayerParams logicalOr = 840;
  if (_internal_has_logicalor()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        840, _Internal::logicalor(this), target, stream);
  }

  // .CoreML.Specification.LogicalXorLayerParams logicalXor = 845;
  if (_internal_has_logicalxor()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        845, _Internal::logicalxor(this), target, stream);
  }

  // .CoreML.Specification.LogicalNotLayerParams logicalNot = 850;
  if (_internal_has_logicalnot()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        850, _Internal::logicalnot(this), target, stream);
  }

  // .CoreML.Specification.LogicalAndLayerParams logicalAnd = 855;
  if (_internal_has_logicaland()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        855, _Internal::logicaland(this), target, stream);
  }

  // .CoreML.Specification.ModBroadcastableLayerParams modBroadcastable = 865;
  if (_internal_has_modbroadcastable()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        865, _Internal::modbroadcastable(this), target, stream);
  }

  // .CoreML.Specification.MinBroadcastableLayerParams minBroadcastable = 870;
  if (_internal_has_minbroadcastable()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        870, _Internal::minbroadcastable(this), target, stream);
  }

  // .CoreML.Specification.MaxBroadcastableLayerParams maxBroadcastable = 875;
  if (_internal_has_maxbroadcastable()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        875, _Internal::maxbroadcastable(this), target, stream);
  }

  // .CoreML.Specification.AddBroadcastableLayerParams addBroadcastable = 880;
  if (_internal_has_addbroadcastable()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        880, _Internal::addbroadcastable(this), target, stream);
  }

  // .CoreML.Specification.PowBroadcastableLayerParams powBroadcastable = 885;
  if (_internal_has_powbroadcastable()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        885, _Internal::powbroadcastable(this), target, stream);
  }

  // .CoreML.Specification.DivideBroadcastableLayerParams divideBroadcastable = 890;
  if (_internal_has_dividebroadcastable()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        890, _Internal::dividebroadcastable(this), target, stream);
  }

  // .CoreML.Specification.FloorDivBroadcastableLayerParams floorDivBroadcastable = 895;
  if (_internal_has_floordivbroadcastable()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        895, _Internal::floordivbroadcastable(this), target, stream);
  }

  // .CoreML.Specification.MultiplyBroadcastableLayerParams multiplyBroadcastable = 900;
  if (_internal_has_multiplybroadcastable()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        900, _Internal::multiplybroadcastable(this), target, stream);
  }

  // .CoreML.Specification.SubtractBroadcastableLayerParams subtractBroadcastable = 905;
  if (_internal_has_subtractbroadcastable()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        905, _Internal::subtractbroadcastable(this), target, stream);
  }

  // .CoreML.Specification.TileLayerParams tile = 920;
  if (_internal_has_tile()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        920, _Internal::tile(this), target, stream);
  }

  // .CoreML.Specification.StackLayerParams stack = 925;
  if (_internal_has_stack()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        925, _Internal::stack(this), target, stream);
  }

  // .CoreML.Specification.GatherLayerParams gather = 930;
  if (_internal_has_gather()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        930, _Internal::gather(this), target, stream);
  }

  // .CoreML.Specification.ScatterLayerParams scatter = 935;
  if (_internal_has_scatter()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        935, _Internal::scatter(this), target, stream);
  }

  // .CoreML.Specification.GatherNDLayerParams gatherND = 940;
  if (_internal_has_gathernd()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        940, _Internal::gathernd(this), target, stream);
  }

  // .CoreML.Specification.ScatterNDLayerParams scatterND = 945;
  if (_internal_has_scatternd()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        945, _Internal::scatternd(this), target, stream);
  }

  // .CoreML.Specification.SoftmaxNDLayerParams softmaxND = 950;
  if (_internal_has_softmaxnd()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        950, _Internal::softmaxnd(this), target, stream);
  }

  // .CoreML.Specification.GatherAlongAxisLayerParams gatherAlongAxis = 952;
  if (_internal_has_gatheralongaxis()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        952, _Internal::gatheralongaxis(this), target, stream);
  }

  // .CoreML.Specification.ScatterAlongAxisLayerParams scatterAlongAxis = 954;
  if (_internal_has_scatteralongaxis()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        954, _Internal::scatteralongaxis(this), target, stream);
  }

  // .CoreML.Specification.ReverseLayerParams reverse = 960;
  if (_internal_has_reverse()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        960, _Internal::reverse(this), target, stream);
  }

  // .CoreML.Specification.ReverseSeqLayerParams reverseSeq = 965;
  if (_internal_has_reverseseq()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        965, _Internal::reverseseq(this), target, stream);
  }

  // .CoreML.Specification.SplitNDLayerParams splitND = 975;
  if (_internal_has_splitnd()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        975, _Internal::splitnd(this), target, stream);
  }

  // .CoreML.Specification.ConcatNDLayerParams concatND = 980;
  if (_internal_has_concatnd()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        980, _Internal::concatnd(this), target, stream);
  }

  // .CoreML.Specification.TransposeLayerParams transpose = 985;
  if (_internal_has_transpose()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        985, _Internal::transpose(this), target, stream);
  }

  // .CoreML.Specification.SliceStaticLayerParams sliceStatic = 995;
  if (_internal_has_slicestatic()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        995, _Internal::slicestatic(this), target, stream);
  }

  // .CoreML.Specification.SliceDynamicLayerParams sliceDynamic = 1000;
  if (_internal_has_slicedynamic()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1000, _Internal::slicedynamic(this), target, stream);
  }

  // .CoreML.Specification.SlidingWindowsLayerParams slidingWindows = 1005;
  if (_internal_has_slidingwindows()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1005, _Internal::slidingwindows(this), target, stream);
  }

  // .CoreML.Specification.TopKLayerParams topK = 1015;
  if (_internal_has_topk()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1015, _Internal::topk(this), target, stream);
  }

  // .CoreML.Specification.ArgMinLayerParams argMin = 1020;
  if (_internal_has_argmin()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1020, _Internal::argmin(this), target, stream);
  }

  // .CoreML.Specification.ArgMaxLayerParams argMax = 1025;
  if (_internal_has_argmax()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1025, _Internal::argmax(this), target, stream);
  }

  // .CoreML.Specification.EmbeddingNDLayerParams embeddingND = 1040;
  if (_internal_has_embeddingnd()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1040, _Internal::embeddingnd(this), target, stream);
  }

  // .CoreML.Specification.BatchedMatMulLayerParams batchedMatmul = 1045;
  if (_internal_has_batchedmatmul()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1045, _Internal::batchedmatmul(this), target, stream);
  }

  // .CoreML.Specification.GetShapeLayerParams getShape = 1065;
  if (_internal_has_getshape()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1065, _Internal::getshape(this), target, stream);
  }

  // .CoreML.Specification.LoadConstantNDLayerParams loadConstantND = 1070;
  if (_internal_has_loadconstantnd()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1070, _Internal::loadconstantnd(this), target, stream);
  }

  // .CoreML.Specification.FillLikeLayerParams fillLike = 1080;
  if (_internal_has_filllike()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1080, _Internal::filllike(this), target, stream);
  }

  // .CoreML.Specification.FillStaticLayerParams fillStatic = 1085;
  if (_internal_has_fillstatic()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1085, _Internal::fillstatic(this), target, stream);
  }

  // .CoreML.Specification.FillDynamicLayerParams fillDynamic = 1090;
  if (_internal_has_filldynamic()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1090, _Internal::filldynamic(this), target, stream);
  }

  // .CoreML.Specification.BroadcastToLikeLayerParams broadcastToLike = 1100;
  if (_internal_has_broadcasttolike()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1100, _Internal::broadcasttolike(this), target, stream);
  }

  // .CoreML.Specification.BroadcastToStaticLayerParams broadcastToStatic = 1105;
  if (_internal_has_broadcasttostatic()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1105, _Internal::broadcasttostatic(this), target, stream);
  }

  // .CoreML.Specification.BroadcastToDynamicLayerParams broadcastToDynamic = 1110;
  if (_internal_has_broadcasttodynamic()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1110, _Internal::broadcasttodynamic(this), target, stream);
  }

  // .CoreML.Specification.SqueezeLayerParams squeeze = 1120;
  if (_internal_has_squeeze()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1120, _Internal::squeeze(this), target, stream);
  }

  // .CoreML.Specification.ExpandDimsLayerParams expandDims = 1125;
  if (_internal_has_expanddims()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1125, _Internal::expanddims(this), target, stream);
  }

  // .CoreML.Specification.FlattenTo2DLayerParams flattenTo2D = 1130;
  if (_internal_has_flattento2d()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1130, _Internal::flattento2d(this), target, stream);
  }

  // .CoreML.Specification.ReshapeLikeLayerParams reshapeLike = 1135;
  if (_internal_has_reshapelike()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1135, _Internal::reshapelike(this), target, stream);
  }

  // .CoreML.Specification.ReshapeStaticLayerParams reshapeStatic = 1140;
  if (_internal_has_reshapestatic()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1140, _Internal::reshapestatic(this), target, stream);
  }

  // .CoreML.Specification.ReshapeDynamicLayerParams reshapeDynamic = 1145;
  if (_internal_has_reshapedynamic()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1145, _Internal::reshapedynamic(this), target, stream);
  }

  // .CoreML.Specification.RankPreservingReshapeLayerParams rankPreservingReshape = 1150;
  if (_internal_has_rankpreservingreshape()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1150, _Internal::rankpreservingreshape(this), target, stream);
  }

  // .CoreML.Specification.ConstantPaddingLayerParams constantPad = 1155;
  if (_internal_has_constantpad()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1155, _Internal::constantpad(this), target, stream);
  }

  // .CoreML.Specification.RandomNormalLikeLayerParams randomNormalLike = 1170;
  if (_internal_has_randomnormallike()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1170, _Internal::randomnormallike(this), target, stream);
  }

  // .CoreML.Specification.RandomNormalStaticLayerParams randomNormalStatic = 1175;
  if (_internal_has_randomnormalstatic()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1175, _Internal::randomnormalstatic(this), target, stream);
  }

  // .CoreML.Specification.RandomNormalDynamicLayerParams randomNormalDynamic = 1180;
  if (_internal_has_randomnormaldynamic()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1180, _Internal::randomnormaldynamic(this), target, stream);
  }

  // .CoreML.Specification.RandomUniformLikeLayerParams randomUniformLike = 1190;
  if (_internal_has_randomuniformlike()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1190, _Internal::randomuniformlike(this), target, stream);
  }

  // .CoreML.Specification.RandomUniformStaticLayerParams randomUniformStatic = 1195;
  if (_internal_has_randomuniformstatic()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1195, _Internal::randomuniformstatic(this), target, stream);
  }

  // .CoreML.Specification.RandomUniformDynamicLayerParams randomUniformDynamic = 1200;
  if (_internal_has_randomuniformdynamic()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1200, _Internal::randomuniformdynamic(this), target, stream);
  }

  // .CoreML.Specification.RandomBernoulliLikeLayerParams randomBernoulliLike = 1210;
  if (_internal_has_randombernoullilike()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1210, _Internal::randombernoullilike(this), target, stream);
  }

  // .CoreML.Specification.RandomBernoulliStaticLayerParams randomBernoulliStatic = 1215;
  if (_internal_has_randombernoullistatic()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1215, _Internal::randombernoullistatic(this), target, stream);
  }

  // .CoreML.Specification.RandomBernoulliDynamicLayerParams randomBernoulliDynamic = 1220;
  if (_internal_has_randombernoullidynamic()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1220, _Internal::randombernoullidynamic(this), target, stream);
  }

  // .CoreML.Specification.CategoricalDistributionLayerParams categoricalDistribution = 1230;
  if (_internal_has_categoricaldistribution()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1230, _Internal::categoricaldistribution(this), target, stream);
  }

  // .CoreML.Specification.ReduceL1LayerParams reduceL1 = 1250;
  if (_internal_has_reducel1()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1250, _Internal::reducel1(this), target, stream);
  }

  // .CoreML.Specification.ReduceL2LayerParams reduceL2 = 1255;
  if (_internal_has_reducel2()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1255, _Internal::reducel2(this), target, stream);
  }

  // .CoreML.Specification.ReduceMaxLayerParams reduceMax = 1260;
  if (_internal_has_reducemax()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1260, _Internal::reducemax(this), target, stream);
  }

  // .CoreML.Specification.ReduceMinLayerParams reduceMin = 1265;
  if (_internal_has_reducemin()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1265, _Internal::reducemin(this), target, stream);
  }

  // .CoreML.Specification.ReduceSumLayerParams reduceSum = 1270;
  if (_internal_has_reducesum()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1270, _Internal::reducesum(this), target, stream);
  }

  // .CoreML.Specification.ReduceProdLayerParams reduceProd = 1275;
  if (_internal_has_reduceprod()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1275, _Internal::reduceprod(this), target, stream);
  }

  // .CoreML.Specification.ReduceMeanLayerParams reduceMean = 1280;
  if (_internal_has_reducemean()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1280, _Internal::reducemean(this), target, stream);
  }

  // .CoreML.Specification.ReduceLogSumLayerParams reduceLogSum = 1285;
  if (_internal_has_reducelogsum()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1285, _Internal::reducelogsum(this), target, stream);
  }

  // .CoreML.Specification.ReduceSumSquareLayerParams reduceSumSquare = 1290;
  if (_internal_has_reducesumsquare()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1290, _Internal::reducesumsquare(this), target, stream);
  }

  // .CoreML.Specification.ReduceLogSumExpLayerParams reduceLogSumExp = 1295;
  if (_internal_has_reducelogsumexp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1295, _Internal::reducelogsumexp(this), target, stream);
  }

  // .CoreML.Specification.WhereNonZeroLayerParams whereNonZero = 1313;
  if (_internal_has_wherenonzero()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1313, _Internal::wherenonzero(this), target, stream);
  }

  // .CoreML.Specification.MatrixBandPartLayerParams matrixBandPart = 1315;
  if (_internal_has_matrixbandpart()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1315, _Internal::matrixbandpart(this), target, stream);
  }

  // .CoreML.Specification.LowerTriangularLayerParams lowerTriangular = 1320;
  if (_internal_has_lowertriangular()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1320, _Internal::lowertriangular(this), target, stream);
  }

  // .CoreML.Specification.UpperTriangularLayerParams upperTriangular = 1325;
  if (_internal_has_uppertriangular()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1325, _Internal::uppertriangular(this), target, stream);
  }

  // .CoreML.Specification.WhereBroadcastableLayerParams whereBroadcastable = 1330;
  if (_internal_has_wherebroadcastable()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1330, _Internal::wherebroadcastable(this), target, stream);
  }

  // .CoreML.Specification.LayerNormalizationLayerParams layerNormalization = 1350;
  if (_internal_has_layernormalization()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1350, _Internal::layernormalization(this), target, stream);
  }

  // .CoreML.Specification.NonMaximumSuppressionLayerParams NonMaximumSuppression = 1400;
  if (_internal_has_nonmaximumsuppression()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1400, _Internal::nonmaximumsuppression(this), target, stream);
  }

  // .CoreML.Specification.OneHotLayerParams oneHot = 1450;
  if (_internal_has_onehot()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1450, _Internal::onehot(this), target, stream);
  }

  // .CoreML.Specification.CumSumLayerParams cumSum = 1455;
  if (_internal_has_cumsum()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1455, _Internal::cumsum(this), target, stream);
  }

  // .CoreML.Specification.ClampedReLULayerParams clampedReLU = 1460;
  if (_internal_has_clampedrelu()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1460, _Internal::clampedrelu(this), target, stream);
  }

  // .CoreML.Specification.ArgSortLayerParams argSort = 1461;
  if (_internal_has_argsort()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1461, _Internal::argsort(this), target, stream);
  }

  // .CoreML.Specification.Pooling3DLayerParams pooling3d = 1465;
  if (_internal_has_pooling3d()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1465, _Internal::pooling3d(this), target, stream);
  }

  // .CoreML.Specification.GlobalPooling3DLayerParams globalPooling3d = 1466;
  if (_internal_has_globalpooling3d()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1466, _Internal::globalpooling3d(this), target, stream);
  }

  // .CoreML.Specification.SliceBySizeLayerParams sliceBySize = 1470;
  if (_internal_has_slicebysize()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1470, _Internal::slicebysize(this), target, stream);
  }

  // .CoreML.Specification.Convolution3DLayerParams convolution3d = 1471;
  if (_internal_has_convolution3d()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1471, _Internal::convolution3d(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.NeuralNetworkLayer)
  return target;
}

size_t NeuralNetworkLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.NeuralNetworkLayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string input = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(input_.size());
  for (int i = 0, n = input_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      input_.Get(i));
  }

  // repeated string output = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(output_.size());
  for (int i = 0, n = output_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      output_.Get(i));
  }

  // repeated .CoreML.Specification.Tensor inputTensor = 4;
  total_size += 1UL * this->_internal_inputtensor_size();
  for (const auto& msg : this->inputtensor_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CoreML.Specification.Tensor outputTensor = 5;
  total_size += 1UL * this->_internal_outputtensor_size();
  for (const auto& msg : this->outputtensor_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool isUpdatable = 10;
  if (this->_internal_isupdatable() != 0) {
    total_size += 1 + 1;
  }

  switch (layer_case()) {
    // .CoreML.Specification.ConvolutionLayerParams convolution = 100;
    case kConvolution: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.convolution_);
      break;
    }
    // .CoreML.Specification.PoolingLayerParams pooling = 120;
    case kPooling: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.pooling_);
      break;
    }
    // .CoreML.Specification.ActivationParams activation = 130;
    case kActivation: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.activation_);
      break;
    }
    // .CoreML.Specification.InnerProductLayerParams innerProduct = 140;
    case kInnerProduct: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.innerproduct_);
      break;
    }
    // .CoreML.Specification.EmbeddingLayerParams embedding = 150;
    case kEmbedding: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.embedding_);
      break;
    }
    // .CoreML.Specification.BatchnormLayerParams batchnorm = 160;
    case kBatchnorm: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.batchnorm_);
      break;
    }
    // .CoreML.Specification.MeanVarianceNormalizeLayerParams mvn = 165;
    case kMvn: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.mvn_);
      break;
    }
    // .CoreML.Specification.L2NormalizeLayerParams l2normalize = 170;
    case kL2Normalize: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.l2normalize_);
      break;
    }
    // .CoreML.Specification.SoftmaxLayerParams softmax = 175;
    case kSoftmax: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.softmax_);
      break;
    }
    // .CoreML.Specification.LRNLayerParams lrn = 180;
    case kLrn: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.lrn_);
      break;
    }
    // .CoreML.Specification.CropLayerParams crop = 190;
    case kCrop: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.crop_);
      break;
    }
    // .CoreML.Specification.PaddingLayerParams padding = 200;
    case kPadding: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.padding_);
      break;
    }
    // .CoreML.Specification.UpsampleLayerParams upsample = 210;
    case kUpsample: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.upsample_);
      break;
    }
    // .CoreML.Specification.ResizeBilinearLayerParams resizeBilinear = 211;
    case kResizeBilinear: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.resizebilinear_);
      break;
    }
    // .CoreML.Specification.CropResizeLayerParams cropResize = 212;
    case kCropResize: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.cropresize_);
      break;
    }
    // .CoreML.Specification.UnaryFunctionLayerParams unary = 220;
    case kUnary: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.unary_);
      break;
    }
    // .CoreML.Specification.AddLayerParams add = 230;
    case kAdd: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.add_);
      break;
    }
    // .CoreML.Specification.MultiplyLayerParams multiply = 231;
    case kMultiply: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.multiply_);
      break;
    }
    // .CoreML.Specification.AverageLayerParams average = 240;
    case kAverage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.average_);
      break;
    }
    // .CoreML.Specification.ScaleLayerParams scale = 245;
    case kScale: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.scale_);
      break;
    }
    // .CoreML.Specification.BiasLayerParams bias = 250;
    case kBias: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.bias_);
      break;
    }
    // .CoreML.Specification.MaxLayerParams max = 260;
    case kMax: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.max_);
      break;
    }
    // .CoreML.Specification.MinLayerParams min = 261;
    case kMin: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.min_);
      break;
    }
    // .CoreML.Specification.DotProductLayerParams dot = 270;
    case kDot: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.dot_);
      break;
    }
    // .CoreML.Specification.ReduceLayerParams reduce = 280;
    case kReduce: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.reduce_);
      break;
    }
    // .CoreML.Specification.LoadConstantLayerParams loadConstant = 290;
    case kLoadConstant: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.loadconstant_);
      break;
    }
    // .CoreML.Specification.ReshapeLayerParams reshape = 300;
    case kReshape: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.reshape_);
      break;
    }
    // .CoreML.Specification.FlattenLayerParams flatten = 301;
    case kFlatten: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.flatten_);
      break;
    }
    // .CoreML.Specification.PermuteLayerParams permute = 310;
    case kPermute: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.permute_);
      break;
    }
    // .CoreML.Specification.ConcatLayerParams concat = 320;
    case kConcat: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.concat_);
      break;
    }
    // .CoreML.Specification.SplitLayerParams split = 330;
    case kSplit: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.split_);
      break;
    }
    // .CoreML.Specification.SequenceRepeatLayerParams sequenceRepeat = 340;
    case kSequenceRepeat: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.sequencerepeat_);
      break;
    }
    // .CoreML.Specification.ReorganizeDataLayerParams reorganizeData = 345;
    case kReorganizeData: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.reorganizedata_);
      break;
    }
    // .CoreML.Specification.SliceLayerParams slice = 350;
    case kSlice: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.slice_);
      break;
    }
    // .CoreML.Specification.SimpleRecurrentLayerParams simpleRecurrent = 400;
    case kSimpleRecurrent: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.simplerecurrent_);
      break;
    }
    // .CoreML.Specification.GRULayerParams gru = 410;
    case kGru: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.gru_);
      break;
    }
    // .CoreML.Specification.UniDirectionalLSTMLayerParams uniDirectionalLSTM = 420;
    case kUniDirectionalLSTM: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.unidirectionallstm_);
      break;
    }
    // .CoreML.Specification.BiDirectionalLSTMLayerParams biDirectionalLSTM = 430;
    case kBiDirectionalLSTM: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.bidirectionallstm_);
      break;
    }
    // .CoreML.Specification.CustomLayerParams custom = 500;
    case kCustom: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.custom_);
      break;
    }
    // .CoreML.Specification.CopyLayerParams copy = 600;
    case kCopy: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.copy_);
      break;
    }
    // .CoreML.Specification.BranchLayerParams branch = 605;
    case kBranch: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.branch_);
      break;
    }
    // .CoreML.Specification.LoopLayerParams loop = 615;
    case kLoop: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.loop_);
      break;
    }
    // .CoreML.Specification.LoopBreakLayerParams loopBreak = 620;
    case kLoopBreak: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.loopbreak_);
      break;
    }
    // .CoreML.Specification.LoopContinueLayerParams loopContinue = 625;
    case kLoopContinue: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.loopcontinue_);
      break;
    }
    // .CoreML.Specification.RangeStaticLayerParams rangeStatic = 635;
    case kRangeStatic: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.rangestatic_);
      break;
    }
    // .CoreML.Specification.RangeDynamicLayerParams rangeDynamic = 640;
    case kRangeDynamic: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.rangedynamic_);
      break;
    }
    // .CoreML.Specification.ClipLayerParams clip = 660;
    case kClip: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.clip_);
      break;
    }
    // .CoreML.Specification.CeilLayerParams ceil = 665;
    case kCeil: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.ceil_);
      break;
    }
    // .CoreML.Specification.FloorLayerParams floor = 670;
    case kFloor: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.floor_);
      break;
    }
    // .CoreML.Specification.SignLayerParams sign = 680;
    case kSign: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.sign_);
      break;
    }
    // .CoreML.Specification.RoundLayerParams round = 685;
    case kRound: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.round_);
      break;
    }
    // .CoreML.Specification.Exp2LayerParams exp2 = 700;
    case kExp2: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.exp2_);
      break;
    }
    // .CoreML.Specification.SinLayerParams sin = 710;
    case kSin: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.sin_);
      break;
    }
    // .CoreML.Specification.CosLayerParams cos = 715;
    case kCos: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.cos_);
      break;
    }
    // .CoreML.Specification.TanLayerParams tan = 720;
    case kTan: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.tan_);
      break;
    }
    // .CoreML.Specification.AsinLayerParams asin = 730;
    case kAsin: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.asin_);
      break;
    }
    // .CoreML.Specification.AcosLayerParams acos = 735;
    case kAcos: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.acos_);
      break;
    }
    // .CoreML.Specification.AtanLayerParams atan = 740;
    case kAtan: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.atan_);
      break;
    }
    // .CoreML.Specification.SinhLayerParams sinh = 750;
    case kSinh: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.sinh_);
      break;
    }
    // .CoreML.Specification.CoshLayerParams cosh = 755;
    case kCosh: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.cosh_);
      break;
    }
    // .CoreML.Specification.TanhLayerParams tanh = 760;
    case kTanh: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.tanh_);
      break;
    }
    // .CoreML.Specification.AsinhLayerParams asinh = 770;
    case kAsinh: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.asinh_);
      break;
    }
    // .CoreML.Specification.AcoshLayerParams acosh = 775;
    case kAcosh: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.acosh_);
      break;
    }
    // .CoreML.Specification.AtanhLayerParams atanh = 780;
    case kAtanh: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.atanh_);
      break;
    }
    // .CoreML.Specification.ErfLayerParams erf = 790;
    case kErf: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.erf_);
      break;
    }
    // .CoreML.Specification.GeluLayerParams gelu = 795;
    case kGelu: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.gelu_);
      break;
    }
    // .CoreML.Specification.EqualLayerParams equal = 815;
    case kEqual: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.equal_);
      break;
    }
    // .CoreML.Specification.NotEqualLayerParams notEqual = 820;
    case kNotEqual: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.notequal_);
      break;
    }
    // .CoreML.Specification.LessThanLayerParams lessThan = 825;
    case kLessThan: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.lessthan_);
      break;
    }
    // .CoreML.Specification.LessEqualLayerParams lessEqual = 827;
    case kLessEqual: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.lessequal_);
      break;
    }
    // .CoreML.Specification.GreaterThanLayerParams greaterThan = 830;
    case kGreaterThan: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.greaterthan_);
      break;
    }
    // .CoreML.Specification.GreaterEqualLayerParams greaterEqual = 832;
    case kGreaterEqual: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.greaterequal_);
      break;
    }
    // .CoreML.Specification.LogicalOrLayerParams logicalOr = 840;
    case kLogicalOr: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.logicalor_);
      break;
    }
    // .CoreML.Specification.LogicalXorLayerParams logicalXor = 845;
    case kLogicalXor: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.logicalxor_);
      break;
    }
    // .CoreML.Specification.LogicalNotLayerParams logicalNot = 850;
    case kLogicalNot: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.logicalnot_);
      break;
    }
    // .CoreML.Specification.LogicalAndLayerParams logicalAnd = 855;
    case kLogicalAnd: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.logicaland_);
      break;
    }
    // .CoreML.Specification.ModBroadcastableLayerParams modBroadcastable = 865;
    case kModBroadcastable: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.modbroadcastable_);
      break;
    }
    // .CoreML.Specification.MinBroadcastableLayerParams minBroadcastable = 870;
    case kMinBroadcastable: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.minbroadcastable_);
      break;
    }
    // .CoreML.Specification.MaxBroadcastableLayerParams maxBroadcastable = 875;
    case kMaxBroadcastable: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.maxbroadcastable_);
      break;
    }
    // .CoreML.Specification.AddBroadcastableLayerParams addBroadcastable = 880;
    case kAddBroadcastable: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.addbroadcastable_);
      break;
    }
    // .CoreML.Specification.PowBroadcastableLayerParams powBroadcastable = 885;
    case kPowBroadcastable: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.powbroadcastable_);
      break;
    }
    // .CoreML.Specification.DivideBroadcastableLayerParams divideBroadcastable = 890;
    case kDivideBroadcastable: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.dividebroadcastable_);
      break;
    }
    // .CoreML.Specification.FloorDivBroadcastableLayerParams floorDivBroadcastable = 895;
    case kFloorDivBroadcastable: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.floordivbroadcastable_);
      break;
    }
    // .CoreML.Specification.MultiplyBroadcastableLayerParams multiplyBroadcastable = 900;
    case kMultiplyBroadcastable: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.multiplybroadcastable_);
      break;
    }
    // .CoreML.Specification.SubtractBroadcastableLayerParams subtractBroadcastable = 905;
    case kSubtractBroadcastable: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.subtractbroadcastable_);
      break;
    }
    // .CoreML.Specification.TileLayerParams tile = 920;
    case kTile: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.tile_);
      break;
    }
    // .CoreML.Specification.StackLayerParams stack = 925;
    case kStack: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.stack_);
      break;
    }
    // .CoreML.Specification.GatherLayerParams gather = 930;
    case kGather: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.gather_);
      break;
    }
    // .CoreML.Specification.ScatterLayerParams scatter = 935;
    case kScatter: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.scatter_);
      break;
    }
    // .CoreML.Specification.GatherNDLayerParams gatherND = 940;
    case kGatherND: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.gathernd_);
      break;
    }
    // .CoreML.Specification.ScatterNDLayerParams scatterND = 945;
    case kScatterND: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.scatternd_);
      break;
    }
    // .CoreML.Specification.SoftmaxNDLayerParams softmaxND = 950;
    case kSoftmaxND: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.softmaxnd_);
      break;
    }
    // .CoreML.Specification.GatherAlongAxisLayerParams gatherAlongAxis = 952;
    case kGatherAlongAxis: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.gatheralongaxis_);
      break;
    }
    // .CoreML.Specification.ScatterAlongAxisLayerParams scatterAlongAxis = 954;
    case kScatterAlongAxis: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.scatteralongaxis_);
      break;
    }
    // .CoreML.Specification.ReverseLayerParams reverse = 960;
    case kReverse: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.reverse_);
      break;
    }
    // .CoreML.Specification.ReverseSeqLayerParams reverseSeq = 965;
    case kReverseSeq: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.reverseseq_);
      break;
    }
    // .CoreML.Specification.SplitNDLayerParams splitND = 975;
    case kSplitND: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.splitnd_);
      break;
    }
    // .CoreML.Specification.ConcatNDLayerParams concatND = 980;
    case kConcatND: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.concatnd_);
      break;
    }
    // .CoreML.Specification.TransposeLayerParams transpose = 985;
    case kTranspose: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.transpose_);
      break;
    }
    // .CoreML.Specification.SliceStaticLayerParams sliceStatic = 995;
    case kSliceStatic: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.slicestatic_);
      break;
    }
    // .CoreML.Specification.SliceDynamicLayerParams sliceDynamic = 1000;
    case kSliceDynamic: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.slicedynamic_);
      break;
    }
    // .CoreML.Specification.SlidingWindowsLayerParams slidingWindows = 1005;
    case kSlidingWindows: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.slidingwindows_);
      break;
    }
    // .CoreML.Specification.TopKLayerParams topK = 1015;
    case kTopK: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.topk_);
      break;
    }
    // .CoreML.Specification.ArgMinLayerParams argMin = 1020;
    case kArgMin: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.argmin_);
      break;
    }
    // .CoreML.Specification.ArgMaxLayerParams argMax = 1025;
    case kArgMax: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.argmax_);
      break;
    }
    // .CoreML.Specification.EmbeddingNDLayerParams embeddingND = 1040;
    case kEmbeddingND: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.embeddingnd_);
      break;
    }
    // .CoreML.Specification.BatchedMatMulLayerParams batchedMatmul = 1045;
    case kBatchedMatmul: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.batchedmatmul_);
      break;
    }
    // .CoreML.Specification.GetShapeLayerParams getShape = 1065;
    case kGetShape: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.getshape_);
      break;
    }
    // .CoreML.Specification.LoadConstantNDLayerParams loadConstantND = 1070;
    case kLoadConstantND: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.loadconstantnd_);
      break;
    }
    // .CoreML.Specification.FillLikeLayerParams fillLike = 1080;
    case kFillLike: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.filllike_);
      break;
    }
    // .CoreML.Specification.FillStaticLayerParams fillStatic = 1085;
    case kFillStatic: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.fillstatic_);
      break;
    }
    // .CoreML.Specification.FillDynamicLayerParams fillDynamic = 1090;
    case kFillDynamic: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.filldynamic_);
      break;
    }
    // .CoreML.Specification.BroadcastToLikeLayerParams broadcastToLike = 1100;
    case kBroadcastToLike: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.broadcasttolike_);
      break;
    }
    // .CoreML.Specification.BroadcastToStaticLayerParams broadcastToStatic = 1105;
    case kBroadcastToStatic: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.broadcasttostatic_);
      break;
    }
    // .CoreML.Specification.BroadcastToDynamicLayerParams broadcastToDynamic = 1110;
    case kBroadcastToDynamic: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.broadcasttodynamic_);
      break;
    }
    // .CoreML.Specification.SqueezeLayerParams squeeze = 1120;
    case kSqueeze: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.squeeze_);
      break;
    }
    // .CoreML.Specification.ExpandDimsLayerParams expandDims = 1125;
    case kExpandDims: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.expanddims_);
      break;
    }
    // .CoreML.Specification.FlattenTo2DLayerParams flattenTo2D = 1130;
    case kFlattenTo2D: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.flattento2d_);
      break;
    }
    // .CoreML.Specification.ReshapeLikeLayerParams reshapeLike = 1135;
    case kReshapeLike: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.reshapelike_);
      break;
    }
    // .CoreML.Specification.ReshapeStaticLayerParams reshapeStatic = 1140;
    case kReshapeStatic: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.reshapestatic_);
      break;
    }
    // .CoreML.Specification.ReshapeDynamicLayerParams reshapeDynamic = 1145;
    case kReshapeDynamic: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.reshapedynamic_);
      break;
    }
    // .CoreML.Specification.RankPreservingReshapeLayerParams rankPreservingReshape = 1150;
    case kRankPreservingReshape: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.rankpreservingreshape_);
      break;
    }
    // .CoreML.Specification.ConstantPaddingLayerParams constantPad = 1155;
    case kConstantPad: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.constantpad_);
      break;
    }
    // .CoreML.Specification.RandomNormalLikeLayerParams randomNormalLike = 1170;
    case kRandomNormalLike: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.randomnormallike_);
      break;
    }
    // .CoreML.Specification.RandomNormalStaticLayerParams randomNormalStatic = 1175;
    case kRandomNormalStatic: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.randomnormalstatic_);
      break;
    }
    // .CoreML.Specification.RandomNormalDynamicLayerParams randomNormalDynamic = 1180;
    case kRandomNormalDynamic: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.randomnormaldynamic_);
      break;
    }
    // .CoreML.Specification.RandomUniformLikeLayerParams randomUniformLike = 1190;
    case kRandomUniformLike: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.randomuniformlike_);
      break;
    }
    // .CoreML.Specification.RandomUniformStaticLayerParams randomUniformStatic = 1195;
    case kRandomUniformStatic: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.randomuniformstatic_);
      break;
    }
    // .CoreML.Specification.RandomUniformDynamicLayerParams randomUniformDynamic = 1200;
    case kRandomUniformDynamic: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.randomuniformdynamic_);
      break;
    }
    // .CoreML.Specification.RandomBernoulliLikeLayerParams randomBernoulliLike = 1210;
    case kRandomBernoulliLike: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.randombernoullilike_);
      break;
    }
    // .CoreML.Specification.RandomBernoulliStaticLayerParams randomBernoulliStatic = 1215;
    case kRandomBernoulliStatic: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.randombernoullistatic_);
      break;
    }
    // .CoreML.Specification.RandomBernoulliDynamicLayerParams randomBernoulliDynamic = 1220;
    case kRandomBernoulliDynamic: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.randombernoullidynamic_);
      break;
    }
    // .CoreML.Specification.CategoricalDistributionLayerParams categoricalDistribution = 1230;
    case kCategoricalDistribution: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.categoricaldistribution_);
      break;
    }
    // .CoreML.Specification.ReduceL1LayerParams reduceL1 = 1250;
    case kReduceL1: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.reducel1_);
      break;
    }
    // .CoreML.Specification.ReduceL2LayerParams reduceL2 = 1255;
    case kReduceL2: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.reducel2_);
      break;
    }
    // .CoreML.Specification.ReduceMaxLayerParams reduceMax = 1260;
    case kReduceMax: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.reducemax_);
      break;
    }
    // .CoreML.Specification.ReduceMinLayerParams reduceMin = 1265;
    case kReduceMin: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.reducemin_);
      break;
    }
    // .CoreML.Specification.ReduceSumLayerParams reduceSum = 1270;
    case kReduceSum: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.reducesum_);
      break;
    }
    // .CoreML.Specification.ReduceProdLayerParams reduceProd = 1275;
    case kReduceProd: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.reduceprod_);
      break;
    }
    // .CoreML.Specification.ReduceMeanLayerParams reduceMean = 1280;
    case kReduceMean: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.reducemean_);
      break;
    }
    // .CoreML.Specification.ReduceLogSumLayerParams reduceLogSum = 1285;
    case kReduceLogSum: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.reducelogsum_);
      break;
    }
    // .CoreML.Specification.ReduceSumSquareLayerParams reduceSumSquare = 1290;
    case kReduceSumSquare: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.reducesumsquare_);
      break;
    }
    // .CoreML.Specification.ReduceLogSumExpLayerParams reduceLogSumExp = 1295;
    case kReduceLogSumExp: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.reducelogsumexp_);
      break;
    }
    // .CoreML.Specification.WhereNonZeroLayerParams whereNonZero = 1313;
    case kWhereNonZero: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.wherenonzero_);
      break;
    }
    // .CoreML.Specification.MatrixBandPartLayerParams matrixBandPart = 1315;
    case kMatrixBandPart: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.matrixbandpart_);
      break;
    }
    // .CoreML.Specification.LowerTriangularLayerParams lowerTriangular = 1320;
    case kLowerTriangular: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.lowertriangular_);
      break;
    }
    // .CoreML.Specification.UpperTriangularLayerParams upperTriangular = 1325;
    case kUpperTriangular: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.uppertriangular_);
      break;
    }
    // .CoreML.Specification.WhereBroadcastableLayerParams whereBroadcastable = 1330;
    case kWhereBroadcastable: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.wherebroadcastable_);
      break;
    }
    // .CoreML.Specification.LayerNormalizationLayerParams layerNormalization = 1350;
    case kLayerNormalization: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.layernormalization_);
      break;
    }
    // .CoreML.Specification.NonMaximumSuppressionLayerParams NonMaximumSuppression = 1400;
    case kNonMaximumSuppression: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.nonmaximumsuppression_);
      break;
    }
    // .CoreML.Specification.OneHotLayerParams oneHot = 1450;
    case kOneHot: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.onehot_);
      break;
    }
    // .CoreML.Specification.CumSumLayerParams cumSum = 1455;
    case kCumSum: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.cumsum_);
      break;
    }
    // .CoreML.Specification.ClampedReLULayerParams clampedReLU = 1460;
    case kClampedReLU: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.clampedrelu_);
      break;
    }
    // .CoreML.Specification.ArgSortLayerParams argSort = 1461;
    case kArgSort: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.argsort_);
      break;
    }
    // .CoreML.Specification.Pooling3DLayerParams pooling3d = 1465;
    case kPooling3D: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.pooling3d_);
      break;
    }
    // .CoreML.Specification.GlobalPooling3DLayerParams globalPooling3d = 1466;
    case kGlobalPooling3D: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.globalpooling3d_);
      break;
    }
    // .CoreML.Specification.SliceBySizeLayerParams sliceBySize = 1470;
    case kSliceBySize: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.slicebysize_);
      break;
    }
    // .CoreML.Specification.Convolution3DLayerParams convolution3d = 1471;
    case kConvolution3D: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_.convolution3d_);
      break;
    }
    case LAYER_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NeuralNetworkLayer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const NeuralNetworkLayer*>(
      &from));
}

void NeuralNetworkLayer::MergeFrom(const NeuralNetworkLayer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.NeuralNetworkLayer)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  input_.MergeFrom(from.input_);
  output_.MergeFrom(from.output_);
  inputtensor_.MergeFrom(from.inputtensor_);
  outputtensor_.MergeFrom(from.outputtensor_);
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_isupdatable() != 0) {
    _internal_set_isupdatable(from._internal_isupdatable());
  }
  switch (from.layer_case()) {
    case kConvolution: {
      _internal_mutable_convolution()->::CoreML::Specification::ConvolutionLayerParams::MergeFrom(from._internal_convolution());
      break;
    }
    case kPooling: {
      _internal_mutable_pooling()->::CoreML::Specification::PoolingLayerParams::MergeFrom(from._internal_pooling());
      break;
    }
    case kActivation: {
      _internal_mutable_activation()->::CoreML::Specification::ActivationParams::MergeFrom(from._internal_activation());
      break;
    }
    case kInnerProduct: {
      _internal_mutable_innerproduct()->::CoreML::Specification::InnerProductLayerParams::MergeFrom(from._internal_innerproduct());
      break;
    }
    case kEmbedding: {
      _internal_mutable_embedding()->::CoreML::Specification::EmbeddingLayerParams::MergeFrom(from._internal_embedding());
      break;
    }
    case kBatchnorm: {
      _internal_mutable_batchnorm()->::CoreML::Specification::BatchnormLayerParams::MergeFrom(from._internal_batchnorm());
      break;
    }
    case kMvn: {
      _internal_mutable_mvn()->::CoreML::Specification::MeanVarianceNormalizeLayerParams::MergeFrom(from._internal_mvn());
      break;
    }
    case kL2Normalize: {
      _internal_mutable_l2normalize()->::CoreML::Specification::L2NormalizeLayerParams::MergeFrom(from._internal_l2normalize());
      break;
    }
    case kSoftmax: {
      _internal_mutable_softmax()->::CoreML::Specification::SoftmaxLayerParams::MergeFrom(from._internal_softmax());
      break;
    }
    case kLrn: {
      _internal_mutable_lrn()->::CoreML::Specification::LRNLayerParams::MergeFrom(from._internal_lrn());
      break;
    }
    case kCrop: {
      _internal_mutable_crop()->::CoreML::Specification::CropLayerParams::MergeFrom(from._internal_crop());
      break;
    }
    case kPadding: {
      _internal_mutable_padding()->::CoreML::Specification::PaddingLayerParams::MergeFrom(from._internal_padding());
      break;
    }
    case kUpsample: {
      _internal_mutable_upsample()->::CoreML::Specification::UpsampleLayerParams::MergeFrom(from._internal_upsample());
      break;
    }
    case kResizeBilinear: {
      _internal_mutable_resizebilinear()->::CoreML::Specification::ResizeBilinearLayerParams::MergeFrom(from._internal_resizebilinear());
      break;
    }
    case kCropResize: {
      _internal_mutable_cropresize()->::CoreML::Specification::CropResizeLayerParams::MergeFrom(from._internal_cropresize());
      break;
    }
    case kUnary: {
      _internal_mutable_unary()->::CoreML::Specification::UnaryFunctionLayerParams::MergeFrom(from._internal_unary());
      break;
    }
    case kAdd: {
      _internal_mutable_add()->::CoreML::Specification::AddLayerParams::MergeFrom(from._internal_add());
      break;
    }
    case kMultiply: {
      _internal_mutable_multiply()->::CoreML::Specification::MultiplyLayerParams::MergeFrom(from._internal_multiply());
      break;
    }
    case kAverage: {
      _internal_mutable_average()->::CoreML::Specification::AverageLayerParams::MergeFrom(from._internal_average());
      break;
    }
    case kScale: {
      _internal_mutable_scale()->::CoreML::Specification::ScaleLayerParams::MergeFrom(from._internal_scale());
      break;
    }
    case kBias: {
      _internal_mutable_bias()->::CoreML::Specification::BiasLayerParams::MergeFrom(from._internal_bias());
      break;
    }
    case kMax: {
      _internal_mutable_max()->::CoreML::Specification::MaxLayerParams::MergeFrom(from._internal_max());
      break;
    }
    case kMin: {
      _internal_mutable_min()->::CoreML::Specification::MinLayerParams::MergeFrom(from._internal_min());
      break;
    }
    case kDot: {
      _internal_mutable_dot()->::CoreML::Specification::DotProductLayerParams::MergeFrom(from._internal_dot());
      break;
    }
    case kReduce: {
      _internal_mutable_reduce()->::CoreML::Specification::ReduceLayerParams::MergeFrom(from._internal_reduce());
      break;
    }
    case kLoadConstant: {
      _internal_mutable_loadconstant()->::CoreML::Specification::LoadConstantLayerParams::MergeFrom(from._internal_loadconstant());
      break;
    }
    case kReshape: {
      _internal_mutable_reshape()->::CoreML::Specification::ReshapeLayerParams::MergeFrom(from._internal_reshape());
      break;
    }
    case kFlatten: {
      _internal_mutable_flatten()->::CoreML::Specification::FlattenLayerParams::MergeFrom(from._internal_flatten());
      break;
    }
    case kPermute: {
      _internal_mutable_permute()->::CoreML::Specification::PermuteLayerParams::MergeFrom(from._internal_permute());
      break;
    }
    case kConcat: {
      _internal_mutable_concat()->::CoreML::Specification::ConcatLayerParams::MergeFrom(from._internal_concat());
      break;
    }
    case kSplit: {
      _internal_mutable_split()->::CoreML::Specification::SplitLayerParams::MergeFrom(from._internal_split());
      break;
    }
    case kSequenceRepeat: {
      _internal_mutable_sequencerepeat()->::CoreML::Specification::SequenceRepeatLayerParams::MergeFrom(from._internal_sequencerepeat());
      break;
    }
    case kReorganizeData: {
      _internal_mutable_reorganizedata()->::CoreML::Specification::ReorganizeDataLayerParams::MergeFrom(from._internal_reorganizedata());
      break;
    }
    case kSlice: {
      _internal_mutable_slice()->::CoreML::Specification::SliceLayerParams::MergeFrom(from._internal_slice());
      break;
    }
    case kSimpleRecurrent: {
      _internal_mutable_simplerecurrent()->::CoreML::Specification::SimpleRecurrentLayerParams::MergeFrom(from._internal_simplerecurrent());
      break;
    }
    case kGru: {
      _internal_mutable_gru()->::CoreML::Specification::GRULayerParams::MergeFrom(from._internal_gru());
      break;
    }
    case kUniDirectionalLSTM: {
      _internal_mutable_unidirectionallstm()->::CoreML::Specification::UniDirectionalLSTMLayerParams::MergeFrom(from._internal_unidirectionallstm());
      break;
    }
    case kBiDirectionalLSTM: {
      _internal_mutable_bidirectionallstm()->::CoreML::Specification::BiDirectionalLSTMLayerParams::MergeFrom(from._internal_bidirectionallstm());
      break;
    }
    case kCustom: {
      _internal_mutable_custom()->::CoreML::Specification::CustomLayerParams::MergeFrom(from._internal_custom());
      break;
    }
    case kCopy: {
      _internal_mutable_copy()->::CoreML::Specification::CopyLayerParams::MergeFrom(from._internal_copy());
      break;
    }
    case kBranch: {
      _internal_mutable_branch()->::CoreML::Specification::BranchLayerParams::MergeFrom(from._internal_branch());
      break;
    }
    case kLoop: {
      _internal_mutable_loop()->::CoreML::Specification::LoopLayerParams::MergeFrom(from._internal_loop());
      break;
    }
    case kLoopBreak: {
      _internal_mutable_loopbreak()->::CoreML::Specification::LoopBreakLayerParams::MergeFrom(from._internal_loopbreak());
      break;
    }
    case kLoopContinue: {
      _internal_mutable_loopcontinue()->::CoreML::Specification::LoopContinueLayerParams::MergeFrom(from._internal_loopcontinue());
      break;
    }
    case kRangeStatic: {
      _internal_mutable_rangestatic()->::CoreML::Specification::RangeStaticLayerParams::MergeFrom(from._internal_rangestatic());
      break;
    }
    case kRangeDynamic: {
      _internal_mutable_rangedynamic()->::CoreML::Specification::RangeDynamicLayerParams::MergeFrom(from._internal_rangedynamic());
      break;
    }
    case kClip: {
      _internal_mutable_clip()->::CoreML::Specification::ClipLayerParams::MergeFrom(from._internal_clip());
      break;
    }
    case kCeil: {
      _internal_mutable_ceil()->::CoreML::Specification::CeilLayerParams::MergeFrom(from._internal_ceil());
      break;
    }
    case kFloor: {
      _internal_mutable_floor()->::CoreML::Specification::FloorLayerParams::MergeFrom(from._internal_floor());
      break;
    }
    case kSign: {
      _internal_mutable_sign()->::CoreML::Specification::SignLayerParams::MergeFrom(from._internal_sign());
      break;
    }
    case kRound: {
      _internal_mutable_round()->::CoreML::Specification::RoundLayerParams::MergeFrom(from._internal_round());
      break;
    }
    case kExp2: {
      _internal_mutable_exp2()->::CoreML::Specification::Exp2LayerParams::MergeFrom(from._internal_exp2());
      break;
    }
    case kSin: {
      _internal_mutable_sin()->::CoreML::Specification::SinLayerParams::MergeFrom(from._internal_sin());
      break;
    }
    case kCos: {
      _internal_mutable_cos()->::CoreML::Specification::CosLayerParams::MergeFrom(from._internal_cos());
      break;
    }
    case kTan: {
      _internal_mutable_tan()->::CoreML::Specification::TanLayerParams::MergeFrom(from._internal_tan());
      break;
    }
    case kAsin: {
      _internal_mutable_asin()->::CoreML::Specification::AsinLayerParams::MergeFrom(from._internal_asin());
      break;
    }
    case kAcos: {
      _internal_mutable_acos()->::CoreML::Specification::AcosLayerParams::MergeFrom(from._internal_acos());
      break;
    }
    case kAtan: {
      _internal_mutable_atan()->::CoreML::Specification::AtanLayerParams::MergeFrom(from._internal_atan());
      break;
    }
    case kSinh: {
      _internal_mutable_sinh()->::CoreML::Specification::SinhLayerParams::MergeFrom(from._internal_sinh());
      break;
    }
    case kCosh: {
      _internal_mutable_cosh()->::CoreML::Specification::CoshLayerParams::MergeFrom(from._internal_cosh());
      break;
    }
    case kTanh: {
      _internal_mutable_tanh()->::CoreML::Specification::TanhLayerParams::MergeFrom(from._internal_tanh());
      break;
    }
    case kAsinh: {
      _internal_mutable_asinh()->::CoreML::Specification::AsinhLayerParams::MergeFrom(from._internal_asinh());
      break;
    }
    case kAcosh: {
      _internal_mutable_acosh()->::CoreML::Specification::AcoshLayerParams::MergeFrom(from._internal_acosh());
      break;
    }
    case kAtanh: {
      _internal_mutable_atanh()->::CoreML::Specification::AtanhLayerParams::MergeFrom(from._internal_atanh());
      break;
    }
    case kErf: {
      _internal_mutable_erf()->::CoreML::Specification::ErfLayerParams::MergeFrom(from._internal_erf());
      break;
    }
    case kGelu: {
      _internal_mutable_gelu()->::CoreML::Specification::GeluLayerParams::MergeFrom(from._internal_gelu());
      break;
    }
    case kEqual: {
      _internal_mutable_equal()->::CoreML::Specification::EqualLayerParams::MergeFrom(from._internal_equal());
      break;
    }
    case kNotEqual: {
      _internal_mutable_notequal()->::CoreML::Specification::NotEqualLayerParams::MergeFrom(from._internal_notequal());
      break;
    }
    case kLessThan: {
      _internal_mutable_lessthan()->::CoreML::Specification::LessThanLayerParams::MergeFrom(from._internal_lessthan());
      break;
    }
    case kLessEqual: {
      _internal_mutable_lessequal()->::CoreML::Specification::LessEqualLayerParams::MergeFrom(from._internal_lessequal());
      break;
    }
    case kGreaterThan: {
      _internal_mutable_greaterthan()->::CoreML::Specification::GreaterThanLayerParams::MergeFrom(from._internal_greaterthan());
      break;
    }
    case kGreaterEqual: {
      _internal_mutable_greaterequal()->::CoreML::Specification::GreaterEqualLayerParams::MergeFrom(from._internal_greaterequal());
      break;
    }
    case kLogicalOr: {
      _internal_mutable_logicalor()->::CoreML::Specification::LogicalOrLayerParams::MergeFrom(from._internal_logicalor());
      break;
    }
    case kLogicalXor: {
      _internal_mutable_logicalxor()->::CoreML::Specification::LogicalXorLayerParams::MergeFrom(from._internal_logicalxor());
      break;
    }
    case kLogicalNot: {
      _internal_mutable_logicalnot()->::CoreML::Specification::LogicalNotLayerParams::MergeFrom(from._internal_logicalnot());
      break;
    }
    case kLogicalAnd: {
      _internal_mutable_logicaland()->::CoreML::Specification::LogicalAndLayerParams::MergeFrom(from._internal_logicaland());
      break;
    }
    case kModBroadcastable: {
      _internal_mutable_modbroadcastable()->::CoreML::Specification::ModBroadcastableLayerParams::MergeFrom(from._internal_modbroadcastable());
      break;
    }
    case kMinBroadcastable: {
      _internal_mutable_minbroadcastable()->::CoreML::Specification::MinBroadcastableLayerParams::MergeFrom(from._internal_minbroadcastable());
      break;
    }
    case kMaxBroadcastable: {
      _internal_mutable_maxbroadcastable()->::CoreML::Specification::MaxBroadcastableLayerParams::MergeFrom(from._internal_maxbroadcastable());
      break;
    }
    case kAddBroadcastable: {
      _internal_mutable_addbroadcastable()->::CoreML::Specification::AddBroadcastableLayerParams::MergeFrom(from._internal_addbroadcastable());
      break;
    }
    case kPowBroadcastable: {
      _internal_mutable_powbroadcastable()->::CoreML::Specification::PowBroadcastableLayerParams::MergeFrom(from._internal_powbroadcastable());
      break;
    }
    case kDivideBroadcastable: {
      _internal_mutable_dividebroadcastable()->::CoreML::Specification::DivideBroadcastableLayerParams::MergeFrom(from._internal_dividebroadcastable());
      break;
    }
    case kFloorDivBroadcastable: {
      _internal_mutable_floordivbroadcastable()->::CoreML::Specification::FloorDivBroadcastableLayerParams::MergeFrom(from._internal_floordivbroadcastable());
      break;
    }
    case kMultiplyBroadcastable: {
      _internal_mutable_multiplybroadcastable()->::CoreML::Specification::MultiplyBroadcastableLayerParams::MergeFrom(from._internal_multiplybroadcastable());
      break;
    }
    case kSubtractBroadcastable: {
      _internal_mutable_subtractbroadcastable()->::CoreML::Specification::SubtractBroadcastableLayerParams::MergeFrom(from._internal_subtractbroadcastable());
      break;
    }
    case kTile: {
      _internal_mutable_tile()->::CoreML::Specification::TileLayerParams::MergeFrom(from._internal_tile());
      break;
    }
    case kStack: {
      _internal_mutable_stack()->::CoreML::Specification::StackLayerParams::MergeFrom(from._internal_stack());
      break;
    }
    case kGather: {
      _internal_mutable_gather()->::CoreML::Specification::GatherLayerParams::MergeFrom(from._internal_gather());
      break;
    }
    case kScatter: {
      _internal_mutable_scatter()->::CoreML::Specification::ScatterLayerParams::MergeFrom(from._internal_scatter());
      break;
    }
    case kGatherND: {
      _internal_mutable_gathernd()->::CoreML::Specification::GatherNDLayerParams::MergeFrom(from._internal_gathernd());
      break;
    }
    case kScatterND: {
      _internal_mutable_scatternd()->::CoreML::Specification::ScatterNDLayerParams::MergeFrom(from._internal_scatternd());
      break;
    }
    case kSoftmaxND: {
      _internal_mutable_softmaxnd()->::CoreML::Specification::SoftmaxNDLayerParams::MergeFrom(from._internal_softmaxnd());
      break;
    }
    case kGatherAlongAxis: {
      _internal_mutable_gatheralongaxis()->::CoreML::Specification::GatherAlongAxisLayerParams::MergeFrom(from._internal_gatheralongaxis());
      break;
    }
    case kScatterAlongAxis: {
      _internal_mutable_scatteralongaxis()->::CoreML::Specification::ScatterAlongAxisLayerParams::MergeFrom(from._internal_scatteralongaxis());
      break;
    }
    case kReverse: {
      _internal_mutable_reverse()->::CoreML::Specification::ReverseLayerParams::MergeFrom(from._internal_reverse());
      break;
    }
    case kReverseSeq: {
      _internal_mutable_reverseseq()->::CoreML::Specification::ReverseSeqLayerParams::MergeFrom(from._internal_reverseseq());
      break;
    }
    case kSplitND: {
      _internal_mutable_splitnd()->::CoreML::Specification::SplitNDLayerParams::MergeFrom(from._internal_splitnd());
      break;
    }
    case kConcatND: {
      _internal_mutable_concatnd()->::CoreML::Specification::ConcatNDLayerParams::MergeFrom(from._internal_concatnd());
      break;
    }
    case kTranspose: {
      _internal_mutable_transpose()->::CoreML::Specification::TransposeLayerParams::MergeFrom(from._internal_transpose());
      break;
    }
    case kSliceStatic: {
      _internal_mutable_slicestatic()->::CoreML::Specification::SliceStaticLayerParams::MergeFrom(from._internal_slicestatic());
      break;
    }
    case kSliceDynamic: {
      _internal_mutable_slicedynamic()->::CoreML::Specification::SliceDynamicLayerParams::MergeFrom(from._internal_slicedynamic());
      break;
    }
    case kSlidingWindows: {
      _internal_mutable_slidingwindows()->::CoreML::Specification::SlidingWindowsLayerParams::MergeFrom(from._internal_slidingwindows());
      break;
    }
    case kTopK: {
      _internal_mutable_topk()->::CoreML::Specification::TopKLayerParams::MergeFrom(from._internal_topk());
      break;
    }
    case kArgMin: {
      _internal_mutable_argmin()->::CoreML::Specification::ArgMinLayerParams::MergeFrom(from._internal_argmin());
      break;
    }
    case kArgMax: {
      _internal_mutable_argmax()->::CoreML::Specification::ArgMaxLayerParams::MergeFrom(from._internal_argmax());
      break;
    }
    case kEmbeddingND: {
      _internal_mutable_embeddingnd()->::CoreML::Specification::EmbeddingNDLayerParams::MergeFrom(from._internal_embeddingnd());
      break;
    }
    case kBatchedMatmul: {
      _internal_mutable_batchedmatmul()->::CoreML::Specification::BatchedMatMulLayerParams::MergeFrom(from._internal_batchedmatmul());
      break;
    }
    case kGetShape: {
      _internal_mutable_getshape()->::CoreML::Specification::GetShapeLayerParams::MergeFrom(from._internal_getshape());
      break;
    }
    case kLoadConstantND: {
      _internal_mutable_loadconstantnd()->::CoreML::Specification::LoadConstantNDLayerParams::MergeFrom(from._internal_loadconstantnd());
      break;
    }
    case kFillLike: {
      _internal_mutable_filllike()->::CoreML::Specification::FillLikeLayerParams::MergeFrom(from._internal_filllike());
      break;
    }
    case kFillStatic: {
      _internal_mutable_fillstatic()->::CoreML::Specification::FillStaticLayerParams::MergeFrom(from._internal_fillstatic());
      break;
    }
    case kFillDynamic: {
      _internal_mutable_filldynamic()->::CoreML::Specification::FillDynamicLayerParams::MergeFrom(from._internal_filldynamic());
      break;
    }
    case kBroadcastToLike: {
      _internal_mutable_broadcasttolike()->::CoreML::Specification::BroadcastToLikeLayerParams::MergeFrom(from._internal_broadcasttolike());
      break;
    }
    case kBroadcastToStatic: {
      _internal_mutable_broadcasttostatic()->::CoreML::Specification::BroadcastToStaticLayerParams::MergeFrom(from._internal_broadcasttostatic());
      break;
    }
    case kBroadcastToDynamic: {
      _internal_mutable_broadcasttodynamic()->::CoreML::Specification::BroadcastToDynamicLayerParams::MergeFrom(from._internal_broadcasttodynamic());
      break;
    }
    case kSqueeze: {
      _internal_mutable_squeeze()->::CoreML::Specification::SqueezeLayerParams::MergeFrom(from._internal_squeeze());
      break;
    }
    case kExpandDims: {
      _internal_mutable_expanddims()->::CoreML::Specification::ExpandDimsLayerParams::MergeFrom(from._internal_expanddims());
      break;
    }
    case kFlattenTo2D: {
      _internal_mutable_flattento2d()->::CoreML::Specification::FlattenTo2DLayerParams::MergeFrom(from._internal_flattento2d());
      break;
    }
    case kReshapeLike: {
      _internal_mutable_reshapelike()->::CoreML::Specification::ReshapeLikeLayerParams::MergeFrom(from._internal_reshapelike());
      break;
    }
    case kReshapeStatic: {
      _internal_mutable_reshapestatic()->::CoreML::Specification::ReshapeStaticLayerParams::MergeFrom(from._internal_reshapestatic());
      break;
    }
    case kReshapeDynamic: {
      _internal_mutable_reshapedynamic()->::CoreML::Specification::ReshapeDynamicLayerParams::MergeFrom(from._internal_reshapedynamic());
      break;
    }
    case kRankPreservingReshape: {
      _internal_mutable_rankpreservingreshape()->::CoreML::Specification::RankPreservingReshapeLayerParams::MergeFrom(from._internal_rankpreservingreshape());
      break;
    }
    case kConstantPad: {
      _internal_mutable_constantpad()->::CoreML::Specification::ConstantPaddingLayerParams::MergeFrom(from._internal_constantpad());
      break;
    }
    case kRandomNormalLike: {
      _internal_mutable_randomnormallike()->::CoreML::Specification::RandomNormalLikeLayerParams::MergeFrom(from._internal_randomnormallike());
      break;
    }
    case kRandomNormalStatic: {
      _internal_mutable_randomnormalstatic()->::CoreML::Specification::RandomNormalStaticLayerParams::MergeFrom(from._internal_randomnormalstatic());
      break;
    }
    case kRandomNormalDynamic: {
      _internal_mutable_randomnormaldynamic()->::CoreML::Specification::RandomNormalDynamicLayerParams::MergeFrom(from._internal_randomnormaldynamic());
      break;
    }
    case kRandomUniformLike: {
      _internal_mutable_randomuniformlike()->::CoreML::Specification::RandomUniformLikeLayerParams::MergeFrom(from._internal_randomuniformlike());
      break;
    }
    case kRandomUniformStatic: {
      _internal_mutable_randomuniformstatic()->::CoreML::Specification::RandomUniformStaticLayerParams::MergeFrom(from._internal_randomuniformstatic());
      break;
    }
    case kRandomUniformDynamic: {
      _internal_mutable_randomuniformdynamic()->::CoreML::Specification::RandomUniformDynamicLayerParams::MergeFrom(from._internal_randomuniformdynamic());
      break;
    }
    case kRandomBernoulliLike: {
      _internal_mutable_randombernoullilike()->::CoreML::Specification::RandomBernoulliLikeLayerParams::MergeFrom(from._internal_randombernoullilike());
      break;
    }
    case kRandomBernoulliStatic: {
      _internal_mutable_randombernoullistatic()->::CoreML::Specification::RandomBernoulliStaticLayerParams::MergeFrom(from._internal_randombernoullistatic());
      break;
    }
    case kRandomBernoulliDynamic: {
      _internal_mutable_randombernoullidynamic()->::CoreML::Specification::RandomBernoulliDynamicLayerParams::MergeFrom(from._internal_randombernoullidynamic());
      break;
    }
    case kCategoricalDistribution: {
      _internal_mutable_categoricaldistribution()->::CoreML::Specification::CategoricalDistributionLayerParams::MergeFrom(from._internal_categoricaldistribution());
      break;
    }
    case kReduceL1: {
      _internal_mutable_reducel1()->::CoreML::Specification::ReduceL1LayerParams::MergeFrom(from._internal_reducel1());
      break;
    }
    case kReduceL2: {
      _internal_mutable_reducel2()->::CoreML::Specification::ReduceL2LayerParams::MergeFrom(from._internal_reducel2());
      break;
    }
    case kReduceMax: {
      _internal_mutable_reducemax()->::CoreML::Specification::ReduceMaxLayerParams::MergeFrom(from._internal_reducemax());
      break;
    }
    case kReduceMin: {
      _internal_mutable_reducemin()->::CoreML::Specification::ReduceMinLayerParams::MergeFrom(from._internal_reducemin());
      break;
    }
    case kReduceSum: {
      _internal_mutable_reducesum()->::CoreML::Specification::ReduceSumLayerParams::MergeFrom(from._internal_reducesum());
      break;
    }
    case kReduceProd: {
      _internal_mutable_reduceprod()->::CoreML::Specification::ReduceProdLayerParams::MergeFrom(from._internal_reduceprod());
      break;
    }
    case kReduceMean: {
      _internal_mutable_reducemean()->::CoreML::Specification::ReduceMeanLayerParams::MergeFrom(from._internal_reducemean());
      break;
    }
    case kReduceLogSum: {
      _internal_mutable_reducelogsum()->::CoreML::Specification::ReduceLogSumLayerParams::MergeFrom(from._internal_reducelogsum());
      break;
    }
    case kReduceSumSquare: {
      _internal_mutable_reducesumsquare()->::CoreML::Specification::ReduceSumSquareLayerParams::MergeFrom(from._internal_reducesumsquare());
      break;
    }
    case kReduceLogSumExp: {
      _internal_mutable_reducelogsumexp()->::CoreML::Specification::ReduceLogSumExpLayerParams::MergeFrom(from._internal_reducelogsumexp());
      break;
    }
    case kWhereNonZero: {
      _internal_mutable_wherenonzero()->::CoreML::Specification::WhereNonZeroLayerParams::MergeFrom(from._internal_wherenonzero());
      break;
    }
    case kMatrixBandPart: {
      _internal_mutable_matrixbandpart()->::CoreML::Specification::MatrixBandPartLayerParams::MergeFrom(from._internal_matrixbandpart());
      break;
    }
    case kLowerTriangular: {
      _internal_mutable_lowertriangular()->::CoreML::Specification::LowerTriangularLayerParams::MergeFrom(from._internal_lowertriangular());
      break;
    }
    case kUpperTriangular: {
      _internal_mutable_uppertriangular()->::CoreML::Specification::UpperTriangularLayerParams::MergeFrom(from._internal_uppertriangular());
      break;
    }
    case kWhereBroadcastable: {
      _internal_mutable_wherebroadcastable()->::CoreML::Specification::WhereBroadcastableLayerParams::MergeFrom(from._internal_wherebroadcastable());
      break;
    }
    case kLayerNormalization: {
      _internal_mutable_layernormalization()->::CoreML::Specification::LayerNormalizationLayerParams::MergeFrom(from._internal_layernormalization());
      break;
    }
    case kNonMaximumSuppression: {
      _internal_mutable_nonmaximumsuppression()->::CoreML::Specification::NonMaximumSuppressionLayerParams::MergeFrom(from._internal_nonmaximumsuppression());
      break;
    }
    case kOneHot: {
      _internal_mutable_onehot()->::CoreML::Specification::OneHotLayerParams::MergeFrom(from._internal_onehot());
      break;
    }
    case kCumSum: {
      _internal_mutable_cumsum()->::CoreML::Specification::CumSumLayerParams::MergeFrom(from._internal_cumsum());
      break;
    }
    case kClampedReLU: {
      _internal_mutable_clampedrelu()->::CoreML::Specification::ClampedReLULayerParams::MergeFrom(from._internal_clampedrelu());
      break;
    }
    case kArgSort: {
      _internal_mutable_argsort()->::CoreML::Specification::ArgSortLayerParams::MergeFrom(from._internal_argsort());
      break;
    }
    case kPooling3D: {
      _internal_mutable_pooling3d()->::CoreML::Specification::Pooling3DLayerParams::MergeFrom(from._internal_pooling3d());
      break;
    }
    case kGlobalPooling3D: {
      _internal_mutable_globalpooling3d()->::CoreML::Specification::GlobalPooling3DLayerParams::MergeFrom(from._internal_globalpooling3d());
      break;
    }
    case kSliceBySize: {
      _internal_mutable_slicebysize()->::CoreML::Specification::SliceBySizeLayerParams::MergeFrom(from._internal_slicebysize());
      break;
    }
    case kConvolution3D: {
      _internal_mutable_convolution3d()->::CoreML::Specification::Convolution3DLayerParams::MergeFrom(from._internal_convolution3d());
      break;
    }
    case LAYER_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NeuralNetworkLayer::CopyFrom(const NeuralNetworkLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.NeuralNetworkLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NeuralNetworkLayer::IsInitialized() const {
  return true;
}

void NeuralNetworkLayer::InternalSwap(NeuralNetworkLayer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  input_.InternalSwap(&other->input_);
  output_.InternalSwap(&other->output_);
  inputtensor_.InternalSwap(&other->inputtensor_);
  outputtensor_.InternalSwap(&other->outputtensor_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(isupdatable_, other->isupdatable_);
  swap(layer_, other->layer_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string NeuralNetworkLayer::GetTypeName() const {
  return "CoreML.Specification.NeuralNetworkLayer";
}


// ===================================================================

class BranchLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::NeuralNetwork& ifbranch(const BranchLayerParams* msg);
  static const ::CoreML::Specification::NeuralNetwork& elsebranch(const BranchLayerParams* msg);
};

const ::CoreML::Specification::NeuralNetwork&
BranchLayerParams::_Internal::ifbranch(const BranchLayerParams* msg) {
  return *msg->ifbranch_;
}
const ::CoreML::Specification::NeuralNetwork&
BranchLayerParams::_Internal::elsebranch(const BranchLayerParams* msg) {
  return *msg->elsebranch_;
}
BranchLayerParams::BranchLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.BranchLayerParams)
}
BranchLayerParams::BranchLayerParams(const BranchLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_ifbranch()) {
    ifbranch_ = new ::CoreML::Specification::NeuralNetwork(*from.ifbranch_);
  } else {
    ifbranch_ = nullptr;
  }
  if (from._internal_has_elsebranch()) {
    elsebranch_ = new ::CoreML::Specification::NeuralNetwork(*from.elsebranch_);
  } else {
    elsebranch_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.BranchLayerParams)
}

inline void BranchLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ifbranch_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&elsebranch_) -
    reinterpret_cast<char*>(&ifbranch_)) + sizeof(elsebranch_));
}

BranchLayerParams::~BranchLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.BranchLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BranchLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete ifbranch_;
  if (this != internal_default_instance()) delete elsebranch_;
}

void BranchLayerParams::ArenaDtor(void* object) {
  BranchLayerParams* _this = reinterpret_cast< BranchLayerParams* >(object);
  (void)_this;
}
void BranchLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BranchLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BranchLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.BranchLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && ifbranch_ != nullptr) {
    delete ifbranch_;
  }
  ifbranch_ = nullptr;
  if (GetArenaForAllocation() == nullptr && elsebranch_ != nullptr) {
    delete elsebranch_;
  }
  elsebranch_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* BranchLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.NeuralNetwork ifBranch = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ifbranch(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NeuralNetwork elseBranch = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_elsebranch(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BranchLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.BranchLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.NeuralNetwork ifBranch = 1;
  if (this->_internal_has_ifbranch()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::ifbranch(this), target, stream);
  }

  // .CoreML.Specification.NeuralNetwork elseBranch = 2;
  if (this->_internal_has_elsebranch()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::elsebranch(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.BranchLayerParams)
  return target;
}

size_t BranchLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.BranchLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.NeuralNetwork ifBranch = 1;
  if (this->_internal_has_ifbranch()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *ifbranch_);
  }

  // .CoreML.Specification.NeuralNetwork elseBranch = 2;
  if (this->_internal_has_elsebranch()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *elsebranch_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BranchLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BranchLayerParams*>(
      &from));
}

void BranchLayerParams::MergeFrom(const BranchLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.BranchLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ifbranch()) {
    _internal_mutable_ifbranch()->::CoreML::Specification::NeuralNetwork::MergeFrom(from._internal_ifbranch());
  }
  if (from._internal_has_elsebranch()) {
    _internal_mutable_elsebranch()->::CoreML::Specification::NeuralNetwork::MergeFrom(from._internal_elsebranch());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BranchLayerParams::CopyFrom(const BranchLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.BranchLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BranchLayerParams::IsInitialized() const {
  return true;
}

void BranchLayerParams::InternalSwap(BranchLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BranchLayerParams, elsebranch_)
      + sizeof(BranchLayerParams::elsebranch_)
      - PROTOBUF_FIELD_OFFSET(BranchLayerParams, ifbranch_)>(
          reinterpret_cast<char*>(&ifbranch_),
          reinterpret_cast<char*>(&other->ifbranch_));
}

std::string BranchLayerParams::GetTypeName() const {
  return "CoreML.Specification.BranchLayerParams";
}


// ===================================================================

class LoopLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::NeuralNetwork& conditionnetwork(const LoopLayerParams* msg);
  static const ::CoreML::Specification::NeuralNetwork& bodynetwork(const LoopLayerParams* msg);
};

const ::CoreML::Specification::NeuralNetwork&
LoopLayerParams::_Internal::conditionnetwork(const LoopLayerParams* msg) {
  return *msg->conditionnetwork_;
}
const ::CoreML::Specification::NeuralNetwork&
LoopLayerParams::_Internal::bodynetwork(const LoopLayerParams* msg) {
  return *msg->bodynetwork_;
}
LoopLayerParams::LoopLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LoopLayerParams)
}
LoopLayerParams::LoopLayerParams(const LoopLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  conditionvar_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    conditionvar_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_conditionvar().empty()) {
    conditionvar_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_conditionvar(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_conditionnetwork()) {
    conditionnetwork_ = new ::CoreML::Specification::NeuralNetwork(*from.conditionnetwork_);
  } else {
    conditionnetwork_ = nullptr;
  }
  if (from._internal_has_bodynetwork()) {
    bodynetwork_ = new ::CoreML::Specification::NeuralNetwork(*from.bodynetwork_);
  } else {
    bodynetwork_ = nullptr;
  }
  maxloopiterations_ = from.maxloopiterations_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LoopLayerParams)
}

inline void LoopLayerParams::SharedCtor() {
conditionvar_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  conditionvar_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&conditionnetwork_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&maxloopiterations_) -
    reinterpret_cast<char*>(&conditionnetwork_)) + sizeof(maxloopiterations_));
}

LoopLayerParams::~LoopLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LoopLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LoopLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  conditionvar_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete conditionnetwork_;
  if (this != internal_default_instance()) delete bodynetwork_;
}

void LoopLayerParams::ArenaDtor(void* object) {
  LoopLayerParams* _this = reinterpret_cast< LoopLayerParams* >(object);
  (void)_this;
}
void LoopLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LoopLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LoopLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LoopLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  conditionvar_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && conditionnetwork_ != nullptr) {
    delete conditionnetwork_;
  }
  conditionnetwork_ = nullptr;
  if (GetArenaForAllocation() == nullptr && bodynetwork_ != nullptr) {
    delete bodynetwork_;
  }
  bodynetwork_ = nullptr;
  maxloopiterations_ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* LoopLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 maxLoopIterations = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          maxloopiterations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string conditionVar = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_conditionvar();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NeuralNetwork conditionNetwork = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_conditionnetwork(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NeuralNetwork bodyNetwork = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_bodynetwork(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoopLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LoopLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 maxLoopIterations = 1;
  if (this->_internal_maxloopiterations() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_maxloopiterations(), target);
  }

  // string conditionVar = 2;
  if (!this->_internal_conditionvar().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_conditionvar().data(), static_cast<int>(this->_internal_conditionvar().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.LoopLayerParams.conditionVar");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_conditionvar(), target);
  }

  // .CoreML.Specification.NeuralNetwork conditionNetwork = 3;
  if (this->_internal_has_conditionnetwork()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::conditionnetwork(this), target, stream);
  }

  // .CoreML.Specification.NeuralNetwork bodyNetwork = 4;
  if (this->_internal_has_bodynetwork()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::bodynetwork(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LoopLayerParams)
  return target;
}

size_t LoopLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LoopLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string conditionVar = 2;
  if (!this->_internal_conditionvar().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_conditionvar());
  }

  // .CoreML.Specification.NeuralNetwork conditionNetwork = 3;
  if (this->_internal_has_conditionnetwork()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *conditionnetwork_);
  }

  // .CoreML.Specification.NeuralNetwork bodyNetwork = 4;
  if (this->_internal_has_bodynetwork()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bodynetwork_);
  }

  // uint64 maxLoopIterations = 1;
  if (this->_internal_maxloopiterations() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_maxloopiterations());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoopLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LoopLayerParams*>(
      &from));
}

void LoopLayerParams::MergeFrom(const LoopLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LoopLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_conditionvar().empty()) {
    _internal_set_conditionvar(from._internal_conditionvar());
  }
  if (from._internal_has_conditionnetwork()) {
    _internal_mutable_conditionnetwork()->::CoreML::Specification::NeuralNetwork::MergeFrom(from._internal_conditionnetwork());
  }
  if (from._internal_has_bodynetwork()) {
    _internal_mutable_bodynetwork()->::CoreML::Specification::NeuralNetwork::MergeFrom(from._internal_bodynetwork());
  }
  if (from._internal_maxloopiterations() != 0) {
    _internal_set_maxloopiterations(from._internal_maxloopiterations());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoopLayerParams::CopyFrom(const LoopLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LoopLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoopLayerParams::IsInitialized() const {
  return true;
}

void LoopLayerParams::InternalSwap(LoopLayerParams* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &conditionvar_, lhs_arena,
      &other->conditionvar_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LoopLayerParams, maxloopiterations_)
      + sizeof(LoopLayerParams::maxloopiterations_)
      - PROTOBUF_FIELD_OFFSET(LoopLayerParams, conditionnetwork_)>(
          reinterpret_cast<char*>(&conditionnetwork_),
          reinterpret_cast<char*>(&other->conditionnetwork_));
}

std::string LoopLayerParams::GetTypeName() const {
  return "CoreML.Specification.LoopLayerParams";
}


// ===================================================================

class LoopBreakLayerParams::_Internal {
 public:
};

LoopBreakLayerParams::LoopBreakLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LoopBreakLayerParams)
}
LoopBreakLayerParams::LoopBreakLayerParams(const LoopBreakLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LoopBreakLayerParams)
}

inline void LoopBreakLayerParams::SharedCtor() {
}

LoopBreakLayerParams::~LoopBreakLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LoopBreakLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LoopBreakLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LoopBreakLayerParams::ArenaDtor(void* object) {
  LoopBreakLayerParams* _this = reinterpret_cast< LoopBreakLayerParams* >(object);
  (void)_this;
}
void LoopBreakLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LoopBreakLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LoopBreakLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LoopBreakLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* LoopBreakLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoopBreakLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LoopBreakLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LoopBreakLayerParams)
  return target;
}

size_t LoopBreakLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LoopBreakLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoopBreakLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LoopBreakLayerParams*>(
      &from));
}

void LoopBreakLayerParams::MergeFrom(const LoopBreakLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LoopBreakLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoopBreakLayerParams::CopyFrom(const LoopBreakLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LoopBreakLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoopBreakLayerParams::IsInitialized() const {
  return true;
}

void LoopBreakLayerParams::InternalSwap(LoopBreakLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string LoopBreakLayerParams::GetTypeName() const {
  return "CoreML.Specification.LoopBreakLayerParams";
}


// ===================================================================

class LoopContinueLayerParams::_Internal {
 public:
};

LoopContinueLayerParams::LoopContinueLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LoopContinueLayerParams)
}
LoopContinueLayerParams::LoopContinueLayerParams(const LoopContinueLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LoopContinueLayerParams)
}

inline void LoopContinueLayerParams::SharedCtor() {
}

LoopContinueLayerParams::~LoopContinueLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LoopContinueLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LoopContinueLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LoopContinueLayerParams::ArenaDtor(void* object) {
  LoopContinueLayerParams* _this = reinterpret_cast< LoopContinueLayerParams* >(object);
  (void)_this;
}
void LoopContinueLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LoopContinueLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LoopContinueLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LoopContinueLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* LoopContinueLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoopContinueLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LoopContinueLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LoopContinueLayerParams)
  return target;
}

size_t LoopContinueLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LoopContinueLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoopContinueLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LoopContinueLayerParams*>(
      &from));
}

void LoopContinueLayerParams::MergeFrom(const LoopContinueLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LoopContinueLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoopContinueLayerParams::CopyFrom(const LoopContinueLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LoopContinueLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoopContinueLayerParams::IsInitialized() const {
  return true;
}

void LoopContinueLayerParams::InternalSwap(LoopContinueLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string LoopContinueLayerParams::GetTypeName() const {
  return "CoreML.Specification.LoopContinueLayerParams";
}


// ===================================================================

class CopyLayerParams::_Internal {
 public:
};

CopyLayerParams::CopyLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.CopyLayerParams)
}
CopyLayerParams::CopyLayerParams(const CopyLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.CopyLayerParams)
}

inline void CopyLayerParams::SharedCtor() {
}

CopyLayerParams::~CopyLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.CopyLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CopyLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CopyLayerParams::ArenaDtor(void* object) {
  CopyLayerParams* _this = reinterpret_cast< CopyLayerParams* >(object);
  (void)_this;
}
void CopyLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CopyLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CopyLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.CopyLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CopyLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CopyLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.CopyLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.CopyLayerParams)
  return target;
}

size_t CopyLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.CopyLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CopyLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CopyLayerParams*>(
      &from));
}

void CopyLayerParams::MergeFrom(const CopyLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.CopyLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CopyLayerParams::CopyFrom(const CopyLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.CopyLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CopyLayerParams::IsInitialized() const {
  return true;
}

void CopyLayerParams::InternalSwap(CopyLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CopyLayerParams::GetTypeName() const {
  return "CoreML.Specification.CopyLayerParams";
}


// ===================================================================

class GreaterThanLayerParams::_Internal {
 public:
};

GreaterThanLayerParams::GreaterThanLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.GreaterThanLayerParams)
}
GreaterThanLayerParams::GreaterThanLayerParams(const GreaterThanLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  alpha_ = from.alpha_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.GreaterThanLayerParams)
}

inline void GreaterThanLayerParams::SharedCtor() {
alpha_ = 0;
}

GreaterThanLayerParams::~GreaterThanLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.GreaterThanLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GreaterThanLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GreaterThanLayerParams::ArenaDtor(void* object) {
  GreaterThanLayerParams* _this = reinterpret_cast< GreaterThanLayerParams* >(object);
  (void)_this;
}
void GreaterThanLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GreaterThanLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GreaterThanLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.GreaterThanLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  alpha_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* GreaterThanLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float alpha = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GreaterThanLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.GreaterThanLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float alpha = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_alpha(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.GreaterThanLayerParams)
  return target;
}

size_t GreaterThanLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.GreaterThanLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float alpha = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GreaterThanLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GreaterThanLayerParams*>(
      &from));
}

void GreaterThanLayerParams::MergeFrom(const GreaterThanLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.GreaterThanLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = from._internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    _internal_set_alpha(from._internal_alpha());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GreaterThanLayerParams::CopyFrom(const GreaterThanLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.GreaterThanLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GreaterThanLayerParams::IsInitialized() const {
  return true;
}

void GreaterThanLayerParams::InternalSwap(GreaterThanLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(alpha_, other->alpha_);
}

std::string GreaterThanLayerParams::GetTypeName() const {
  return "CoreML.Specification.GreaterThanLayerParams";
}


// ===================================================================

class GreaterEqualLayerParams::_Internal {
 public:
};

GreaterEqualLayerParams::GreaterEqualLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.GreaterEqualLayerParams)
}
GreaterEqualLayerParams::GreaterEqualLayerParams(const GreaterEqualLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  alpha_ = from.alpha_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.GreaterEqualLayerParams)
}

inline void GreaterEqualLayerParams::SharedCtor() {
alpha_ = 0;
}

GreaterEqualLayerParams::~GreaterEqualLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.GreaterEqualLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GreaterEqualLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GreaterEqualLayerParams::ArenaDtor(void* object) {
  GreaterEqualLayerParams* _this = reinterpret_cast< GreaterEqualLayerParams* >(object);
  (void)_this;
}
void GreaterEqualLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GreaterEqualLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GreaterEqualLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.GreaterEqualLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  alpha_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* GreaterEqualLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float alpha = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GreaterEqualLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.GreaterEqualLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float alpha = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_alpha(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.GreaterEqualLayerParams)
  return target;
}

size_t GreaterEqualLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.GreaterEqualLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float alpha = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GreaterEqualLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GreaterEqualLayerParams*>(
      &from));
}

void GreaterEqualLayerParams::MergeFrom(const GreaterEqualLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.GreaterEqualLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = from._internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    _internal_set_alpha(from._internal_alpha());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GreaterEqualLayerParams::CopyFrom(const GreaterEqualLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.GreaterEqualLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GreaterEqualLayerParams::IsInitialized() const {
  return true;
}

void GreaterEqualLayerParams::InternalSwap(GreaterEqualLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(alpha_, other->alpha_);
}

std::string GreaterEqualLayerParams::GetTypeName() const {
  return "CoreML.Specification.GreaterEqualLayerParams";
}


// ===================================================================

class LessThanLayerParams::_Internal {
 public:
};

LessThanLayerParams::LessThanLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LessThanLayerParams)
}
LessThanLayerParams::LessThanLayerParams(const LessThanLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  alpha_ = from.alpha_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LessThanLayerParams)
}

inline void LessThanLayerParams::SharedCtor() {
alpha_ = 0;
}

LessThanLayerParams::~LessThanLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LessThanLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LessThanLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LessThanLayerParams::ArenaDtor(void* object) {
  LessThanLayerParams* _this = reinterpret_cast< LessThanLayerParams* >(object);
  (void)_this;
}
void LessThanLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LessThanLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LessThanLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LessThanLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  alpha_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* LessThanLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float alpha = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LessThanLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LessThanLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float alpha = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_alpha(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LessThanLayerParams)
  return target;
}

size_t LessThanLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LessThanLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float alpha = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LessThanLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LessThanLayerParams*>(
      &from));
}

void LessThanLayerParams::MergeFrom(const LessThanLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LessThanLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = from._internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    _internal_set_alpha(from._internal_alpha());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LessThanLayerParams::CopyFrom(const LessThanLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LessThanLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LessThanLayerParams::IsInitialized() const {
  return true;
}

void LessThanLayerParams::InternalSwap(LessThanLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(alpha_, other->alpha_);
}

std::string LessThanLayerParams::GetTypeName() const {
  return "CoreML.Specification.LessThanLayerParams";
}


// ===================================================================

class LessEqualLayerParams::_Internal {
 public:
};

LessEqualLayerParams::LessEqualLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LessEqualLayerParams)
}
LessEqualLayerParams::LessEqualLayerParams(const LessEqualLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  alpha_ = from.alpha_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LessEqualLayerParams)
}

inline void LessEqualLayerParams::SharedCtor() {
alpha_ = 0;
}

LessEqualLayerParams::~LessEqualLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LessEqualLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LessEqualLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LessEqualLayerParams::ArenaDtor(void* object) {
  LessEqualLayerParams* _this = reinterpret_cast< LessEqualLayerParams* >(object);
  (void)_this;
}
void LessEqualLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LessEqualLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LessEqualLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LessEqualLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  alpha_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* LessEqualLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float alpha = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LessEqualLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LessEqualLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float alpha = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_alpha(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LessEqualLayerParams)
  return target;
}

size_t LessEqualLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LessEqualLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float alpha = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LessEqualLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LessEqualLayerParams*>(
      &from));
}

void LessEqualLayerParams::MergeFrom(const LessEqualLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LessEqualLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = from._internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    _internal_set_alpha(from._internal_alpha());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LessEqualLayerParams::CopyFrom(const LessEqualLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LessEqualLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LessEqualLayerParams::IsInitialized() const {
  return true;
}

void LessEqualLayerParams::InternalSwap(LessEqualLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(alpha_, other->alpha_);
}

std::string LessEqualLayerParams::GetTypeName() const {
  return "CoreML.Specification.LessEqualLayerParams";
}


// ===================================================================

class EqualLayerParams::_Internal {
 public:
};

EqualLayerParams::EqualLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.EqualLayerParams)
}
EqualLayerParams::EqualLayerParams(const EqualLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  alpha_ = from.alpha_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.EqualLayerParams)
}

inline void EqualLayerParams::SharedCtor() {
alpha_ = 0;
}

EqualLayerParams::~EqualLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.EqualLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void EqualLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EqualLayerParams::ArenaDtor(void* object) {
  EqualLayerParams* _this = reinterpret_cast< EqualLayerParams* >(object);
  (void)_this;
}
void EqualLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EqualLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EqualLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.EqualLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  alpha_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* EqualLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float alpha = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EqualLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.EqualLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_alpha(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.EqualLayerParams)
  return target;
}

size_t EqualLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.EqualLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EqualLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EqualLayerParams*>(
      &from));
}

void EqualLayerParams::MergeFrom(const EqualLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.EqualLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = from._internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    _internal_set_alpha(from._internal_alpha());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EqualLayerParams::CopyFrom(const EqualLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.EqualLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EqualLayerParams::IsInitialized() const {
  return true;
}

void EqualLayerParams::InternalSwap(EqualLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(alpha_, other->alpha_);
}

std::string EqualLayerParams::GetTypeName() const {
  return "CoreML.Specification.EqualLayerParams";
}


// ===================================================================

class NotEqualLayerParams::_Internal {
 public:
};

NotEqualLayerParams::NotEqualLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.NotEqualLayerParams)
}
NotEqualLayerParams::NotEqualLayerParams(const NotEqualLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  alpha_ = from.alpha_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.NotEqualLayerParams)
}

inline void NotEqualLayerParams::SharedCtor() {
alpha_ = 0;
}

NotEqualLayerParams::~NotEqualLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.NotEqualLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void NotEqualLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NotEqualLayerParams::ArenaDtor(void* object) {
  NotEqualLayerParams* _this = reinterpret_cast< NotEqualLayerParams* >(object);
  (void)_this;
}
void NotEqualLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NotEqualLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NotEqualLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.NotEqualLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  alpha_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* NotEqualLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float alpha = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NotEqualLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.NotEqualLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_alpha(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.NotEqualLayerParams)
  return target;
}

size_t NotEqualLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.NotEqualLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NotEqualLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const NotEqualLayerParams*>(
      &from));
}

void NotEqualLayerParams::MergeFrom(const NotEqualLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.NotEqualLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = from._internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    _internal_set_alpha(from._internal_alpha());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NotEqualLayerParams::CopyFrom(const NotEqualLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.NotEqualLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotEqualLayerParams::IsInitialized() const {
  return true;
}

void NotEqualLayerParams::InternalSwap(NotEqualLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(alpha_, other->alpha_);
}

std::string NotEqualLayerParams::GetTypeName() const {
  return "CoreML.Specification.NotEqualLayerParams";
}


// ===================================================================

class LogicalAndLayerParams::_Internal {
 public:
};

LogicalAndLayerParams::LogicalAndLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LogicalAndLayerParams)
}
LogicalAndLayerParams::LogicalAndLayerParams(const LogicalAndLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LogicalAndLayerParams)
}

inline void LogicalAndLayerParams::SharedCtor() {
}

LogicalAndLayerParams::~LogicalAndLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LogicalAndLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LogicalAndLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LogicalAndLayerParams::ArenaDtor(void* object) {
  LogicalAndLayerParams* _this = reinterpret_cast< LogicalAndLayerParams* >(object);
  (void)_this;
}
void LogicalAndLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LogicalAndLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LogicalAndLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LogicalAndLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* LogicalAndLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogicalAndLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LogicalAndLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LogicalAndLayerParams)
  return target;
}

size_t LogicalAndLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LogicalAndLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogicalAndLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LogicalAndLayerParams*>(
      &from));
}

void LogicalAndLayerParams::MergeFrom(const LogicalAndLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LogicalAndLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LogicalAndLayerParams::CopyFrom(const LogicalAndLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LogicalAndLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalAndLayerParams::IsInitialized() const {
  return true;
}

void LogicalAndLayerParams::InternalSwap(LogicalAndLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string LogicalAndLayerParams::GetTypeName() const {
  return "CoreML.Specification.LogicalAndLayerParams";
}


// ===================================================================

class LogicalOrLayerParams::_Internal {
 public:
};

LogicalOrLayerParams::LogicalOrLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LogicalOrLayerParams)
}
LogicalOrLayerParams::LogicalOrLayerParams(const LogicalOrLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LogicalOrLayerParams)
}

inline void LogicalOrLayerParams::SharedCtor() {
}

LogicalOrLayerParams::~LogicalOrLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LogicalOrLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LogicalOrLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LogicalOrLayerParams::ArenaDtor(void* object) {
  LogicalOrLayerParams* _this = reinterpret_cast< LogicalOrLayerParams* >(object);
  (void)_this;
}
void LogicalOrLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LogicalOrLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LogicalOrLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LogicalOrLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* LogicalOrLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogicalOrLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LogicalOrLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LogicalOrLayerParams)
  return target;
}

size_t LogicalOrLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LogicalOrLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogicalOrLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LogicalOrLayerParams*>(
      &from));
}

void LogicalOrLayerParams::MergeFrom(const LogicalOrLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LogicalOrLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LogicalOrLayerParams::CopyFrom(const LogicalOrLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LogicalOrLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalOrLayerParams::IsInitialized() const {
  return true;
}

void LogicalOrLayerParams::InternalSwap(LogicalOrLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string LogicalOrLayerParams::GetTypeName() const {
  return "CoreML.Specification.LogicalOrLayerParams";
}


// ===================================================================

class LogicalXorLayerParams::_Internal {
 public:
};

LogicalXorLayerParams::LogicalXorLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LogicalXorLayerParams)
}
LogicalXorLayerParams::LogicalXorLayerParams(const LogicalXorLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LogicalXorLayerParams)
}

inline void LogicalXorLayerParams::SharedCtor() {
}

LogicalXorLayerParams::~LogicalXorLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LogicalXorLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LogicalXorLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LogicalXorLayerParams::ArenaDtor(void* object) {
  LogicalXorLayerParams* _this = reinterpret_cast< LogicalXorLayerParams* >(object);
  (void)_this;
}
void LogicalXorLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LogicalXorLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LogicalXorLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LogicalXorLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* LogicalXorLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogicalXorLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LogicalXorLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LogicalXorLayerParams)
  return target;
}

size_t LogicalXorLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LogicalXorLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogicalXorLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LogicalXorLayerParams*>(
      &from));
}

void LogicalXorLayerParams::MergeFrom(const LogicalXorLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LogicalXorLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LogicalXorLayerParams::CopyFrom(const LogicalXorLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LogicalXorLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalXorLayerParams::IsInitialized() const {
  return true;
}

void LogicalXorLayerParams::InternalSwap(LogicalXorLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string LogicalXorLayerParams::GetTypeName() const {
  return "CoreML.Specification.LogicalXorLayerParams";
}


// ===================================================================

class LogicalNotLayerParams::_Internal {
 public:
};

LogicalNotLayerParams::LogicalNotLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LogicalNotLayerParams)
}
LogicalNotLayerParams::LogicalNotLayerParams(const LogicalNotLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LogicalNotLayerParams)
}

inline void LogicalNotLayerParams::SharedCtor() {
}

LogicalNotLayerParams::~LogicalNotLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LogicalNotLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LogicalNotLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LogicalNotLayerParams::ArenaDtor(void* object) {
  LogicalNotLayerParams* _this = reinterpret_cast< LogicalNotLayerParams* >(object);
  (void)_this;
}
void LogicalNotLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LogicalNotLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LogicalNotLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LogicalNotLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* LogicalNotLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogicalNotLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LogicalNotLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LogicalNotLayerParams)
  return target;
}

size_t LogicalNotLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LogicalNotLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogicalNotLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LogicalNotLayerParams*>(
      &from));
}

void LogicalNotLayerParams::MergeFrom(const LogicalNotLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LogicalNotLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LogicalNotLayerParams::CopyFrom(const LogicalNotLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LogicalNotLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalNotLayerParams::IsInitialized() const {
  return true;
}

void LogicalNotLayerParams::InternalSwap(LogicalNotLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string LogicalNotLayerParams::GetTypeName() const {
  return "CoreML.Specification.LogicalNotLayerParams";
}


// ===================================================================

class BorderAmounts_EdgeSizes::_Internal {
 public:
};

BorderAmounts_EdgeSizes::BorderAmounts_EdgeSizes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.BorderAmounts.EdgeSizes)
}
BorderAmounts_EdgeSizes::BorderAmounts_EdgeSizes(const BorderAmounts_EdgeSizes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&startedgesize_, &from.startedgesize_,
    static_cast<size_t>(reinterpret_cast<char*>(&endedgesize_) -
    reinterpret_cast<char*>(&startedgesize_)) + sizeof(endedgesize_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.BorderAmounts.EdgeSizes)
}

inline void BorderAmounts_EdgeSizes::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&startedgesize_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&endedgesize_) -
    reinterpret_cast<char*>(&startedgesize_)) + sizeof(endedgesize_));
}

BorderAmounts_EdgeSizes::~BorderAmounts_EdgeSizes() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.BorderAmounts.EdgeSizes)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BorderAmounts_EdgeSizes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BorderAmounts_EdgeSizes::ArenaDtor(void* object) {
  BorderAmounts_EdgeSizes* _this = reinterpret_cast< BorderAmounts_EdgeSizes* >(object);
  (void)_this;
}
void BorderAmounts_EdgeSizes::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BorderAmounts_EdgeSizes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BorderAmounts_EdgeSizes::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.BorderAmounts.EdgeSizes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&startedgesize_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&endedgesize_) -
      reinterpret_cast<char*>(&startedgesize_)) + sizeof(endedgesize_));
  _internal_metadata_.Clear<std::string>();
}

const char* BorderAmounts_EdgeSizes::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 startEdgeSize = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          startedgesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 endEdgeSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          endedgesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BorderAmounts_EdgeSizes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.BorderAmounts.EdgeSizes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 startEdgeSize = 1;
  if (this->_internal_startedgesize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_startedgesize(), target);
  }

  // uint64 endEdgeSize = 2;
  if (this->_internal_endedgesize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_endedgesize(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.BorderAmounts.EdgeSizes)
  return target;
}

size_t BorderAmounts_EdgeSizes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.BorderAmounts.EdgeSizes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 startEdgeSize = 1;
  if (this->_internal_startedgesize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_startedgesize());
  }

  // uint64 endEdgeSize = 2;
  if (this->_internal_endedgesize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_endedgesize());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BorderAmounts_EdgeSizes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BorderAmounts_EdgeSizes*>(
      &from));
}

void BorderAmounts_EdgeSizes::MergeFrom(const BorderAmounts_EdgeSizes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.BorderAmounts.EdgeSizes)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_startedgesize() != 0) {
    _internal_set_startedgesize(from._internal_startedgesize());
  }
  if (from._internal_endedgesize() != 0) {
    _internal_set_endedgesize(from._internal_endedgesize());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BorderAmounts_EdgeSizes::CopyFrom(const BorderAmounts_EdgeSizes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.BorderAmounts.EdgeSizes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BorderAmounts_EdgeSizes::IsInitialized() const {
  return true;
}

void BorderAmounts_EdgeSizes::InternalSwap(BorderAmounts_EdgeSizes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BorderAmounts_EdgeSizes, endedgesize_)
      + sizeof(BorderAmounts_EdgeSizes::endedgesize_)
      - PROTOBUF_FIELD_OFFSET(BorderAmounts_EdgeSizes, startedgesize_)>(
          reinterpret_cast<char*>(&startedgesize_),
          reinterpret_cast<char*>(&other->startedgesize_));
}

std::string BorderAmounts_EdgeSizes::GetTypeName() const {
  return "CoreML.Specification.BorderAmounts.EdgeSizes";
}


// ===================================================================

class BorderAmounts::_Internal {
 public:
};

BorderAmounts::BorderAmounts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  borderamounts_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.BorderAmounts)
}
BorderAmounts::BorderAmounts(const BorderAmounts& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      borderamounts_(from.borderamounts_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.BorderAmounts)
}

inline void BorderAmounts::SharedCtor() {
}

BorderAmounts::~BorderAmounts() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.BorderAmounts)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BorderAmounts::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BorderAmounts::ArenaDtor(void* object) {
  BorderAmounts* _this = reinterpret_cast< BorderAmounts* >(object);
  (void)_this;
}
void BorderAmounts::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BorderAmounts::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BorderAmounts::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.BorderAmounts)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  borderamounts_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BorderAmounts::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.BorderAmounts.EdgeSizes borderAmounts = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_borderamounts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BorderAmounts::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.BorderAmounts)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.BorderAmounts.EdgeSizes borderAmounts = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_borderamounts_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_borderamounts(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.BorderAmounts)
  return target;
}

size_t BorderAmounts::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.BorderAmounts)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.BorderAmounts.EdgeSizes borderAmounts = 10;
  total_size += 1UL * this->_internal_borderamounts_size();
  for (const auto& msg : this->borderamounts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BorderAmounts::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BorderAmounts*>(
      &from));
}

void BorderAmounts::MergeFrom(const BorderAmounts& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.BorderAmounts)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  borderamounts_.MergeFrom(from.borderamounts_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BorderAmounts::CopyFrom(const BorderAmounts& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.BorderAmounts)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BorderAmounts::IsInitialized() const {
  return true;
}

void BorderAmounts::InternalSwap(BorderAmounts* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  borderamounts_.InternalSwap(&other->borderamounts_);
}

std::string BorderAmounts::GetTypeName() const {
  return "CoreML.Specification.BorderAmounts";
}


// ===================================================================

class ValidPadding::_Internal {
 public:
  static const ::CoreML::Specification::BorderAmounts& paddingamounts(const ValidPadding* msg);
};

const ::CoreML::Specification::BorderAmounts&
ValidPadding::_Internal::paddingamounts(const ValidPadding* msg) {
  return *msg->paddingamounts_;
}
ValidPadding::ValidPadding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ValidPadding)
}
ValidPadding::ValidPadding(const ValidPadding& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_paddingamounts()) {
    paddingamounts_ = new ::CoreML::Specification::BorderAmounts(*from.paddingamounts_);
  } else {
    paddingamounts_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ValidPadding)
}

inline void ValidPadding::SharedCtor() {
paddingamounts_ = nullptr;
}

ValidPadding::~ValidPadding() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ValidPadding)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ValidPadding::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete paddingamounts_;
}

void ValidPadding::ArenaDtor(void* object) {
  ValidPadding* _this = reinterpret_cast< ValidPadding* >(object);
  (void)_this;
}
void ValidPadding::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ValidPadding::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ValidPadding::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ValidPadding)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && paddingamounts_ != nullptr) {
    delete paddingamounts_;
  }
  paddingamounts_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* ValidPadding::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.BorderAmounts paddingAmounts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_paddingamounts(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ValidPadding::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ValidPadding)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.BorderAmounts paddingAmounts = 1;
  if (this->_internal_has_paddingamounts()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::paddingamounts(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ValidPadding)
  return target;
}

size_t ValidPadding::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ValidPadding)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.BorderAmounts paddingAmounts = 1;
  if (this->_internal_has_paddingamounts()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *paddingamounts_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ValidPadding::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ValidPadding*>(
      &from));
}

void ValidPadding::MergeFrom(const ValidPadding& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ValidPadding)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_paddingamounts()) {
    _internal_mutable_paddingamounts()->::CoreML::Specification::BorderAmounts::MergeFrom(from._internal_paddingamounts());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ValidPadding::CopyFrom(const ValidPadding& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ValidPadding)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ValidPadding::IsInitialized() const {
  return true;
}

void ValidPadding::InternalSwap(ValidPadding* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(paddingamounts_, other->paddingamounts_);
}

std::string ValidPadding::GetTypeName() const {
  return "CoreML.Specification.ValidPadding";
}


// ===================================================================

class SamePadding::_Internal {
 public:
};

SamePadding::SamePadding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SamePadding)
}
SamePadding::SamePadding(const SamePadding& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  asymmetrymode_ = from.asymmetrymode_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SamePadding)
}

inline void SamePadding::SharedCtor() {
asymmetrymode_ = 0;
}

SamePadding::~SamePadding() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SamePadding)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SamePadding::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SamePadding::ArenaDtor(void* object) {
  SamePadding* _this = reinterpret_cast< SamePadding* >(object);
  (void)_this;
}
void SamePadding::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SamePadding::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SamePadding::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SamePadding)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  asymmetrymode_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* SamePadding::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.SamePadding.SamePaddingMode asymmetryMode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_asymmetrymode(static_cast<::CoreML::Specification::SamePadding_SamePaddingMode>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SamePadding::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SamePadding)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.SamePadding.SamePaddingMode asymmetryMode = 1;
  if (this->_internal_asymmetrymode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_asymmetrymode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SamePadding)
  return target;
}

size_t SamePadding::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SamePadding)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.SamePadding.SamePaddingMode asymmetryMode = 1;
  if (this->_internal_asymmetrymode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_asymmetrymode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SamePadding::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SamePadding*>(
      &from));
}

void SamePadding::MergeFrom(const SamePadding& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SamePadding)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_asymmetrymode() != 0) {
    _internal_set_asymmetrymode(from._internal_asymmetrymode());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SamePadding::CopyFrom(const SamePadding& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SamePadding)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SamePadding::IsInitialized() const {
  return true;
}

void SamePadding::InternalSwap(SamePadding* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(asymmetrymode_, other->asymmetrymode_);
}

std::string SamePadding::GetTypeName() const {
  return "CoreML.Specification.SamePadding";
}


// ===================================================================

class SamplingMode::_Internal {
 public:
};

SamplingMode::SamplingMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SamplingMode)
}
SamplingMode::SamplingMode(const SamplingMode& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  samplingmethod_ = from.samplingmethod_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SamplingMode)
}

inline void SamplingMode::SharedCtor() {
samplingmethod_ = 0;
}

SamplingMode::~SamplingMode() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SamplingMode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SamplingMode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SamplingMode::ArenaDtor(void* object) {
  SamplingMode* _this = reinterpret_cast< SamplingMode* >(object);
  (void)_this;
}
void SamplingMode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SamplingMode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SamplingMode::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SamplingMode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  samplingmethod_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* SamplingMode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.SamplingMode.Method samplingMethod = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_samplingmethod(static_cast<::CoreML::Specification::SamplingMode_Method>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SamplingMode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SamplingMode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.SamplingMode.Method samplingMethod = 1;
  if (this->_internal_samplingmethod() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_samplingmethod(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SamplingMode)
  return target;
}

size_t SamplingMode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SamplingMode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.SamplingMode.Method samplingMethod = 1;
  if (this->_internal_samplingmethod() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_samplingmethod());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SamplingMode::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SamplingMode*>(
      &from));
}

void SamplingMode::MergeFrom(const SamplingMode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SamplingMode)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_samplingmethod() != 0) {
    _internal_set_samplingmethod(from._internal_samplingmethod());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SamplingMode::CopyFrom(const SamplingMode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SamplingMode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SamplingMode::IsInitialized() const {
  return true;
}

void SamplingMode::InternalSwap(SamplingMode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(samplingmethod_, other->samplingmethod_);
}

std::string SamplingMode::GetTypeName() const {
  return "CoreML.Specification.SamplingMode";
}


// ===================================================================

class BoxCoordinatesMode::_Internal {
 public:
};

BoxCoordinatesMode::BoxCoordinatesMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.BoxCoordinatesMode)
}
BoxCoordinatesMode::BoxCoordinatesMode(const BoxCoordinatesMode& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  boxmode_ = from.boxmode_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.BoxCoordinatesMode)
}

inline void BoxCoordinatesMode::SharedCtor() {
boxmode_ = 0;
}

BoxCoordinatesMode::~BoxCoordinatesMode() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.BoxCoordinatesMode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BoxCoordinatesMode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BoxCoordinatesMode::ArenaDtor(void* object) {
  BoxCoordinatesMode* _this = reinterpret_cast< BoxCoordinatesMode* >(object);
  (void)_this;
}
void BoxCoordinatesMode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BoxCoordinatesMode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BoxCoordinatesMode::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.BoxCoordinatesMode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  boxmode_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* BoxCoordinatesMode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.BoxCoordinatesMode.Coordinates boxMode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_boxmode(static_cast<::CoreML::Specification::BoxCoordinatesMode_Coordinates>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BoxCoordinatesMode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.BoxCoordinatesMode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.BoxCoordinatesMode.Coordinates boxMode = 1;
  if (this->_internal_boxmode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_boxmode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.BoxCoordinatesMode)
  return target;
}

size_t BoxCoordinatesMode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.BoxCoordinatesMode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.BoxCoordinatesMode.Coordinates boxMode = 1;
  if (this->_internal_boxmode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_boxmode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BoxCoordinatesMode::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BoxCoordinatesMode*>(
      &from));
}

void BoxCoordinatesMode::MergeFrom(const BoxCoordinatesMode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.BoxCoordinatesMode)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_boxmode() != 0) {
    _internal_set_boxmode(from._internal_boxmode());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BoxCoordinatesMode::CopyFrom(const BoxCoordinatesMode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.BoxCoordinatesMode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BoxCoordinatesMode::IsInitialized() const {
  return true;
}

void BoxCoordinatesMode::InternalSwap(BoxCoordinatesMode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(boxmode_, other->boxmode_);
}

std::string BoxCoordinatesMode::GetTypeName() const {
  return "CoreML.Specification.BoxCoordinatesMode";
}


// ===================================================================

class WeightParams::_Internal {
 public:
  static const ::CoreML::Specification::QuantizationParams& quantization(const WeightParams* msg);
};

const ::CoreML::Specification::QuantizationParams&
WeightParams::_Internal::quantization(const WeightParams* msg) {
  return *msg->quantization_;
}
WeightParams::WeightParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  floatvalue_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.WeightParams)
}
WeightParams::WeightParams(const WeightParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      floatvalue_(from.floatvalue_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  float16value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    float16value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_float16value().empty()) {
    float16value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_float16value(), 
      GetArenaForAllocation());
  }
  rawvalue_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    rawvalue_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_rawvalue().empty()) {
    rawvalue_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_rawvalue(), 
      GetArenaForAllocation());
  }
  int8rawvalue_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    int8rawvalue_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_int8rawvalue().empty()) {
    int8rawvalue_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_int8rawvalue(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_quantization()) {
    quantization_ = new ::CoreML::Specification::QuantizationParams(*from.quantization_);
  } else {
    quantization_ = nullptr;
  }
  isupdatable_ = from.isupdatable_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.WeightParams)
}

inline void WeightParams::SharedCtor() {
float16value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  float16value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
rawvalue_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  rawvalue_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
int8rawvalue_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  int8rawvalue_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&quantization_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&isupdatable_) -
    reinterpret_cast<char*>(&quantization_)) + sizeof(isupdatable_));
}

WeightParams::~WeightParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.WeightParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void WeightParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  float16value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  rawvalue_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  int8rawvalue_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete quantization_;
}

void WeightParams::ArenaDtor(void* object) {
  WeightParams* _this = reinterpret_cast< WeightParams* >(object);
  (void)_this;
}
void WeightParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WeightParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WeightParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.WeightParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  floatvalue_.Clear();
  float16value_.ClearToEmpty();
  rawvalue_.ClearToEmpty();
  int8rawvalue_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && quantization_ != nullptr) {
    delete quantization_;
  }
  quantization_ = nullptr;
  isupdatable_ = false;
  _internal_metadata_.Clear<std::string>();
}

const char* WeightParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float floatValue = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_floatvalue(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 13) {
          _internal_add_floatvalue(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bytes float16Value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_float16value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes rawValue = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          auto str = _internal_mutable_rawvalue();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes int8RawValue = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          auto str = _internal_mutable_int8rawvalue();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.QuantizationParams quantization = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_quantization(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isUpdatable = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          isupdatable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WeightParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.WeightParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float floatValue = 1;
  if (this->_internal_floatvalue_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_floatvalue(), target);
  }

  // bytes float16Value = 2;
  if (!this->_internal_float16value().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_float16value(), target);
  }

  // bytes rawValue = 30;
  if (!this->_internal_rawvalue().empty()) {
    target = stream->WriteBytesMaybeAliased(
        30, this->_internal_rawvalue(), target);
  }

  // bytes int8RawValue = 31;
  if (!this->_internal_int8rawvalue().empty()) {
    target = stream->WriteBytesMaybeAliased(
        31, this->_internal_int8rawvalue(), target);
  }

  // .CoreML.Specification.QuantizationParams quantization = 40;
  if (this->_internal_has_quantization()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        40, _Internal::quantization(this), target, stream);
  }

  // bool isUpdatable = 50;
  if (this->_internal_isupdatable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(50, this->_internal_isupdatable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.WeightParams)
  return target;
}

size_t WeightParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.WeightParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float floatValue = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_floatvalue_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // bytes float16Value = 2;
  if (!this->_internal_float16value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_float16value());
  }

  // bytes rawValue = 30;
  if (!this->_internal_rawvalue().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_rawvalue());
  }

  // bytes int8RawValue = 31;
  if (!this->_internal_int8rawvalue().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_int8rawvalue());
  }

  // .CoreML.Specification.QuantizationParams quantization = 40;
  if (this->_internal_has_quantization()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *quantization_);
  }

  // bool isUpdatable = 50;
  if (this->_internal_isupdatable() != 0) {
    total_size += 2 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WeightParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const WeightParams*>(
      &from));
}

void WeightParams::MergeFrom(const WeightParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.WeightParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  floatvalue_.MergeFrom(from.floatvalue_);
  if (!from._internal_float16value().empty()) {
    _internal_set_float16value(from._internal_float16value());
  }
  if (!from._internal_rawvalue().empty()) {
    _internal_set_rawvalue(from._internal_rawvalue());
  }
  if (!from._internal_int8rawvalue().empty()) {
    _internal_set_int8rawvalue(from._internal_int8rawvalue());
  }
  if (from._internal_has_quantization()) {
    _internal_mutable_quantization()->::CoreML::Specification::QuantizationParams::MergeFrom(from._internal_quantization());
  }
  if (from._internal_isupdatable() != 0) {
    _internal_set_isupdatable(from._internal_isupdatable());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WeightParams::CopyFrom(const WeightParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.WeightParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WeightParams::IsInitialized() const {
  return true;
}

void WeightParams::InternalSwap(WeightParams* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  floatvalue_.InternalSwap(&other->floatvalue_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &float16value_, lhs_arena,
      &other->float16value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &rawvalue_, lhs_arena,
      &other->rawvalue_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &int8rawvalue_, lhs_arena,
      &other->int8rawvalue_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WeightParams, isupdatable_)
      + sizeof(WeightParams::isupdatable_)
      - PROTOBUF_FIELD_OFFSET(WeightParams, quantization_)>(
          reinterpret_cast<char*>(&quantization_),
          reinterpret_cast<char*>(&other->quantization_));
}

std::string WeightParams::GetTypeName() const {
  return "CoreML.Specification.WeightParams";
}


// ===================================================================

class QuantizationParams::_Internal {
 public:
  static const ::CoreML::Specification::LinearQuantizationParams& linearquantization(const QuantizationParams* msg);
  static const ::CoreML::Specification::LookUpTableQuantizationParams& lookuptablequantization(const QuantizationParams* msg);
};

const ::CoreML::Specification::LinearQuantizationParams&
QuantizationParams::_Internal::linearquantization(const QuantizationParams* msg) {
  return *msg->QuantizationType_.linearquantization_;
}
const ::CoreML::Specification::LookUpTableQuantizationParams&
QuantizationParams::_Internal::lookuptablequantization(const QuantizationParams* msg) {
  return *msg->QuantizationType_.lookuptablequantization_;
}
void QuantizationParams::set_allocated_linearquantization(::CoreML::Specification::LinearQuantizationParams* linearquantization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_QuantizationType();
  if (linearquantization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::LinearQuantizationParams>::GetOwningArena(linearquantization);
    if (message_arena != submessage_arena) {
      linearquantization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linearquantization, submessage_arena);
    }
    set_has_linearquantization();
    QuantizationType_.linearquantization_ = linearquantization;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.QuantizationParams.linearQuantization)
}
void QuantizationParams::set_allocated_lookuptablequantization(::CoreML::Specification::LookUpTableQuantizationParams* lookuptablequantization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_QuantizationType();
  if (lookuptablequantization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::LookUpTableQuantizationParams>::GetOwningArena(lookuptablequantization);
    if (message_arena != submessage_arena) {
      lookuptablequantization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lookuptablequantization, submessage_arena);
    }
    set_has_lookuptablequantization();
    QuantizationType_.lookuptablequantization_ = lookuptablequantization;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.QuantizationParams.lookupTableQuantization)
}
QuantizationParams::QuantizationParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.QuantizationParams)
}
QuantizationParams::QuantizationParams(const QuantizationParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  numberofbits_ = from.numberofbits_;
  clear_has_QuantizationType();
  switch (from.QuantizationType_case()) {
    case kLinearQuantization: {
      _internal_mutable_linearquantization()->::CoreML::Specification::LinearQuantizationParams::MergeFrom(from._internal_linearquantization());
      break;
    }
    case kLookupTableQuantization: {
      _internal_mutable_lookuptablequantization()->::CoreML::Specification::LookUpTableQuantizationParams::MergeFrom(from._internal_lookuptablequantization());
      break;
    }
    case QUANTIZATIONTYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.QuantizationParams)
}

inline void QuantizationParams::SharedCtor() {
numberofbits_ = uint64_t{0u};
clear_has_QuantizationType();
}

QuantizationParams::~QuantizationParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.QuantizationParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void QuantizationParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_QuantizationType()) {
    clear_QuantizationType();
  }
}

void QuantizationParams::ArenaDtor(void* object) {
  QuantizationParams* _this = reinterpret_cast< QuantizationParams* >(object);
  (void)_this;
}
void QuantizationParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void QuantizationParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void QuantizationParams::clear_QuantizationType() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.QuantizationParams)
  switch (QuantizationType_case()) {
    case kLinearQuantization: {
      if (GetArenaForAllocation() == nullptr) {
        delete QuantizationType_.linearquantization_;
      }
      break;
    }
    case kLookupTableQuantization: {
      if (GetArenaForAllocation() == nullptr) {
        delete QuantizationType_.lookuptablequantization_;
      }
      break;
    }
    case QUANTIZATIONTYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = QUANTIZATIONTYPE_NOT_SET;
}


void QuantizationParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.QuantizationParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  numberofbits_ = uint64_t{0u};
  clear_QuantizationType();
  _internal_metadata_.Clear<std::string>();
}

const char* QuantizationParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 numberOfBits = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          numberofbits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LinearQuantizationParams linearQuantization = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_linearquantization(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LookUpTableQuantizationParams lookupTableQuantization = 102;
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_lookuptablequantization(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QuantizationParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.QuantizationParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 numberOfBits = 1;
  if (this->_internal_numberofbits() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_numberofbits(), target);
  }

  // .CoreML.Specification.LinearQuantizationParams linearQuantization = 101;
  if (_internal_has_linearquantization()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        101, _Internal::linearquantization(this), target, stream);
  }

  // .CoreML.Specification.LookUpTableQuantizationParams lookupTableQuantization = 102;
  if (_internal_has_lookuptablequantization()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        102, _Internal::lookuptablequantization(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.QuantizationParams)
  return target;
}

size_t QuantizationParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.QuantizationParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 numberOfBits = 1;
  if (this->_internal_numberofbits() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_numberofbits());
  }

  switch (QuantizationType_case()) {
    // .CoreML.Specification.LinearQuantizationParams linearQuantization = 101;
    case kLinearQuantization: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *QuantizationType_.linearquantization_);
      break;
    }
    // .CoreML.Specification.LookUpTableQuantizationParams lookupTableQuantization = 102;
    case kLookupTableQuantization: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *QuantizationType_.lookuptablequantization_);
      break;
    }
    case QUANTIZATIONTYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void QuantizationParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const QuantizationParams*>(
      &from));
}

void QuantizationParams::MergeFrom(const QuantizationParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.QuantizationParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_numberofbits() != 0) {
    _internal_set_numberofbits(from._internal_numberofbits());
  }
  switch (from.QuantizationType_case()) {
    case kLinearQuantization: {
      _internal_mutable_linearquantization()->::CoreML::Specification::LinearQuantizationParams::MergeFrom(from._internal_linearquantization());
      break;
    }
    case kLookupTableQuantization: {
      _internal_mutable_lookuptablequantization()->::CoreML::Specification::LookUpTableQuantizationParams::MergeFrom(from._internal_lookuptablequantization());
      break;
    }
    case QUANTIZATIONTYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void QuantizationParams::CopyFrom(const QuantizationParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.QuantizationParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuantizationParams::IsInitialized() const {
  return true;
}

void QuantizationParams::InternalSwap(QuantizationParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(numberofbits_, other->numberofbits_);
  swap(QuantizationType_, other->QuantizationType_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string QuantizationParams::GetTypeName() const {
  return "CoreML.Specification.QuantizationParams";
}


// ===================================================================

class LinearQuantizationParams::_Internal {
 public:
};

LinearQuantizationParams::LinearQuantizationParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  scale_(arena),
  bias_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LinearQuantizationParams)
}
LinearQuantizationParams::LinearQuantizationParams(const LinearQuantizationParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      scale_(from.scale_),
      bias_(from.bias_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LinearQuantizationParams)
}

inline void LinearQuantizationParams::SharedCtor() {
}

LinearQuantizationParams::~LinearQuantizationParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LinearQuantizationParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LinearQuantizationParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LinearQuantizationParams::ArenaDtor(void* object) {
  LinearQuantizationParams* _this = reinterpret_cast< LinearQuantizationParams* >(object);
  (void)_this;
}
void LinearQuantizationParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LinearQuantizationParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LinearQuantizationParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LinearQuantizationParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  scale_.Clear();
  bias_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LinearQuantizationParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float scale = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_scale(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 13) {
          _internal_add_scale(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float bias = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_bias(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 21) {
          _internal_add_bias(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LinearQuantizationParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LinearQuantizationParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float scale = 1;
  if (this->_internal_scale_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_scale(), target);
  }

  // repeated float bias = 2;
  if (this->_internal_bias_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_bias(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LinearQuantizationParams)
  return target;
}

size_t LinearQuantizationParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LinearQuantizationParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float scale = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_scale_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float bias = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_bias_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LinearQuantizationParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LinearQuantizationParams*>(
      &from));
}

void LinearQuantizationParams::MergeFrom(const LinearQuantizationParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LinearQuantizationParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  scale_.MergeFrom(from.scale_);
  bias_.MergeFrom(from.bias_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LinearQuantizationParams::CopyFrom(const LinearQuantizationParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LinearQuantizationParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinearQuantizationParams::IsInitialized() const {
  return true;
}

void LinearQuantizationParams::InternalSwap(LinearQuantizationParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  scale_.InternalSwap(&other->scale_);
  bias_.InternalSwap(&other->bias_);
}

std::string LinearQuantizationParams::GetTypeName() const {
  return "CoreML.Specification.LinearQuantizationParams";
}


// ===================================================================

class LookUpTableQuantizationParams::_Internal {
 public:
};

LookUpTableQuantizationParams::LookUpTableQuantizationParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  floatvalue_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LookUpTableQuantizationParams)
}
LookUpTableQuantizationParams::LookUpTableQuantizationParams(const LookUpTableQuantizationParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      floatvalue_(from.floatvalue_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LookUpTableQuantizationParams)
}

inline void LookUpTableQuantizationParams::SharedCtor() {
}

LookUpTableQuantizationParams::~LookUpTableQuantizationParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LookUpTableQuantizationParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LookUpTableQuantizationParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LookUpTableQuantizationParams::ArenaDtor(void* object) {
  LookUpTableQuantizationParams* _this = reinterpret_cast< LookUpTableQuantizationParams* >(object);
  (void)_this;
}
void LookUpTableQuantizationParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LookUpTableQuantizationParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LookUpTableQuantizationParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LookUpTableQuantizationParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  floatvalue_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LookUpTableQuantizationParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float floatValue = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_floatvalue(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 13) {
          _internal_add_floatvalue(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LookUpTableQuantizationParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LookUpTableQuantizationParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float floatValue = 1;
  if (this->_internal_floatvalue_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_floatvalue(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LookUpTableQuantizationParams)
  return target;
}

size_t LookUpTableQuantizationParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LookUpTableQuantizationParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float floatValue = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_floatvalue_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LookUpTableQuantizationParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LookUpTableQuantizationParams*>(
      &from));
}

void LookUpTableQuantizationParams::MergeFrom(const LookUpTableQuantizationParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LookUpTableQuantizationParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  floatvalue_.MergeFrom(from.floatvalue_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LookUpTableQuantizationParams::CopyFrom(const LookUpTableQuantizationParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LookUpTableQuantizationParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LookUpTableQuantizationParams::IsInitialized() const {
  return true;
}

void LookUpTableQuantizationParams::InternalSwap(LookUpTableQuantizationParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  floatvalue_.InternalSwap(&other->floatvalue_);
}

std::string LookUpTableQuantizationParams::GetTypeName() const {
  return "CoreML.Specification.LookUpTableQuantizationParams";
}


// ===================================================================

class ConvolutionLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::ValidPadding& valid(const ConvolutionLayerParams* msg);
  static const ::CoreML::Specification::SamePadding& same(const ConvolutionLayerParams* msg);
  static const ::CoreML::Specification::WeightParams& weights(const ConvolutionLayerParams* msg);
  static const ::CoreML::Specification::WeightParams& bias(const ConvolutionLayerParams* msg);
};

const ::CoreML::Specification::ValidPadding&
ConvolutionLayerParams::_Internal::valid(const ConvolutionLayerParams* msg) {
  return *msg->ConvolutionPaddingType_.valid_;
}
const ::CoreML::Specification::SamePadding&
ConvolutionLayerParams::_Internal::same(const ConvolutionLayerParams* msg) {
  return *msg->ConvolutionPaddingType_.same_;
}
const ::CoreML::Specification::WeightParams&
ConvolutionLayerParams::_Internal::weights(const ConvolutionLayerParams* msg) {
  return *msg->weights_;
}
const ::CoreML::Specification::WeightParams&
ConvolutionLayerParams::_Internal::bias(const ConvolutionLayerParams* msg) {
  return *msg->bias_;
}
void ConvolutionLayerParams::set_allocated_valid(::CoreML::Specification::ValidPadding* valid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ConvolutionPaddingType();
  if (valid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ValidPadding>::GetOwningArena(valid);
    if (message_arena != submessage_arena) {
      valid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, valid, submessage_arena);
    }
    set_has_valid();
    ConvolutionPaddingType_.valid_ = valid;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ConvolutionLayerParams.valid)
}
void ConvolutionLayerParams::set_allocated_same(::CoreML::Specification::SamePadding* same) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ConvolutionPaddingType();
  if (same) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SamePadding>::GetOwningArena(same);
    if (message_arena != submessage_arena) {
      same = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, same, submessage_arena);
    }
    set_has_same();
    ConvolutionPaddingType_.same_ = same;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ConvolutionLayerParams.same)
}
ConvolutionLayerParams::ConvolutionLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  kernelsize_(arena),
  stride_(arena),
  dilationfactor_(arena),
  outputshape_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ConvolutionLayerParams)
}
ConvolutionLayerParams::ConvolutionLayerParams(const ConvolutionLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      kernelsize_(from.kernelsize_),
      stride_(from.stride_),
      dilationfactor_(from.dilationfactor_),
      outputshape_(from.outputshape_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_weights()) {
    weights_ = new ::CoreML::Specification::WeightParams(*from.weights_);
  } else {
    weights_ = nullptr;
  }
  if (from._internal_has_bias()) {
    bias_ = new ::CoreML::Specification::WeightParams(*from.bias_);
  } else {
    bias_ = nullptr;
  }
  ::memcpy(&outputchannels_, &from.outputchannels_,
    static_cast<size_t>(reinterpret_cast<char*>(&hasbias_) -
    reinterpret_cast<char*>(&outputchannels_)) + sizeof(hasbias_));
  clear_has_ConvolutionPaddingType();
  switch (from.ConvolutionPaddingType_case()) {
    case kValid: {
      _internal_mutable_valid()->::CoreML::Specification::ValidPadding::MergeFrom(from._internal_valid());
      break;
    }
    case kSame: {
      _internal_mutable_same()->::CoreML::Specification::SamePadding::MergeFrom(from._internal_same());
      break;
    }
    case CONVOLUTIONPADDINGTYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ConvolutionLayerParams)
}

inline void ConvolutionLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&weights_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&hasbias_) -
    reinterpret_cast<char*>(&weights_)) + sizeof(hasbias_));
clear_has_ConvolutionPaddingType();
}

ConvolutionLayerParams::~ConvolutionLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ConvolutionLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ConvolutionLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete weights_;
  if (this != internal_default_instance()) delete bias_;
  if (has_ConvolutionPaddingType()) {
    clear_ConvolutionPaddingType();
  }
}

void ConvolutionLayerParams::ArenaDtor(void* object) {
  ConvolutionLayerParams* _this = reinterpret_cast< ConvolutionLayerParams* >(object);
  (void)_this;
}
void ConvolutionLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConvolutionLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConvolutionLayerParams::clear_ConvolutionPaddingType() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.ConvolutionLayerParams)
  switch (ConvolutionPaddingType_case()) {
    case kValid: {
      if (GetArenaForAllocation() == nullptr) {
        delete ConvolutionPaddingType_.valid_;
      }
      break;
    }
    case kSame: {
      if (GetArenaForAllocation() == nullptr) {
        delete ConvolutionPaddingType_.same_;
      }
      break;
    }
    case CONVOLUTIONPADDINGTYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = CONVOLUTIONPADDINGTYPE_NOT_SET;
}


void ConvolutionLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ConvolutionLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  kernelsize_.Clear();
  stride_.Clear();
  dilationfactor_.Clear();
  outputshape_.Clear();
  if (GetArenaForAllocation() == nullptr && weights_ != nullptr) {
    delete weights_;
  }
  weights_ = nullptr;
  if (GetArenaForAllocation() == nullptr && bias_ != nullptr) {
    delete bias_;
  }
  bias_ = nullptr;
  ::memset(&outputchannels_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&hasbias_) -
      reinterpret_cast<char*>(&outputchannels_)) + sizeof(hasbias_));
  clear_ConvolutionPaddingType();
  _internal_metadata_.Clear<std::string>();
}

const char* ConvolutionLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 outputChannels = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          outputchannels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 kernelChannels = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          kernelchannels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 nGroups = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          ngroups_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 kernelSize = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_kernelsize(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 160) {
          _internal_add_kernelsize(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 stride = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_stride(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 240) {
          _internal_add_stride(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 dilationFactor = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_dilationfactor(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 64) {
          _internal_add_dilationfactor(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ValidPadding valid = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_valid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SamePadding same = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_same(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isDeconvolution = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          isdeconvolution_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hasBias = 70;
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          hasbias_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams weights = 90;
      case 90:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_weights(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams bias = 91;
      case 91:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_bias(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 outputShape = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_outputshape(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_outputshape(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConvolutionLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ConvolutionLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 outputChannels = 1;
  if (this->_internal_outputchannels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_outputchannels(), target);
  }

  // uint64 kernelChannels = 2;
  if (this->_internal_kernelchannels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_kernelchannels(), target);
  }

  // uint64 nGroups = 10;
  if (this->_internal_ngroups() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(10, this->_internal_ngroups(), target);
  }

  // repeated uint64 kernelSize = 20;
  {
    int byte_size = _kernelsize_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          20, _internal_kernelsize(), byte_size, target);
    }
  }

  // repeated uint64 stride = 30;
  {
    int byte_size = _stride_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          30, _internal_stride(), byte_size, target);
    }
  }

  // repeated uint64 dilationFactor = 40;
  {
    int byte_size = _dilationfactor_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          40, _internal_dilationfactor(), byte_size, target);
    }
  }

  // .CoreML.Specification.ValidPadding valid = 50;
  if (_internal_has_valid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        50, _Internal::valid(this), target, stream);
  }

  // .CoreML.Specification.SamePadding same = 51;
  if (_internal_has_same()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        51, _Internal::same(this), target, stream);
  }

  // bool isDeconvolution = 60;
  if (this->_internal_isdeconvolution() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(60, this->_internal_isdeconvolution(), target);
  }

  // bool hasBias = 70;
  if (this->_internal_hasbias() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(70, this->_internal_hasbias(), target);
  }

  // .CoreML.Specification.WeightParams weights = 90;
  if (this->_internal_has_weights()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        90, _Internal::weights(this), target, stream);
  }

  // .CoreML.Specification.WeightParams bias = 91;
  if (this->_internal_has_bias()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        91, _Internal::bias(this), target, stream);
  }

  // repeated uint64 outputShape = 100;
  {
    int byte_size = _outputshape_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          100, _internal_outputshape(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ConvolutionLayerParams)
  return target;
}

size_t ConvolutionLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ConvolutionLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 kernelSize = 20;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->kernelsize_);
    if (data_size > 0) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _kernelsize_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint64 stride = 30;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->stride_);
    if (data_size > 0) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _stride_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint64 dilationFactor = 40;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->dilationfactor_);
    if (data_size > 0) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _dilationfactor_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint64 outputShape = 100;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->outputshape_);
    if (data_size > 0) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _outputshape_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .CoreML.Specification.WeightParams weights = 90;
  if (this->_internal_has_weights()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *weights_);
  }

  // .CoreML.Specification.WeightParams bias = 91;
  if (this->_internal_has_bias()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bias_);
  }

  // uint64 outputChannels = 1;
  if (this->_internal_outputchannels() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_outputchannels());
  }

  // uint64 kernelChannels = 2;
  if (this->_internal_kernelchannels() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_kernelchannels());
  }

  // uint64 nGroups = 10;
  if (this->_internal_ngroups() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_ngroups());
  }

  // bool isDeconvolution = 60;
  if (this->_internal_isdeconvolution() != 0) {
    total_size += 2 + 1;
  }

  // bool hasBias = 70;
  if (this->_internal_hasbias() != 0) {
    total_size += 2 + 1;
  }

  switch (ConvolutionPaddingType_case()) {
    // .CoreML.Specification.ValidPadding valid = 50;
    case kValid: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ConvolutionPaddingType_.valid_);
      break;
    }
    // .CoreML.Specification.SamePadding same = 51;
    case kSame: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ConvolutionPaddingType_.same_);
      break;
    }
    case CONVOLUTIONPADDINGTYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConvolutionLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ConvolutionLayerParams*>(
      &from));
}

void ConvolutionLayerParams::MergeFrom(const ConvolutionLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ConvolutionLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  kernelsize_.MergeFrom(from.kernelsize_);
  stride_.MergeFrom(from.stride_);
  dilationfactor_.MergeFrom(from.dilationfactor_);
  outputshape_.MergeFrom(from.outputshape_);
  if (from._internal_has_weights()) {
    _internal_mutable_weights()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_weights());
  }
  if (from._internal_has_bias()) {
    _internal_mutable_bias()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_bias());
  }
  if (from._internal_outputchannels() != 0) {
    _internal_set_outputchannels(from._internal_outputchannels());
  }
  if (from._internal_kernelchannels() != 0) {
    _internal_set_kernelchannels(from._internal_kernelchannels());
  }
  if (from._internal_ngroups() != 0) {
    _internal_set_ngroups(from._internal_ngroups());
  }
  if (from._internal_isdeconvolution() != 0) {
    _internal_set_isdeconvolution(from._internal_isdeconvolution());
  }
  if (from._internal_hasbias() != 0) {
    _internal_set_hasbias(from._internal_hasbias());
  }
  switch (from.ConvolutionPaddingType_case()) {
    case kValid: {
      _internal_mutable_valid()->::CoreML::Specification::ValidPadding::MergeFrom(from._internal_valid());
      break;
    }
    case kSame: {
      _internal_mutable_same()->::CoreML::Specification::SamePadding::MergeFrom(from._internal_same());
      break;
    }
    case CONVOLUTIONPADDINGTYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConvolutionLayerParams::CopyFrom(const ConvolutionLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ConvolutionLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConvolutionLayerParams::IsInitialized() const {
  return true;
}

void ConvolutionLayerParams::InternalSwap(ConvolutionLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  kernelsize_.InternalSwap(&other->kernelsize_);
  stride_.InternalSwap(&other->stride_);
  dilationfactor_.InternalSwap(&other->dilationfactor_);
  outputshape_.InternalSwap(&other->outputshape_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConvolutionLayerParams, hasbias_)
      + sizeof(ConvolutionLayerParams::hasbias_)
      - PROTOBUF_FIELD_OFFSET(ConvolutionLayerParams, weights_)>(
          reinterpret_cast<char*>(&weights_),
          reinterpret_cast<char*>(&other->weights_));
  swap(ConvolutionPaddingType_, other->ConvolutionPaddingType_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ConvolutionLayerParams::GetTypeName() const {
  return "CoreML.Specification.ConvolutionLayerParams";
}


// ===================================================================

class Convolution3DLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::WeightParams& weights(const Convolution3DLayerParams* msg);
  static const ::CoreML::Specification::WeightParams& bias(const Convolution3DLayerParams* msg);
};

const ::CoreML::Specification::WeightParams&
Convolution3DLayerParams::_Internal::weights(const Convolution3DLayerParams* msg) {
  return *msg->weights_;
}
const ::CoreML::Specification::WeightParams&
Convolution3DLayerParams::_Internal::bias(const Convolution3DLayerParams* msg) {
  return *msg->bias_;
}
Convolution3DLayerParams::Convolution3DLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  outputshape_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.Convolution3DLayerParams)
}
Convolution3DLayerParams::Convolution3DLayerParams(const Convolution3DLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      outputshape_(from.outputshape_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_weights()) {
    weights_ = new ::CoreML::Specification::WeightParams(*from.weights_);
  } else {
    weights_ = nullptr;
  }
  if (from._internal_has_bias()) {
    bias_ = new ::CoreML::Specification::WeightParams(*from.bias_);
  } else {
    bias_ = nullptr;
  }
  ::memcpy(&outputchannels_, &from.outputchannels_,
    static_cast<size_t>(reinterpret_cast<char*>(&custompaddingright_) -
    reinterpret_cast<char*>(&outputchannels_)) + sizeof(custompaddingright_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Convolution3DLayerParams)
}

inline void Convolution3DLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&weights_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&custompaddingright_) -
    reinterpret_cast<char*>(&weights_)) + sizeof(custompaddingright_));
}

Convolution3DLayerParams::~Convolution3DLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Convolution3DLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Convolution3DLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete weights_;
  if (this != internal_default_instance()) delete bias_;
}

void Convolution3DLayerParams::ArenaDtor(void* object) {
  Convolution3DLayerParams* _this = reinterpret_cast< Convolution3DLayerParams* >(object);
  (void)_this;
}
void Convolution3DLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Convolution3DLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Convolution3DLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Convolution3DLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  outputshape_.Clear();
  if (GetArenaForAllocation() == nullptr && weights_ != nullptr) {
    delete weights_;
  }
  weights_ = nullptr;
  if (GetArenaForAllocation() == nullptr && bias_ != nullptr) {
    delete bias_;
  }
  bias_ = nullptr;
  ::memset(&outputchannels_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&custompaddingright_) -
      reinterpret_cast<char*>(&outputchannels_)) + sizeof(custompaddingright_));
  _internal_metadata_.Clear<std::string>();
}

const char* Convolution3DLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 outputChannels = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          outputchannels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 inputChannels = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          inputchannels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 nGroups = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          ngroups_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 kernelDepth = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          kerneldepth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 kernelHeight = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          kernelheight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 kernelWidth = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          kernelwidth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 strideDepth = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          stridedepth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 strideHeight = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          strideheight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 strideWidth = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          stridewidth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dilationDepth = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          dilationdepth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dilationHeight = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          dilationheight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dilationWidth = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          dilationwidth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hasBias = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          hasbias_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams weights = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_weights(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams bias = 61;
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_bias(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Convolution3DLayerParams.PaddingType paddingType = 70;
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_paddingtype(static_cast<::CoreML::Specification::Convolution3DLayerParams_PaddingType>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 customPaddingFront = 80;
      case 80:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          custompaddingfront_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 customPaddingBack = 81;
      case 81:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          custompaddingback_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 customPaddingTop = 82;
      case 82:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          custompaddingtop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 customPaddingBottom = 83;
      case 83:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          custompaddingbottom_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 customPaddingLeft = 84;
      case 84:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          custompaddingleft_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 customPaddingRight = 85;
      case 85:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          custompaddingright_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isDeconvolution = 86;
      case 86:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          isdeconvolution_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 outputShape = 87;
      case 87:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_outputshape(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 184) {
          _internal_add_outputshape(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Convolution3DLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.Convolution3DLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 outputChannels = 1;
  if (this->_internal_outputchannels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_outputchannels(), target);
  }

  // int32 inputChannels = 2;
  if (this->_internal_inputchannels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_inputchannels(), target);
  }

  // int32 nGroups = 10;
  if (this->_internal_ngroups() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(10, this->_internal_ngroups(), target);
  }

  // int32 kernelDepth = 20;
  if (this->_internal_kerneldepth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(20, this->_internal_kerneldepth(), target);
  }

  // int32 kernelHeight = 21;
  if (this->_internal_kernelheight() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(21, this->_internal_kernelheight(), target);
  }

  // int32 kernelWidth = 22;
  if (this->_internal_kernelwidth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(22, this->_internal_kernelwidth(), target);
  }

  // int32 strideDepth = 31;
  if (this->_internal_stridedepth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(31, this->_internal_stridedepth(), target);
  }

  // int32 strideHeight = 32;
  if (this->_internal_strideheight() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(32, this->_internal_strideheight(), target);
  }

  // int32 strideWidth = 33;
  if (this->_internal_stridewidth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(33, this->_internal_stridewidth(), target);
  }

  // int32 dilationDepth = 40;
  if (this->_internal_dilationdepth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(40, this->_internal_dilationdepth(), target);
  }

  // int32 dilationHeight = 41;
  if (this->_internal_dilationheight() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(41, this->_internal_dilationheight(), target);
  }

  // int32 dilationWidth = 42;
  if (this->_internal_dilationwidth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(42, this->_internal_dilationwidth(), target);
  }

  // bool hasBias = 50;
  if (this->_internal_hasbias() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(50, this->_internal_hasbias(), target);
  }

  // .CoreML.Specification.WeightParams weights = 60;
  if (this->_internal_has_weights()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        60, _Internal::weights(this), target, stream);
  }

  // .CoreML.Specification.WeightParams bias = 61;
  if (this->_internal_has_bias()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        61, _Internal::bias(this), target, stream);
  }

  // .CoreML.Specification.Convolution3DLayerParams.PaddingType paddingType = 70;
  if (this->_internal_paddingtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      70, this->_internal_paddingtype(), target);
  }

  // int32 customPaddingFront = 80;
  if (this->_internal_custompaddingfront() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(80, this->_internal_custompaddingfront(), target);
  }

  // int32 customPaddingBack = 81;
  if (this->_internal_custompaddingback() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(81, this->_internal_custompaddingback(), target);
  }

  // int32 customPaddingTop = 82;
  if (this->_internal_custompaddingtop() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(82, this->_internal_custompaddingtop(), target);
  }

  // int32 customPaddingBottom = 83;
  if (this->_internal_custompaddingbottom() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(83, this->_internal_custompaddingbottom(), target);
  }

  // int32 customPaddingLeft = 84;
  if (this->_internal_custompaddingleft() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(84, this->_internal_custompaddingleft(), target);
  }

  // int32 customPaddingRight = 85;
  if (this->_internal_custompaddingright() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(85, this->_internal_custompaddingright(), target);
  }

  // bool isDeconvolution = 86;
  if (this->_internal_isdeconvolution() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(86, this->_internal_isdeconvolution(), target);
  }

  // repeated uint64 outputShape = 87;
  {
    int byte_size = _outputshape_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          87, _internal_outputshape(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.Convolution3DLayerParams)
  return target;
}

size_t Convolution3DLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Convolution3DLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 outputShape = 87;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->outputshape_);
    if (data_size > 0) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _outputshape_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .CoreML.Specification.WeightParams weights = 60;
  if (this->_internal_has_weights()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *weights_);
  }

  // .CoreML.Specification.WeightParams bias = 61;
  if (this->_internal_has_bias()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bias_);
  }

  // int32 outputChannels = 1;
  if (this->_internal_outputchannels() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_outputchannels());
  }

  // int32 inputChannels = 2;
  if (this->_internal_inputchannels() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_inputchannels());
  }

  // int32 nGroups = 10;
  if (this->_internal_ngroups() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_ngroups());
  }

  // int32 kernelDepth = 20;
  if (this->_internal_kerneldepth() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_kerneldepth());
  }

  // int32 kernelHeight = 21;
  if (this->_internal_kernelheight() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_kernelheight());
  }

  // int32 kernelWidth = 22;
  if (this->_internal_kernelwidth() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_kernelwidth());
  }

  // int32 strideDepth = 31;
  if (this->_internal_stridedepth() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_stridedepth());
  }

  // int32 strideHeight = 32;
  if (this->_internal_strideheight() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_strideheight());
  }

  // int32 strideWidth = 33;
  if (this->_internal_stridewidth() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_stridewidth());
  }

  // int32 dilationDepth = 40;
  if (this->_internal_dilationdepth() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_dilationdepth());
  }

  // int32 dilationHeight = 41;
  if (this->_internal_dilationheight() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_dilationheight());
  }

  // int32 dilationWidth = 42;
  if (this->_internal_dilationwidth() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_dilationwidth());
  }

  // bool hasBias = 50;
  if (this->_internal_hasbias() != 0) {
    total_size += 2 + 1;
  }

  // bool isDeconvolution = 86;
  if (this->_internal_isdeconvolution() != 0) {
    total_size += 2 + 1;
  }

  // .CoreML.Specification.Convolution3DLayerParams.PaddingType paddingType = 70;
  if (this->_internal_paddingtype() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_paddingtype());
  }

  // int32 customPaddingFront = 80;
  if (this->_internal_custompaddingfront() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_custompaddingfront());
  }

  // int32 customPaddingBack = 81;
  if (this->_internal_custompaddingback() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_custompaddingback());
  }

  // int32 customPaddingTop = 82;
  if (this->_internal_custompaddingtop() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_custompaddingtop());
  }

  // int32 customPaddingBottom = 83;
  if (this->_internal_custompaddingbottom() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_custompaddingbottom());
  }

  // int32 customPaddingLeft = 84;
  if (this->_internal_custompaddingleft() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_custompaddingleft());
  }

  // int32 customPaddingRight = 85;
  if (this->_internal_custompaddingright() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_custompaddingright());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Convolution3DLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Convolution3DLayerParams*>(
      &from));
}

void Convolution3DLayerParams::MergeFrom(const Convolution3DLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Convolution3DLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  outputshape_.MergeFrom(from.outputshape_);
  if (from._internal_has_weights()) {
    _internal_mutable_weights()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_weights());
  }
  if (from._internal_has_bias()) {
    _internal_mutable_bias()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_bias());
  }
  if (from._internal_outputchannels() != 0) {
    _internal_set_outputchannels(from._internal_outputchannels());
  }
  if (from._internal_inputchannels() != 0) {
    _internal_set_inputchannels(from._internal_inputchannels());
  }
  if (from._internal_ngroups() != 0) {
    _internal_set_ngroups(from._internal_ngroups());
  }
  if (from._internal_kerneldepth() != 0) {
    _internal_set_kerneldepth(from._internal_kerneldepth());
  }
  if (from._internal_kernelheight() != 0) {
    _internal_set_kernelheight(from._internal_kernelheight());
  }
  if (from._internal_kernelwidth() != 0) {
    _internal_set_kernelwidth(from._internal_kernelwidth());
  }
  if (from._internal_stridedepth() != 0) {
    _internal_set_stridedepth(from._internal_stridedepth());
  }
  if (from._internal_strideheight() != 0) {
    _internal_set_strideheight(from._internal_strideheight());
  }
  if (from._internal_stridewidth() != 0) {
    _internal_set_stridewidth(from._internal_stridewidth());
  }
  if (from._internal_dilationdepth() != 0) {
    _internal_set_dilationdepth(from._internal_dilationdepth());
  }
  if (from._internal_dilationheight() != 0) {
    _internal_set_dilationheight(from._internal_dilationheight());
  }
  if (from._internal_dilationwidth() != 0) {
    _internal_set_dilationwidth(from._internal_dilationwidth());
  }
  if (from._internal_hasbias() != 0) {
    _internal_set_hasbias(from._internal_hasbias());
  }
  if (from._internal_isdeconvolution() != 0) {
    _internal_set_isdeconvolution(from._internal_isdeconvolution());
  }
  if (from._internal_paddingtype() != 0) {
    _internal_set_paddingtype(from._internal_paddingtype());
  }
  if (from._internal_custompaddingfront() != 0) {
    _internal_set_custompaddingfront(from._internal_custompaddingfront());
  }
  if (from._internal_custompaddingback() != 0) {
    _internal_set_custompaddingback(from._internal_custompaddingback());
  }
  if (from._internal_custompaddingtop() != 0) {
    _internal_set_custompaddingtop(from._internal_custompaddingtop());
  }
  if (from._internal_custompaddingbottom() != 0) {
    _internal_set_custompaddingbottom(from._internal_custompaddingbottom());
  }
  if (from._internal_custompaddingleft() != 0) {
    _internal_set_custompaddingleft(from._internal_custompaddingleft());
  }
  if (from._internal_custompaddingright() != 0) {
    _internal_set_custompaddingright(from._internal_custompaddingright());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Convolution3DLayerParams::CopyFrom(const Convolution3DLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Convolution3DLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Convolution3DLayerParams::IsInitialized() const {
  return true;
}

void Convolution3DLayerParams::InternalSwap(Convolution3DLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  outputshape_.InternalSwap(&other->outputshape_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Convolution3DLayerParams, custompaddingright_)
      + sizeof(Convolution3DLayerParams::custompaddingright_)
      - PROTOBUF_FIELD_OFFSET(Convolution3DLayerParams, weights_)>(
          reinterpret_cast<char*>(&weights_),
          reinterpret_cast<char*>(&other->weights_));
}

std::string Convolution3DLayerParams::GetTypeName() const {
  return "CoreML.Specification.Convolution3DLayerParams";
}


// ===================================================================

class InnerProductLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::WeightParams& weights(const InnerProductLayerParams* msg);
  static const ::CoreML::Specification::WeightParams& bias(const InnerProductLayerParams* msg);
};

const ::CoreML::Specification::WeightParams&
InnerProductLayerParams::_Internal::weights(const InnerProductLayerParams* msg) {
  return *msg->weights_;
}
const ::CoreML::Specification::WeightParams&
InnerProductLayerParams::_Internal::bias(const InnerProductLayerParams* msg) {
  return *msg->bias_;
}
InnerProductLayerParams::InnerProductLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.InnerProductLayerParams)
}
InnerProductLayerParams::InnerProductLayerParams(const InnerProductLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_weights()) {
    weights_ = new ::CoreML::Specification::WeightParams(*from.weights_);
  } else {
    weights_ = nullptr;
  }
  if (from._internal_has_bias()) {
    bias_ = new ::CoreML::Specification::WeightParams(*from.bias_);
  } else {
    bias_ = nullptr;
  }
  ::memcpy(&inputchannels_, &from.inputchannels_,
    static_cast<size_t>(reinterpret_cast<char*>(&int8dynamicquantize_) -
    reinterpret_cast<char*>(&inputchannels_)) + sizeof(int8dynamicquantize_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.InnerProductLayerParams)
}

inline void InnerProductLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&weights_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&int8dynamicquantize_) -
    reinterpret_cast<char*>(&weights_)) + sizeof(int8dynamicquantize_));
}

InnerProductLayerParams::~InnerProductLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.InnerProductLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void InnerProductLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete weights_;
  if (this != internal_default_instance()) delete bias_;
}

void InnerProductLayerParams::ArenaDtor(void* object) {
  InnerProductLayerParams* _this = reinterpret_cast< InnerProductLayerParams* >(object);
  (void)_this;
}
void InnerProductLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InnerProductLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InnerProductLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.InnerProductLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && weights_ != nullptr) {
    delete weights_;
  }
  weights_ = nullptr;
  if (GetArenaForAllocation() == nullptr && bias_ != nullptr) {
    delete bias_;
  }
  bias_ = nullptr;
  ::memset(&inputchannels_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&int8dynamicquantize_) -
      reinterpret_cast<char*>(&inputchannels_)) + sizeof(int8dynamicquantize_));
  _internal_metadata_.Clear<std::string>();
}

const char* InnerProductLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 inputChannels = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          inputchannels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 outputChannels = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          outputchannels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hasBias = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          hasbias_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams weights = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_weights(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams bias = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_bias(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool int8DynamicQuantize = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          int8dynamicquantize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InnerProductLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.InnerProductLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 inputChannels = 1;
  if (this->_internal_inputchannels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_inputchannels(), target);
  }

  // uint64 outputChannels = 2;
  if (this->_internal_outputchannels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_outputchannels(), target);
  }

  // bool hasBias = 10;
  if (this->_internal_hasbias() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_hasbias(), target);
  }

  // .CoreML.Specification.WeightParams weights = 20;
  if (this->_internal_has_weights()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::weights(this), target, stream);
  }

  // .CoreML.Specification.WeightParams bias = 21;
  if (this->_internal_has_bias()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        21, _Internal::bias(this), target, stream);
  }

  // bool int8DynamicQuantize = 22;
  if (this->_internal_int8dynamicquantize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(22, this->_internal_int8dynamicquantize(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.InnerProductLayerParams)
  return target;
}

size_t InnerProductLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.InnerProductLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.WeightParams weights = 20;
  if (this->_internal_has_weights()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *weights_);
  }

  // .CoreML.Specification.WeightParams bias = 21;
  if (this->_internal_has_bias()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bias_);
  }

  // uint64 inputChannels = 1;
  if (this->_internal_inputchannels() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_inputchannels());
  }

  // uint64 outputChannels = 2;
  if (this->_internal_outputchannels() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_outputchannels());
  }

  // bool hasBias = 10;
  if (this->_internal_hasbias() != 0) {
    total_size += 1 + 1;
  }

  // bool int8DynamicQuantize = 22;
  if (this->_internal_int8dynamicquantize() != 0) {
    total_size += 2 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InnerProductLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const InnerProductLayerParams*>(
      &from));
}

void InnerProductLayerParams::MergeFrom(const InnerProductLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.InnerProductLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_weights()) {
    _internal_mutable_weights()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_weights());
  }
  if (from._internal_has_bias()) {
    _internal_mutable_bias()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_bias());
  }
  if (from._internal_inputchannels() != 0) {
    _internal_set_inputchannels(from._internal_inputchannels());
  }
  if (from._internal_outputchannels() != 0) {
    _internal_set_outputchannels(from._internal_outputchannels());
  }
  if (from._internal_hasbias() != 0) {
    _internal_set_hasbias(from._internal_hasbias());
  }
  if (from._internal_int8dynamicquantize() != 0) {
    _internal_set_int8dynamicquantize(from._internal_int8dynamicquantize());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InnerProductLayerParams::CopyFrom(const InnerProductLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.InnerProductLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InnerProductLayerParams::IsInitialized() const {
  return true;
}

void InnerProductLayerParams::InternalSwap(InnerProductLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InnerProductLayerParams, int8dynamicquantize_)
      + sizeof(InnerProductLayerParams::int8dynamicquantize_)
      - PROTOBUF_FIELD_OFFSET(InnerProductLayerParams, weights_)>(
          reinterpret_cast<char*>(&weights_),
          reinterpret_cast<char*>(&other->weights_));
}

std::string InnerProductLayerParams::GetTypeName() const {
  return "CoreML.Specification.InnerProductLayerParams";
}


// ===================================================================

class EmbeddingLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::WeightParams& weights(const EmbeddingLayerParams* msg);
  static const ::CoreML::Specification::WeightParams& bias(const EmbeddingLayerParams* msg);
};

const ::CoreML::Specification::WeightParams&
EmbeddingLayerParams::_Internal::weights(const EmbeddingLayerParams* msg) {
  return *msg->weights_;
}
const ::CoreML::Specification::WeightParams&
EmbeddingLayerParams::_Internal::bias(const EmbeddingLayerParams* msg) {
  return *msg->bias_;
}
EmbeddingLayerParams::EmbeddingLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.EmbeddingLayerParams)
}
EmbeddingLayerParams::EmbeddingLayerParams(const EmbeddingLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_weights()) {
    weights_ = new ::CoreML::Specification::WeightParams(*from.weights_);
  } else {
    weights_ = nullptr;
  }
  if (from._internal_has_bias()) {
    bias_ = new ::CoreML::Specification::WeightParams(*from.bias_);
  } else {
    bias_ = nullptr;
  }
  ::memcpy(&inputdim_, &from.inputdim_,
    static_cast<size_t>(reinterpret_cast<char*>(&hasbias_) -
    reinterpret_cast<char*>(&inputdim_)) + sizeof(hasbias_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.EmbeddingLayerParams)
}

inline void EmbeddingLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&weights_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&hasbias_) -
    reinterpret_cast<char*>(&weights_)) + sizeof(hasbias_));
}

EmbeddingLayerParams::~EmbeddingLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.EmbeddingLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void EmbeddingLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete weights_;
  if (this != internal_default_instance()) delete bias_;
}

void EmbeddingLayerParams::ArenaDtor(void* object) {
  EmbeddingLayerParams* _this = reinterpret_cast< EmbeddingLayerParams* >(object);
  (void)_this;
}
void EmbeddingLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EmbeddingLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EmbeddingLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.EmbeddingLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && weights_ != nullptr) {
    delete weights_;
  }
  weights_ = nullptr;
  if (GetArenaForAllocation() == nullptr && bias_ != nullptr) {
    delete bias_;
  }
  bias_ = nullptr;
  ::memset(&inputdim_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&hasbias_) -
      reinterpret_cast<char*>(&inputdim_)) + sizeof(hasbias_));
  _internal_metadata_.Clear<std::string>();
}

const char* EmbeddingLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 inputDim = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          inputdim_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 outputChannels = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          outputchannels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hasBias = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          hasbias_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams weights = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_weights(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams bias = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_bias(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EmbeddingLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.EmbeddingLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 inputDim = 1;
  if (this->_internal_inputdim() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_inputdim(), target);
  }

  // uint64 outputChannels = 2;
  if (this->_internal_outputchannels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_outputchannels(), target);
  }

  // bool hasBias = 10;
  if (this->_internal_hasbias() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_hasbias(), target);
  }

  // .CoreML.Specification.WeightParams weights = 20;
  if (this->_internal_has_weights()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::weights(this), target, stream);
  }

  // .CoreML.Specification.WeightParams bias = 21;
  if (this->_internal_has_bias()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        21, _Internal::bias(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.EmbeddingLayerParams)
  return target;
}

size_t EmbeddingLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.EmbeddingLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.WeightParams weights = 20;
  if (this->_internal_has_weights()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *weights_);
  }

  // .CoreML.Specification.WeightParams bias = 21;
  if (this->_internal_has_bias()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bias_);
  }

  // uint64 inputDim = 1;
  if (this->_internal_inputdim() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_inputdim());
  }

  // uint64 outputChannels = 2;
  if (this->_internal_outputchannels() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_outputchannels());
  }

  // bool hasBias = 10;
  if (this->_internal_hasbias() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EmbeddingLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EmbeddingLayerParams*>(
      &from));
}

void EmbeddingLayerParams::MergeFrom(const EmbeddingLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.EmbeddingLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_weights()) {
    _internal_mutable_weights()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_weights());
  }
  if (from._internal_has_bias()) {
    _internal_mutable_bias()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_bias());
  }
  if (from._internal_inputdim() != 0) {
    _internal_set_inputdim(from._internal_inputdim());
  }
  if (from._internal_outputchannels() != 0) {
    _internal_set_outputchannels(from._internal_outputchannels());
  }
  if (from._internal_hasbias() != 0) {
    _internal_set_hasbias(from._internal_hasbias());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EmbeddingLayerParams::CopyFrom(const EmbeddingLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.EmbeddingLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmbeddingLayerParams::IsInitialized() const {
  return true;
}

void EmbeddingLayerParams::InternalSwap(EmbeddingLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EmbeddingLayerParams, hasbias_)
      + sizeof(EmbeddingLayerParams::hasbias_)
      - PROTOBUF_FIELD_OFFSET(EmbeddingLayerParams, weights_)>(
          reinterpret_cast<char*>(&weights_),
          reinterpret_cast<char*>(&other->weights_));
}

std::string EmbeddingLayerParams::GetTypeName() const {
  return "CoreML.Specification.EmbeddingLayerParams";
}


// ===================================================================

class EmbeddingNDLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::WeightParams& weights(const EmbeddingNDLayerParams* msg);
  static const ::CoreML::Specification::WeightParams& bias(const EmbeddingNDLayerParams* msg);
};

const ::CoreML::Specification::WeightParams&
EmbeddingNDLayerParams::_Internal::weights(const EmbeddingNDLayerParams* msg) {
  return *msg->weights_;
}
const ::CoreML::Specification::WeightParams&
EmbeddingNDLayerParams::_Internal::bias(const EmbeddingNDLayerParams* msg) {
  return *msg->bias_;
}
EmbeddingNDLayerParams::EmbeddingNDLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.EmbeddingNDLayerParams)
}
EmbeddingNDLayerParams::EmbeddingNDLayerParams(const EmbeddingNDLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_weights()) {
    weights_ = new ::CoreML::Specification::WeightParams(*from.weights_);
  } else {
    weights_ = nullptr;
  }
  if (from._internal_has_bias()) {
    bias_ = new ::CoreML::Specification::WeightParams(*from.bias_);
  } else {
    bias_ = nullptr;
  }
  ::memcpy(&vocabsize_, &from.vocabsize_,
    static_cast<size_t>(reinterpret_cast<char*>(&hasbias_) -
    reinterpret_cast<char*>(&vocabsize_)) + sizeof(hasbias_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.EmbeddingNDLayerParams)
}

inline void EmbeddingNDLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&weights_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&hasbias_) -
    reinterpret_cast<char*>(&weights_)) + sizeof(hasbias_));
}

EmbeddingNDLayerParams::~EmbeddingNDLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.EmbeddingNDLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void EmbeddingNDLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete weights_;
  if (this != internal_default_instance()) delete bias_;
}

void EmbeddingNDLayerParams::ArenaDtor(void* object) {
  EmbeddingNDLayerParams* _this = reinterpret_cast< EmbeddingNDLayerParams* >(object);
  (void)_this;
}
void EmbeddingNDLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EmbeddingNDLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EmbeddingNDLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.EmbeddingNDLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && weights_ != nullptr) {
    delete weights_;
  }
  weights_ = nullptr;
  if (GetArenaForAllocation() == nullptr && bias_ != nullptr) {
    delete bias_;
  }
  bias_ = nullptr;
  ::memset(&vocabsize_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&hasbias_) -
      reinterpret_cast<char*>(&vocabsize_)) + sizeof(hasbias_));
  _internal_metadata_.Clear<std::string>();
}

const char* EmbeddingNDLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 vocabSize = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          vocabsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 embeddingSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          embeddingsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hasBias = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          hasbias_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams weights = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_weights(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams bias = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_bias(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EmbeddingNDLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.EmbeddingNDLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 vocabSize = 1;
  if (this->_internal_vocabsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_vocabsize(), target);
  }

  // uint64 embeddingSize = 2;
  if (this->_internal_embeddingsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_embeddingsize(), target);
  }

  // bool hasBias = 3;
  if (this->_internal_hasbias() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_hasbias(), target);
  }

  // .CoreML.Specification.WeightParams weights = 20;
  if (this->_internal_has_weights()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::weights(this), target, stream);
  }

  // .CoreML.Specification.WeightParams bias = 21;
  if (this->_internal_has_bias()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        21, _Internal::bias(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.EmbeddingNDLayerParams)
  return target;
}

size_t EmbeddingNDLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.EmbeddingNDLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.WeightParams weights = 20;
  if (this->_internal_has_weights()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *weights_);
  }

  // .CoreML.Specification.WeightParams bias = 21;
  if (this->_internal_has_bias()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bias_);
  }

  // uint64 vocabSize = 1;
  if (this->_internal_vocabsize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_vocabsize());
  }

  // uint64 embeddingSize = 2;
  if (this->_internal_embeddingsize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_embeddingsize());
  }

  // bool hasBias = 3;
  if (this->_internal_hasbias() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EmbeddingNDLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EmbeddingNDLayerParams*>(
      &from));
}

void EmbeddingNDLayerParams::MergeFrom(const EmbeddingNDLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.EmbeddingNDLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_weights()) {
    _internal_mutable_weights()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_weights());
  }
  if (from._internal_has_bias()) {
    _internal_mutable_bias()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_bias());
  }
  if (from._internal_vocabsize() != 0) {
    _internal_set_vocabsize(from._internal_vocabsize());
  }
  if (from._internal_embeddingsize() != 0) {
    _internal_set_embeddingsize(from._internal_embeddingsize());
  }
  if (from._internal_hasbias() != 0) {
    _internal_set_hasbias(from._internal_hasbias());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EmbeddingNDLayerParams::CopyFrom(const EmbeddingNDLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.EmbeddingNDLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmbeddingNDLayerParams::IsInitialized() const {
  return true;
}

void EmbeddingNDLayerParams::InternalSwap(EmbeddingNDLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EmbeddingNDLayerParams, hasbias_)
      + sizeof(EmbeddingNDLayerParams::hasbias_)
      - PROTOBUF_FIELD_OFFSET(EmbeddingNDLayerParams, weights_)>(
          reinterpret_cast<char*>(&weights_),
          reinterpret_cast<char*>(&other->weights_));
}

std::string EmbeddingNDLayerParams::GetTypeName() const {
  return "CoreML.Specification.EmbeddingNDLayerParams";
}


// ===================================================================

class BatchnormLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::WeightParams& gamma(const BatchnormLayerParams* msg);
  static const ::CoreML::Specification::WeightParams& beta(const BatchnormLayerParams* msg);
  static const ::CoreML::Specification::WeightParams& mean(const BatchnormLayerParams* msg);
  static const ::CoreML::Specification::WeightParams& variance(const BatchnormLayerParams* msg);
};

const ::CoreML::Specification::WeightParams&
BatchnormLayerParams::_Internal::gamma(const BatchnormLayerParams* msg) {
  return *msg->gamma_;
}
const ::CoreML::Specification::WeightParams&
BatchnormLayerParams::_Internal::beta(const BatchnormLayerParams* msg) {
  return *msg->beta_;
}
const ::CoreML::Specification::WeightParams&
BatchnormLayerParams::_Internal::mean(const BatchnormLayerParams* msg) {
  return *msg->mean_;
}
const ::CoreML::Specification::WeightParams&
BatchnormLayerParams::_Internal::variance(const BatchnormLayerParams* msg) {
  return *msg->variance_;
}
BatchnormLayerParams::BatchnormLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.BatchnormLayerParams)
}
BatchnormLayerParams::BatchnormLayerParams(const BatchnormLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_gamma()) {
    gamma_ = new ::CoreML::Specification::WeightParams(*from.gamma_);
  } else {
    gamma_ = nullptr;
  }
  if (from._internal_has_beta()) {
    beta_ = new ::CoreML::Specification::WeightParams(*from.beta_);
  } else {
    beta_ = nullptr;
  }
  if (from._internal_has_mean()) {
    mean_ = new ::CoreML::Specification::WeightParams(*from.mean_);
  } else {
    mean_ = nullptr;
  }
  if (from._internal_has_variance()) {
    variance_ = new ::CoreML::Specification::WeightParams(*from.variance_);
  } else {
    variance_ = nullptr;
  }
  ::memcpy(&channels_, &from.channels_,
    static_cast<size_t>(reinterpret_cast<char*>(&epsilon_) -
    reinterpret_cast<char*>(&channels_)) + sizeof(epsilon_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.BatchnormLayerParams)
}

inline void BatchnormLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gamma_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&epsilon_) -
    reinterpret_cast<char*>(&gamma_)) + sizeof(epsilon_));
}

BatchnormLayerParams::~BatchnormLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.BatchnormLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BatchnormLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete gamma_;
  if (this != internal_default_instance()) delete beta_;
  if (this != internal_default_instance()) delete mean_;
  if (this != internal_default_instance()) delete variance_;
}

void BatchnormLayerParams::ArenaDtor(void* object) {
  BatchnormLayerParams* _this = reinterpret_cast< BatchnormLayerParams* >(object);
  (void)_this;
}
void BatchnormLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BatchnormLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BatchnormLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.BatchnormLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && gamma_ != nullptr) {
    delete gamma_;
  }
  gamma_ = nullptr;
  if (GetArenaForAllocation() == nullptr && beta_ != nullptr) {
    delete beta_;
  }
  beta_ = nullptr;
  if (GetArenaForAllocation() == nullptr && mean_ != nullptr) {
    delete mean_;
  }
  mean_ = nullptr;
  if (GetArenaForAllocation() == nullptr && variance_ != nullptr) {
    delete variance_;
  }
  variance_ = nullptr;
  ::memset(&channels_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&epsilon_) -
      reinterpret_cast<char*>(&channels_)) + sizeof(epsilon_));
  _internal_metadata_.Clear<std::string>();
}

const char* BatchnormLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 channels = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool computeMeanVar = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          computemeanvar_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool instanceNormalization = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          instancenormalization_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float epsilon = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          epsilon_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams gamma = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_gamma(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams beta = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_beta(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams mean = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_mean(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams variance = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_variance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchnormLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.BatchnormLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 channels = 1;
  if (this->_internal_channels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_channels(), target);
  }

  // bool computeMeanVar = 5;
  if (this->_internal_computemeanvar() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_computemeanvar(), target);
  }

  // bool instanceNormalization = 6;
  if (this->_internal_instancenormalization() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_instancenormalization(), target);
  }

  // float epsilon = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_epsilon = this->_internal_epsilon();
  uint32_t raw_epsilon;
  memcpy(&raw_epsilon, &tmp_epsilon, sizeof(tmp_epsilon));
  if (raw_epsilon != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_epsilon(), target);
  }

  // .CoreML.Specification.WeightParams gamma = 15;
  if (this->_internal_has_gamma()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        15, _Internal::gamma(this), target, stream);
  }

  // .CoreML.Specification.WeightParams beta = 16;
  if (this->_internal_has_beta()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        16, _Internal::beta(this), target, stream);
  }

  // .CoreML.Specification.WeightParams mean = 17;
  if (this->_internal_has_mean()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        17, _Internal::mean(this), target, stream);
  }

  // .CoreML.Specification.WeightParams variance = 18;
  if (this->_internal_has_variance()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        18, _Internal::variance(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.BatchnormLayerParams)
  return target;
}

size_t BatchnormLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.BatchnormLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.WeightParams gamma = 15;
  if (this->_internal_has_gamma()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *gamma_);
  }

  // .CoreML.Specification.WeightParams beta = 16;
  if (this->_internal_has_beta()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *beta_);
  }

  // .CoreML.Specification.WeightParams mean = 17;
  if (this->_internal_has_mean()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *mean_);
  }

  // .CoreML.Specification.WeightParams variance = 18;
  if (this->_internal_has_variance()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *variance_);
  }

  // uint64 channels = 1;
  if (this->_internal_channels() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_channels());
  }

  // bool computeMeanVar = 5;
  if (this->_internal_computemeanvar() != 0) {
    total_size += 1 + 1;
  }

  // bool instanceNormalization = 6;
  if (this->_internal_instancenormalization() != 0) {
    total_size += 1 + 1;
  }

  // float epsilon = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_epsilon = this->_internal_epsilon();
  uint32_t raw_epsilon;
  memcpy(&raw_epsilon, &tmp_epsilon, sizeof(tmp_epsilon));
  if (raw_epsilon != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BatchnormLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BatchnormLayerParams*>(
      &from));
}

void BatchnormLayerParams::MergeFrom(const BatchnormLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.BatchnormLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_gamma()) {
    _internal_mutable_gamma()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_gamma());
  }
  if (from._internal_has_beta()) {
    _internal_mutable_beta()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_beta());
  }
  if (from._internal_has_mean()) {
    _internal_mutable_mean()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_mean());
  }
  if (from._internal_has_variance()) {
    _internal_mutable_variance()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_variance());
  }
  if (from._internal_channels() != 0) {
    _internal_set_channels(from._internal_channels());
  }
  if (from._internal_computemeanvar() != 0) {
    _internal_set_computemeanvar(from._internal_computemeanvar());
  }
  if (from._internal_instancenormalization() != 0) {
    _internal_set_instancenormalization(from._internal_instancenormalization());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_epsilon = from._internal_epsilon();
  uint32_t raw_epsilon;
  memcpy(&raw_epsilon, &tmp_epsilon, sizeof(tmp_epsilon));
  if (raw_epsilon != 0) {
    _internal_set_epsilon(from._internal_epsilon());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BatchnormLayerParams::CopyFrom(const BatchnormLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.BatchnormLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchnormLayerParams::IsInitialized() const {
  return true;
}

void BatchnormLayerParams::InternalSwap(BatchnormLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BatchnormLayerParams, epsilon_)
      + sizeof(BatchnormLayerParams::epsilon_)
      - PROTOBUF_FIELD_OFFSET(BatchnormLayerParams, gamma_)>(
          reinterpret_cast<char*>(&gamma_),
          reinterpret_cast<char*>(&other->gamma_));
}

std::string BatchnormLayerParams::GetTypeName() const {
  return "CoreML.Specification.BatchnormLayerParams";
}


// ===================================================================

class PoolingLayerParams_ValidCompletePadding::_Internal {
 public:
};

PoolingLayerParams_ValidCompletePadding::PoolingLayerParams_ValidCompletePadding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  paddingamounts_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.PoolingLayerParams.ValidCompletePadding)
}
PoolingLayerParams_ValidCompletePadding::PoolingLayerParams_ValidCompletePadding(const PoolingLayerParams_ValidCompletePadding& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      paddingamounts_(from.paddingamounts_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.PoolingLayerParams.ValidCompletePadding)
}

inline void PoolingLayerParams_ValidCompletePadding::SharedCtor() {
}

PoolingLayerParams_ValidCompletePadding::~PoolingLayerParams_ValidCompletePadding() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.PoolingLayerParams.ValidCompletePadding)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PoolingLayerParams_ValidCompletePadding::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PoolingLayerParams_ValidCompletePadding::ArenaDtor(void* object) {
  PoolingLayerParams_ValidCompletePadding* _this = reinterpret_cast< PoolingLayerParams_ValidCompletePadding* >(object);
  (void)_this;
}
void PoolingLayerParams_ValidCompletePadding::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PoolingLayerParams_ValidCompletePadding::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PoolingLayerParams_ValidCompletePadding::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.PoolingLayerParams.ValidCompletePadding)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  paddingamounts_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PoolingLayerParams_ValidCompletePadding::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 paddingAmounts = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_paddingamounts(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 80) {
          _internal_add_paddingamounts(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PoolingLayerParams_ValidCompletePadding::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.PoolingLayerParams.ValidCompletePadding)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 paddingAmounts = 10;
  {
    int byte_size = _paddingamounts_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          10, _internal_paddingamounts(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.PoolingLayerParams.ValidCompletePadding)
  return target;
}

size_t PoolingLayerParams_ValidCompletePadding::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.PoolingLayerParams.ValidCompletePadding)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 paddingAmounts = 10;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->paddingamounts_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _paddingamounts_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PoolingLayerParams_ValidCompletePadding::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PoolingLayerParams_ValidCompletePadding*>(
      &from));
}

void PoolingLayerParams_ValidCompletePadding::MergeFrom(const PoolingLayerParams_ValidCompletePadding& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.PoolingLayerParams.ValidCompletePadding)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  paddingamounts_.MergeFrom(from.paddingamounts_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PoolingLayerParams_ValidCompletePadding::CopyFrom(const PoolingLayerParams_ValidCompletePadding& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.PoolingLayerParams.ValidCompletePadding)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PoolingLayerParams_ValidCompletePadding::IsInitialized() const {
  return true;
}

void PoolingLayerParams_ValidCompletePadding::InternalSwap(PoolingLayerParams_ValidCompletePadding* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  paddingamounts_.InternalSwap(&other->paddingamounts_);
}

std::string PoolingLayerParams_ValidCompletePadding::GetTypeName() const {
  return "CoreML.Specification.PoolingLayerParams.ValidCompletePadding";
}


// ===================================================================

class PoolingLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::ValidPadding& valid(const PoolingLayerParams* msg);
  static const ::CoreML::Specification::SamePadding& same(const PoolingLayerParams* msg);
  static const ::CoreML::Specification::PoolingLayerParams_ValidCompletePadding& includelastpixel(const PoolingLayerParams* msg);
};

const ::CoreML::Specification::ValidPadding&
PoolingLayerParams::_Internal::valid(const PoolingLayerParams* msg) {
  return *msg->PoolingPaddingType_.valid_;
}
const ::CoreML::Specification::SamePadding&
PoolingLayerParams::_Internal::same(const PoolingLayerParams* msg) {
  return *msg->PoolingPaddingType_.same_;
}
const ::CoreML::Specification::PoolingLayerParams_ValidCompletePadding&
PoolingLayerParams::_Internal::includelastpixel(const PoolingLayerParams* msg) {
  return *msg->PoolingPaddingType_.includelastpixel_;
}
void PoolingLayerParams::set_allocated_valid(::CoreML::Specification::ValidPadding* valid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_PoolingPaddingType();
  if (valid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::ValidPadding>::GetOwningArena(valid);
    if (message_arena != submessage_arena) {
      valid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, valid, submessage_arena);
    }
    set_has_valid();
    PoolingPaddingType_.valid_ = valid;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PoolingLayerParams.valid)
}
void PoolingLayerParams::set_allocated_same(::CoreML::Specification::SamePadding* same) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_PoolingPaddingType();
  if (same) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SamePadding>::GetOwningArena(same);
    if (message_arena != submessage_arena) {
      same = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, same, submessage_arena);
    }
    set_has_same();
    PoolingPaddingType_.same_ = same;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PoolingLayerParams.same)
}
void PoolingLayerParams::set_allocated_includelastpixel(::CoreML::Specification::PoolingLayerParams_ValidCompletePadding* includelastpixel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_PoolingPaddingType();
  if (includelastpixel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::PoolingLayerParams_ValidCompletePadding>::GetOwningArena(includelastpixel);
    if (message_arena != submessage_arena) {
      includelastpixel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, includelastpixel, submessage_arena);
    }
    set_has_includelastpixel();
    PoolingPaddingType_.includelastpixel_ = includelastpixel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PoolingLayerParams.includeLastPixel)
}
PoolingLayerParams::PoolingLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  kernelsize_(arena),
  stride_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.PoolingLayerParams)
}
PoolingLayerParams::PoolingLayerParams(const PoolingLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      kernelsize_(from.kernelsize_),
      stride_(from.stride_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&globalpooling_) -
    reinterpret_cast<char*>(&type_)) + sizeof(globalpooling_));
  clear_has_PoolingPaddingType();
  switch (from.PoolingPaddingType_case()) {
    case kValid: {
      _internal_mutable_valid()->::CoreML::Specification::ValidPadding::MergeFrom(from._internal_valid());
      break;
    }
    case kSame: {
      _internal_mutable_same()->::CoreML::Specification::SamePadding::MergeFrom(from._internal_same());
      break;
    }
    case kIncludeLastPixel: {
      _internal_mutable_includelastpixel()->::CoreML::Specification::PoolingLayerParams_ValidCompletePadding::MergeFrom(from._internal_includelastpixel());
      break;
    }
    case POOLINGPADDINGTYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.PoolingLayerParams)
}

inline void PoolingLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&globalpooling_) -
    reinterpret_cast<char*>(&type_)) + sizeof(globalpooling_));
clear_has_PoolingPaddingType();
}

PoolingLayerParams::~PoolingLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.PoolingLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PoolingLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_PoolingPaddingType()) {
    clear_PoolingPaddingType();
  }
}

void PoolingLayerParams::ArenaDtor(void* object) {
  PoolingLayerParams* _this = reinterpret_cast< PoolingLayerParams* >(object);
  (void)_this;
}
void PoolingLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PoolingLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PoolingLayerParams::clear_PoolingPaddingType() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.PoolingLayerParams)
  switch (PoolingPaddingType_case()) {
    case kValid: {
      if (GetArenaForAllocation() == nullptr) {
        delete PoolingPaddingType_.valid_;
      }
      break;
    }
    case kSame: {
      if (GetArenaForAllocation() == nullptr) {
        delete PoolingPaddingType_.same_;
      }
      break;
    }
    case kIncludeLastPixel: {
      if (GetArenaForAllocation() == nullptr) {
        delete PoolingPaddingType_.includelastpixel_;
      }
      break;
    }
    case POOLINGPADDINGTYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = POOLINGPADDINGTYPE_NOT_SET;
}


void PoolingLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.PoolingLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  kernelsize_.Clear();
  stride_.Clear();
  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&globalpooling_) -
      reinterpret_cast<char*>(&type_)) + sizeof(globalpooling_));
  clear_PoolingPaddingType();
  _internal_metadata_.Clear<std::string>();
}

const char* PoolingLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.PoolingLayerParams.PoolingType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::CoreML::Specification::PoolingLayerParams_PoolingType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 kernelSize = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_kernelsize(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 80) {
          _internal_add_kernelsize(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 stride = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_stride(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 160) {
          _internal_add_stride(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ValidPadding valid = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_valid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SamePadding same = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_same(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.PoolingLayerParams.ValidCompletePadding includeLastPixel = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_includelastpixel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool avgPoolExcludePadding = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          avgpoolexcludepadding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool globalPooling = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          globalpooling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PoolingLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.PoolingLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.PoolingLayerParams.PoolingType type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // repeated uint64 kernelSize = 10;
  {
    int byte_size = _kernelsize_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          10, _internal_kernelsize(), byte_size, target);
    }
  }

  // repeated uint64 stride = 20;
  {
    int byte_size = _stride_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          20, _internal_stride(), byte_size, target);
    }
  }

  // .CoreML.Specification.ValidPadding valid = 30;
  if (_internal_has_valid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        30, _Internal::valid(this), target, stream);
  }

  // .CoreML.Specification.SamePadding same = 31;
  if (_internal_has_same()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        31, _Internal::same(this), target, stream);
  }

  // .CoreML.Specification.PoolingLayerParams.ValidCompletePadding includeLastPixel = 32;
  if (_internal_has_includelastpixel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        32, _Internal::includelastpixel(this), target, stream);
  }

  // bool avgPoolExcludePadding = 50;
  if (this->_internal_avgpoolexcludepadding() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(50, this->_internal_avgpoolexcludepadding(), target);
  }

  // bool globalPooling = 60;
  if (this->_internal_globalpooling() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(60, this->_internal_globalpooling(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.PoolingLayerParams)
  return target;
}

size_t PoolingLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.PoolingLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 kernelSize = 10;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->kernelsize_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _kernelsize_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint64 stride = 20;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->stride_);
    if (data_size > 0) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _stride_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .CoreML.Specification.PoolingLayerParams.PoolingType type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  // bool avgPoolExcludePadding = 50;
  if (this->_internal_avgpoolexcludepadding() != 0) {
    total_size += 2 + 1;
  }

  // bool globalPooling = 60;
  if (this->_internal_globalpooling() != 0) {
    total_size += 2 + 1;
  }

  switch (PoolingPaddingType_case()) {
    // .CoreML.Specification.ValidPadding valid = 30;
    case kValid: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *PoolingPaddingType_.valid_);
      break;
    }
    // .CoreML.Specification.SamePadding same = 31;
    case kSame: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *PoolingPaddingType_.same_);
      break;
    }
    // .CoreML.Specification.PoolingLayerParams.ValidCompletePadding includeLastPixel = 32;
    case kIncludeLastPixel: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *PoolingPaddingType_.includelastpixel_);
      break;
    }
    case POOLINGPADDINGTYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PoolingLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PoolingLayerParams*>(
      &from));
}

void PoolingLayerParams::MergeFrom(const PoolingLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.PoolingLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  kernelsize_.MergeFrom(from.kernelsize_);
  stride_.MergeFrom(from.stride_);
  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  if (from._internal_avgpoolexcludepadding() != 0) {
    _internal_set_avgpoolexcludepadding(from._internal_avgpoolexcludepadding());
  }
  if (from._internal_globalpooling() != 0) {
    _internal_set_globalpooling(from._internal_globalpooling());
  }
  switch (from.PoolingPaddingType_case()) {
    case kValid: {
      _internal_mutable_valid()->::CoreML::Specification::ValidPadding::MergeFrom(from._internal_valid());
      break;
    }
    case kSame: {
      _internal_mutable_same()->::CoreML::Specification::SamePadding::MergeFrom(from._internal_same());
      break;
    }
    case kIncludeLastPixel: {
      _internal_mutable_includelastpixel()->::CoreML::Specification::PoolingLayerParams_ValidCompletePadding::MergeFrom(from._internal_includelastpixel());
      break;
    }
    case POOLINGPADDINGTYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PoolingLayerParams::CopyFrom(const PoolingLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.PoolingLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PoolingLayerParams::IsInitialized() const {
  return true;
}

void PoolingLayerParams::InternalSwap(PoolingLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  kernelsize_.InternalSwap(&other->kernelsize_);
  stride_.InternalSwap(&other->stride_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PoolingLayerParams, globalpooling_)
      + sizeof(PoolingLayerParams::globalpooling_)
      - PROTOBUF_FIELD_OFFSET(PoolingLayerParams, type_)>(
          reinterpret_cast<char*>(&type_),
          reinterpret_cast<char*>(&other->type_));
  swap(PoolingPaddingType_, other->PoolingPaddingType_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string PoolingLayerParams::GetTypeName() const {
  return "CoreML.Specification.PoolingLayerParams";
}


// ===================================================================

class Pooling3DLayerParams::_Internal {
 public:
};

Pooling3DLayerParams::Pooling3DLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.Pooling3DLayerParams)
}
Pooling3DLayerParams::Pooling3DLayerParams(const Pooling3DLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&paddingtype_) -
    reinterpret_cast<char*>(&type_)) + sizeof(paddingtype_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Pooling3DLayerParams)
}

inline void Pooling3DLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&paddingtype_) -
    reinterpret_cast<char*>(&type_)) + sizeof(paddingtype_));
}

Pooling3DLayerParams::~Pooling3DLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Pooling3DLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Pooling3DLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Pooling3DLayerParams::ArenaDtor(void* object) {
  Pooling3DLayerParams* _this = reinterpret_cast< Pooling3DLayerParams* >(object);
  (void)_this;
}
void Pooling3DLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Pooling3DLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Pooling3DLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Pooling3DLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&paddingtype_) -
      reinterpret_cast<char*>(&type_)) + sizeof(paddingtype_));
  _internal_metadata_.Clear<std::string>();
}

const char* Pooling3DLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.Pooling3DLayerParams.PoolingType3D type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::CoreML::Specification::Pooling3DLayerParams_PoolingType3D>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 kernelDepth = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          kerneldepth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 kernelHeight = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          kernelheight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 kernelWidth = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          kernelwidth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 strideDepth = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          stridedepth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 strideHeight = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          strideheight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 strideWidth = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          stridewidth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 customPaddingFront = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          custompaddingfront_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 customPaddingBack = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          custompaddingback_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 customPaddingTop = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          custompaddingtop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 customPaddingBottom = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          custompaddingbottom_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 customPaddingLeft = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          custompaddingleft_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 customPaddingRight = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          custompaddingright_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool countExcludePadding = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          countexcludepadding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Pooling3DLayerParams.Pooling3DPaddingType paddingType = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_paddingtype(static_cast<::CoreML::Specification::Pooling3DLayerParams_Pooling3DPaddingType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Pooling3DLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.Pooling3DLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.Pooling3DLayerParams.PoolingType3D type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // int32 kernelDepth = 2;
  if (this->_internal_kerneldepth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_kerneldepth(), target);
  }

  // int32 kernelHeight = 3;
  if (this->_internal_kernelheight() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_kernelheight(), target);
  }

  // int32 kernelWidth = 4;
  if (this->_internal_kernelwidth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_kernelwidth(), target);
  }

  // int32 strideDepth = 5;
  if (this->_internal_stridedepth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_stridedepth(), target);
  }

  // int32 strideHeight = 6;
  if (this->_internal_strideheight() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_strideheight(), target);
  }

  // int32 strideWidth = 7;
  if (this->_internal_stridewidth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_stridewidth(), target);
  }

  // int32 customPaddingFront = 8;
  if (this->_internal_custompaddingfront() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_custompaddingfront(), target);
  }

  // int32 customPaddingBack = 9;
  if (this->_internal_custompaddingback() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->_internal_custompaddingback(), target);
  }

  // int32 customPaddingTop = 10;
  if (this->_internal_custompaddingtop() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(10, this->_internal_custompaddingtop(), target);
  }

  // int32 customPaddingBottom = 11;
  if (this->_internal_custompaddingbottom() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_custompaddingbottom(), target);
  }

  // int32 customPaddingLeft = 12;
  if (this->_internal_custompaddingleft() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(12, this->_internal_custompaddingleft(), target);
  }

  // int32 customPaddingRight = 13;
  if (this->_internal_custompaddingright() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(13, this->_internal_custompaddingright(), target);
  }

  // bool countExcludePadding = 14;
  if (this->_internal_countexcludepadding() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_countexcludepadding(), target);
  }

  // .CoreML.Specification.Pooling3DLayerParams.Pooling3DPaddingType paddingType = 15;
  if (this->_internal_paddingtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      15, this->_internal_paddingtype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.Pooling3DLayerParams)
  return target;
}

size_t Pooling3DLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Pooling3DLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.Pooling3DLayerParams.PoolingType3D type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  // int32 kernelDepth = 2;
  if (this->_internal_kerneldepth() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_kerneldepth());
  }

  // int32 kernelHeight = 3;
  if (this->_internal_kernelheight() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_kernelheight());
  }

  // int32 kernelWidth = 4;
  if (this->_internal_kernelwidth() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_kernelwidth());
  }

  // int32 strideDepth = 5;
  if (this->_internal_stridedepth() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_stridedepth());
  }

  // int32 strideHeight = 6;
  if (this->_internal_strideheight() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_strideheight());
  }

  // int32 strideWidth = 7;
  if (this->_internal_stridewidth() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_stridewidth());
  }

  // int32 customPaddingFront = 8;
  if (this->_internal_custompaddingfront() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_custompaddingfront());
  }

  // int32 customPaddingBack = 9;
  if (this->_internal_custompaddingback() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_custompaddingback());
  }

  // int32 customPaddingTop = 10;
  if (this->_internal_custompaddingtop() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_custompaddingtop());
  }

  // int32 customPaddingBottom = 11;
  if (this->_internal_custompaddingbottom() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_custompaddingbottom());
  }

  // int32 customPaddingLeft = 12;
  if (this->_internal_custompaddingleft() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_custompaddingleft());
  }

  // int32 customPaddingRight = 13;
  if (this->_internal_custompaddingright() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_custompaddingright());
  }

  // bool countExcludePadding = 14;
  if (this->_internal_countexcludepadding() != 0) {
    total_size += 1 + 1;
  }

  // .CoreML.Specification.Pooling3DLayerParams.Pooling3DPaddingType paddingType = 15;
  if (this->_internal_paddingtype() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_paddingtype());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Pooling3DLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Pooling3DLayerParams*>(
      &from));
}

void Pooling3DLayerParams::MergeFrom(const Pooling3DLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Pooling3DLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  if (from._internal_kerneldepth() != 0) {
    _internal_set_kerneldepth(from._internal_kerneldepth());
  }
  if (from._internal_kernelheight() != 0) {
    _internal_set_kernelheight(from._internal_kernelheight());
  }
  if (from._internal_kernelwidth() != 0) {
    _internal_set_kernelwidth(from._internal_kernelwidth());
  }
  if (from._internal_stridedepth() != 0) {
    _internal_set_stridedepth(from._internal_stridedepth());
  }
  if (from._internal_strideheight() != 0) {
    _internal_set_strideheight(from._internal_strideheight());
  }
  if (from._internal_stridewidth() != 0) {
    _internal_set_stridewidth(from._internal_stridewidth());
  }
  if (from._internal_custompaddingfront() != 0) {
    _internal_set_custompaddingfront(from._internal_custompaddingfront());
  }
  if (from._internal_custompaddingback() != 0) {
    _internal_set_custompaddingback(from._internal_custompaddingback());
  }
  if (from._internal_custompaddingtop() != 0) {
    _internal_set_custompaddingtop(from._internal_custompaddingtop());
  }
  if (from._internal_custompaddingbottom() != 0) {
    _internal_set_custompaddingbottom(from._internal_custompaddingbottom());
  }
  if (from._internal_custompaddingleft() != 0) {
    _internal_set_custompaddingleft(from._internal_custompaddingleft());
  }
  if (from._internal_custompaddingright() != 0) {
    _internal_set_custompaddingright(from._internal_custompaddingright());
  }
  if (from._internal_countexcludepadding() != 0) {
    _internal_set_countexcludepadding(from._internal_countexcludepadding());
  }
  if (from._internal_paddingtype() != 0) {
    _internal_set_paddingtype(from._internal_paddingtype());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Pooling3DLayerParams::CopyFrom(const Pooling3DLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Pooling3DLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pooling3DLayerParams::IsInitialized() const {
  return true;
}

void Pooling3DLayerParams::InternalSwap(Pooling3DLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Pooling3DLayerParams, paddingtype_)
      + sizeof(Pooling3DLayerParams::paddingtype_)
      - PROTOBUF_FIELD_OFFSET(Pooling3DLayerParams, type_)>(
          reinterpret_cast<char*>(&type_),
          reinterpret_cast<char*>(&other->type_));
}

std::string Pooling3DLayerParams::GetTypeName() const {
  return "CoreML.Specification.Pooling3DLayerParams";
}


// ===================================================================

class GlobalPooling3DLayerParams::_Internal {
 public:
};

GlobalPooling3DLayerParams::GlobalPooling3DLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.GlobalPooling3DLayerParams)
}
GlobalPooling3DLayerParams::GlobalPooling3DLayerParams(const GlobalPooling3DLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.GlobalPooling3DLayerParams)
}

inline void GlobalPooling3DLayerParams::SharedCtor() {
type_ = 0;
}

GlobalPooling3DLayerParams::~GlobalPooling3DLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.GlobalPooling3DLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GlobalPooling3DLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GlobalPooling3DLayerParams::ArenaDtor(void* object) {
  GlobalPooling3DLayerParams* _this = reinterpret_cast< GlobalPooling3DLayerParams* >(object);
  (void)_this;
}
void GlobalPooling3DLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GlobalPooling3DLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GlobalPooling3DLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.GlobalPooling3DLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* GlobalPooling3DLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.GlobalPooling3DLayerParams.GlobalPoolingType3D type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::CoreML::Specification::GlobalPooling3DLayerParams_GlobalPoolingType3D>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GlobalPooling3DLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.GlobalPooling3DLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.GlobalPooling3DLayerParams.GlobalPoolingType3D type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.GlobalPooling3DLayerParams)
  return target;
}

size_t GlobalPooling3DLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.GlobalPooling3DLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.GlobalPooling3DLayerParams.GlobalPoolingType3D type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GlobalPooling3DLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GlobalPooling3DLayerParams*>(
      &from));
}

void GlobalPooling3DLayerParams::MergeFrom(const GlobalPooling3DLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.GlobalPooling3DLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GlobalPooling3DLayerParams::CopyFrom(const GlobalPooling3DLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.GlobalPooling3DLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlobalPooling3DLayerParams::IsInitialized() const {
  return true;
}

void GlobalPooling3DLayerParams::InternalSwap(GlobalPooling3DLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(type_, other->type_);
}

std::string GlobalPooling3DLayerParams::GetTypeName() const {
  return "CoreML.Specification.GlobalPooling3DLayerParams";
}


// ===================================================================

class PaddingLayerParams_PaddingConstant::_Internal {
 public:
};

PaddingLayerParams_PaddingConstant::PaddingLayerParams_PaddingConstant(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.PaddingLayerParams.PaddingConstant)
}
PaddingLayerParams_PaddingConstant::PaddingLayerParams_PaddingConstant(const PaddingLayerParams_PaddingConstant& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  value_ = from.value_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.PaddingLayerParams.PaddingConstant)
}

inline void PaddingLayerParams_PaddingConstant::SharedCtor() {
value_ = 0;
}

PaddingLayerParams_PaddingConstant::~PaddingLayerParams_PaddingConstant() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.PaddingLayerParams.PaddingConstant)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PaddingLayerParams_PaddingConstant::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PaddingLayerParams_PaddingConstant::ArenaDtor(void* object) {
  PaddingLayerParams_PaddingConstant* _this = reinterpret_cast< PaddingLayerParams_PaddingConstant* >(object);
  (void)_this;
}
void PaddingLayerParams_PaddingConstant::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PaddingLayerParams_PaddingConstant::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PaddingLayerParams_PaddingConstant::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.PaddingLayerParams.PaddingConstant)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  value_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* PaddingLayerParams_PaddingConstant::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PaddingLayerParams_PaddingConstant::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.PaddingLayerParams.PaddingConstant)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float value = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value = this->_internal_value();
  uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.PaddingLayerParams.PaddingConstant)
  return target;
}

size_t PaddingLayerParams_PaddingConstant::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.PaddingLayerParams.PaddingConstant)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float value = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value = this->_internal_value();
  uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PaddingLayerParams_PaddingConstant::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PaddingLayerParams_PaddingConstant*>(
      &from));
}

void PaddingLayerParams_PaddingConstant::MergeFrom(const PaddingLayerParams_PaddingConstant& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.PaddingLayerParams.PaddingConstant)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value = from._internal_value();
  uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    _internal_set_value(from._internal_value());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PaddingLayerParams_PaddingConstant::CopyFrom(const PaddingLayerParams_PaddingConstant& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.PaddingLayerParams.PaddingConstant)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PaddingLayerParams_PaddingConstant::IsInitialized() const {
  return true;
}

void PaddingLayerParams_PaddingConstant::InternalSwap(PaddingLayerParams_PaddingConstant* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(value_, other->value_);
}

std::string PaddingLayerParams_PaddingConstant::GetTypeName() const {
  return "CoreML.Specification.PaddingLayerParams.PaddingConstant";
}


// ===================================================================

class PaddingLayerParams_PaddingReflection::_Internal {
 public:
};

PaddingLayerParams_PaddingReflection::PaddingLayerParams_PaddingReflection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.PaddingLayerParams.PaddingReflection)
}
PaddingLayerParams_PaddingReflection::PaddingLayerParams_PaddingReflection(const PaddingLayerParams_PaddingReflection& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.PaddingLayerParams.PaddingReflection)
}

inline void PaddingLayerParams_PaddingReflection::SharedCtor() {
}

PaddingLayerParams_PaddingReflection::~PaddingLayerParams_PaddingReflection() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.PaddingLayerParams.PaddingReflection)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PaddingLayerParams_PaddingReflection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PaddingLayerParams_PaddingReflection::ArenaDtor(void* object) {
  PaddingLayerParams_PaddingReflection* _this = reinterpret_cast< PaddingLayerParams_PaddingReflection* >(object);
  (void)_this;
}
void PaddingLayerParams_PaddingReflection::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PaddingLayerParams_PaddingReflection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PaddingLayerParams_PaddingReflection::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.PaddingLayerParams.PaddingReflection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* PaddingLayerParams_PaddingReflection::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PaddingLayerParams_PaddingReflection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.PaddingLayerParams.PaddingReflection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.PaddingLayerParams.PaddingReflection)
  return target;
}

size_t PaddingLayerParams_PaddingReflection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.PaddingLayerParams.PaddingReflection)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PaddingLayerParams_PaddingReflection::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PaddingLayerParams_PaddingReflection*>(
      &from));
}

void PaddingLayerParams_PaddingReflection::MergeFrom(const PaddingLayerParams_PaddingReflection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.PaddingLayerParams.PaddingReflection)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PaddingLayerParams_PaddingReflection::CopyFrom(const PaddingLayerParams_PaddingReflection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.PaddingLayerParams.PaddingReflection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PaddingLayerParams_PaddingReflection::IsInitialized() const {
  return true;
}

void PaddingLayerParams_PaddingReflection::InternalSwap(PaddingLayerParams_PaddingReflection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string PaddingLayerParams_PaddingReflection::GetTypeName() const {
  return "CoreML.Specification.PaddingLayerParams.PaddingReflection";
}


// ===================================================================

class PaddingLayerParams_PaddingReplication::_Internal {
 public:
};

PaddingLayerParams_PaddingReplication::PaddingLayerParams_PaddingReplication(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.PaddingLayerParams.PaddingReplication)
}
PaddingLayerParams_PaddingReplication::PaddingLayerParams_PaddingReplication(const PaddingLayerParams_PaddingReplication& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.PaddingLayerParams.PaddingReplication)
}

inline void PaddingLayerParams_PaddingReplication::SharedCtor() {
}

PaddingLayerParams_PaddingReplication::~PaddingLayerParams_PaddingReplication() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.PaddingLayerParams.PaddingReplication)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PaddingLayerParams_PaddingReplication::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PaddingLayerParams_PaddingReplication::ArenaDtor(void* object) {
  PaddingLayerParams_PaddingReplication* _this = reinterpret_cast< PaddingLayerParams_PaddingReplication* >(object);
  (void)_this;
}
void PaddingLayerParams_PaddingReplication::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PaddingLayerParams_PaddingReplication::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PaddingLayerParams_PaddingReplication::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.PaddingLayerParams.PaddingReplication)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* PaddingLayerParams_PaddingReplication::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PaddingLayerParams_PaddingReplication::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.PaddingLayerParams.PaddingReplication)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.PaddingLayerParams.PaddingReplication)
  return target;
}

size_t PaddingLayerParams_PaddingReplication::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.PaddingLayerParams.PaddingReplication)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PaddingLayerParams_PaddingReplication::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PaddingLayerParams_PaddingReplication*>(
      &from));
}

void PaddingLayerParams_PaddingReplication::MergeFrom(const PaddingLayerParams_PaddingReplication& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.PaddingLayerParams.PaddingReplication)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PaddingLayerParams_PaddingReplication::CopyFrom(const PaddingLayerParams_PaddingReplication& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.PaddingLayerParams.PaddingReplication)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PaddingLayerParams_PaddingReplication::IsInitialized() const {
  return true;
}

void PaddingLayerParams_PaddingReplication::InternalSwap(PaddingLayerParams_PaddingReplication* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string PaddingLayerParams_PaddingReplication::GetTypeName() const {
  return "CoreML.Specification.PaddingLayerParams.PaddingReplication";
}


// ===================================================================

class PaddingLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::PaddingLayerParams_PaddingConstant& constant(const PaddingLayerParams* msg);
  static const ::CoreML::Specification::PaddingLayerParams_PaddingReflection& reflection(const PaddingLayerParams* msg);
  static const ::CoreML::Specification::PaddingLayerParams_PaddingReplication& replication(const PaddingLayerParams* msg);
  static const ::CoreML::Specification::BorderAmounts& paddingamounts(const PaddingLayerParams* msg);
};

const ::CoreML::Specification::PaddingLayerParams_PaddingConstant&
PaddingLayerParams::_Internal::constant(const PaddingLayerParams* msg) {
  return *msg->PaddingType_.constant_;
}
const ::CoreML::Specification::PaddingLayerParams_PaddingReflection&
PaddingLayerParams::_Internal::reflection(const PaddingLayerParams* msg) {
  return *msg->PaddingType_.reflection_;
}
const ::CoreML::Specification::PaddingLayerParams_PaddingReplication&
PaddingLayerParams::_Internal::replication(const PaddingLayerParams* msg) {
  return *msg->PaddingType_.replication_;
}
const ::CoreML::Specification::BorderAmounts&
PaddingLayerParams::_Internal::paddingamounts(const PaddingLayerParams* msg) {
  return *msg->paddingamounts_;
}
void PaddingLayerParams::set_allocated_constant(::CoreML::Specification::PaddingLayerParams_PaddingConstant* constant) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_PaddingType();
  if (constant) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::PaddingLayerParams_PaddingConstant>::GetOwningArena(constant);
    if (message_arena != submessage_arena) {
      constant = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, constant, submessage_arena);
    }
    set_has_constant();
    PaddingType_.constant_ = constant;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PaddingLayerParams.constant)
}
void PaddingLayerParams::set_allocated_reflection(::CoreML::Specification::PaddingLayerParams_PaddingReflection* reflection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_PaddingType();
  if (reflection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::PaddingLayerParams_PaddingReflection>::GetOwningArena(reflection);
    if (message_arena != submessage_arena) {
      reflection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reflection, submessage_arena);
    }
    set_has_reflection();
    PaddingType_.reflection_ = reflection;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PaddingLayerParams.reflection)
}
void PaddingLayerParams::set_allocated_replication(::CoreML::Specification::PaddingLayerParams_PaddingReplication* replication) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_PaddingType();
  if (replication) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::PaddingLayerParams_PaddingReplication>::GetOwningArena(replication);
    if (message_arena != submessage_arena) {
      replication = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, replication, submessage_arena);
    }
    set_has_replication();
    PaddingType_.replication_ = replication;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PaddingLayerParams.replication)
}
PaddingLayerParams::PaddingLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.PaddingLayerParams)
}
PaddingLayerParams::PaddingLayerParams(const PaddingLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_paddingamounts()) {
    paddingamounts_ = new ::CoreML::Specification::BorderAmounts(*from.paddingamounts_);
  } else {
    paddingamounts_ = nullptr;
  }
  clear_has_PaddingType();
  switch (from.PaddingType_case()) {
    case kConstant: {
      _internal_mutable_constant()->::CoreML::Specification::PaddingLayerParams_PaddingConstant::MergeFrom(from._internal_constant());
      break;
    }
    case kReflection: {
      _internal_mutable_reflection()->::CoreML::Specification::PaddingLayerParams_PaddingReflection::MergeFrom(from._internal_reflection());
      break;
    }
    case kReplication: {
      _internal_mutable_replication()->::CoreML::Specification::PaddingLayerParams_PaddingReplication::MergeFrom(from._internal_replication());
      break;
    }
    case PADDINGTYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.PaddingLayerParams)
}

inline void PaddingLayerParams::SharedCtor() {
paddingamounts_ = nullptr;
clear_has_PaddingType();
}

PaddingLayerParams::~PaddingLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.PaddingLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PaddingLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete paddingamounts_;
  if (has_PaddingType()) {
    clear_PaddingType();
  }
}

void PaddingLayerParams::ArenaDtor(void* object) {
  PaddingLayerParams* _this = reinterpret_cast< PaddingLayerParams* >(object);
  (void)_this;
}
void PaddingLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PaddingLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PaddingLayerParams::clear_PaddingType() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.PaddingLayerParams)
  switch (PaddingType_case()) {
    case kConstant: {
      if (GetArenaForAllocation() == nullptr) {
        delete PaddingType_.constant_;
      }
      break;
    }
    case kReflection: {
      if (GetArenaForAllocation() == nullptr) {
        delete PaddingType_.reflection_;
      }
      break;
    }
    case kReplication: {
      if (GetArenaForAllocation() == nullptr) {
        delete PaddingType_.replication_;
      }
      break;
    }
    case PADDINGTYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = PADDINGTYPE_NOT_SET;
}


void PaddingLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.PaddingLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && paddingamounts_ != nullptr) {
    delete paddingamounts_;
  }
  paddingamounts_ = nullptr;
  clear_PaddingType();
  _internal_metadata_.Clear<std::string>();
}

const char* PaddingLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.PaddingLayerParams.PaddingConstant constant = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_constant(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.PaddingLayerParams.PaddingReflection reflection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_reflection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.PaddingLayerParams.PaddingReplication replication = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_replication(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.BorderAmounts paddingAmounts = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_paddingamounts(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PaddingLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.PaddingLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.PaddingLayerParams.PaddingConstant constant = 1;
  if (_internal_has_constant()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::constant(this), target, stream);
  }

  // .CoreML.Specification.PaddingLayerParams.PaddingReflection reflection = 2;
  if (_internal_has_reflection()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::reflection(this), target, stream);
  }

  // .CoreML.Specification.PaddingLayerParams.PaddingReplication replication = 3;
  if (_internal_has_replication()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::replication(this), target, stream);
  }

  // .CoreML.Specification.BorderAmounts paddingAmounts = 10;
  if (this->_internal_has_paddingamounts()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::paddingamounts(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.PaddingLayerParams)
  return target;
}

size_t PaddingLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.PaddingLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.BorderAmounts paddingAmounts = 10;
  if (this->_internal_has_paddingamounts()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *paddingamounts_);
  }

  switch (PaddingType_case()) {
    // .CoreML.Specification.PaddingLayerParams.PaddingConstant constant = 1;
    case kConstant: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *PaddingType_.constant_);
      break;
    }
    // .CoreML.Specification.PaddingLayerParams.PaddingReflection reflection = 2;
    case kReflection: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *PaddingType_.reflection_);
      break;
    }
    // .CoreML.Specification.PaddingLayerParams.PaddingReplication replication = 3;
    case kReplication: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *PaddingType_.replication_);
      break;
    }
    case PADDINGTYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PaddingLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PaddingLayerParams*>(
      &from));
}

void PaddingLayerParams::MergeFrom(const PaddingLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.PaddingLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_paddingamounts()) {
    _internal_mutable_paddingamounts()->::CoreML::Specification::BorderAmounts::MergeFrom(from._internal_paddingamounts());
  }
  switch (from.PaddingType_case()) {
    case kConstant: {
      _internal_mutable_constant()->::CoreML::Specification::PaddingLayerParams_PaddingConstant::MergeFrom(from._internal_constant());
      break;
    }
    case kReflection: {
      _internal_mutable_reflection()->::CoreML::Specification::PaddingLayerParams_PaddingReflection::MergeFrom(from._internal_reflection());
      break;
    }
    case kReplication: {
      _internal_mutable_replication()->::CoreML::Specification::PaddingLayerParams_PaddingReplication::MergeFrom(from._internal_replication());
      break;
    }
    case PADDINGTYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PaddingLayerParams::CopyFrom(const PaddingLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.PaddingLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PaddingLayerParams::IsInitialized() const {
  return true;
}

void PaddingLayerParams::InternalSwap(PaddingLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(paddingamounts_, other->paddingamounts_);
  swap(PaddingType_, other->PaddingType_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string PaddingLayerParams::GetTypeName() const {
  return "CoreML.Specification.PaddingLayerParams";
}


// ===================================================================

class ConcatLayerParams::_Internal {
 public:
};

ConcatLayerParams::ConcatLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ConcatLayerParams)
}
ConcatLayerParams::ConcatLayerParams(const ConcatLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  sequenceconcat_ = from.sequenceconcat_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ConcatLayerParams)
}

inline void ConcatLayerParams::SharedCtor() {
sequenceconcat_ = false;
}

ConcatLayerParams::~ConcatLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ConcatLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ConcatLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ConcatLayerParams::ArenaDtor(void* object) {
  ConcatLayerParams* _this = reinterpret_cast< ConcatLayerParams* >(object);
  (void)_this;
}
void ConcatLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConcatLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConcatLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ConcatLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sequenceconcat_ = false;
  _internal_metadata_.Clear<std::string>();
}

const char* ConcatLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool sequenceConcat = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          sequenceconcat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConcatLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ConcatLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool sequenceConcat = 100;
  if (this->_internal_sequenceconcat() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(100, this->_internal_sequenceconcat(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ConcatLayerParams)
  return target;
}

size_t ConcatLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ConcatLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool sequenceConcat = 100;
  if (this->_internal_sequenceconcat() != 0) {
    total_size += 2 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConcatLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ConcatLayerParams*>(
      &from));
}

void ConcatLayerParams::MergeFrom(const ConcatLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ConcatLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_sequenceconcat() != 0) {
    _internal_set_sequenceconcat(from._internal_sequenceconcat());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConcatLayerParams::CopyFrom(const ConcatLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ConcatLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConcatLayerParams::IsInitialized() const {
  return true;
}

void ConcatLayerParams::InternalSwap(ConcatLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(sequenceconcat_, other->sequenceconcat_);
}

std::string ConcatLayerParams::GetTypeName() const {
  return "CoreML.Specification.ConcatLayerParams";
}


// ===================================================================

class LRNLayerParams::_Internal {
 public:
};

LRNLayerParams::LRNLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LRNLayerParams)
}
LRNLayerParams::LRNLayerParams(const LRNLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&alpha_, &from.alpha_,
    static_cast<size_t>(reinterpret_cast<char*>(&k_) -
    reinterpret_cast<char*>(&alpha_)) + sizeof(k_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LRNLayerParams)
}

inline void LRNLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&alpha_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&k_) -
    reinterpret_cast<char*>(&alpha_)) + sizeof(k_));
}

LRNLayerParams::~LRNLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LRNLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LRNLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LRNLayerParams::ArenaDtor(void* object) {
  LRNLayerParams* _this = reinterpret_cast< LRNLayerParams* >(object);
  (void)_this;
}
void LRNLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LRNLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LRNLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LRNLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&alpha_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&k_) -
      reinterpret_cast<char*>(&alpha_)) + sizeof(k_));
  _internal_metadata_.Clear<std::string>();
}

const char* LRNLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float alpha = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float beta = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          beta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // uint64 localSize = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          localsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float k = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          k_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LRNLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LRNLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_alpha(), target);
  }

  // float beta = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_beta = this->_internal_beta();
  uint32_t raw_beta;
  memcpy(&raw_beta, &tmp_beta, sizeof(tmp_beta));
  if (raw_beta != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_beta(), target);
  }

  // uint64 localSize = 3;
  if (this->_internal_localsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_localsize(), target);
  }

  // float k = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_k = this->_internal_k();
  uint32_t raw_k;
  memcpy(&raw_k, &tmp_k, sizeof(tmp_k));
  if (raw_k != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_k(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LRNLayerParams)
  return target;
}

size_t LRNLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LRNLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    total_size += 1 + 4;
  }

  // float beta = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_beta = this->_internal_beta();
  uint32_t raw_beta;
  memcpy(&raw_beta, &tmp_beta, sizeof(tmp_beta));
  if (raw_beta != 0) {
    total_size += 1 + 4;
  }

  // uint64 localSize = 3;
  if (this->_internal_localsize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_localsize());
  }

  // float k = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_k = this->_internal_k();
  uint32_t raw_k;
  memcpy(&raw_k, &tmp_k, sizeof(tmp_k));
  if (raw_k != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LRNLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LRNLayerParams*>(
      &from));
}

void LRNLayerParams::MergeFrom(const LRNLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LRNLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = from._internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    _internal_set_alpha(from._internal_alpha());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_beta = from._internal_beta();
  uint32_t raw_beta;
  memcpy(&raw_beta, &tmp_beta, sizeof(tmp_beta));
  if (raw_beta != 0) {
    _internal_set_beta(from._internal_beta());
  }
  if (from._internal_localsize() != 0) {
    _internal_set_localsize(from._internal_localsize());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_k = from._internal_k();
  uint32_t raw_k;
  memcpy(&raw_k, &tmp_k, sizeof(tmp_k));
  if (raw_k != 0) {
    _internal_set_k(from._internal_k());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LRNLayerParams::CopyFrom(const LRNLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LRNLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LRNLayerParams::IsInitialized() const {
  return true;
}

void LRNLayerParams::InternalSwap(LRNLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LRNLayerParams, k_)
      + sizeof(LRNLayerParams::k_)
      - PROTOBUF_FIELD_OFFSET(LRNLayerParams, alpha_)>(
          reinterpret_cast<char*>(&alpha_),
          reinterpret_cast<char*>(&other->alpha_));
}

std::string LRNLayerParams::GetTypeName() const {
  return "CoreML.Specification.LRNLayerParams";
}


// ===================================================================

class SoftmaxLayerParams::_Internal {
 public:
};

SoftmaxLayerParams::SoftmaxLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SoftmaxLayerParams)
}
SoftmaxLayerParams::SoftmaxLayerParams(const SoftmaxLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SoftmaxLayerParams)
}

inline void SoftmaxLayerParams::SharedCtor() {
}

SoftmaxLayerParams::~SoftmaxLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SoftmaxLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SoftmaxLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SoftmaxLayerParams::ArenaDtor(void* object) {
  SoftmaxLayerParams* _this = reinterpret_cast< SoftmaxLayerParams* >(object);
  (void)_this;
}
void SoftmaxLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SoftmaxLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SoftmaxLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SoftmaxLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* SoftmaxLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SoftmaxLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SoftmaxLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SoftmaxLayerParams)
  return target;
}

size_t SoftmaxLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SoftmaxLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SoftmaxLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SoftmaxLayerParams*>(
      &from));
}

void SoftmaxLayerParams::MergeFrom(const SoftmaxLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SoftmaxLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SoftmaxLayerParams::CopyFrom(const SoftmaxLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SoftmaxLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SoftmaxLayerParams::IsInitialized() const {
  return true;
}

void SoftmaxLayerParams::InternalSwap(SoftmaxLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string SoftmaxLayerParams::GetTypeName() const {
  return "CoreML.Specification.SoftmaxLayerParams";
}


// ===================================================================

class SplitLayerParams::_Internal {
 public:
};

SplitLayerParams::SplitLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SplitLayerParams)
}
SplitLayerParams::SplitLayerParams(const SplitLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  noutputs_ = from.noutputs_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SplitLayerParams)
}

inline void SplitLayerParams::SharedCtor() {
noutputs_ = uint64_t{0u};
}

SplitLayerParams::~SplitLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SplitLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SplitLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SplitLayerParams::ArenaDtor(void* object) {
  SplitLayerParams* _this = reinterpret_cast< SplitLayerParams* >(object);
  (void)_this;
}
void SplitLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SplitLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SplitLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SplitLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  noutputs_ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* SplitLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 nOutputs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          noutputs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SplitLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SplitLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 nOutputs = 1;
  if (this->_internal_noutputs() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_noutputs(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SplitLayerParams)
  return target;
}

size_t SplitLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SplitLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 nOutputs = 1;
  if (this->_internal_noutputs() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_noutputs());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SplitLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SplitLayerParams*>(
      &from));
}

void SplitLayerParams::MergeFrom(const SplitLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SplitLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_noutputs() != 0) {
    _internal_set_noutputs(from._internal_noutputs());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SplitLayerParams::CopyFrom(const SplitLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SplitLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SplitLayerParams::IsInitialized() const {
  return true;
}

void SplitLayerParams::InternalSwap(SplitLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(noutputs_, other->noutputs_);
}

std::string SplitLayerParams::GetTypeName() const {
  return "CoreML.Specification.SplitLayerParams";
}


// ===================================================================

class AddLayerParams::_Internal {
 public:
};

AddLayerParams::AddLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.AddLayerParams)
}
AddLayerParams::AddLayerParams(const AddLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  alpha_ = from.alpha_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.AddLayerParams)
}

inline void AddLayerParams::SharedCtor() {
alpha_ = 0;
}

AddLayerParams::~AddLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.AddLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AddLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AddLayerParams::ArenaDtor(void* object) {
  AddLayerParams* _this = reinterpret_cast< AddLayerParams* >(object);
  (void)_this;
}
void AddLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AddLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AddLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.AddLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  alpha_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* AddLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float alpha = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AddLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.AddLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_alpha(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.AddLayerParams)
  return target;
}

size_t AddLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.AddLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AddLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AddLayerParams*>(
      &from));
}

void AddLayerParams::MergeFrom(const AddLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.AddLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = from._internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    _internal_set_alpha(from._internal_alpha());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AddLayerParams::CopyFrom(const AddLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.AddLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddLayerParams::IsInitialized() const {
  return true;
}

void AddLayerParams::InternalSwap(AddLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(alpha_, other->alpha_);
}

std::string AddLayerParams::GetTypeName() const {
  return "CoreML.Specification.AddLayerParams";
}


// ===================================================================

class MultiplyLayerParams::_Internal {
 public:
};

MultiplyLayerParams::MultiplyLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MultiplyLayerParams)
}
MultiplyLayerParams::MultiplyLayerParams(const MultiplyLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  alpha_ = from.alpha_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MultiplyLayerParams)
}

inline void MultiplyLayerParams::SharedCtor() {
alpha_ = 0;
}

MultiplyLayerParams::~MultiplyLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MultiplyLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void MultiplyLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MultiplyLayerParams::ArenaDtor(void* object) {
  MultiplyLayerParams* _this = reinterpret_cast< MultiplyLayerParams* >(object);
  (void)_this;
}
void MultiplyLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MultiplyLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MultiplyLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MultiplyLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  alpha_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* MultiplyLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float alpha = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MultiplyLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MultiplyLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_alpha(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MultiplyLayerParams)
  return target;
}

size_t MultiplyLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MultiplyLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MultiplyLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MultiplyLayerParams*>(
      &from));
}

void MultiplyLayerParams::MergeFrom(const MultiplyLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MultiplyLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = from._internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    _internal_set_alpha(from._internal_alpha());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MultiplyLayerParams::CopyFrom(const MultiplyLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MultiplyLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultiplyLayerParams::IsInitialized() const {
  return true;
}

void MultiplyLayerParams::InternalSwap(MultiplyLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(alpha_, other->alpha_);
}

std::string MultiplyLayerParams::GetTypeName() const {
  return "CoreML.Specification.MultiplyLayerParams";
}


// ===================================================================

class UnaryFunctionLayerParams::_Internal {
 public:
};

UnaryFunctionLayerParams::UnaryFunctionLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.UnaryFunctionLayerParams)
}
UnaryFunctionLayerParams::UnaryFunctionLayerParams(const UnaryFunctionLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&scale_) -
    reinterpret_cast<char*>(&type_)) + sizeof(scale_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.UnaryFunctionLayerParams)
}

inline void UnaryFunctionLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&scale_) -
    reinterpret_cast<char*>(&type_)) + sizeof(scale_));
}

UnaryFunctionLayerParams::~UnaryFunctionLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.UnaryFunctionLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void UnaryFunctionLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UnaryFunctionLayerParams::ArenaDtor(void* object) {
  UnaryFunctionLayerParams* _this = reinterpret_cast< UnaryFunctionLayerParams* >(object);
  (void)_this;
}
void UnaryFunctionLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UnaryFunctionLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UnaryFunctionLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.UnaryFunctionLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&scale_) -
      reinterpret_cast<char*>(&type_)) + sizeof(scale_));
  _internal_metadata_.Clear<std::string>();
}

const char* UnaryFunctionLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.UnaryFunctionLayerParams.Operation type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::CoreML::Specification::UnaryFunctionLayerParams_Operation>(val));
        } else
          goto handle_unusual;
        continue;
      // float alpha = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float epsilon = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          epsilon_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float shift = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          shift_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float scale = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnaryFunctionLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.UnaryFunctionLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.UnaryFunctionLayerParams.Operation type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // float alpha = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_alpha(), target);
  }

  // float epsilon = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_epsilon = this->_internal_epsilon();
  uint32_t raw_epsilon;
  memcpy(&raw_epsilon, &tmp_epsilon, sizeof(tmp_epsilon));
  if (raw_epsilon != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_epsilon(), target);
  }

  // float shift = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_shift = this->_internal_shift();
  uint32_t raw_shift;
  memcpy(&raw_shift, &tmp_shift, sizeof(tmp_shift));
  if (raw_shift != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_shift(), target);
  }

  // float scale = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale = this->_internal_scale();
  uint32_t raw_scale;
  memcpy(&raw_scale, &tmp_scale, sizeof(tmp_scale));
  if (raw_scale != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_scale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.UnaryFunctionLayerParams)
  return target;
}

size_t UnaryFunctionLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.UnaryFunctionLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.UnaryFunctionLayerParams.Operation type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  // float alpha = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    total_size += 1 + 4;
  }

  // float epsilon = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_epsilon = this->_internal_epsilon();
  uint32_t raw_epsilon;
  memcpy(&raw_epsilon, &tmp_epsilon, sizeof(tmp_epsilon));
  if (raw_epsilon != 0) {
    total_size += 1 + 4;
  }

  // float shift = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_shift = this->_internal_shift();
  uint32_t raw_shift;
  memcpy(&raw_shift, &tmp_shift, sizeof(tmp_shift));
  if (raw_shift != 0) {
    total_size += 1 + 4;
  }

  // float scale = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale = this->_internal_scale();
  uint32_t raw_scale;
  memcpy(&raw_scale, &tmp_scale, sizeof(tmp_scale));
  if (raw_scale != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UnaryFunctionLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UnaryFunctionLayerParams*>(
      &from));
}

void UnaryFunctionLayerParams::MergeFrom(const UnaryFunctionLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.UnaryFunctionLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = from._internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    _internal_set_alpha(from._internal_alpha());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_epsilon = from._internal_epsilon();
  uint32_t raw_epsilon;
  memcpy(&raw_epsilon, &tmp_epsilon, sizeof(tmp_epsilon));
  if (raw_epsilon != 0) {
    _internal_set_epsilon(from._internal_epsilon());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_shift = from._internal_shift();
  uint32_t raw_shift;
  memcpy(&raw_shift, &tmp_shift, sizeof(tmp_shift));
  if (raw_shift != 0) {
    _internal_set_shift(from._internal_shift());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scale = from._internal_scale();
  uint32_t raw_scale;
  memcpy(&raw_scale, &tmp_scale, sizeof(tmp_scale));
  if (raw_scale != 0) {
    _internal_set_scale(from._internal_scale());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UnaryFunctionLayerParams::CopyFrom(const UnaryFunctionLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.UnaryFunctionLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnaryFunctionLayerParams::IsInitialized() const {
  return true;
}

void UnaryFunctionLayerParams::InternalSwap(UnaryFunctionLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UnaryFunctionLayerParams, scale_)
      + sizeof(UnaryFunctionLayerParams::scale_)
      - PROTOBUF_FIELD_OFFSET(UnaryFunctionLayerParams, type_)>(
          reinterpret_cast<char*>(&type_),
          reinterpret_cast<char*>(&other->type_));
}

std::string UnaryFunctionLayerParams::GetTypeName() const {
  return "CoreML.Specification.UnaryFunctionLayerParams";
}


// ===================================================================

class UpsampleLayerParams::_Internal {
 public:
};

UpsampleLayerParams::UpsampleLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  scalingfactor_(arena),
  fractionalscalingfactor_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.UpsampleLayerParams)
}
UpsampleLayerParams::UpsampleLayerParams(const UpsampleLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      scalingfactor_(from.scalingfactor_),
      fractionalscalingfactor_(from.fractionalscalingfactor_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&mode_, &from.mode_,
    static_cast<size_t>(reinterpret_cast<char*>(&linearupsamplemode_) -
    reinterpret_cast<char*>(&mode_)) + sizeof(linearupsamplemode_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.UpsampleLayerParams)
}

inline void UpsampleLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&mode_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&linearupsamplemode_) -
    reinterpret_cast<char*>(&mode_)) + sizeof(linearupsamplemode_));
}

UpsampleLayerParams::~UpsampleLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.UpsampleLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void UpsampleLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UpsampleLayerParams::ArenaDtor(void* object) {
  UpsampleLayerParams* _this = reinterpret_cast< UpsampleLayerParams* >(object);
  (void)_this;
}
void UpsampleLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UpsampleLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UpsampleLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.UpsampleLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  scalingfactor_.Clear();
  fractionalscalingfactor_.Clear();
  ::memset(&mode_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&linearupsamplemode_) -
      reinterpret_cast<char*>(&mode_)) + sizeof(linearupsamplemode_));
  _internal_metadata_.Clear<std::string>();
}

const char* UpsampleLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 scalingFactor = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_scalingfactor(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_scalingfactor(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.UpsampleLayerParams.InterpolationMode mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mode(static_cast<::CoreML::Specification::UpsampleLayerParams_InterpolationMode>(val));
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.UpsampleLayerParams.LinearUpsampleMode linearUpsampleMode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_linearupsamplemode(static_cast<::CoreML::Specification::UpsampleLayerParams_LinearUpsampleMode>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated float fractionalScalingFactor = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_fractionalscalingfactor(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 61) {
          _internal_add_fractionalscalingfactor(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpsampleLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.UpsampleLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 scalingFactor = 1;
  {
    int byte_size = _scalingfactor_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          1, _internal_scalingfactor(), byte_size, target);
    }
  }

  // .CoreML.Specification.UpsampleLayerParams.InterpolationMode mode = 5;
  if (this->_internal_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_mode(), target);
  }

  // .CoreML.Specification.UpsampleLayerParams.LinearUpsampleMode linearUpsampleMode = 6;
  if (this->_internal_linearupsamplemode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_linearupsamplemode(), target);
  }

  // repeated float fractionalScalingFactor = 7;
  if (this->_internal_fractionalscalingfactor_size() > 0) {
    target = stream->WriteFixedPacked(7, _internal_fractionalscalingfactor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.UpsampleLayerParams)
  return target;
}

size_t UpsampleLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.UpsampleLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 scalingFactor = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->scalingfactor_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _scalingfactor_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated float fractionalScalingFactor = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_fractionalscalingfactor_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // .CoreML.Specification.UpsampleLayerParams.InterpolationMode mode = 5;
  if (this->_internal_mode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mode());
  }

  // .CoreML.Specification.UpsampleLayerParams.LinearUpsampleMode linearUpsampleMode = 6;
  if (this->_internal_linearupsamplemode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_linearupsamplemode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UpsampleLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UpsampleLayerParams*>(
      &from));
}

void UpsampleLayerParams::MergeFrom(const UpsampleLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.UpsampleLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  scalingfactor_.MergeFrom(from.scalingfactor_);
  fractionalscalingfactor_.MergeFrom(from.fractionalscalingfactor_);
  if (from._internal_mode() != 0) {
    _internal_set_mode(from._internal_mode());
  }
  if (from._internal_linearupsamplemode() != 0) {
    _internal_set_linearupsamplemode(from._internal_linearupsamplemode());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UpsampleLayerParams::CopyFrom(const UpsampleLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.UpsampleLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpsampleLayerParams::IsInitialized() const {
  return true;
}

void UpsampleLayerParams::InternalSwap(UpsampleLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  scalingfactor_.InternalSwap(&other->scalingfactor_);
  fractionalscalingfactor_.InternalSwap(&other->fractionalscalingfactor_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpsampleLayerParams, linearupsamplemode_)
      + sizeof(UpsampleLayerParams::linearupsamplemode_)
      - PROTOBUF_FIELD_OFFSET(UpsampleLayerParams, mode_)>(
          reinterpret_cast<char*>(&mode_),
          reinterpret_cast<char*>(&other->mode_));
}

std::string UpsampleLayerParams::GetTypeName() const {
  return "CoreML.Specification.UpsampleLayerParams";
}


// ===================================================================

class ResizeBilinearLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::SamplingMode& mode(const ResizeBilinearLayerParams* msg);
};

const ::CoreML::Specification::SamplingMode&
ResizeBilinearLayerParams::_Internal::mode(const ResizeBilinearLayerParams* msg) {
  return *msg->mode_;
}
ResizeBilinearLayerParams::ResizeBilinearLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  targetsize_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ResizeBilinearLayerParams)
}
ResizeBilinearLayerParams::ResizeBilinearLayerParams(const ResizeBilinearLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      targetsize_(from.targetsize_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_mode()) {
    mode_ = new ::CoreML::Specification::SamplingMode(*from.mode_);
  } else {
    mode_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ResizeBilinearLayerParams)
}

inline void ResizeBilinearLayerParams::SharedCtor() {
mode_ = nullptr;
}

ResizeBilinearLayerParams::~ResizeBilinearLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ResizeBilinearLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ResizeBilinearLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete mode_;
}

void ResizeBilinearLayerParams::ArenaDtor(void* object) {
  ResizeBilinearLayerParams* _this = reinterpret_cast< ResizeBilinearLayerParams* >(object);
  (void)_this;
}
void ResizeBilinearLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ResizeBilinearLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ResizeBilinearLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ResizeBilinearLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  targetsize_.Clear();
  if (GetArenaForAllocation() == nullptr && mode_ != nullptr) {
    delete mode_;
  }
  mode_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* ResizeBilinearLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 targetSize = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_targetsize(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_targetsize(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SamplingMode mode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_mode(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResizeBilinearLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ResizeBilinearLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 targetSize = 1;
  {
    int byte_size = _targetsize_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          1, _internal_targetsize(), byte_size, target);
    }
  }

  // .CoreML.Specification.SamplingMode mode = 2;
  if (this->_internal_has_mode()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::mode(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ResizeBilinearLayerParams)
  return target;
}

size_t ResizeBilinearLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ResizeBilinearLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 targetSize = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->targetsize_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _targetsize_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .CoreML.Specification.SamplingMode mode = 2;
  if (this->_internal_has_mode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *mode_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ResizeBilinearLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ResizeBilinearLayerParams*>(
      &from));
}

void ResizeBilinearLayerParams::MergeFrom(const ResizeBilinearLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ResizeBilinearLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  targetsize_.MergeFrom(from.targetsize_);
  if (from._internal_has_mode()) {
    _internal_mutable_mode()->::CoreML::Specification::SamplingMode::MergeFrom(from._internal_mode());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ResizeBilinearLayerParams::CopyFrom(const ResizeBilinearLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ResizeBilinearLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResizeBilinearLayerParams::IsInitialized() const {
  return true;
}

void ResizeBilinearLayerParams::InternalSwap(ResizeBilinearLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  targetsize_.InternalSwap(&other->targetsize_);
  swap(mode_, other->mode_);
}

std::string ResizeBilinearLayerParams::GetTypeName() const {
  return "CoreML.Specification.ResizeBilinearLayerParams";
}


// ===================================================================

class CropResizeLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::SamplingMode& mode(const CropResizeLayerParams* msg);
  static const ::CoreML::Specification::BoxCoordinatesMode& boxindicesmode(const CropResizeLayerParams* msg);
};

const ::CoreML::Specification::SamplingMode&
CropResizeLayerParams::_Internal::mode(const CropResizeLayerParams* msg) {
  return *msg->mode_;
}
const ::CoreML::Specification::BoxCoordinatesMode&
CropResizeLayerParams::_Internal::boxindicesmode(const CropResizeLayerParams* msg) {
  return *msg->boxindicesmode_;
}
CropResizeLayerParams::CropResizeLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  targetsize_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.CropResizeLayerParams)
}
CropResizeLayerParams::CropResizeLayerParams(const CropResizeLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      targetsize_(from.targetsize_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_mode()) {
    mode_ = new ::CoreML::Specification::SamplingMode(*from.mode_);
  } else {
    mode_ = nullptr;
  }
  if (from._internal_has_boxindicesmode()) {
    boxindicesmode_ = new ::CoreML::Specification::BoxCoordinatesMode(*from.boxindicesmode_);
  } else {
    boxindicesmode_ = nullptr;
  }
  ::memcpy(&normalizedcoordinates_, &from.normalizedcoordinates_,
    static_cast<size_t>(reinterpret_cast<char*>(&spatialscale_) -
    reinterpret_cast<char*>(&normalizedcoordinates_)) + sizeof(spatialscale_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.CropResizeLayerParams)
}

inline void CropResizeLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&mode_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&spatialscale_) -
    reinterpret_cast<char*>(&mode_)) + sizeof(spatialscale_));
}

CropResizeLayerParams::~CropResizeLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.CropResizeLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CropResizeLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete mode_;
  if (this != internal_default_instance()) delete boxindicesmode_;
}

void CropResizeLayerParams::ArenaDtor(void* object) {
  CropResizeLayerParams* _this = reinterpret_cast< CropResizeLayerParams* >(object);
  (void)_this;
}
void CropResizeLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CropResizeLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CropResizeLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.CropResizeLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  targetsize_.Clear();
  if (GetArenaForAllocation() == nullptr && mode_ != nullptr) {
    delete mode_;
  }
  mode_ = nullptr;
  if (GetArenaForAllocation() == nullptr && boxindicesmode_ != nullptr) {
    delete boxindicesmode_;
  }
  boxindicesmode_ = nullptr;
  ::memset(&normalizedcoordinates_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&spatialscale_) -
      reinterpret_cast<char*>(&normalizedcoordinates_)) + sizeof(spatialscale_));
  _internal_metadata_.Clear<std::string>();
}

const char* CropResizeLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 targetSize = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_targetsize(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_targetsize(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool normalizedCoordinates = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          normalizedcoordinates_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SamplingMode mode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_mode(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.BoxCoordinatesMode boxIndicesMode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_boxindicesmode(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float spatialScale = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          spatialscale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CropResizeLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.CropResizeLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 targetSize = 1;
  {
    int byte_size = _targetsize_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          1, _internal_targetsize(), byte_size, target);
    }
  }

  // bool normalizedCoordinates = 2;
  if (this->_internal_normalizedcoordinates() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_normalizedcoordinates(), target);
  }

  // .CoreML.Specification.SamplingMode mode = 3;
  if (this->_internal_has_mode()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::mode(this), target, stream);
  }

  // .CoreML.Specification.BoxCoordinatesMode boxIndicesMode = 4;
  if (this->_internal_has_boxindicesmode()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::boxindicesmode(this), target, stream);
  }

  // float spatialScale = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_spatialscale = this->_internal_spatialscale();
  uint32_t raw_spatialscale;
  memcpy(&raw_spatialscale, &tmp_spatialscale, sizeof(tmp_spatialscale));
  if (raw_spatialscale != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_spatialscale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.CropResizeLayerParams)
  return target;
}

size_t CropResizeLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.CropResizeLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 targetSize = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->targetsize_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _targetsize_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .CoreML.Specification.SamplingMode mode = 3;
  if (this->_internal_has_mode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *mode_);
  }

  // .CoreML.Specification.BoxCoordinatesMode boxIndicesMode = 4;
  if (this->_internal_has_boxindicesmode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *boxindicesmode_);
  }

  // bool normalizedCoordinates = 2;
  if (this->_internal_normalizedcoordinates() != 0) {
    total_size += 1 + 1;
  }

  // float spatialScale = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_spatialscale = this->_internal_spatialscale();
  uint32_t raw_spatialscale;
  memcpy(&raw_spatialscale, &tmp_spatialscale, sizeof(tmp_spatialscale));
  if (raw_spatialscale != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CropResizeLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CropResizeLayerParams*>(
      &from));
}

void CropResizeLayerParams::MergeFrom(const CropResizeLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.CropResizeLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  targetsize_.MergeFrom(from.targetsize_);
  if (from._internal_has_mode()) {
    _internal_mutable_mode()->::CoreML::Specification::SamplingMode::MergeFrom(from._internal_mode());
  }
  if (from._internal_has_boxindicesmode()) {
    _internal_mutable_boxindicesmode()->::CoreML::Specification::BoxCoordinatesMode::MergeFrom(from._internal_boxindicesmode());
  }
  if (from._internal_normalizedcoordinates() != 0) {
    _internal_set_normalizedcoordinates(from._internal_normalizedcoordinates());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_spatialscale = from._internal_spatialscale();
  uint32_t raw_spatialscale;
  memcpy(&raw_spatialscale, &tmp_spatialscale, sizeof(tmp_spatialscale));
  if (raw_spatialscale != 0) {
    _internal_set_spatialscale(from._internal_spatialscale());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CropResizeLayerParams::CopyFrom(const CropResizeLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.CropResizeLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CropResizeLayerParams::IsInitialized() const {
  return true;
}

void CropResizeLayerParams::InternalSwap(CropResizeLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  targetsize_.InternalSwap(&other->targetsize_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CropResizeLayerParams, spatialscale_)
      + sizeof(CropResizeLayerParams::spatialscale_)
      - PROTOBUF_FIELD_OFFSET(CropResizeLayerParams, mode_)>(
          reinterpret_cast<char*>(&mode_),
          reinterpret_cast<char*>(&other->mode_));
}

std::string CropResizeLayerParams::GetTypeName() const {
  return "CoreML.Specification.CropResizeLayerParams";
}


// ===================================================================

class BiasLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::WeightParams& bias(const BiasLayerParams* msg);
};

const ::CoreML::Specification::WeightParams&
BiasLayerParams::_Internal::bias(const BiasLayerParams* msg) {
  return *msg->bias_;
}
BiasLayerParams::BiasLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  shape_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.BiasLayerParams)
}
BiasLayerParams::BiasLayerParams(const BiasLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      shape_(from.shape_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_bias()) {
    bias_ = new ::CoreML::Specification::WeightParams(*from.bias_);
  } else {
    bias_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.BiasLayerParams)
}

inline void BiasLayerParams::SharedCtor() {
bias_ = nullptr;
}

BiasLayerParams::~BiasLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.BiasLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BiasLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete bias_;
}

void BiasLayerParams::ArenaDtor(void* object) {
  BiasLayerParams* _this = reinterpret_cast< BiasLayerParams* >(object);
  (void)_this;
}
void BiasLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BiasLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BiasLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.BiasLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  shape_.Clear();
  if (GetArenaForAllocation() == nullptr && bias_ != nullptr) {
    delete bias_;
  }
  bias_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* BiasLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 shape = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_shape(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_shape(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams bias = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_bias(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BiasLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.BiasLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 shape = 1;
  {
    int byte_size = _shape_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          1, _internal_shape(), byte_size, target);
    }
  }

  // .CoreML.Specification.WeightParams bias = 2;
  if (this->_internal_has_bias()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::bias(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.BiasLayerParams)
  return target;
}

size_t BiasLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.BiasLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 shape = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->shape_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _shape_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .CoreML.Specification.WeightParams bias = 2;
  if (this->_internal_has_bias()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bias_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BiasLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BiasLayerParams*>(
      &from));
}

void BiasLayerParams::MergeFrom(const BiasLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.BiasLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  shape_.MergeFrom(from.shape_);
  if (from._internal_has_bias()) {
    _internal_mutable_bias()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_bias());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BiasLayerParams::CopyFrom(const BiasLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.BiasLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BiasLayerParams::IsInitialized() const {
  return true;
}

void BiasLayerParams::InternalSwap(BiasLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  shape_.InternalSwap(&other->shape_);
  swap(bias_, other->bias_);
}

std::string BiasLayerParams::GetTypeName() const {
  return "CoreML.Specification.BiasLayerParams";
}


// ===================================================================

class ScaleLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::WeightParams& scale(const ScaleLayerParams* msg);
  static const ::CoreML::Specification::WeightParams& bias(const ScaleLayerParams* msg);
};

const ::CoreML::Specification::WeightParams&
ScaleLayerParams::_Internal::scale(const ScaleLayerParams* msg) {
  return *msg->scale_;
}
const ::CoreML::Specification::WeightParams&
ScaleLayerParams::_Internal::bias(const ScaleLayerParams* msg) {
  return *msg->bias_;
}
ScaleLayerParams::ScaleLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  shapescale_(arena),
  shapebias_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ScaleLayerParams)
}
ScaleLayerParams::ScaleLayerParams(const ScaleLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      shapescale_(from.shapescale_),
      shapebias_(from.shapebias_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_scale()) {
    scale_ = new ::CoreML::Specification::WeightParams(*from.scale_);
  } else {
    scale_ = nullptr;
  }
  if (from._internal_has_bias()) {
    bias_ = new ::CoreML::Specification::WeightParams(*from.bias_);
  } else {
    bias_ = nullptr;
  }
  hasbias_ = from.hasbias_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ScaleLayerParams)
}

inline void ScaleLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&scale_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&hasbias_) -
    reinterpret_cast<char*>(&scale_)) + sizeof(hasbias_));
}

ScaleLayerParams::~ScaleLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ScaleLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ScaleLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete scale_;
  if (this != internal_default_instance()) delete bias_;
}

void ScaleLayerParams::ArenaDtor(void* object) {
  ScaleLayerParams* _this = reinterpret_cast< ScaleLayerParams* >(object);
  (void)_this;
}
void ScaleLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ScaleLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ScaleLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ScaleLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  shapescale_.Clear();
  shapebias_.Clear();
  if (GetArenaForAllocation() == nullptr && scale_ != nullptr) {
    delete scale_;
  }
  scale_ = nullptr;
  if (GetArenaForAllocation() == nullptr && bias_ != nullptr) {
    delete bias_;
  }
  bias_ = nullptr;
  hasbias_ = false;
  _internal_metadata_.Clear<std::string>();
}

const char* ScaleLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 shapeScale = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_shapescale(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_shapescale(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams scale = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_scale(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hasBias = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          hasbias_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 shapeBias = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_shapebias(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_shapebias(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams bias = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_bias(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScaleLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ScaleLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 shapeScale = 1;
  {
    int byte_size = _shapescale_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          1, _internal_shapescale(), byte_size, target);
    }
  }

  // .CoreML.Specification.WeightParams scale = 2;
  if (this->_internal_has_scale()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::scale(this), target, stream);
  }

  // bool hasBias = 3;
  if (this->_internal_hasbias() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_hasbias(), target);
  }

  // repeated uint64 shapeBias = 4;
  {
    int byte_size = _shapebias_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          4, _internal_shapebias(), byte_size, target);
    }
  }

  // .CoreML.Specification.WeightParams bias = 5;
  if (this->_internal_has_bias()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::bias(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ScaleLayerParams)
  return target;
}

size_t ScaleLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ScaleLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 shapeScale = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->shapescale_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _shapescale_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint64 shapeBias = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->shapebias_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _shapebias_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .CoreML.Specification.WeightParams scale = 2;
  if (this->_internal_has_scale()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *scale_);
  }

  // .CoreML.Specification.WeightParams bias = 5;
  if (this->_internal_has_bias()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bias_);
  }

  // bool hasBias = 3;
  if (this->_internal_hasbias() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ScaleLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ScaleLayerParams*>(
      &from));
}

void ScaleLayerParams::MergeFrom(const ScaleLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ScaleLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  shapescale_.MergeFrom(from.shapescale_);
  shapebias_.MergeFrom(from.shapebias_);
  if (from._internal_has_scale()) {
    _internal_mutable_scale()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_scale());
  }
  if (from._internal_has_bias()) {
    _internal_mutable_bias()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_bias());
  }
  if (from._internal_hasbias() != 0) {
    _internal_set_hasbias(from._internal_hasbias());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ScaleLayerParams::CopyFrom(const ScaleLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ScaleLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScaleLayerParams::IsInitialized() const {
  return true;
}

void ScaleLayerParams::InternalSwap(ScaleLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  shapescale_.InternalSwap(&other->shapescale_);
  shapebias_.InternalSwap(&other->shapebias_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScaleLayerParams, hasbias_)
      + sizeof(ScaleLayerParams::hasbias_)
      - PROTOBUF_FIELD_OFFSET(ScaleLayerParams, scale_)>(
          reinterpret_cast<char*>(&scale_),
          reinterpret_cast<char*>(&other->scale_));
}

std::string ScaleLayerParams::GetTypeName() const {
  return "CoreML.Specification.ScaleLayerParams";
}


// ===================================================================

class LoadConstantLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::WeightParams& data(const LoadConstantLayerParams* msg);
};

const ::CoreML::Specification::WeightParams&
LoadConstantLayerParams::_Internal::data(const LoadConstantLayerParams* msg) {
  return *msg->data_;
}
LoadConstantLayerParams::LoadConstantLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  shape_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LoadConstantLayerParams)
}
LoadConstantLayerParams::LoadConstantLayerParams(const LoadConstantLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      shape_(from.shape_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_data()) {
    data_ = new ::CoreML::Specification::WeightParams(*from.data_);
  } else {
    data_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LoadConstantLayerParams)
}

inline void LoadConstantLayerParams::SharedCtor() {
data_ = nullptr;
}

LoadConstantLayerParams::~LoadConstantLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LoadConstantLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LoadConstantLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete data_;
}

void LoadConstantLayerParams::ArenaDtor(void* object) {
  LoadConstantLayerParams* _this = reinterpret_cast< LoadConstantLayerParams* >(object);
  (void)_this;
}
void LoadConstantLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LoadConstantLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LoadConstantLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LoadConstantLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  shape_.Clear();
  if (GetArenaForAllocation() == nullptr && data_ != nullptr) {
    delete data_;
  }
  data_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* LoadConstantLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 shape = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_shape(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_shape(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoadConstantLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LoadConstantLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 shape = 1;
  {
    int byte_size = _shape_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          1, _internal_shape(), byte_size, target);
    }
  }

  // .CoreML.Specification.WeightParams data = 2;
  if (this->_internal_has_data()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::data(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LoadConstantLayerParams)
  return target;
}

size_t LoadConstantLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LoadConstantLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 shape = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->shape_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _shape_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .CoreML.Specification.WeightParams data = 2;
  if (this->_internal_has_data()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *data_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoadConstantLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LoadConstantLayerParams*>(
      &from));
}

void LoadConstantLayerParams::MergeFrom(const LoadConstantLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LoadConstantLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  shape_.MergeFrom(from.shape_);
  if (from._internal_has_data()) {
    _internal_mutable_data()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_data());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoadConstantLayerParams::CopyFrom(const LoadConstantLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LoadConstantLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadConstantLayerParams::IsInitialized() const {
  return true;
}

void LoadConstantLayerParams::InternalSwap(LoadConstantLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  shape_.InternalSwap(&other->shape_);
  swap(data_, other->data_);
}

std::string LoadConstantLayerParams::GetTypeName() const {
  return "CoreML.Specification.LoadConstantLayerParams";
}


// ===================================================================

class L2NormalizeLayerParams::_Internal {
 public:
};

L2NormalizeLayerParams::L2NormalizeLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.L2NormalizeLayerParams)
}
L2NormalizeLayerParams::L2NormalizeLayerParams(const L2NormalizeLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  epsilon_ = from.epsilon_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.L2NormalizeLayerParams)
}

inline void L2NormalizeLayerParams::SharedCtor() {
epsilon_ = 0;
}

L2NormalizeLayerParams::~L2NormalizeLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.L2NormalizeLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void L2NormalizeLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void L2NormalizeLayerParams::ArenaDtor(void* object) {
  L2NormalizeLayerParams* _this = reinterpret_cast< L2NormalizeLayerParams* >(object);
  (void)_this;
}
void L2NormalizeLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void L2NormalizeLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void L2NormalizeLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.L2NormalizeLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  epsilon_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* L2NormalizeLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float epsilon = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          epsilon_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* L2NormalizeLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.L2NormalizeLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float epsilon = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_epsilon = this->_internal_epsilon();
  uint32_t raw_epsilon;
  memcpy(&raw_epsilon, &tmp_epsilon, sizeof(tmp_epsilon));
  if (raw_epsilon != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_epsilon(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.L2NormalizeLayerParams)
  return target;
}

size_t L2NormalizeLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.L2NormalizeLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float epsilon = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_epsilon = this->_internal_epsilon();
  uint32_t raw_epsilon;
  memcpy(&raw_epsilon, &tmp_epsilon, sizeof(tmp_epsilon));
  if (raw_epsilon != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void L2NormalizeLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const L2NormalizeLayerParams*>(
      &from));
}

void L2NormalizeLayerParams::MergeFrom(const L2NormalizeLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.L2NormalizeLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_epsilon = from._internal_epsilon();
  uint32_t raw_epsilon;
  memcpy(&raw_epsilon, &tmp_epsilon, sizeof(tmp_epsilon));
  if (raw_epsilon != 0) {
    _internal_set_epsilon(from._internal_epsilon());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void L2NormalizeLayerParams::CopyFrom(const L2NormalizeLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.L2NormalizeLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool L2NormalizeLayerParams::IsInitialized() const {
  return true;
}

void L2NormalizeLayerParams::InternalSwap(L2NormalizeLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(epsilon_, other->epsilon_);
}

std::string L2NormalizeLayerParams::GetTypeName() const {
  return "CoreML.Specification.L2NormalizeLayerParams";
}


// ===================================================================

class FlattenLayerParams::_Internal {
 public:
};

FlattenLayerParams::FlattenLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.FlattenLayerParams)
}
FlattenLayerParams::FlattenLayerParams(const FlattenLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  mode_ = from.mode_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.FlattenLayerParams)
}

inline void FlattenLayerParams::SharedCtor() {
mode_ = 0;
}

FlattenLayerParams::~FlattenLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.FlattenLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FlattenLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FlattenLayerParams::ArenaDtor(void* object) {
  FlattenLayerParams* _this = reinterpret_cast< FlattenLayerParams* >(object);
  (void)_this;
}
void FlattenLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FlattenLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FlattenLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.FlattenLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mode_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* FlattenLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.FlattenLayerParams.FlattenOrder mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mode(static_cast<::CoreML::Specification::FlattenLayerParams_FlattenOrder>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlattenLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.FlattenLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.FlattenLayerParams.FlattenOrder mode = 1;
  if (this->_internal_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.FlattenLayerParams)
  return target;
}

size_t FlattenLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.FlattenLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.FlattenLayerParams.FlattenOrder mode = 1;
  if (this->_internal_mode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FlattenLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FlattenLayerParams*>(
      &from));
}

void FlattenLayerParams::MergeFrom(const FlattenLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.FlattenLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_mode() != 0) {
    _internal_set_mode(from._internal_mode());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FlattenLayerParams::CopyFrom(const FlattenLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.FlattenLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlattenLayerParams::IsInitialized() const {
  return true;
}

void FlattenLayerParams::InternalSwap(FlattenLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(mode_, other->mode_);
}

std::string FlattenLayerParams::GetTypeName() const {
  return "CoreML.Specification.FlattenLayerParams";
}


// ===================================================================

class ReshapeLayerParams::_Internal {
 public:
};

ReshapeLayerParams::ReshapeLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  targetshape_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ReshapeLayerParams)
}
ReshapeLayerParams::ReshapeLayerParams(const ReshapeLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      targetshape_(from.targetshape_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  mode_ = from.mode_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ReshapeLayerParams)
}

inline void ReshapeLayerParams::SharedCtor() {
mode_ = 0;
}

ReshapeLayerParams::~ReshapeLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ReshapeLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReshapeLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReshapeLayerParams::ArenaDtor(void* object) {
  ReshapeLayerParams* _this = reinterpret_cast< ReshapeLayerParams* >(object);
  (void)_this;
}
void ReshapeLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReshapeLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReshapeLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ReshapeLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  targetshape_.Clear();
  mode_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* ReshapeLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 targetShape = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_targetshape(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_targetshape(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReshapeLayerParams.ReshapeOrder mode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mode(static_cast<::CoreML::Specification::ReshapeLayerParams_ReshapeOrder>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReshapeLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ReshapeLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 targetShape = 1;
  {
    int byte_size = _targetshape_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_targetshape(), byte_size, target);
    }
  }

  // .CoreML.Specification.ReshapeLayerParams.ReshapeOrder mode = 2;
  if (this->_internal_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ReshapeLayerParams)
  return target;
}

size_t ReshapeLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ReshapeLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 targetShape = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->targetshape_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _targetshape_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .CoreML.Specification.ReshapeLayerParams.ReshapeOrder mode = 2;
  if (this->_internal_mode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReshapeLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReshapeLayerParams*>(
      &from));
}

void ReshapeLayerParams::MergeFrom(const ReshapeLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ReshapeLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  targetshape_.MergeFrom(from.targetshape_);
  if (from._internal_mode() != 0) {
    _internal_set_mode(from._internal_mode());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReshapeLayerParams::CopyFrom(const ReshapeLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ReshapeLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReshapeLayerParams::IsInitialized() const {
  return true;
}

void ReshapeLayerParams::InternalSwap(ReshapeLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  targetshape_.InternalSwap(&other->targetshape_);
  swap(mode_, other->mode_);
}

std::string ReshapeLayerParams::GetTypeName() const {
  return "CoreML.Specification.ReshapeLayerParams";
}


// ===================================================================

class PermuteLayerParams::_Internal {
 public:
};

PermuteLayerParams::PermuteLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  axis_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.PermuteLayerParams)
}
PermuteLayerParams::PermuteLayerParams(const PermuteLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      axis_(from.axis_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.PermuteLayerParams)
}

inline void PermuteLayerParams::SharedCtor() {
}

PermuteLayerParams::~PermuteLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.PermuteLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PermuteLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PermuteLayerParams::ArenaDtor(void* object) {
  PermuteLayerParams* _this = reinterpret_cast< PermuteLayerParams* >(object);
  (void)_this;
}
void PermuteLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PermuteLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PermuteLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.PermuteLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axis_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PermuteLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 axis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_axis(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_axis(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PermuteLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.PermuteLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 axis = 1;
  {
    int byte_size = _axis_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          1, _internal_axis(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.PermuteLayerParams)
  return target;
}

size_t PermuteLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.PermuteLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 axis = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->axis_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _axis_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PermuteLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PermuteLayerParams*>(
      &from));
}

void PermuteLayerParams::MergeFrom(const PermuteLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.PermuteLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  axis_.MergeFrom(from.axis_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PermuteLayerParams::CopyFrom(const PermuteLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.PermuteLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PermuteLayerParams::IsInitialized() const {
  return true;
}

void PermuteLayerParams::InternalSwap(PermuteLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  axis_.InternalSwap(&other->axis_);
}

std::string PermuteLayerParams::GetTypeName() const {
  return "CoreML.Specification.PermuteLayerParams";
}


// ===================================================================

class ReorganizeDataLayerParams::_Internal {
 public:
};

ReorganizeDataLayerParams::ReorganizeDataLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ReorganizeDataLayerParams)
}
ReorganizeDataLayerParams::ReorganizeDataLayerParams(const ReorganizeDataLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&blocksize_, &from.blocksize_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&blocksize_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ReorganizeDataLayerParams)
}

inline void ReorganizeDataLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&blocksize_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&blocksize_)) + sizeof(mode_));
}

ReorganizeDataLayerParams::~ReorganizeDataLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ReorganizeDataLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReorganizeDataLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReorganizeDataLayerParams::ArenaDtor(void* object) {
  ReorganizeDataLayerParams* _this = reinterpret_cast< ReorganizeDataLayerParams* >(object);
  (void)_this;
}
void ReorganizeDataLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReorganizeDataLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReorganizeDataLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ReorganizeDataLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&blocksize_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mode_) -
      reinterpret_cast<char*>(&blocksize_)) + sizeof(mode_));
  _internal_metadata_.Clear<std::string>();
}

const char* ReorganizeDataLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.ReorganizeDataLayerParams.ReorganizationType mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mode(static_cast<::CoreML::Specification::ReorganizeDataLayerParams_ReorganizationType>(val));
        } else
          goto handle_unusual;
        continue;
      // uint64 blockSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          blocksize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReorganizeDataLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ReorganizeDataLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.ReorganizeDataLayerParams.ReorganizationType mode = 1;
  if (this->_internal_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_mode(), target);
  }

  // uint64 blockSize = 2;
  if (this->_internal_blocksize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_blocksize(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ReorganizeDataLayerParams)
  return target;
}

size_t ReorganizeDataLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ReorganizeDataLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 blockSize = 2;
  if (this->_internal_blocksize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_blocksize());
  }

  // .CoreML.Specification.ReorganizeDataLayerParams.ReorganizationType mode = 1;
  if (this->_internal_mode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReorganizeDataLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReorganizeDataLayerParams*>(
      &from));
}

void ReorganizeDataLayerParams::MergeFrom(const ReorganizeDataLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ReorganizeDataLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_blocksize() != 0) {
    _internal_set_blocksize(from._internal_blocksize());
  }
  if (from._internal_mode() != 0) {
    _internal_set_mode(from._internal_mode());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReorganizeDataLayerParams::CopyFrom(const ReorganizeDataLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ReorganizeDataLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReorganizeDataLayerParams::IsInitialized() const {
  return true;
}

void ReorganizeDataLayerParams::InternalSwap(ReorganizeDataLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReorganizeDataLayerParams, mode_)
      + sizeof(ReorganizeDataLayerParams::mode_)
      - PROTOBUF_FIELD_OFFSET(ReorganizeDataLayerParams, blocksize_)>(
          reinterpret_cast<char*>(&blocksize_),
          reinterpret_cast<char*>(&other->blocksize_));
}

std::string ReorganizeDataLayerParams::GetTypeName() const {
  return "CoreML.Specification.ReorganizeDataLayerParams";
}


// ===================================================================

class SliceLayerParams::_Internal {
 public:
};

SliceLayerParams::SliceLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SliceLayerParams)
}
SliceLayerParams::SliceLayerParams(const SliceLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&startindex_, &from.startindex_,
    static_cast<size_t>(reinterpret_cast<char*>(&axis_) -
    reinterpret_cast<char*>(&startindex_)) + sizeof(axis_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SliceLayerParams)
}

inline void SliceLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&startindex_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&axis_) -
    reinterpret_cast<char*>(&startindex_)) + sizeof(axis_));
}

SliceLayerParams::~SliceLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SliceLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SliceLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SliceLayerParams::ArenaDtor(void* object) {
  SliceLayerParams* _this = reinterpret_cast< SliceLayerParams* >(object);
  (void)_this;
}
void SliceLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SliceLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SliceLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SliceLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&startindex_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&axis_) -
      reinterpret_cast<char*>(&startindex_)) + sizeof(axis_));
  _internal_metadata_.Clear<std::string>();
}

const char* SliceLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 startIndex = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          startindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 endIndex = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          endindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 stride = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          stride_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.SliceLayerParams.SliceAxis axis = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_axis(static_cast<::CoreML::Specification::SliceLayerParams_SliceAxis>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SliceLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SliceLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 startIndex = 1;
  if (this->_internal_startindex() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_startindex(), target);
  }

  // int64 endIndex = 2;
  if (this->_internal_endindex() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_endindex(), target);
  }

  // uint64 stride = 3;
  if (this->_internal_stride() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_stride(), target);
  }

  // .CoreML.Specification.SliceLayerParams.SliceAxis axis = 4;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_axis(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SliceLayerParams)
  return target;
}

size_t SliceLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SliceLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 startIndex = 1;
  if (this->_internal_startindex() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_startindex());
  }

  // int64 endIndex = 2;
  if (this->_internal_endindex() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_endindex());
  }

  // uint64 stride = 3;
  if (this->_internal_stride() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_stride());
  }

  // .CoreML.Specification.SliceLayerParams.SliceAxis axis = 4;
  if (this->_internal_axis() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_axis());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SliceLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SliceLayerParams*>(
      &from));
}

void SliceLayerParams::MergeFrom(const SliceLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SliceLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_startindex() != 0) {
    _internal_set_startindex(from._internal_startindex());
  }
  if (from._internal_endindex() != 0) {
    _internal_set_endindex(from._internal_endindex());
  }
  if (from._internal_stride() != 0) {
    _internal_set_stride(from._internal_stride());
  }
  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SliceLayerParams::CopyFrom(const SliceLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SliceLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SliceLayerParams::IsInitialized() const {
  return true;
}

void SliceLayerParams::InternalSwap(SliceLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SliceLayerParams, axis_)
      + sizeof(SliceLayerParams::axis_)
      - PROTOBUF_FIELD_OFFSET(SliceLayerParams, startindex_)>(
          reinterpret_cast<char*>(&startindex_),
          reinterpret_cast<char*>(&other->startindex_));
}

std::string SliceLayerParams::GetTypeName() const {
  return "CoreML.Specification.SliceLayerParams";
}


// ===================================================================

class ReduceLayerParams::_Internal {
 public:
};

ReduceLayerParams::ReduceLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ReduceLayerParams)
}
ReduceLayerParams::ReduceLayerParams(const ReduceLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&mode_, &from.mode_,
    static_cast<size_t>(reinterpret_cast<char*>(&axis_) -
    reinterpret_cast<char*>(&mode_)) + sizeof(axis_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ReduceLayerParams)
}

inline void ReduceLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&mode_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&axis_) -
    reinterpret_cast<char*>(&mode_)) + sizeof(axis_));
}

ReduceLayerParams::~ReduceLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ReduceLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReduceLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReduceLayerParams::ArenaDtor(void* object) {
  ReduceLayerParams* _this = reinterpret_cast< ReduceLayerParams* >(object);
  (void)_this;
}
void ReduceLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReduceLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReduceLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ReduceLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&mode_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&axis_) -
      reinterpret_cast<char*>(&mode_)) + sizeof(axis_));
  _internal_metadata_.Clear<std::string>();
}

const char* ReduceLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.ReduceLayerParams.ReduceOperation mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mode(static_cast<::CoreML::Specification::ReduceLayerParams_ReduceOperation>(val));
        } else
          goto handle_unusual;
        continue;
      // float epsilon = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          epsilon_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ReduceLayerParams.ReduceAxis axis = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_axis(static_cast<::CoreML::Specification::ReduceLayerParams_ReduceAxis>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReduceLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ReduceLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.ReduceLayerParams.ReduceOperation mode = 1;
  if (this->_internal_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_mode(), target);
  }

  // float epsilon = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_epsilon = this->_internal_epsilon();
  uint32_t raw_epsilon;
  memcpy(&raw_epsilon, &tmp_epsilon, sizeof(tmp_epsilon));
  if (raw_epsilon != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_epsilon(), target);
  }

  // .CoreML.Specification.ReduceLayerParams.ReduceAxis axis = 3;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_axis(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ReduceLayerParams)
  return target;
}

size_t ReduceLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ReduceLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.ReduceLayerParams.ReduceOperation mode = 1;
  if (this->_internal_mode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mode());
  }

  // float epsilon = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_epsilon = this->_internal_epsilon();
  uint32_t raw_epsilon;
  memcpy(&raw_epsilon, &tmp_epsilon, sizeof(tmp_epsilon));
  if (raw_epsilon != 0) {
    total_size += 1 + 4;
  }

  // .CoreML.Specification.ReduceLayerParams.ReduceAxis axis = 3;
  if (this->_internal_axis() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_axis());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReduceLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReduceLayerParams*>(
      &from));
}

void ReduceLayerParams::MergeFrom(const ReduceLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ReduceLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_mode() != 0) {
    _internal_set_mode(from._internal_mode());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_epsilon = from._internal_epsilon();
  uint32_t raw_epsilon;
  memcpy(&raw_epsilon, &tmp_epsilon, sizeof(tmp_epsilon));
  if (raw_epsilon != 0) {
    _internal_set_epsilon(from._internal_epsilon());
  }
  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReduceLayerParams::CopyFrom(const ReduceLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ReduceLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReduceLayerParams::IsInitialized() const {
  return true;
}

void ReduceLayerParams::InternalSwap(ReduceLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReduceLayerParams, axis_)
      + sizeof(ReduceLayerParams::axis_)
      - PROTOBUF_FIELD_OFFSET(ReduceLayerParams, mode_)>(
          reinterpret_cast<char*>(&mode_),
          reinterpret_cast<char*>(&other->mode_));
}

std::string ReduceLayerParams::GetTypeName() const {
  return "CoreML.Specification.ReduceLayerParams";
}


// ===================================================================

class CropLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::BorderAmounts& cropamounts(const CropLayerParams* msg);
};

const ::CoreML::Specification::BorderAmounts&
CropLayerParams::_Internal::cropamounts(const CropLayerParams* msg) {
  return *msg->cropamounts_;
}
CropLayerParams::CropLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  offset_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.CropLayerParams)
}
CropLayerParams::CropLayerParams(const CropLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      offset_(from.offset_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_cropamounts()) {
    cropamounts_ = new ::CoreML::Specification::BorderAmounts(*from.cropamounts_);
  } else {
    cropamounts_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.CropLayerParams)
}

inline void CropLayerParams::SharedCtor() {
cropamounts_ = nullptr;
}

CropLayerParams::~CropLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.CropLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CropLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete cropamounts_;
}

void CropLayerParams::ArenaDtor(void* object) {
  CropLayerParams* _this = reinterpret_cast< CropLayerParams* >(object);
  (void)_this;
}
void CropLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CropLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CropLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.CropLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  offset_.Clear();
  if (GetArenaForAllocation() == nullptr && cropamounts_ != nullptr) {
    delete cropamounts_;
  }
  cropamounts_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* CropLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.BorderAmounts cropAmounts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_cropamounts(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 offset = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_offset(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 40) {
          _internal_add_offset(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CropLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.CropLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.BorderAmounts cropAmounts = 1;
  if (this->_internal_has_cropamounts()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::cropamounts(this), target, stream);
  }

  // repeated uint64 offset = 5;
  {
    int byte_size = _offset_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          5, _internal_offset(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.CropLayerParams)
  return target;
}

size_t CropLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.CropLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 offset = 5;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->offset_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _offset_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .CoreML.Specification.BorderAmounts cropAmounts = 1;
  if (this->_internal_has_cropamounts()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *cropamounts_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CropLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CropLayerParams*>(
      &from));
}

void CropLayerParams::MergeFrom(const CropLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.CropLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  offset_.MergeFrom(from.offset_);
  if (from._internal_has_cropamounts()) {
    _internal_mutable_cropamounts()->::CoreML::Specification::BorderAmounts::MergeFrom(from._internal_cropamounts());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CropLayerParams::CopyFrom(const CropLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.CropLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CropLayerParams::IsInitialized() const {
  return true;
}

void CropLayerParams::InternalSwap(CropLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  offset_.InternalSwap(&other->offset_);
  swap(cropamounts_, other->cropamounts_);
}

std::string CropLayerParams::GetTypeName() const {
  return "CoreML.Specification.CropLayerParams";
}


// ===================================================================

class AverageLayerParams::_Internal {
 public:
};

AverageLayerParams::AverageLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.AverageLayerParams)
}
AverageLayerParams::AverageLayerParams(const AverageLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.AverageLayerParams)
}

inline void AverageLayerParams::SharedCtor() {
}

AverageLayerParams::~AverageLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.AverageLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AverageLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AverageLayerParams::ArenaDtor(void* object) {
  AverageLayerParams* _this = reinterpret_cast< AverageLayerParams* >(object);
  (void)_this;
}
void AverageLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AverageLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AverageLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.AverageLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* AverageLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AverageLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.AverageLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.AverageLayerParams)
  return target;
}

size_t AverageLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.AverageLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AverageLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AverageLayerParams*>(
      &from));
}

void AverageLayerParams::MergeFrom(const AverageLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.AverageLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AverageLayerParams::CopyFrom(const AverageLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.AverageLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AverageLayerParams::IsInitialized() const {
  return true;
}

void AverageLayerParams::InternalSwap(AverageLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string AverageLayerParams::GetTypeName() const {
  return "CoreML.Specification.AverageLayerParams";
}


// ===================================================================

class MaxLayerParams::_Internal {
 public:
};

MaxLayerParams::MaxLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MaxLayerParams)
}
MaxLayerParams::MaxLayerParams(const MaxLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MaxLayerParams)
}

inline void MaxLayerParams::SharedCtor() {
}

MaxLayerParams::~MaxLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MaxLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void MaxLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MaxLayerParams::ArenaDtor(void* object) {
  MaxLayerParams* _this = reinterpret_cast< MaxLayerParams* >(object);
  (void)_this;
}
void MaxLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MaxLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MaxLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MaxLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* MaxLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MaxLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MaxLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MaxLayerParams)
  return target;
}

size_t MaxLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MaxLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MaxLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MaxLayerParams*>(
      &from));
}

void MaxLayerParams::MergeFrom(const MaxLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MaxLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MaxLayerParams::CopyFrom(const MaxLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MaxLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MaxLayerParams::IsInitialized() const {
  return true;
}

void MaxLayerParams::InternalSwap(MaxLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string MaxLayerParams::GetTypeName() const {
  return "CoreML.Specification.MaxLayerParams";
}


// ===================================================================

class MinLayerParams::_Internal {
 public:
};

MinLayerParams::MinLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MinLayerParams)
}
MinLayerParams::MinLayerParams(const MinLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MinLayerParams)
}

inline void MinLayerParams::SharedCtor() {
}

MinLayerParams::~MinLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MinLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void MinLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MinLayerParams::ArenaDtor(void* object) {
  MinLayerParams* _this = reinterpret_cast< MinLayerParams* >(object);
  (void)_this;
}
void MinLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MinLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MinLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MinLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* MinLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MinLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MinLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MinLayerParams)
  return target;
}

size_t MinLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MinLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MinLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MinLayerParams*>(
      &from));
}

void MinLayerParams::MergeFrom(const MinLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MinLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MinLayerParams::CopyFrom(const MinLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MinLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MinLayerParams::IsInitialized() const {
  return true;
}

void MinLayerParams::InternalSwap(MinLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string MinLayerParams::GetTypeName() const {
  return "CoreML.Specification.MinLayerParams";
}


// ===================================================================

class DotProductLayerParams::_Internal {
 public:
};

DotProductLayerParams::DotProductLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.DotProductLayerParams)
}
DotProductLayerParams::DotProductLayerParams(const DotProductLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  cosinesimilarity_ = from.cosinesimilarity_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DotProductLayerParams)
}

inline void DotProductLayerParams::SharedCtor() {
cosinesimilarity_ = false;
}

DotProductLayerParams::~DotProductLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DotProductLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void DotProductLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DotProductLayerParams::ArenaDtor(void* object) {
  DotProductLayerParams* _this = reinterpret_cast< DotProductLayerParams* >(object);
  (void)_this;
}
void DotProductLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DotProductLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DotProductLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DotProductLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cosinesimilarity_ = false;
  _internal_metadata_.Clear<std::string>();
}

const char* DotProductLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool cosineSimilarity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          cosinesimilarity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DotProductLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.DotProductLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool cosineSimilarity = 1;
  if (this->_internal_cosinesimilarity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_cosinesimilarity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.DotProductLayerParams)
  return target;
}

size_t DotProductLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DotProductLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool cosineSimilarity = 1;
  if (this->_internal_cosinesimilarity() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DotProductLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DotProductLayerParams*>(
      &from));
}

void DotProductLayerParams::MergeFrom(const DotProductLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DotProductLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_cosinesimilarity() != 0) {
    _internal_set_cosinesimilarity(from._internal_cosinesimilarity());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DotProductLayerParams::CopyFrom(const DotProductLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DotProductLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DotProductLayerParams::IsInitialized() const {
  return true;
}

void DotProductLayerParams::InternalSwap(DotProductLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(cosinesimilarity_, other->cosinesimilarity_);
}

std::string DotProductLayerParams::GetTypeName() const {
  return "CoreML.Specification.DotProductLayerParams";
}


// ===================================================================

class MeanVarianceNormalizeLayerParams::_Internal {
 public:
};

MeanVarianceNormalizeLayerParams::MeanVarianceNormalizeLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MeanVarianceNormalizeLayerParams)
}
MeanVarianceNormalizeLayerParams::MeanVarianceNormalizeLayerParams(const MeanVarianceNormalizeLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&acrosschannels_, &from.acrosschannels_,
    static_cast<size_t>(reinterpret_cast<char*>(&epsilon_) -
    reinterpret_cast<char*>(&acrosschannels_)) + sizeof(epsilon_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MeanVarianceNormalizeLayerParams)
}

inline void MeanVarianceNormalizeLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&acrosschannels_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&epsilon_) -
    reinterpret_cast<char*>(&acrosschannels_)) + sizeof(epsilon_));
}

MeanVarianceNormalizeLayerParams::~MeanVarianceNormalizeLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MeanVarianceNormalizeLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void MeanVarianceNormalizeLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MeanVarianceNormalizeLayerParams::ArenaDtor(void* object) {
  MeanVarianceNormalizeLayerParams* _this = reinterpret_cast< MeanVarianceNormalizeLayerParams* >(object);
  (void)_this;
}
void MeanVarianceNormalizeLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MeanVarianceNormalizeLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MeanVarianceNormalizeLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MeanVarianceNormalizeLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&acrosschannels_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&epsilon_) -
      reinterpret_cast<char*>(&acrosschannels_)) + sizeof(epsilon_));
  _internal_metadata_.Clear<std::string>();
}

const char* MeanVarianceNormalizeLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool acrossChannels = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          acrosschannels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool normalizeVariance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          normalizevariance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float epsilon = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          epsilon_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MeanVarianceNormalizeLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MeanVarianceNormalizeLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool acrossChannels = 1;
  if (this->_internal_acrosschannels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_acrosschannels(), target);
  }

  // bool normalizeVariance = 2;
  if (this->_internal_normalizevariance() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_normalizevariance(), target);
  }

  // float epsilon = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_epsilon = this->_internal_epsilon();
  uint32_t raw_epsilon;
  memcpy(&raw_epsilon, &tmp_epsilon, sizeof(tmp_epsilon));
  if (raw_epsilon != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_epsilon(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MeanVarianceNormalizeLayerParams)
  return target;
}

size_t MeanVarianceNormalizeLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MeanVarianceNormalizeLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool acrossChannels = 1;
  if (this->_internal_acrosschannels() != 0) {
    total_size += 1 + 1;
  }

  // bool normalizeVariance = 2;
  if (this->_internal_normalizevariance() != 0) {
    total_size += 1 + 1;
  }

  // float epsilon = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_epsilon = this->_internal_epsilon();
  uint32_t raw_epsilon;
  memcpy(&raw_epsilon, &tmp_epsilon, sizeof(tmp_epsilon));
  if (raw_epsilon != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MeanVarianceNormalizeLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MeanVarianceNormalizeLayerParams*>(
      &from));
}

void MeanVarianceNormalizeLayerParams::MergeFrom(const MeanVarianceNormalizeLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MeanVarianceNormalizeLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_acrosschannels() != 0) {
    _internal_set_acrosschannels(from._internal_acrosschannels());
  }
  if (from._internal_normalizevariance() != 0) {
    _internal_set_normalizevariance(from._internal_normalizevariance());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_epsilon = from._internal_epsilon();
  uint32_t raw_epsilon;
  memcpy(&raw_epsilon, &tmp_epsilon, sizeof(tmp_epsilon));
  if (raw_epsilon != 0) {
    _internal_set_epsilon(from._internal_epsilon());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MeanVarianceNormalizeLayerParams::CopyFrom(const MeanVarianceNormalizeLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MeanVarianceNormalizeLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MeanVarianceNormalizeLayerParams::IsInitialized() const {
  return true;
}

void MeanVarianceNormalizeLayerParams::InternalSwap(MeanVarianceNormalizeLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MeanVarianceNormalizeLayerParams, epsilon_)
      + sizeof(MeanVarianceNormalizeLayerParams::epsilon_)
      - PROTOBUF_FIELD_OFFSET(MeanVarianceNormalizeLayerParams, acrosschannels_)>(
          reinterpret_cast<char*>(&acrosschannels_),
          reinterpret_cast<char*>(&other->acrosschannels_));
}

std::string MeanVarianceNormalizeLayerParams::GetTypeName() const {
  return "CoreML.Specification.MeanVarianceNormalizeLayerParams";
}


// ===================================================================

class SequenceRepeatLayerParams::_Internal {
 public:
};

SequenceRepeatLayerParams::SequenceRepeatLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SequenceRepeatLayerParams)
}
SequenceRepeatLayerParams::SequenceRepeatLayerParams(const SequenceRepeatLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  nrepetitions_ = from.nrepetitions_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SequenceRepeatLayerParams)
}

inline void SequenceRepeatLayerParams::SharedCtor() {
nrepetitions_ = uint64_t{0u};
}

SequenceRepeatLayerParams::~SequenceRepeatLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SequenceRepeatLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SequenceRepeatLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SequenceRepeatLayerParams::ArenaDtor(void* object) {
  SequenceRepeatLayerParams* _this = reinterpret_cast< SequenceRepeatLayerParams* >(object);
  (void)_this;
}
void SequenceRepeatLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SequenceRepeatLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SequenceRepeatLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SequenceRepeatLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nrepetitions_ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* SequenceRepeatLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 nRepetitions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          nrepetitions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SequenceRepeatLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SequenceRepeatLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 nRepetitions = 1;
  if (this->_internal_nrepetitions() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_nrepetitions(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SequenceRepeatLayerParams)
  return target;
}

size_t SequenceRepeatLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SequenceRepeatLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 nRepetitions = 1;
  if (this->_internal_nrepetitions() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_nrepetitions());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SequenceRepeatLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SequenceRepeatLayerParams*>(
      &from));
}

void SequenceRepeatLayerParams::MergeFrom(const SequenceRepeatLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SequenceRepeatLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_nrepetitions() != 0) {
    _internal_set_nrepetitions(from._internal_nrepetitions());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SequenceRepeatLayerParams::CopyFrom(const SequenceRepeatLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SequenceRepeatLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SequenceRepeatLayerParams::IsInitialized() const {
  return true;
}

void SequenceRepeatLayerParams::InternalSwap(SequenceRepeatLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(nrepetitions_, other->nrepetitions_);
}

std::string SequenceRepeatLayerParams::GetTypeName() const {
  return "CoreML.Specification.SequenceRepeatLayerParams";
}


// ===================================================================

class SimpleRecurrentLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::ActivationParams& activation(const SimpleRecurrentLayerParams* msg);
  static const ::CoreML::Specification::WeightParams& weightmatrix(const SimpleRecurrentLayerParams* msg);
  static const ::CoreML::Specification::WeightParams& recursionmatrix(const SimpleRecurrentLayerParams* msg);
  static const ::CoreML::Specification::WeightParams& biasvector(const SimpleRecurrentLayerParams* msg);
};

const ::CoreML::Specification::ActivationParams&
SimpleRecurrentLayerParams::_Internal::activation(const SimpleRecurrentLayerParams* msg) {
  return *msg->activation_;
}
const ::CoreML::Specification::WeightParams&
SimpleRecurrentLayerParams::_Internal::weightmatrix(const SimpleRecurrentLayerParams* msg) {
  return *msg->weightmatrix_;
}
const ::CoreML::Specification::WeightParams&
SimpleRecurrentLayerParams::_Internal::recursionmatrix(const SimpleRecurrentLayerParams* msg) {
  return *msg->recursionmatrix_;
}
const ::CoreML::Specification::WeightParams&
SimpleRecurrentLayerParams::_Internal::biasvector(const SimpleRecurrentLayerParams* msg) {
  return *msg->biasvector_;
}
SimpleRecurrentLayerParams::SimpleRecurrentLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SimpleRecurrentLayerParams)
}
SimpleRecurrentLayerParams::SimpleRecurrentLayerParams(const SimpleRecurrentLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_activation()) {
    activation_ = new ::CoreML::Specification::ActivationParams(*from.activation_);
  } else {
    activation_ = nullptr;
  }
  if (from._internal_has_weightmatrix()) {
    weightmatrix_ = new ::CoreML::Specification::WeightParams(*from.weightmatrix_);
  } else {
    weightmatrix_ = nullptr;
  }
  if (from._internal_has_recursionmatrix()) {
    recursionmatrix_ = new ::CoreML::Specification::WeightParams(*from.recursionmatrix_);
  } else {
    recursionmatrix_ = nullptr;
  }
  if (from._internal_has_biasvector()) {
    biasvector_ = new ::CoreML::Specification::WeightParams(*from.biasvector_);
  } else {
    biasvector_ = nullptr;
  }
  ::memcpy(&inputvectorsize_, &from.inputvectorsize_,
    static_cast<size_t>(reinterpret_cast<char*>(&reverseinput_) -
    reinterpret_cast<char*>(&inputvectorsize_)) + sizeof(reverseinput_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SimpleRecurrentLayerParams)
}

inline void SimpleRecurrentLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&activation_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reverseinput_) -
    reinterpret_cast<char*>(&activation_)) + sizeof(reverseinput_));
}

SimpleRecurrentLayerParams::~SimpleRecurrentLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SimpleRecurrentLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SimpleRecurrentLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete activation_;
  if (this != internal_default_instance()) delete weightmatrix_;
  if (this != internal_default_instance()) delete recursionmatrix_;
  if (this != internal_default_instance()) delete biasvector_;
}

void SimpleRecurrentLayerParams::ArenaDtor(void* object) {
  SimpleRecurrentLayerParams* _this = reinterpret_cast< SimpleRecurrentLayerParams* >(object);
  (void)_this;
}
void SimpleRecurrentLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SimpleRecurrentLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SimpleRecurrentLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SimpleRecurrentLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && activation_ != nullptr) {
    delete activation_;
  }
  activation_ = nullptr;
  if (GetArenaForAllocation() == nullptr && weightmatrix_ != nullptr) {
    delete weightmatrix_;
  }
  weightmatrix_ = nullptr;
  if (GetArenaForAllocation() == nullptr && recursionmatrix_ != nullptr) {
    delete recursionmatrix_;
  }
  recursionmatrix_ = nullptr;
  if (GetArenaForAllocation() == nullptr && biasvector_ != nullptr) {
    delete biasvector_;
  }
  biasvector_ = nullptr;
  ::memset(&inputvectorsize_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reverseinput_) -
      reinterpret_cast<char*>(&inputvectorsize_)) + sizeof(reverseinput_));
  _internal_metadata_.Clear<std::string>();
}

const char* SimpleRecurrentLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 inputVectorSize = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          inputvectorsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 outputVectorSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          outputvectorsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ActivationParams activation = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_activation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool sequenceOutput = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          sequenceoutput_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hasBiasVector = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          hasbiasvector_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams weightMatrix = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_weightmatrix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams recursionMatrix = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_recursionmatrix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams biasVector = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_biasvector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reverseInput = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          reverseinput_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SimpleRecurrentLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SimpleRecurrentLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 inputVectorSize = 1;
  if (this->_internal_inputvectorsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_inputvectorsize(), target);
  }

  // uint64 outputVectorSize = 2;
  if (this->_internal_outputvectorsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_outputvectorsize(), target);
  }

  // .CoreML.Specification.ActivationParams activation = 10;
  if (this->_internal_has_activation()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::activation(this), target, stream);
  }

  // bool sequenceOutput = 15;
  if (this->_internal_sequenceoutput() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_sequenceoutput(), target);
  }

  // bool hasBiasVector = 20;
  if (this->_internal_hasbiasvector() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(20, this->_internal_hasbiasvector(), target);
  }

  // .CoreML.Specification.WeightParams weightMatrix = 30;
  if (this->_internal_has_weightmatrix()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        30, _Internal::weightmatrix(this), target, stream);
  }

  // .CoreML.Specification.WeightParams recursionMatrix = 31;
  if (this->_internal_has_recursionmatrix()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        31, _Internal::recursionmatrix(this), target, stream);
  }

  // .CoreML.Specification.WeightParams biasVector = 32;
  if (this->_internal_has_biasvector()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        32, _Internal::biasvector(this), target, stream);
  }

  // bool reverseInput = 100;
  if (this->_internal_reverseinput() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(100, this->_internal_reverseinput(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SimpleRecurrentLayerParams)
  return target;
}

size_t SimpleRecurrentLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SimpleRecurrentLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.ActivationParams activation = 10;
  if (this->_internal_has_activation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *activation_);
  }

  // .CoreML.Specification.WeightParams weightMatrix = 30;
  if (this->_internal_has_weightmatrix()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *weightmatrix_);
  }

  // .CoreML.Specification.WeightParams recursionMatrix = 31;
  if (this->_internal_has_recursionmatrix()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *recursionmatrix_);
  }

  // .CoreML.Specification.WeightParams biasVector = 32;
  if (this->_internal_has_biasvector()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *biasvector_);
  }

  // uint64 inputVectorSize = 1;
  if (this->_internal_inputvectorsize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_inputvectorsize());
  }

  // uint64 outputVectorSize = 2;
  if (this->_internal_outputvectorsize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_outputvectorsize());
  }

  // bool sequenceOutput = 15;
  if (this->_internal_sequenceoutput() != 0) {
    total_size += 1 + 1;
  }

  // bool hasBiasVector = 20;
  if (this->_internal_hasbiasvector() != 0) {
    total_size += 2 + 1;
  }

  // bool reverseInput = 100;
  if (this->_internal_reverseinput() != 0) {
    total_size += 2 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SimpleRecurrentLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SimpleRecurrentLayerParams*>(
      &from));
}

void SimpleRecurrentLayerParams::MergeFrom(const SimpleRecurrentLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SimpleRecurrentLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_activation()) {
    _internal_mutable_activation()->::CoreML::Specification::ActivationParams::MergeFrom(from._internal_activation());
  }
  if (from._internal_has_weightmatrix()) {
    _internal_mutable_weightmatrix()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_weightmatrix());
  }
  if (from._internal_has_recursionmatrix()) {
    _internal_mutable_recursionmatrix()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_recursionmatrix());
  }
  if (from._internal_has_biasvector()) {
    _internal_mutable_biasvector()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_biasvector());
  }
  if (from._internal_inputvectorsize() != 0) {
    _internal_set_inputvectorsize(from._internal_inputvectorsize());
  }
  if (from._internal_outputvectorsize() != 0) {
    _internal_set_outputvectorsize(from._internal_outputvectorsize());
  }
  if (from._internal_sequenceoutput() != 0) {
    _internal_set_sequenceoutput(from._internal_sequenceoutput());
  }
  if (from._internal_hasbiasvector() != 0) {
    _internal_set_hasbiasvector(from._internal_hasbiasvector());
  }
  if (from._internal_reverseinput() != 0) {
    _internal_set_reverseinput(from._internal_reverseinput());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SimpleRecurrentLayerParams::CopyFrom(const SimpleRecurrentLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SimpleRecurrentLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimpleRecurrentLayerParams::IsInitialized() const {
  return true;
}

void SimpleRecurrentLayerParams::InternalSwap(SimpleRecurrentLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SimpleRecurrentLayerParams, reverseinput_)
      + sizeof(SimpleRecurrentLayerParams::reverseinput_)
      - PROTOBUF_FIELD_OFFSET(SimpleRecurrentLayerParams, activation_)>(
          reinterpret_cast<char*>(&activation_),
          reinterpret_cast<char*>(&other->activation_));
}

std::string SimpleRecurrentLayerParams::GetTypeName() const {
  return "CoreML.Specification.SimpleRecurrentLayerParams";
}


// ===================================================================

class GRULayerParams::_Internal {
 public:
  static const ::CoreML::Specification::WeightParams& updategateweightmatrix(const GRULayerParams* msg);
  static const ::CoreML::Specification::WeightParams& resetgateweightmatrix(const GRULayerParams* msg);
  static const ::CoreML::Specification::WeightParams& outputgateweightmatrix(const GRULayerParams* msg);
  static const ::CoreML::Specification::WeightParams& updategaterecursionmatrix(const GRULayerParams* msg);
  static const ::CoreML::Specification::WeightParams& resetgaterecursionmatrix(const GRULayerParams* msg);
  static const ::CoreML::Specification::WeightParams& outputgaterecursionmatrix(const GRULayerParams* msg);
  static const ::CoreML::Specification::WeightParams& updategatebiasvector(const GRULayerParams* msg);
  static const ::CoreML::Specification::WeightParams& resetgatebiasvector(const GRULayerParams* msg);
  static const ::CoreML::Specification::WeightParams& outputgatebiasvector(const GRULayerParams* msg);
};

const ::CoreML::Specification::WeightParams&
GRULayerParams::_Internal::updategateweightmatrix(const GRULayerParams* msg) {
  return *msg->updategateweightmatrix_;
}
const ::CoreML::Specification::WeightParams&
GRULayerParams::_Internal::resetgateweightmatrix(const GRULayerParams* msg) {
  return *msg->resetgateweightmatrix_;
}
const ::CoreML::Specification::WeightParams&
GRULayerParams::_Internal::outputgateweightmatrix(const GRULayerParams* msg) {
  return *msg->outputgateweightmatrix_;
}
const ::CoreML::Specification::WeightParams&
GRULayerParams::_Internal::updategaterecursionmatrix(const GRULayerParams* msg) {
  return *msg->updategaterecursionmatrix_;
}
const ::CoreML::Specification::WeightParams&
GRULayerParams::_Internal::resetgaterecursionmatrix(const GRULayerParams* msg) {
  return *msg->resetgaterecursionmatrix_;
}
const ::CoreML::Specification::WeightParams&
GRULayerParams::_Internal::outputgaterecursionmatrix(const GRULayerParams* msg) {
  return *msg->outputgaterecursionmatrix_;
}
const ::CoreML::Specification::WeightParams&
GRULayerParams::_Internal::updategatebiasvector(const GRULayerParams* msg) {
  return *msg->updategatebiasvector_;
}
const ::CoreML::Specification::WeightParams&
GRULayerParams::_Internal::resetgatebiasvector(const GRULayerParams* msg) {
  return *msg->resetgatebiasvector_;
}
const ::CoreML::Specification::WeightParams&
GRULayerParams::_Internal::outputgatebiasvector(const GRULayerParams* msg) {
  return *msg->outputgatebiasvector_;
}
GRULayerParams::GRULayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  activations_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.GRULayerParams)
}
GRULayerParams::GRULayerParams(const GRULayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      activations_(from.activations_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_updategateweightmatrix()) {
    updategateweightmatrix_ = new ::CoreML::Specification::WeightParams(*from.updategateweightmatrix_);
  } else {
    updategateweightmatrix_ = nullptr;
  }
  if (from._internal_has_resetgateweightmatrix()) {
    resetgateweightmatrix_ = new ::CoreML::Specification::WeightParams(*from.resetgateweightmatrix_);
  } else {
    resetgateweightmatrix_ = nullptr;
  }
  if (from._internal_has_outputgateweightmatrix()) {
    outputgateweightmatrix_ = new ::CoreML::Specification::WeightParams(*from.outputgateweightmatrix_);
  } else {
    outputgateweightmatrix_ = nullptr;
  }
  if (from._internal_has_updategaterecursionmatrix()) {
    updategaterecursionmatrix_ = new ::CoreML::Specification::WeightParams(*from.updategaterecursionmatrix_);
  } else {
    updategaterecursionmatrix_ = nullptr;
  }
  if (from._internal_has_resetgaterecursionmatrix()) {
    resetgaterecursionmatrix_ = new ::CoreML::Specification::WeightParams(*from.resetgaterecursionmatrix_);
  } else {
    resetgaterecursionmatrix_ = nullptr;
  }
  if (from._internal_has_outputgaterecursionmatrix()) {
    outputgaterecursionmatrix_ = new ::CoreML::Specification::WeightParams(*from.outputgaterecursionmatrix_);
  } else {
    outputgaterecursionmatrix_ = nullptr;
  }
  if (from._internal_has_updategatebiasvector()) {
    updategatebiasvector_ = new ::CoreML::Specification::WeightParams(*from.updategatebiasvector_);
  } else {
    updategatebiasvector_ = nullptr;
  }
  if (from._internal_has_resetgatebiasvector()) {
    resetgatebiasvector_ = new ::CoreML::Specification::WeightParams(*from.resetgatebiasvector_);
  } else {
    resetgatebiasvector_ = nullptr;
  }
  if (from._internal_has_outputgatebiasvector()) {
    outputgatebiasvector_ = new ::CoreML::Specification::WeightParams(*from.outputgatebiasvector_);
  } else {
    outputgatebiasvector_ = nullptr;
  }
  ::memcpy(&inputvectorsize_, &from.inputvectorsize_,
    static_cast<size_t>(reinterpret_cast<char*>(&reverseinput_) -
    reinterpret_cast<char*>(&inputvectorsize_)) + sizeof(reverseinput_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.GRULayerParams)
}

inline void GRULayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&updategateweightmatrix_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reverseinput_) -
    reinterpret_cast<char*>(&updategateweightmatrix_)) + sizeof(reverseinput_));
}

GRULayerParams::~GRULayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.GRULayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GRULayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete updategateweightmatrix_;
  if (this != internal_default_instance()) delete resetgateweightmatrix_;
  if (this != internal_default_instance()) delete outputgateweightmatrix_;
  if (this != internal_default_instance()) delete updategaterecursionmatrix_;
  if (this != internal_default_instance()) delete resetgaterecursionmatrix_;
  if (this != internal_default_instance()) delete outputgaterecursionmatrix_;
  if (this != internal_default_instance()) delete updategatebiasvector_;
  if (this != internal_default_instance()) delete resetgatebiasvector_;
  if (this != internal_default_instance()) delete outputgatebiasvector_;
}

void GRULayerParams::ArenaDtor(void* object) {
  GRULayerParams* _this = reinterpret_cast< GRULayerParams* >(object);
  (void)_this;
}
void GRULayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GRULayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GRULayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.GRULayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  activations_.Clear();
  if (GetArenaForAllocation() == nullptr && updategateweightmatrix_ != nullptr) {
    delete updategateweightmatrix_;
  }
  updategateweightmatrix_ = nullptr;
  if (GetArenaForAllocation() == nullptr && resetgateweightmatrix_ != nullptr) {
    delete resetgateweightmatrix_;
  }
  resetgateweightmatrix_ = nullptr;
  if (GetArenaForAllocation() == nullptr && outputgateweightmatrix_ != nullptr) {
    delete outputgateweightmatrix_;
  }
  outputgateweightmatrix_ = nullptr;
  if (GetArenaForAllocation() == nullptr && updategaterecursionmatrix_ != nullptr) {
    delete updategaterecursionmatrix_;
  }
  updategaterecursionmatrix_ = nullptr;
  if (GetArenaForAllocation() == nullptr && resetgaterecursionmatrix_ != nullptr) {
    delete resetgaterecursionmatrix_;
  }
  resetgaterecursionmatrix_ = nullptr;
  if (GetArenaForAllocation() == nullptr && outputgaterecursionmatrix_ != nullptr) {
    delete outputgaterecursionmatrix_;
  }
  outputgaterecursionmatrix_ = nullptr;
  if (GetArenaForAllocation() == nullptr && updategatebiasvector_ != nullptr) {
    delete updategatebiasvector_;
  }
  updategatebiasvector_ = nullptr;
  if (GetArenaForAllocation() == nullptr && resetgatebiasvector_ != nullptr) {
    delete resetgatebiasvector_;
  }
  resetgatebiasvector_ = nullptr;
  if (GetArenaForAllocation() == nullptr && outputgatebiasvector_ != nullptr) {
    delete outputgatebiasvector_;
  }
  outputgatebiasvector_ = nullptr;
  ::memset(&inputvectorsize_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reverseinput_) -
      reinterpret_cast<char*>(&inputvectorsize_)) + sizeof(reverseinput_));
  _internal_metadata_.Clear<std::string>();
}

const char* GRULayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 inputVectorSize = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          inputvectorsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 outputVectorSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          outputvectorsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.ActivationParams activations = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_activations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool sequenceOutput = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          sequenceoutput_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hasBiasVectors = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          hasbiasvectors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams updateGateWeightMatrix = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_updategateweightmatrix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams resetGateWeightMatrix = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_resetgateweightmatrix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams outputGateWeightMatrix = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_outputgateweightmatrix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams updateGateRecursionMatrix = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_updategaterecursionmatrix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams resetGateRecursionMatrix = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_resetgaterecursionmatrix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams outputGateRecursionMatrix = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_outputgaterecursionmatrix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams updateGateBiasVector = 70;
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_updategatebiasvector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams resetGateBiasVector = 71;
      case 71:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_resetgatebiasvector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams outputGateBiasVector = 72;
      case 72:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_outputgatebiasvector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reverseInput = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          reverseinput_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GRULayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.GRULayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 inputVectorSize = 1;
  if (this->_internal_inputvectorsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_inputvectorsize(), target);
  }

  // uint64 outputVectorSize = 2;
  if (this->_internal_outputvectorsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_outputvectorsize(), target);
  }

  // repeated .CoreML.Specification.ActivationParams activations = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_activations_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_activations(i), target, stream);
  }

  // bool sequenceOutput = 15;
  if (this->_internal_sequenceoutput() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_sequenceoutput(), target);
  }

  // bool hasBiasVectors = 20;
  if (this->_internal_hasbiasvectors() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(20, this->_internal_hasbiasvectors(), target);
  }

  // .CoreML.Specification.WeightParams updateGateWeightMatrix = 30;
  if (this->_internal_has_updategateweightmatrix()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        30, _Internal::updategateweightmatrix(this), target, stream);
  }

  // .CoreML.Specification.WeightParams resetGateWeightMatrix = 31;
  if (this->_internal_has_resetgateweightmatrix()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        31, _Internal::resetgateweightmatrix(this), target, stream);
  }

  // .CoreML.Specification.WeightParams outputGateWeightMatrix = 32;
  if (this->_internal_has_outputgateweightmatrix()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        32, _Internal::outputgateweightmatrix(this), target, stream);
  }

  // .CoreML.Specification.WeightParams updateGateRecursionMatrix = 50;
  if (this->_internal_has_updategaterecursionmatrix()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        50, _Internal::updategaterecursionmatrix(this), target, stream);
  }

  // .CoreML.Specification.WeightParams resetGateRecursionMatrix = 51;
  if (this->_internal_has_resetgaterecursionmatrix()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        51, _Internal::resetgaterecursionmatrix(this), target, stream);
  }

  // .CoreML.Specification.WeightParams outputGateRecursionMatrix = 52;
  if (this->_internal_has_outputgaterecursionmatrix()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        52, _Internal::outputgaterecursionmatrix(this), target, stream);
  }

  // .CoreML.Specification.WeightParams updateGateBiasVector = 70;
  if (this->_internal_has_updategatebiasvector()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        70, _Internal::updategatebiasvector(this), target, stream);
  }

  // .CoreML.Specification.WeightParams resetGateBiasVector = 71;
  if (this->_internal_has_resetgatebiasvector()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        71, _Internal::resetgatebiasvector(this), target, stream);
  }

  // .CoreML.Specification.WeightParams outputGateBiasVector = 72;
  if (this->_internal_has_outputgatebiasvector()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        72, _Internal::outputgatebiasvector(this), target, stream);
  }

  // bool reverseInput = 100;
  if (this->_internal_reverseinput() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(100, this->_internal_reverseinput(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.GRULayerParams)
  return target;
}

size_t GRULayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.GRULayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.ActivationParams activations = 10;
  total_size += 1UL * this->_internal_activations_size();
  for (const auto& msg : this->activations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .CoreML.Specification.WeightParams updateGateWeightMatrix = 30;
  if (this->_internal_has_updategateweightmatrix()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *updategateweightmatrix_);
  }

  // .CoreML.Specification.WeightParams resetGateWeightMatrix = 31;
  if (this->_internal_has_resetgateweightmatrix()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *resetgateweightmatrix_);
  }

  // .CoreML.Specification.WeightParams outputGateWeightMatrix = 32;
  if (this->_internal_has_outputgateweightmatrix()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *outputgateweightmatrix_);
  }

  // .CoreML.Specification.WeightParams updateGateRecursionMatrix = 50;
  if (this->_internal_has_updategaterecursionmatrix()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *updategaterecursionmatrix_);
  }

  // .CoreML.Specification.WeightParams resetGateRecursionMatrix = 51;
  if (this->_internal_has_resetgaterecursionmatrix()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *resetgaterecursionmatrix_);
  }

  // .CoreML.Specification.WeightParams outputGateRecursionMatrix = 52;
  if (this->_internal_has_outputgaterecursionmatrix()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *outputgaterecursionmatrix_);
  }

  // .CoreML.Specification.WeightParams updateGateBiasVector = 70;
  if (this->_internal_has_updategatebiasvector()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *updategatebiasvector_);
  }

  // .CoreML.Specification.WeightParams resetGateBiasVector = 71;
  if (this->_internal_has_resetgatebiasvector()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *resetgatebiasvector_);
  }

  // .CoreML.Specification.WeightParams outputGateBiasVector = 72;
  if (this->_internal_has_outputgatebiasvector()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *outputgatebiasvector_);
  }

  // uint64 inputVectorSize = 1;
  if (this->_internal_inputvectorsize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_inputvectorsize());
  }

  // uint64 outputVectorSize = 2;
  if (this->_internal_outputvectorsize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_outputvectorsize());
  }

  // bool sequenceOutput = 15;
  if (this->_internal_sequenceoutput() != 0) {
    total_size += 1 + 1;
  }

  // bool hasBiasVectors = 20;
  if (this->_internal_hasbiasvectors() != 0) {
    total_size += 2 + 1;
  }

  // bool reverseInput = 100;
  if (this->_internal_reverseinput() != 0) {
    total_size += 2 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GRULayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GRULayerParams*>(
      &from));
}

void GRULayerParams::MergeFrom(const GRULayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.GRULayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  activations_.MergeFrom(from.activations_);
  if (from._internal_has_updategateweightmatrix()) {
    _internal_mutable_updategateweightmatrix()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_updategateweightmatrix());
  }
  if (from._internal_has_resetgateweightmatrix()) {
    _internal_mutable_resetgateweightmatrix()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_resetgateweightmatrix());
  }
  if (from._internal_has_outputgateweightmatrix()) {
    _internal_mutable_outputgateweightmatrix()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_outputgateweightmatrix());
  }
  if (from._internal_has_updategaterecursionmatrix()) {
    _internal_mutable_updategaterecursionmatrix()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_updategaterecursionmatrix());
  }
  if (from._internal_has_resetgaterecursionmatrix()) {
    _internal_mutable_resetgaterecursionmatrix()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_resetgaterecursionmatrix());
  }
  if (from._internal_has_outputgaterecursionmatrix()) {
    _internal_mutable_outputgaterecursionmatrix()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_outputgaterecursionmatrix());
  }
  if (from._internal_has_updategatebiasvector()) {
    _internal_mutable_updategatebiasvector()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_updategatebiasvector());
  }
  if (from._internal_has_resetgatebiasvector()) {
    _internal_mutable_resetgatebiasvector()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_resetgatebiasvector());
  }
  if (from._internal_has_outputgatebiasvector()) {
    _internal_mutable_outputgatebiasvector()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_outputgatebiasvector());
  }
  if (from._internal_inputvectorsize() != 0) {
    _internal_set_inputvectorsize(from._internal_inputvectorsize());
  }
  if (from._internal_outputvectorsize() != 0) {
    _internal_set_outputvectorsize(from._internal_outputvectorsize());
  }
  if (from._internal_sequenceoutput() != 0) {
    _internal_set_sequenceoutput(from._internal_sequenceoutput());
  }
  if (from._internal_hasbiasvectors() != 0) {
    _internal_set_hasbiasvectors(from._internal_hasbiasvectors());
  }
  if (from._internal_reverseinput() != 0) {
    _internal_set_reverseinput(from._internal_reverseinput());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GRULayerParams::CopyFrom(const GRULayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.GRULayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GRULayerParams::IsInitialized() const {
  return true;
}

void GRULayerParams::InternalSwap(GRULayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  activations_.InternalSwap(&other->activations_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GRULayerParams, reverseinput_)
      + sizeof(GRULayerParams::reverseinput_)
      - PROTOBUF_FIELD_OFFSET(GRULayerParams, updategateweightmatrix_)>(
          reinterpret_cast<char*>(&updategateweightmatrix_),
          reinterpret_cast<char*>(&other->updategateweightmatrix_));
}

std::string GRULayerParams::GetTypeName() const {
  return "CoreML.Specification.GRULayerParams";
}


// ===================================================================

class LSTMParams::_Internal {
 public:
};

LSTMParams::LSTMParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LSTMParams)
}
LSTMParams::LSTMParams(const LSTMParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&cellclipthreshold_, &from.cellclipthreshold_,
    static_cast<size_t>(reinterpret_cast<char*>(&coupledinputandforgetgate_) -
    reinterpret_cast<char*>(&cellclipthreshold_)) + sizeof(coupledinputandforgetgate_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LSTMParams)
}

inline void LSTMParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&cellclipthreshold_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&coupledinputandforgetgate_) -
    reinterpret_cast<char*>(&cellclipthreshold_)) + sizeof(coupledinputandforgetgate_));
}

LSTMParams::~LSTMParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LSTMParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LSTMParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LSTMParams::ArenaDtor(void* object) {
  LSTMParams* _this = reinterpret_cast< LSTMParams* >(object);
  (void)_this;
}
void LSTMParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LSTMParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LSTMParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LSTMParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&cellclipthreshold_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&coupledinputandforgetgate_) -
      reinterpret_cast<char*>(&cellclipthreshold_)) + sizeof(coupledinputandforgetgate_));
  _internal_metadata_.Clear<std::string>();
}

const char* LSTMParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool sequenceOutput = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          sequenceoutput_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hasBiasVectors = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          hasbiasvectors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool forgetBias = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          forgetbias_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hasPeepholeVectors = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          haspeepholevectors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool coupledInputAndForgetGate = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          coupledinputandforgetgate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float cellClipThreshold = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 229)) {
          cellclipthreshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LSTMParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LSTMParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool sequenceOutput = 10;
  if (this->_internal_sequenceoutput() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_sequenceoutput(), target);
  }

  // bool hasBiasVectors = 20;
  if (this->_internal_hasbiasvectors() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(20, this->_internal_hasbiasvectors(), target);
  }

  // bool forgetBias = 30;
  if (this->_internal_forgetbias() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(30, this->_internal_forgetbias(), target);
  }

  // bool hasPeepholeVectors = 40;
  if (this->_internal_haspeepholevectors() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(40, this->_internal_haspeepholevectors(), target);
  }

  // bool coupledInputAndForgetGate = 50;
  if (this->_internal_coupledinputandforgetgate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(50, this->_internal_coupledinputandforgetgate(), target);
  }

  // float cellClipThreshold = 60;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_cellclipthreshold = this->_internal_cellclipthreshold();
  uint32_t raw_cellclipthreshold;
  memcpy(&raw_cellclipthreshold, &tmp_cellclipthreshold, sizeof(tmp_cellclipthreshold));
  if (raw_cellclipthreshold != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(60, this->_internal_cellclipthreshold(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LSTMParams)
  return target;
}

size_t LSTMParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LSTMParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float cellClipThreshold = 60;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_cellclipthreshold = this->_internal_cellclipthreshold();
  uint32_t raw_cellclipthreshold;
  memcpy(&raw_cellclipthreshold, &tmp_cellclipthreshold, sizeof(tmp_cellclipthreshold));
  if (raw_cellclipthreshold != 0) {
    total_size += 2 + 4;
  }

  // bool sequenceOutput = 10;
  if (this->_internal_sequenceoutput() != 0) {
    total_size += 1 + 1;
  }

  // bool hasBiasVectors = 20;
  if (this->_internal_hasbiasvectors() != 0) {
    total_size += 2 + 1;
  }

  // bool forgetBias = 30;
  if (this->_internal_forgetbias() != 0) {
    total_size += 2 + 1;
  }

  // bool hasPeepholeVectors = 40;
  if (this->_internal_haspeepholevectors() != 0) {
    total_size += 2 + 1;
  }

  // bool coupledInputAndForgetGate = 50;
  if (this->_internal_coupledinputandforgetgate() != 0) {
    total_size += 2 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LSTMParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LSTMParams*>(
      &from));
}

void LSTMParams::MergeFrom(const LSTMParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LSTMParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_cellclipthreshold = from._internal_cellclipthreshold();
  uint32_t raw_cellclipthreshold;
  memcpy(&raw_cellclipthreshold, &tmp_cellclipthreshold, sizeof(tmp_cellclipthreshold));
  if (raw_cellclipthreshold != 0) {
    _internal_set_cellclipthreshold(from._internal_cellclipthreshold());
  }
  if (from._internal_sequenceoutput() != 0) {
    _internal_set_sequenceoutput(from._internal_sequenceoutput());
  }
  if (from._internal_hasbiasvectors() != 0) {
    _internal_set_hasbiasvectors(from._internal_hasbiasvectors());
  }
  if (from._internal_forgetbias() != 0) {
    _internal_set_forgetbias(from._internal_forgetbias());
  }
  if (from._internal_haspeepholevectors() != 0) {
    _internal_set_haspeepholevectors(from._internal_haspeepholevectors());
  }
  if (from._internal_coupledinputandforgetgate() != 0) {
    _internal_set_coupledinputandforgetgate(from._internal_coupledinputandforgetgate());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LSTMParams::CopyFrom(const LSTMParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LSTMParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LSTMParams::IsInitialized() const {
  return true;
}

void LSTMParams::InternalSwap(LSTMParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LSTMParams, coupledinputandforgetgate_)
      + sizeof(LSTMParams::coupledinputandforgetgate_)
      - PROTOBUF_FIELD_OFFSET(LSTMParams, cellclipthreshold_)>(
          reinterpret_cast<char*>(&cellclipthreshold_),
          reinterpret_cast<char*>(&other->cellclipthreshold_));
}

std::string LSTMParams::GetTypeName() const {
  return "CoreML.Specification.LSTMParams";
}


// ===================================================================

class LSTMWeightParams::_Internal {
 public:
  static const ::CoreML::Specification::WeightParams& inputgateweightmatrix(const LSTMWeightParams* msg);
  static const ::CoreML::Specification::WeightParams& forgetgateweightmatrix(const LSTMWeightParams* msg);
  static const ::CoreML::Specification::WeightParams& blockinputweightmatrix(const LSTMWeightParams* msg);
  static const ::CoreML::Specification::WeightParams& outputgateweightmatrix(const LSTMWeightParams* msg);
  static const ::CoreML::Specification::WeightParams& inputgaterecursionmatrix(const LSTMWeightParams* msg);
  static const ::CoreML::Specification::WeightParams& forgetgaterecursionmatrix(const LSTMWeightParams* msg);
  static const ::CoreML::Specification::WeightParams& blockinputrecursionmatrix(const LSTMWeightParams* msg);
  static const ::CoreML::Specification::WeightParams& outputgaterecursionmatrix(const LSTMWeightParams* msg);
  static const ::CoreML::Specification::WeightParams& inputgatebiasvector(const LSTMWeightParams* msg);
  static const ::CoreML::Specification::WeightParams& forgetgatebiasvector(const LSTMWeightParams* msg);
  static const ::CoreML::Specification::WeightParams& blockinputbiasvector(const LSTMWeightParams* msg);
  static const ::CoreML::Specification::WeightParams& outputgatebiasvector(const LSTMWeightParams* msg);
  static const ::CoreML::Specification::WeightParams& inputgatepeepholevector(const LSTMWeightParams* msg);
  static const ::CoreML::Specification::WeightParams& forgetgatepeepholevector(const LSTMWeightParams* msg);
  static const ::CoreML::Specification::WeightParams& outputgatepeepholevector(const LSTMWeightParams* msg);
};

const ::CoreML::Specification::WeightParams&
LSTMWeightParams::_Internal::inputgateweightmatrix(const LSTMWeightParams* msg) {
  return *msg->inputgateweightmatrix_;
}
const ::CoreML::Specification::WeightParams&
LSTMWeightParams::_Internal::forgetgateweightmatrix(const LSTMWeightParams* msg) {
  return *msg->forgetgateweightmatrix_;
}
const ::CoreML::Specification::WeightParams&
LSTMWeightParams::_Internal::blockinputweightmatrix(const LSTMWeightParams* msg) {
  return *msg->blockinputweightmatrix_;
}
const ::CoreML::Specification::WeightParams&
LSTMWeightParams::_Internal::outputgateweightmatrix(const LSTMWeightParams* msg) {
  return *msg->outputgateweightmatrix_;
}
const ::CoreML::Specification::WeightParams&
LSTMWeightParams::_Internal::inputgaterecursionmatrix(const LSTMWeightParams* msg) {
  return *msg->inputgaterecursionmatrix_;
}
const ::CoreML::Specification::WeightParams&
LSTMWeightParams::_Internal::forgetgaterecursionmatrix(const LSTMWeightParams* msg) {
  return *msg->forgetgaterecursionmatrix_;
}
const ::CoreML::Specification::WeightParams&
LSTMWeightParams::_Internal::blockinputrecursionmatrix(const LSTMWeightParams* msg) {
  return *msg->blockinputrecursionmatrix_;
}
const ::CoreML::Specification::WeightParams&
LSTMWeightParams::_Internal::outputgaterecursionmatrix(const LSTMWeightParams* msg) {
  return *msg->outputgaterecursionmatrix_;
}
const ::CoreML::Specification::WeightParams&
LSTMWeightParams::_Internal::inputgatebiasvector(const LSTMWeightParams* msg) {
  return *msg->inputgatebiasvector_;
}
const ::CoreML::Specification::WeightParams&
LSTMWeightParams::_Internal::forgetgatebiasvector(const LSTMWeightParams* msg) {
  return *msg->forgetgatebiasvector_;
}
const ::CoreML::Specification::WeightParams&
LSTMWeightParams::_Internal::blockinputbiasvector(const LSTMWeightParams* msg) {
  return *msg->blockinputbiasvector_;
}
const ::CoreML::Specification::WeightParams&
LSTMWeightParams::_Internal::outputgatebiasvector(const LSTMWeightParams* msg) {
  return *msg->outputgatebiasvector_;
}
const ::CoreML::Specification::WeightParams&
LSTMWeightParams::_Internal::inputgatepeepholevector(const LSTMWeightParams* msg) {
  return *msg->inputgatepeepholevector_;
}
const ::CoreML::Specification::WeightParams&
LSTMWeightParams::_Internal::forgetgatepeepholevector(const LSTMWeightParams* msg) {
  return *msg->forgetgatepeepholevector_;
}
const ::CoreML::Specification::WeightParams&
LSTMWeightParams::_Internal::outputgatepeepholevector(const LSTMWeightParams* msg) {
  return *msg->outputgatepeepholevector_;
}
LSTMWeightParams::LSTMWeightParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LSTMWeightParams)
}
LSTMWeightParams::LSTMWeightParams(const LSTMWeightParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_inputgateweightmatrix()) {
    inputgateweightmatrix_ = new ::CoreML::Specification::WeightParams(*from.inputgateweightmatrix_);
  } else {
    inputgateweightmatrix_ = nullptr;
  }
  if (from._internal_has_forgetgateweightmatrix()) {
    forgetgateweightmatrix_ = new ::CoreML::Specification::WeightParams(*from.forgetgateweightmatrix_);
  } else {
    forgetgateweightmatrix_ = nullptr;
  }
  if (from._internal_has_blockinputweightmatrix()) {
    blockinputweightmatrix_ = new ::CoreML::Specification::WeightParams(*from.blockinputweightmatrix_);
  } else {
    blockinputweightmatrix_ = nullptr;
  }
  if (from._internal_has_outputgateweightmatrix()) {
    outputgateweightmatrix_ = new ::CoreML::Specification::WeightParams(*from.outputgateweightmatrix_);
  } else {
    outputgateweightmatrix_ = nullptr;
  }
  if (from._internal_has_inputgaterecursionmatrix()) {
    inputgaterecursionmatrix_ = new ::CoreML::Specification::WeightParams(*from.inputgaterecursionmatrix_);
  } else {
    inputgaterecursionmatrix_ = nullptr;
  }
  if (from._internal_has_forgetgaterecursionmatrix()) {
    forgetgaterecursionmatrix_ = new ::CoreML::Specification::WeightParams(*from.forgetgaterecursionmatrix_);
  } else {
    forgetgaterecursionmatrix_ = nullptr;
  }
  if (from._internal_has_blockinputrecursionmatrix()) {
    blockinputrecursionmatrix_ = new ::CoreML::Specification::WeightParams(*from.blockinputrecursionmatrix_);
  } else {
    blockinputrecursionmatrix_ = nullptr;
  }
  if (from._internal_has_outputgaterecursionmatrix()) {
    outputgaterecursionmatrix_ = new ::CoreML::Specification::WeightParams(*from.outputgaterecursionmatrix_);
  } else {
    outputgaterecursionmatrix_ = nullptr;
  }
  if (from._internal_has_inputgatebiasvector()) {
    inputgatebiasvector_ = new ::CoreML::Specification::WeightParams(*from.inputgatebiasvector_);
  } else {
    inputgatebiasvector_ = nullptr;
  }
  if (from._internal_has_forgetgatebiasvector()) {
    forgetgatebiasvector_ = new ::CoreML::Specification::WeightParams(*from.forgetgatebiasvector_);
  } else {
    forgetgatebiasvector_ = nullptr;
  }
  if (from._internal_has_blockinputbiasvector()) {
    blockinputbiasvector_ = new ::CoreML::Specification::WeightParams(*from.blockinputbiasvector_);
  } else {
    blockinputbiasvector_ = nullptr;
  }
  if (from._internal_has_outputgatebiasvector()) {
    outputgatebiasvector_ = new ::CoreML::Specification::WeightParams(*from.outputgatebiasvector_);
  } else {
    outputgatebiasvector_ = nullptr;
  }
  if (from._internal_has_inputgatepeepholevector()) {
    inputgatepeepholevector_ = new ::CoreML::Specification::WeightParams(*from.inputgatepeepholevector_);
  } else {
    inputgatepeepholevector_ = nullptr;
  }
  if (from._internal_has_forgetgatepeepholevector()) {
    forgetgatepeepholevector_ = new ::CoreML::Specification::WeightParams(*from.forgetgatepeepholevector_);
  } else {
    forgetgatepeepholevector_ = nullptr;
  }
  if (from._internal_has_outputgatepeepholevector()) {
    outputgatepeepholevector_ = new ::CoreML::Specification::WeightParams(*from.outputgatepeepholevector_);
  } else {
    outputgatepeepholevector_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LSTMWeightParams)
}

inline void LSTMWeightParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&inputgateweightmatrix_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&outputgatepeepholevector_) -
    reinterpret_cast<char*>(&inputgateweightmatrix_)) + sizeof(outputgatepeepholevector_));
}

LSTMWeightParams::~LSTMWeightParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LSTMWeightParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LSTMWeightParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete inputgateweightmatrix_;
  if (this != internal_default_instance()) delete forgetgateweightmatrix_;
  if (this != internal_default_instance()) delete blockinputweightmatrix_;
  if (this != internal_default_instance()) delete outputgateweightmatrix_;
  if (this != internal_default_instance()) delete inputgaterecursionmatrix_;
  if (this != internal_default_instance()) delete forgetgaterecursionmatrix_;
  if (this != internal_default_instance()) delete blockinputrecursionmatrix_;
  if (this != internal_default_instance()) delete outputgaterecursionmatrix_;
  if (this != internal_default_instance()) delete inputgatebiasvector_;
  if (this != internal_default_instance()) delete forgetgatebiasvector_;
  if (this != internal_default_instance()) delete blockinputbiasvector_;
  if (this != internal_default_instance()) delete outputgatebiasvector_;
  if (this != internal_default_instance()) delete inputgatepeepholevector_;
  if (this != internal_default_instance()) delete forgetgatepeepholevector_;
  if (this != internal_default_instance()) delete outputgatepeepholevector_;
}

void LSTMWeightParams::ArenaDtor(void* object) {
  LSTMWeightParams* _this = reinterpret_cast< LSTMWeightParams* >(object);
  (void)_this;
}
void LSTMWeightParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LSTMWeightParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LSTMWeightParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LSTMWeightParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && inputgateweightmatrix_ != nullptr) {
    delete inputgateweightmatrix_;
  }
  inputgateweightmatrix_ = nullptr;
  if (GetArenaForAllocation() == nullptr && forgetgateweightmatrix_ != nullptr) {
    delete forgetgateweightmatrix_;
  }
  forgetgateweightmatrix_ = nullptr;
  if (GetArenaForAllocation() == nullptr && blockinputweightmatrix_ != nullptr) {
    delete blockinputweightmatrix_;
  }
  blockinputweightmatrix_ = nullptr;
  if (GetArenaForAllocation() == nullptr && outputgateweightmatrix_ != nullptr) {
    delete outputgateweightmatrix_;
  }
  outputgateweightmatrix_ = nullptr;
  if (GetArenaForAllocation() == nullptr && inputgaterecursionmatrix_ != nullptr) {
    delete inputgaterecursionmatrix_;
  }
  inputgaterecursionmatrix_ = nullptr;
  if (GetArenaForAllocation() == nullptr && forgetgaterecursionmatrix_ != nullptr) {
    delete forgetgaterecursionmatrix_;
  }
  forgetgaterecursionmatrix_ = nullptr;
  if (GetArenaForAllocation() == nullptr && blockinputrecursionmatrix_ != nullptr) {
    delete blockinputrecursionmatrix_;
  }
  blockinputrecursionmatrix_ = nullptr;
  if (GetArenaForAllocation() == nullptr && outputgaterecursionmatrix_ != nullptr) {
    delete outputgaterecursionmatrix_;
  }
  outputgaterecursionmatrix_ = nullptr;
  if (GetArenaForAllocation() == nullptr && inputgatebiasvector_ != nullptr) {
    delete inputgatebiasvector_;
  }
  inputgatebiasvector_ = nullptr;
  if (GetArenaForAllocation() == nullptr && forgetgatebiasvector_ != nullptr) {
    delete forgetgatebiasvector_;
  }
  forgetgatebiasvector_ = nullptr;
  if (GetArenaForAllocation() == nullptr && blockinputbiasvector_ != nullptr) {
    delete blockinputbiasvector_;
  }
  blockinputbiasvector_ = nullptr;
  if (GetArenaForAllocation() == nullptr && outputgatebiasvector_ != nullptr) {
    delete outputgatebiasvector_;
  }
  outputgatebiasvector_ = nullptr;
  if (GetArenaForAllocation() == nullptr && inputgatepeepholevector_ != nullptr) {
    delete inputgatepeepholevector_;
  }
  inputgatepeepholevector_ = nullptr;
  if (GetArenaForAllocation() == nullptr && forgetgatepeepholevector_ != nullptr) {
    delete forgetgatepeepholevector_;
  }
  forgetgatepeepholevector_ = nullptr;
  if (GetArenaForAllocation() == nullptr && outputgatepeepholevector_ != nullptr) {
    delete outputgatepeepholevector_;
  }
  outputgatepeepholevector_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* LSTMWeightParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.WeightParams inputGateWeightMatrix = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_inputgateweightmatrix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams forgetGateWeightMatrix = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_forgetgateweightmatrix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams blockInputWeightMatrix = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_blockinputweightmatrix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams outputGateWeightMatrix = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_outputgateweightmatrix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams inputGateRecursionMatrix = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_inputgaterecursionmatrix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams forgetGateRecursionMatrix = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_forgetgaterecursionmatrix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams blockInputRecursionMatrix = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_blockinputrecursionmatrix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams outputGateRecursionMatrix = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_outputgaterecursionmatrix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams inputGateBiasVector = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_inputgatebiasvector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams forgetGateBiasVector = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_forgetgatebiasvector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams blockInputBiasVector = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_blockinputbiasvector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams outputGateBiasVector = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_outputgatebiasvector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams inputGatePeepholeVector = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_inputgatepeepholevector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams forgetGatePeepholeVector = 61;
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_forgetgatepeepholevector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams outputGatePeepholeVector = 62;
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_outputgatepeepholevector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LSTMWeightParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LSTMWeightParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.WeightParams inputGateWeightMatrix = 1;
  if (this->_internal_has_inputgateweightmatrix()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::inputgateweightmatrix(this), target, stream);
  }

  // .CoreML.Specification.WeightParams forgetGateWeightMatrix = 2;
  if (this->_internal_has_forgetgateweightmatrix()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::forgetgateweightmatrix(this), target, stream);
  }

  // .CoreML.Specification.WeightParams blockInputWeightMatrix = 3;
  if (this->_internal_has_blockinputweightmatrix()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::blockinputweightmatrix(this), target, stream);
  }

  // .CoreML.Specification.WeightParams outputGateWeightMatrix = 4;
  if (this->_internal_has_outputgateweightmatrix()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::outputgateweightmatrix(this), target, stream);
  }

  // .CoreML.Specification.WeightParams inputGateRecursionMatrix = 20;
  if (this->_internal_has_inputgaterecursionmatrix()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::inputgaterecursionmatrix(this), target, stream);
  }

  // .CoreML.Specification.WeightParams forgetGateRecursionMatrix = 21;
  if (this->_internal_has_forgetgaterecursionmatrix()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        21, _Internal::forgetgaterecursionmatrix(this), target, stream);
  }

  // .CoreML.Specification.WeightParams blockInputRecursionMatrix = 22;
  if (this->_internal_has_blockinputrecursionmatrix()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        22, _Internal::blockinputrecursionmatrix(this), target, stream);
  }

  // .CoreML.Specification.WeightParams outputGateRecursionMatrix = 23;
  if (this->_internal_has_outputgaterecursionmatrix()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        23, _Internal::outputgaterecursionmatrix(this), target, stream);
  }

  // .CoreML.Specification.WeightParams inputGateBiasVector = 40;
  if (this->_internal_has_inputgatebiasvector()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        40, _Internal::inputgatebiasvector(this), target, stream);
  }

  // .CoreML.Specification.WeightParams forgetGateBiasVector = 41;
  if (this->_internal_has_forgetgatebiasvector()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        41, _Internal::forgetgatebiasvector(this), target, stream);
  }

  // .CoreML.Specification.WeightParams blockInputBiasVector = 42;
  if (this->_internal_has_blockinputbiasvector()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        42, _Internal::blockinputbiasvector(this), target, stream);
  }

  // .CoreML.Specification.WeightParams outputGateBiasVector = 43;
  if (this->_internal_has_outputgatebiasvector()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        43, _Internal::outputgatebiasvector(this), target, stream);
  }

  // .CoreML.Specification.WeightParams inputGatePeepholeVector = 60;
  if (this->_internal_has_inputgatepeepholevector()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        60, _Internal::inputgatepeepholevector(this), target, stream);
  }

  // .CoreML.Specification.WeightParams forgetGatePeepholeVector = 61;
  if (this->_internal_has_forgetgatepeepholevector()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        61, _Internal::forgetgatepeepholevector(this), target, stream);
  }

  // .CoreML.Specification.WeightParams outputGatePeepholeVector = 62;
  if (this->_internal_has_outputgatepeepholevector()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        62, _Internal::outputgatepeepholevector(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LSTMWeightParams)
  return target;
}

size_t LSTMWeightParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LSTMWeightParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.WeightParams inputGateWeightMatrix = 1;
  if (this->_internal_has_inputgateweightmatrix()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *inputgateweightmatrix_);
  }

  // .CoreML.Specification.WeightParams forgetGateWeightMatrix = 2;
  if (this->_internal_has_forgetgateweightmatrix()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *forgetgateweightmatrix_);
  }

  // .CoreML.Specification.WeightParams blockInputWeightMatrix = 3;
  if (this->_internal_has_blockinputweightmatrix()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *blockinputweightmatrix_);
  }

  // .CoreML.Specification.WeightParams outputGateWeightMatrix = 4;
  if (this->_internal_has_outputgateweightmatrix()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *outputgateweightmatrix_);
  }

  // .CoreML.Specification.WeightParams inputGateRecursionMatrix = 20;
  if (this->_internal_has_inputgaterecursionmatrix()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *inputgaterecursionmatrix_);
  }

  // .CoreML.Specification.WeightParams forgetGateRecursionMatrix = 21;
  if (this->_internal_has_forgetgaterecursionmatrix()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *forgetgaterecursionmatrix_);
  }

  // .CoreML.Specification.WeightParams blockInputRecursionMatrix = 22;
  if (this->_internal_has_blockinputrecursionmatrix()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *blockinputrecursionmatrix_);
  }

  // .CoreML.Specification.WeightParams outputGateRecursionMatrix = 23;
  if (this->_internal_has_outputgaterecursionmatrix()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *outputgaterecursionmatrix_);
  }

  // .CoreML.Specification.WeightParams inputGateBiasVector = 40;
  if (this->_internal_has_inputgatebiasvector()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *inputgatebiasvector_);
  }

  // .CoreML.Specification.WeightParams forgetGateBiasVector = 41;
  if (this->_internal_has_forgetgatebiasvector()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *forgetgatebiasvector_);
  }

  // .CoreML.Specification.WeightParams blockInputBiasVector = 42;
  if (this->_internal_has_blockinputbiasvector()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *blockinputbiasvector_);
  }

  // .CoreML.Specification.WeightParams outputGateBiasVector = 43;
  if (this->_internal_has_outputgatebiasvector()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *outputgatebiasvector_);
  }

  // .CoreML.Specification.WeightParams inputGatePeepholeVector = 60;
  if (this->_internal_has_inputgatepeepholevector()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *inputgatepeepholevector_);
  }

  // .CoreML.Specification.WeightParams forgetGatePeepholeVector = 61;
  if (this->_internal_has_forgetgatepeepholevector()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *forgetgatepeepholevector_);
  }

  // .CoreML.Specification.WeightParams outputGatePeepholeVector = 62;
  if (this->_internal_has_outputgatepeepholevector()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *outputgatepeepholevector_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LSTMWeightParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LSTMWeightParams*>(
      &from));
}

void LSTMWeightParams::MergeFrom(const LSTMWeightParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LSTMWeightParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_inputgateweightmatrix()) {
    _internal_mutable_inputgateweightmatrix()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_inputgateweightmatrix());
  }
  if (from._internal_has_forgetgateweightmatrix()) {
    _internal_mutable_forgetgateweightmatrix()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_forgetgateweightmatrix());
  }
  if (from._internal_has_blockinputweightmatrix()) {
    _internal_mutable_blockinputweightmatrix()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_blockinputweightmatrix());
  }
  if (from._internal_has_outputgateweightmatrix()) {
    _internal_mutable_outputgateweightmatrix()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_outputgateweightmatrix());
  }
  if (from._internal_has_inputgaterecursionmatrix()) {
    _internal_mutable_inputgaterecursionmatrix()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_inputgaterecursionmatrix());
  }
  if (from._internal_has_forgetgaterecursionmatrix()) {
    _internal_mutable_forgetgaterecursionmatrix()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_forgetgaterecursionmatrix());
  }
  if (from._internal_has_blockinputrecursionmatrix()) {
    _internal_mutable_blockinputrecursionmatrix()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_blockinputrecursionmatrix());
  }
  if (from._internal_has_outputgaterecursionmatrix()) {
    _internal_mutable_outputgaterecursionmatrix()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_outputgaterecursionmatrix());
  }
  if (from._internal_has_inputgatebiasvector()) {
    _internal_mutable_inputgatebiasvector()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_inputgatebiasvector());
  }
  if (from._internal_has_forgetgatebiasvector()) {
    _internal_mutable_forgetgatebiasvector()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_forgetgatebiasvector());
  }
  if (from._internal_has_blockinputbiasvector()) {
    _internal_mutable_blockinputbiasvector()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_blockinputbiasvector());
  }
  if (from._internal_has_outputgatebiasvector()) {
    _internal_mutable_outputgatebiasvector()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_outputgatebiasvector());
  }
  if (from._internal_has_inputgatepeepholevector()) {
    _internal_mutable_inputgatepeepholevector()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_inputgatepeepholevector());
  }
  if (from._internal_has_forgetgatepeepholevector()) {
    _internal_mutable_forgetgatepeepholevector()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_forgetgatepeepholevector());
  }
  if (from._internal_has_outputgatepeepholevector()) {
    _internal_mutable_outputgatepeepholevector()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_outputgatepeepholevector());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LSTMWeightParams::CopyFrom(const LSTMWeightParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LSTMWeightParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LSTMWeightParams::IsInitialized() const {
  return true;
}

void LSTMWeightParams::InternalSwap(LSTMWeightParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LSTMWeightParams, outputgatepeepholevector_)
      + sizeof(LSTMWeightParams::outputgatepeepholevector_)
      - PROTOBUF_FIELD_OFFSET(LSTMWeightParams, inputgateweightmatrix_)>(
          reinterpret_cast<char*>(&inputgateweightmatrix_),
          reinterpret_cast<char*>(&other->inputgateweightmatrix_));
}

std::string LSTMWeightParams::GetTypeName() const {
  return "CoreML.Specification.LSTMWeightParams";
}


// ===================================================================

class UniDirectionalLSTMLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::LSTMParams& params(const UniDirectionalLSTMLayerParams* msg);
  static const ::CoreML::Specification::LSTMWeightParams& weightparams(const UniDirectionalLSTMLayerParams* msg);
};

const ::CoreML::Specification::LSTMParams&
UniDirectionalLSTMLayerParams::_Internal::params(const UniDirectionalLSTMLayerParams* msg) {
  return *msg->params_;
}
const ::CoreML::Specification::LSTMWeightParams&
UniDirectionalLSTMLayerParams::_Internal::weightparams(const UniDirectionalLSTMLayerParams* msg) {
  return *msg->weightparams_;
}
UniDirectionalLSTMLayerParams::UniDirectionalLSTMLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  activations_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.UniDirectionalLSTMLayerParams)
}
UniDirectionalLSTMLayerParams::UniDirectionalLSTMLayerParams(const UniDirectionalLSTMLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      activations_(from.activations_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_params()) {
    params_ = new ::CoreML::Specification::LSTMParams(*from.params_);
  } else {
    params_ = nullptr;
  }
  if (from._internal_has_weightparams()) {
    weightparams_ = new ::CoreML::Specification::LSTMWeightParams(*from.weightparams_);
  } else {
    weightparams_ = nullptr;
  }
  ::memcpy(&inputvectorsize_, &from.inputvectorsize_,
    static_cast<size_t>(reinterpret_cast<char*>(&reverseinput_) -
    reinterpret_cast<char*>(&inputvectorsize_)) + sizeof(reverseinput_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.UniDirectionalLSTMLayerParams)
}

inline void UniDirectionalLSTMLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&params_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reverseinput_) -
    reinterpret_cast<char*>(&params_)) + sizeof(reverseinput_));
}

UniDirectionalLSTMLayerParams::~UniDirectionalLSTMLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.UniDirectionalLSTMLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void UniDirectionalLSTMLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete params_;
  if (this != internal_default_instance()) delete weightparams_;
}

void UniDirectionalLSTMLayerParams::ArenaDtor(void* object) {
  UniDirectionalLSTMLayerParams* _this = reinterpret_cast< UniDirectionalLSTMLayerParams* >(object);
  (void)_this;
}
void UniDirectionalLSTMLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UniDirectionalLSTMLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UniDirectionalLSTMLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.UniDirectionalLSTMLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  activations_.Clear();
  if (GetArenaForAllocation() == nullptr && params_ != nullptr) {
    delete params_;
  }
  params_ = nullptr;
  if (GetArenaForAllocation() == nullptr && weightparams_ != nullptr) {
    delete weightparams_;
  }
  weightparams_ = nullptr;
  ::memset(&inputvectorsize_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reverseinput_) -
      reinterpret_cast<char*>(&inputvectorsize_)) + sizeof(reverseinput_));
  _internal_metadata_.Clear<std::string>();
}

const char* UniDirectionalLSTMLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 inputVectorSize = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          inputvectorsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 outputVectorSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          outputvectorsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.ActivationParams activations = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_activations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LSTMParams params = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_params(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LSTMWeightParams weightParams = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_weightparams(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reverseInput = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          reverseinput_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UniDirectionalLSTMLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.UniDirectionalLSTMLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 inputVectorSize = 1;
  if (this->_internal_inputvectorsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_inputvectorsize(), target);
  }

  // uint64 outputVectorSize = 2;
  if (this->_internal_outputvectorsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_outputvectorsize(), target);
  }

  // repeated .CoreML.Specification.ActivationParams activations = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_activations_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_activations(i), target, stream);
  }

  // .CoreML.Specification.LSTMParams params = 15;
  if (this->_internal_has_params()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        15, _Internal::params(this), target, stream);
  }

  // .CoreML.Specification.LSTMWeightParams weightParams = 20;
  if (this->_internal_has_weightparams()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::weightparams(this), target, stream);
  }

  // bool reverseInput = 100;
  if (this->_internal_reverseinput() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(100, this->_internal_reverseinput(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.UniDirectionalLSTMLayerParams)
  return target;
}

size_t UniDirectionalLSTMLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.UniDirectionalLSTMLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.ActivationParams activations = 10;
  total_size += 1UL * this->_internal_activations_size();
  for (const auto& msg : this->activations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .CoreML.Specification.LSTMParams params = 15;
  if (this->_internal_has_params()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *params_);
  }

  // .CoreML.Specification.LSTMWeightParams weightParams = 20;
  if (this->_internal_has_weightparams()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *weightparams_);
  }

  // uint64 inputVectorSize = 1;
  if (this->_internal_inputvectorsize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_inputvectorsize());
  }

  // uint64 outputVectorSize = 2;
  if (this->_internal_outputvectorsize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_outputvectorsize());
  }

  // bool reverseInput = 100;
  if (this->_internal_reverseinput() != 0) {
    total_size += 2 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UniDirectionalLSTMLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UniDirectionalLSTMLayerParams*>(
      &from));
}

void UniDirectionalLSTMLayerParams::MergeFrom(const UniDirectionalLSTMLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.UniDirectionalLSTMLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  activations_.MergeFrom(from.activations_);
  if (from._internal_has_params()) {
    _internal_mutable_params()->::CoreML::Specification::LSTMParams::MergeFrom(from._internal_params());
  }
  if (from._internal_has_weightparams()) {
    _internal_mutable_weightparams()->::CoreML::Specification::LSTMWeightParams::MergeFrom(from._internal_weightparams());
  }
  if (from._internal_inputvectorsize() != 0) {
    _internal_set_inputvectorsize(from._internal_inputvectorsize());
  }
  if (from._internal_outputvectorsize() != 0) {
    _internal_set_outputvectorsize(from._internal_outputvectorsize());
  }
  if (from._internal_reverseinput() != 0) {
    _internal_set_reverseinput(from._internal_reverseinput());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UniDirectionalLSTMLayerParams::CopyFrom(const UniDirectionalLSTMLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.UniDirectionalLSTMLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UniDirectionalLSTMLayerParams::IsInitialized() const {
  return true;
}

void UniDirectionalLSTMLayerParams::InternalSwap(UniDirectionalLSTMLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  activations_.InternalSwap(&other->activations_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UniDirectionalLSTMLayerParams, reverseinput_)
      + sizeof(UniDirectionalLSTMLayerParams::reverseinput_)
      - PROTOBUF_FIELD_OFFSET(UniDirectionalLSTMLayerParams, params_)>(
          reinterpret_cast<char*>(&params_),
          reinterpret_cast<char*>(&other->params_));
}

std::string UniDirectionalLSTMLayerParams::GetTypeName() const {
  return "CoreML.Specification.UniDirectionalLSTMLayerParams";
}


// ===================================================================

class BiDirectionalLSTMLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::LSTMParams& params(const BiDirectionalLSTMLayerParams* msg);
};

const ::CoreML::Specification::LSTMParams&
BiDirectionalLSTMLayerParams::_Internal::params(const BiDirectionalLSTMLayerParams* msg) {
  return *msg->params_;
}
BiDirectionalLSTMLayerParams::BiDirectionalLSTMLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  activationsforwardlstm_(arena),
  activationsbackwardlstm_(arena),
  weightparams_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.BiDirectionalLSTMLayerParams)
}
BiDirectionalLSTMLayerParams::BiDirectionalLSTMLayerParams(const BiDirectionalLSTMLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      activationsforwardlstm_(from.activationsforwardlstm_),
      activationsbackwardlstm_(from.activationsbackwardlstm_),
      weightparams_(from.weightparams_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_params()) {
    params_ = new ::CoreML::Specification::LSTMParams(*from.params_);
  } else {
    params_ = nullptr;
  }
  ::memcpy(&inputvectorsize_, &from.inputvectorsize_,
    static_cast<size_t>(reinterpret_cast<char*>(&outputvectorsize_) -
    reinterpret_cast<char*>(&inputvectorsize_)) + sizeof(outputvectorsize_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.BiDirectionalLSTMLayerParams)
}

inline void BiDirectionalLSTMLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&params_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&outputvectorsize_) -
    reinterpret_cast<char*>(&params_)) + sizeof(outputvectorsize_));
}

BiDirectionalLSTMLayerParams::~BiDirectionalLSTMLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.BiDirectionalLSTMLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BiDirectionalLSTMLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete params_;
}

void BiDirectionalLSTMLayerParams::ArenaDtor(void* object) {
  BiDirectionalLSTMLayerParams* _this = reinterpret_cast< BiDirectionalLSTMLayerParams* >(object);
  (void)_this;
}
void BiDirectionalLSTMLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BiDirectionalLSTMLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BiDirectionalLSTMLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.BiDirectionalLSTMLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  activationsforwardlstm_.Clear();
  activationsbackwardlstm_.Clear();
  weightparams_.Clear();
  if (GetArenaForAllocation() == nullptr && params_ != nullptr) {
    delete params_;
  }
  params_ = nullptr;
  ::memset(&inputvectorsize_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&outputvectorsize_) -
      reinterpret_cast<char*>(&inputvectorsize_)) + sizeof(outputvectorsize_));
  _internal_metadata_.Clear<std::string>();
}

const char* BiDirectionalLSTMLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 inputVectorSize = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          inputvectorsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 outputVectorSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          outputvectorsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.ActivationParams activationsForwardLSTM = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_activationsforwardlstm(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.ActivationParams activationsBackwardLSTM = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_activationsbackwardlstm(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.LSTMParams params = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_params(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.LSTMWeightParams weightParams = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_weightparams(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BiDirectionalLSTMLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.BiDirectionalLSTMLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 inputVectorSize = 1;
  if (this->_internal_inputvectorsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_inputvectorsize(), target);
  }

  // uint64 outputVectorSize = 2;
  if (this->_internal_outputvectorsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_outputvectorsize(), target);
  }

  // repeated .CoreML.Specification.ActivationParams activationsForwardLSTM = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_activationsforwardlstm_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_activationsforwardlstm(i), target, stream);
  }

  // repeated .CoreML.Specification.ActivationParams activationsBackwardLSTM = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_activationsbackwardlstm_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, this->_internal_activationsbackwardlstm(i), target, stream);
  }

  // .CoreML.Specification.LSTMParams params = 15;
  if (this->_internal_has_params()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        15, _Internal::params(this), target, stream);
  }

  // repeated .CoreML.Specification.LSTMWeightParams weightParams = 20;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_weightparams_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, this->_internal_weightparams(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.BiDirectionalLSTMLayerParams)
  return target;
}

size_t BiDirectionalLSTMLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.BiDirectionalLSTMLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.ActivationParams activationsForwardLSTM = 10;
  total_size += 1UL * this->_internal_activationsforwardlstm_size();
  for (const auto& msg : this->activationsforwardlstm_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CoreML.Specification.ActivationParams activationsBackwardLSTM = 11;
  total_size += 1UL * this->_internal_activationsbackwardlstm_size();
  for (const auto& msg : this->activationsbackwardlstm_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CoreML.Specification.LSTMWeightParams weightParams = 20;
  total_size += 2UL * this->_internal_weightparams_size();
  for (const auto& msg : this->weightparams_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .CoreML.Specification.LSTMParams params = 15;
  if (this->_internal_has_params()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *params_);
  }

  // uint64 inputVectorSize = 1;
  if (this->_internal_inputvectorsize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_inputvectorsize());
  }

  // uint64 outputVectorSize = 2;
  if (this->_internal_outputvectorsize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_outputvectorsize());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BiDirectionalLSTMLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BiDirectionalLSTMLayerParams*>(
      &from));
}

void BiDirectionalLSTMLayerParams::MergeFrom(const BiDirectionalLSTMLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.BiDirectionalLSTMLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  activationsforwardlstm_.MergeFrom(from.activationsforwardlstm_);
  activationsbackwardlstm_.MergeFrom(from.activationsbackwardlstm_);
  weightparams_.MergeFrom(from.weightparams_);
  if (from._internal_has_params()) {
    _internal_mutable_params()->::CoreML::Specification::LSTMParams::MergeFrom(from._internal_params());
  }
  if (from._internal_inputvectorsize() != 0) {
    _internal_set_inputvectorsize(from._internal_inputvectorsize());
  }
  if (from._internal_outputvectorsize() != 0) {
    _internal_set_outputvectorsize(from._internal_outputvectorsize());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BiDirectionalLSTMLayerParams::CopyFrom(const BiDirectionalLSTMLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.BiDirectionalLSTMLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BiDirectionalLSTMLayerParams::IsInitialized() const {
  return true;
}

void BiDirectionalLSTMLayerParams::InternalSwap(BiDirectionalLSTMLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  activationsforwardlstm_.InternalSwap(&other->activationsforwardlstm_);
  activationsbackwardlstm_.InternalSwap(&other->activationsbackwardlstm_);
  weightparams_.InternalSwap(&other->weightparams_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BiDirectionalLSTMLayerParams, outputvectorsize_)
      + sizeof(BiDirectionalLSTMLayerParams::outputvectorsize_)
      - PROTOBUF_FIELD_OFFSET(BiDirectionalLSTMLayerParams, params_)>(
          reinterpret_cast<char*>(&params_),
          reinterpret_cast<char*>(&other->params_));
}

std::string BiDirectionalLSTMLayerParams::GetTypeName() const {
  return "CoreML.Specification.BiDirectionalLSTMLayerParams";
}


// ===================================================================

class CustomLayerParams_CustomLayerParamValue::_Internal {
 public:
};

CustomLayerParams_CustomLayerParamValue::CustomLayerParams_CustomLayerParamValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.CustomLayerParams.CustomLayerParamValue)
}
CustomLayerParams_CustomLayerParamValue::CustomLayerParams_CustomLayerParamValue(const CustomLayerParams_CustomLayerParamValue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_value();
  switch (from.value_case()) {
    case kDoubleValue: {
      _internal_set_doublevalue(from._internal_doublevalue());
      break;
    }
    case kStringValue: {
      _internal_set_stringvalue(from._internal_stringvalue());
      break;
    }
    case kIntValue: {
      _internal_set_intvalue(from._internal_intvalue());
      break;
    }
    case kLongValue: {
      _internal_set_longvalue(from._internal_longvalue());
      break;
    }
    case kBoolValue: {
      _internal_set_boolvalue(from._internal_boolvalue());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.CustomLayerParams.CustomLayerParamValue)
}

inline void CustomLayerParams_CustomLayerParamValue::SharedCtor() {
clear_has_value();
}

CustomLayerParams_CustomLayerParamValue::~CustomLayerParams_CustomLayerParamValue() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.CustomLayerParams.CustomLayerParamValue)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CustomLayerParams_CustomLayerParamValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_value()) {
    clear_value();
  }
}

void CustomLayerParams_CustomLayerParamValue::ArenaDtor(void* object) {
  CustomLayerParams_CustomLayerParamValue* _this = reinterpret_cast< CustomLayerParams_CustomLayerParamValue* >(object);
  (void)_this;
}
void CustomLayerParams_CustomLayerParamValue::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CustomLayerParams_CustomLayerParamValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CustomLayerParams_CustomLayerParamValue::clear_value() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.CustomLayerParams.CustomLayerParamValue)
  switch (value_case()) {
    case kDoubleValue: {
      // No need to clear
      break;
    }
    case kStringValue: {
      value_.stringvalue_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
      break;
    }
    case kIntValue: {
      // No need to clear
      break;
    }
    case kLongValue: {
      // No need to clear
      break;
    }
    case kBoolValue: {
      // No need to clear
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = VALUE_NOT_SET;
}


void CustomLayerParams_CustomLayerParamValue::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.CustomLayerParams.CustomLayerParamValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_value();
  _internal_metadata_.Clear<std::string>();
}

const char* CustomLayerParams_CustomLayerParamValue::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double doubleValue = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _internal_set_doublevalue(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string stringValue = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_stringvalue();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 intValue = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _internal_set_intvalue(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 longValue = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _internal_set_longvalue(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool boolValue = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _internal_set_boolvalue(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CustomLayerParams_CustomLayerParamValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.CustomLayerParams.CustomLayerParamValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double doubleValue = 10;
  if (_internal_has_doublevalue()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(10, this->_internal_doublevalue(), target);
  }

  // string stringValue = 20;
  if (_internal_has_stringvalue()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stringvalue().data(), static_cast<int>(this->_internal_stringvalue().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.CustomLayerParams.CustomLayerParamValue.stringValue");
    target = stream->WriteStringMaybeAliased(
        20, this->_internal_stringvalue(), target);
  }

  // int32 intValue = 30;
  if (_internal_has_intvalue()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(30, this->_internal_intvalue(), target);
  }

  // int64 longValue = 40;
  if (_internal_has_longvalue()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(40, this->_internal_longvalue(), target);
  }

  // bool boolValue = 50;
  if (_internal_has_boolvalue()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(50, this->_internal_boolvalue(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.CustomLayerParams.CustomLayerParamValue)
  return target;
}

size_t CustomLayerParams_CustomLayerParamValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.CustomLayerParams.CustomLayerParamValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (value_case()) {
    // double doubleValue = 10;
    case kDoubleValue: {
      total_size += 1 + 8;
      break;
    }
    // string stringValue = 20;
    case kStringValue: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_stringvalue());
      break;
    }
    // int32 intValue = 30;
    case kIntValue: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_intvalue());
      break;
    }
    // int64 longValue = 40;
    case kLongValue: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_longvalue());
      break;
    }
    // bool boolValue = 50;
    case kBoolValue: {
      total_size += 2 + 1;
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CustomLayerParams_CustomLayerParamValue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CustomLayerParams_CustomLayerParamValue*>(
      &from));
}

void CustomLayerParams_CustomLayerParamValue::MergeFrom(const CustomLayerParams_CustomLayerParamValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.CustomLayerParams.CustomLayerParamValue)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.value_case()) {
    case kDoubleValue: {
      _internal_set_doublevalue(from._internal_doublevalue());
      break;
    }
    case kStringValue: {
      _internal_set_stringvalue(from._internal_stringvalue());
      break;
    }
    case kIntValue: {
      _internal_set_intvalue(from._internal_intvalue());
      break;
    }
    case kLongValue: {
      _internal_set_longvalue(from._internal_longvalue());
      break;
    }
    case kBoolValue: {
      _internal_set_boolvalue(from._internal_boolvalue());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CustomLayerParams_CustomLayerParamValue::CopyFrom(const CustomLayerParams_CustomLayerParamValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.CustomLayerParams.CustomLayerParamValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CustomLayerParams_CustomLayerParamValue::IsInitialized() const {
  return true;
}

void CustomLayerParams_CustomLayerParamValue::InternalSwap(CustomLayerParams_CustomLayerParamValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(value_, other->value_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string CustomLayerParams_CustomLayerParamValue::GetTypeName() const {
  return "CoreML.Specification.CustomLayerParams.CustomLayerParamValue";
}


// ===================================================================

CustomLayerParams_ParametersEntry_DoNotUse::CustomLayerParams_ParametersEntry_DoNotUse() {}
CustomLayerParams_ParametersEntry_DoNotUse::CustomLayerParams_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void CustomLayerParams_ParametersEntry_DoNotUse::MergeFrom(const CustomLayerParams_ParametersEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class CustomLayerParams::_Internal {
 public:
};

CustomLayerParams::CustomLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  weights_(arena),
  parameters_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.CustomLayerParams)
}
CustomLayerParams::CustomLayerParams(const CustomLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      weights_(from.weights_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  parameters_.MergeFrom(from.parameters_);
  classname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    classname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_classname().empty()) {
    classname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_classname(), 
      GetArenaForAllocation());
  }
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_description(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.CustomLayerParams)
}

inline void CustomLayerParams::SharedCtor() {
classname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  classname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CustomLayerParams::~CustomLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.CustomLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CustomLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  classname_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CustomLayerParams::ArenaDtor(void* object) {
  CustomLayerParams* _this = reinterpret_cast< CustomLayerParams* >(object);
  (void)_this;
}
void CustomLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CustomLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CustomLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.CustomLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  weights_.Clear();
  parameters_.Clear();
  classname_.ClearToEmpty();
  description_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* CustomLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string className = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_classname();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.WeightParams weights = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_weights(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, .CoreML.Specification.CustomLayerParams.CustomLayerParamValue> parameters = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(&parameters_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<242>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string description = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_description();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CustomLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.CustomLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string className = 10;
  if (!this->_internal_classname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_classname().data(), static_cast<int>(this->_internal_classname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.CustomLayerParams.className");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_classname(), target);
  }

  // repeated .CoreML.Specification.WeightParams weights = 20;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_weights_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, this->_internal_weights(i), target, stream);
  }

  // map<string, .CoreML.Specification.CustomLayerParams.CustomLayerParamValue> parameters = 30;
  if (!this->_internal_parameters().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::CustomLayerParams_CustomLayerParamValue >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.CustomLayerParams.ParametersEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_parameters().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_parameters().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::CustomLayerParams_CustomLayerParamValue >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::CustomLayerParams_CustomLayerParamValue >::const_iterator
          it = this->_internal_parameters().begin();
          it != this->_internal_parameters().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = CustomLayerParams_ParametersEntry_DoNotUse::Funcs::InternalSerialize(30, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::CustomLayerParams_CustomLayerParamValue >::const_iterator
          it = this->_internal_parameters().begin();
          it != this->_internal_parameters().end(); ++it) {
        target = CustomLayerParams_ParametersEntry_DoNotUse::Funcs::InternalSerialize(30, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  // string description = 40;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.CustomLayerParams.description");
    target = stream->WriteStringMaybeAliased(
        40, this->_internal_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.CustomLayerParams)
  return target;
}

size_t CustomLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.CustomLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.WeightParams weights = 20;
  total_size += 2UL * this->_internal_weights_size();
  for (const auto& msg : this->weights_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, .CoreML.Specification.CustomLayerParams.CustomLayerParamValue> parameters = 30;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_parameters_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CoreML::Specification::CustomLayerParams_CustomLayerParamValue >::const_iterator
      it = this->_internal_parameters().begin();
      it != this->_internal_parameters().end(); ++it) {
    total_size += CustomLayerParams_ParametersEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string className = 10;
  if (!this->_internal_classname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_classname());
  }

  // string description = 40;
  if (!this->_internal_description().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CustomLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CustomLayerParams*>(
      &from));
}

void CustomLayerParams::MergeFrom(const CustomLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.CustomLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  weights_.MergeFrom(from.weights_);
  parameters_.MergeFrom(from.parameters_);
  if (!from._internal_classname().empty()) {
    _internal_set_classname(from._internal_classname());
  }
  if (!from._internal_description().empty()) {
    _internal_set_description(from._internal_description());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CustomLayerParams::CopyFrom(const CustomLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.CustomLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CustomLayerParams::IsInitialized() const {
  return true;
}

void CustomLayerParams::InternalSwap(CustomLayerParams* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  weights_.InternalSwap(&other->weights_);
  parameters_.InternalSwap(&other->parameters_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &classname_, lhs_arena,
      &other->classname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &description_, lhs_arena,
      &other->description_, rhs_arena
  );
}

std::string CustomLayerParams::GetTypeName() const {
  return "CoreML.Specification.CustomLayerParams";
}


// ===================================================================

class TransposeLayerParams::_Internal {
 public:
};

TransposeLayerParams::TransposeLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  axes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.TransposeLayerParams)
}
TransposeLayerParams::TransposeLayerParams(const TransposeLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      axes_(from.axes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.TransposeLayerParams)
}

inline void TransposeLayerParams::SharedCtor() {
}

TransposeLayerParams::~TransposeLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.TransposeLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TransposeLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TransposeLayerParams::ArenaDtor(void* object) {
  TransposeLayerParams* _this = reinterpret_cast< TransposeLayerParams* >(object);
  (void)_this;
}
void TransposeLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TransposeLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TransposeLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.TransposeLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axes_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TransposeLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 axes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_axes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_axes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TransposeLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.TransposeLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 axes = 1;
  {
    int byte_size = _axes_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          1, _internal_axes(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.TransposeLayerParams)
  return target;
}

size_t TransposeLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.TransposeLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 axes = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->axes_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _axes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TransposeLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TransposeLayerParams*>(
      &from));
}

void TransposeLayerParams::MergeFrom(const TransposeLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.TransposeLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  axes_.MergeFrom(from.axes_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TransposeLayerParams::CopyFrom(const TransposeLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.TransposeLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransposeLayerParams::IsInitialized() const {
  return true;
}

void TransposeLayerParams::InternalSwap(TransposeLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  axes_.InternalSwap(&other->axes_);
}

std::string TransposeLayerParams::GetTypeName() const {
  return "CoreML.Specification.TransposeLayerParams";
}


// ===================================================================

class BatchedMatMulLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::WeightParams& weights(const BatchedMatMulLayerParams* msg);
  static const ::CoreML::Specification::WeightParams& bias(const BatchedMatMulLayerParams* msg);
};

const ::CoreML::Specification::WeightParams&
BatchedMatMulLayerParams::_Internal::weights(const BatchedMatMulLayerParams* msg) {
  return *msg->weights_;
}
const ::CoreML::Specification::WeightParams&
BatchedMatMulLayerParams::_Internal::bias(const BatchedMatMulLayerParams* msg) {
  return *msg->bias_;
}
BatchedMatMulLayerParams::BatchedMatMulLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.BatchedMatMulLayerParams)
}
BatchedMatMulLayerParams::BatchedMatMulLayerParams(const BatchedMatMulLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_weights()) {
    weights_ = new ::CoreML::Specification::WeightParams(*from.weights_);
  } else {
    weights_ = nullptr;
  }
  if (from._internal_has_bias()) {
    bias_ = new ::CoreML::Specification::WeightParams(*from.bias_);
  } else {
    bias_ = nullptr;
  }
  ::memcpy(&weightmatrixfirstdimension_, &from.weightmatrixfirstdimension_,
    static_cast<size_t>(reinterpret_cast<char*>(&int8dynamicquantize_) -
    reinterpret_cast<char*>(&weightmatrixfirstdimension_)) + sizeof(int8dynamicquantize_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.BatchedMatMulLayerParams)
}

inline void BatchedMatMulLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&weights_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&int8dynamicquantize_) -
    reinterpret_cast<char*>(&weights_)) + sizeof(int8dynamicquantize_));
}

BatchedMatMulLayerParams::~BatchedMatMulLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.BatchedMatMulLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BatchedMatMulLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete weights_;
  if (this != internal_default_instance()) delete bias_;
}

void BatchedMatMulLayerParams::ArenaDtor(void* object) {
  BatchedMatMulLayerParams* _this = reinterpret_cast< BatchedMatMulLayerParams* >(object);
  (void)_this;
}
void BatchedMatMulLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BatchedMatMulLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BatchedMatMulLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.BatchedMatMulLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && weights_ != nullptr) {
    delete weights_;
  }
  weights_ = nullptr;
  if (GetArenaForAllocation() == nullptr && bias_ != nullptr) {
    delete bias_;
  }
  bias_ = nullptr;
  ::memset(&weightmatrixfirstdimension_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&int8dynamicquantize_) -
      reinterpret_cast<char*>(&weightmatrixfirstdimension_)) + sizeof(int8dynamicquantize_));
  _internal_metadata_.Clear<std::string>();
}

const char* BatchedMatMulLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool transposeA = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          transposea_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool transposeB = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          transposeb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 weightMatrixFirstDimension = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          weightmatrixfirstdimension_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 weightMatrixSecondDimension = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          weightmatrixseconddimension_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hasBias = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          hasbias_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams weights = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_weights(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams bias = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_bias(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool int8DynamicQuantize = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          int8dynamicquantize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchedMatMulLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.BatchedMatMulLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool transposeA = 1;
  if (this->_internal_transposea() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_transposea(), target);
  }

  // bool transposeB = 2;
  if (this->_internal_transposeb() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_transposeb(), target);
  }

  // uint64 weightMatrixFirstDimension = 5;
  if (this->_internal_weightmatrixfirstdimension() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_weightmatrixfirstdimension(), target);
  }

  // uint64 weightMatrixSecondDimension = 6;
  if (this->_internal_weightmatrixseconddimension() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_weightmatrixseconddimension(), target);
  }

  // bool hasBias = 7;
  if (this->_internal_hasbias() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_hasbias(), target);
  }

  // .CoreML.Specification.WeightParams weights = 8;
  if (this->_internal_has_weights()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::weights(this), target, stream);
  }

  // .CoreML.Specification.WeightParams bias = 9;
  if (this->_internal_has_bias()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::bias(this), target, stream);
  }

  // bool int8DynamicQuantize = 10;
  if (this->_internal_int8dynamicquantize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_int8dynamicquantize(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.BatchedMatMulLayerParams)
  return target;
}

size_t BatchedMatMulLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.BatchedMatMulLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.WeightParams weights = 8;
  if (this->_internal_has_weights()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *weights_);
  }

  // .CoreML.Specification.WeightParams bias = 9;
  if (this->_internal_has_bias()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bias_);
  }

  // uint64 weightMatrixFirstDimension = 5;
  if (this->_internal_weightmatrixfirstdimension() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_weightmatrixfirstdimension());
  }

  // uint64 weightMatrixSecondDimension = 6;
  if (this->_internal_weightmatrixseconddimension() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_weightmatrixseconddimension());
  }

  // bool transposeA = 1;
  if (this->_internal_transposea() != 0) {
    total_size += 1 + 1;
  }

  // bool transposeB = 2;
  if (this->_internal_transposeb() != 0) {
    total_size += 1 + 1;
  }

  // bool hasBias = 7;
  if (this->_internal_hasbias() != 0) {
    total_size += 1 + 1;
  }

  // bool int8DynamicQuantize = 10;
  if (this->_internal_int8dynamicquantize() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BatchedMatMulLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BatchedMatMulLayerParams*>(
      &from));
}

void BatchedMatMulLayerParams::MergeFrom(const BatchedMatMulLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.BatchedMatMulLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_weights()) {
    _internal_mutable_weights()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_weights());
  }
  if (from._internal_has_bias()) {
    _internal_mutable_bias()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_bias());
  }
  if (from._internal_weightmatrixfirstdimension() != 0) {
    _internal_set_weightmatrixfirstdimension(from._internal_weightmatrixfirstdimension());
  }
  if (from._internal_weightmatrixseconddimension() != 0) {
    _internal_set_weightmatrixseconddimension(from._internal_weightmatrixseconddimension());
  }
  if (from._internal_transposea() != 0) {
    _internal_set_transposea(from._internal_transposea());
  }
  if (from._internal_transposeb() != 0) {
    _internal_set_transposeb(from._internal_transposeb());
  }
  if (from._internal_hasbias() != 0) {
    _internal_set_hasbias(from._internal_hasbias());
  }
  if (from._internal_int8dynamicquantize() != 0) {
    _internal_set_int8dynamicquantize(from._internal_int8dynamicquantize());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BatchedMatMulLayerParams::CopyFrom(const BatchedMatMulLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.BatchedMatMulLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchedMatMulLayerParams::IsInitialized() const {
  return true;
}

void BatchedMatMulLayerParams::InternalSwap(BatchedMatMulLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BatchedMatMulLayerParams, int8dynamicquantize_)
      + sizeof(BatchedMatMulLayerParams::int8dynamicquantize_)
      - PROTOBUF_FIELD_OFFSET(BatchedMatMulLayerParams, weights_)>(
          reinterpret_cast<char*>(&weights_),
          reinterpret_cast<char*>(&other->weights_));
}

std::string BatchedMatMulLayerParams::GetTypeName() const {
  return "CoreML.Specification.BatchedMatMulLayerParams";
}


// ===================================================================

class ConcatNDLayerParams::_Internal {
 public:
};

ConcatNDLayerParams::ConcatNDLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ConcatNDLayerParams)
}
ConcatNDLayerParams::ConcatNDLayerParams(const ConcatNDLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&axis_, &from.axis_,
    static_cast<size_t>(reinterpret_cast<char*>(&interleave_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(interleave_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ConcatNDLayerParams)
}

inline void ConcatNDLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&axis_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&interleave_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(interleave_));
}

ConcatNDLayerParams::~ConcatNDLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ConcatNDLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ConcatNDLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ConcatNDLayerParams::ArenaDtor(void* object) {
  ConcatNDLayerParams* _this = reinterpret_cast< ConcatNDLayerParams* >(object);
  (void)_this;
}
void ConcatNDLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConcatNDLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConcatNDLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ConcatNDLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&axis_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&interleave_) -
      reinterpret_cast<char*>(&axis_)) + sizeof(interleave_));
  _internal_metadata_.Clear<std::string>();
}

const char* ConcatNDLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 axis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool interleave = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          interleave_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConcatNDLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ConcatNDLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_axis(), target);
  }

  // bool interleave = 2;
  if (this->_internal_interleave() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_interleave(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ConcatNDLayerParams)
  return target;
}

size_t ConcatNDLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ConcatNDLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_axis());
  }

  // bool interleave = 2;
  if (this->_internal_interleave() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConcatNDLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ConcatNDLayerParams*>(
      &from));
}

void ConcatNDLayerParams::MergeFrom(const ConcatNDLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ConcatNDLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  if (from._internal_interleave() != 0) {
    _internal_set_interleave(from._internal_interleave());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConcatNDLayerParams::CopyFrom(const ConcatNDLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ConcatNDLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConcatNDLayerParams::IsInitialized() const {
  return true;
}

void ConcatNDLayerParams::InternalSwap(ConcatNDLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConcatNDLayerParams, interleave_)
      + sizeof(ConcatNDLayerParams::interleave_)
      - PROTOBUF_FIELD_OFFSET(ConcatNDLayerParams, axis_)>(
          reinterpret_cast<char*>(&axis_),
          reinterpret_cast<char*>(&other->axis_));
}

std::string ConcatNDLayerParams::GetTypeName() const {
  return "CoreML.Specification.ConcatNDLayerParams";
}


// ===================================================================

class SoftmaxNDLayerParams::_Internal {
 public:
};

SoftmaxNDLayerParams::SoftmaxNDLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SoftmaxNDLayerParams)
}
SoftmaxNDLayerParams::SoftmaxNDLayerParams(const SoftmaxNDLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  axis_ = from.axis_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SoftmaxNDLayerParams)
}

inline void SoftmaxNDLayerParams::SharedCtor() {
axis_ = int64_t{0};
}

SoftmaxNDLayerParams::~SoftmaxNDLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SoftmaxNDLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SoftmaxNDLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SoftmaxNDLayerParams::ArenaDtor(void* object) {
  SoftmaxNDLayerParams* _this = reinterpret_cast< SoftmaxNDLayerParams* >(object);
  (void)_this;
}
void SoftmaxNDLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SoftmaxNDLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SoftmaxNDLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SoftmaxNDLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axis_ = int64_t{0};
  _internal_metadata_.Clear<std::string>();
}

const char* SoftmaxNDLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 axis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SoftmaxNDLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SoftmaxNDLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_axis(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SoftmaxNDLayerParams)
  return target;
}

size_t SoftmaxNDLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SoftmaxNDLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_axis());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SoftmaxNDLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SoftmaxNDLayerParams*>(
      &from));
}

void SoftmaxNDLayerParams::MergeFrom(const SoftmaxNDLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SoftmaxNDLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SoftmaxNDLayerParams::CopyFrom(const SoftmaxNDLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SoftmaxNDLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SoftmaxNDLayerParams::IsInitialized() const {
  return true;
}

void SoftmaxNDLayerParams::InternalSwap(SoftmaxNDLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(axis_, other->axis_);
}

std::string SoftmaxNDLayerParams::GetTypeName() const {
  return "CoreML.Specification.SoftmaxNDLayerParams";
}


// ===================================================================

class ReverseLayerParams::_Internal {
 public:
};

ReverseLayerParams::ReverseLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  reversedim_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ReverseLayerParams)
}
ReverseLayerParams::ReverseLayerParams(const ReverseLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      reversedim_(from.reversedim_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ReverseLayerParams)
}

inline void ReverseLayerParams::SharedCtor() {
}

ReverseLayerParams::~ReverseLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ReverseLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReverseLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReverseLayerParams::ArenaDtor(void* object) {
  ReverseLayerParams* _this = reinterpret_cast< ReverseLayerParams* >(object);
  (void)_this;
}
void ReverseLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReverseLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReverseLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ReverseLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  reversedim_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ReverseLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bool reverseDim = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_reversedim(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_reversedim(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReverseLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ReverseLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bool reverseDim = 1;
  if (this->_internal_reversedim_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_reversedim(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ReverseLayerParams)
  return target;
}

size_t ReverseLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ReverseLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bool reverseDim = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_reversedim_size());
    size_t data_size = 1UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReverseLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReverseLayerParams*>(
      &from));
}

void ReverseLayerParams::MergeFrom(const ReverseLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ReverseLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  reversedim_.MergeFrom(from.reversedim_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReverseLayerParams::CopyFrom(const ReverseLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ReverseLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReverseLayerParams::IsInitialized() const {
  return true;
}

void ReverseLayerParams::InternalSwap(ReverseLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  reversedim_.InternalSwap(&other->reversedim_);
}

std::string ReverseLayerParams::GetTypeName() const {
  return "CoreML.Specification.ReverseLayerParams";
}


// ===================================================================

class ReverseSeqLayerParams::_Internal {
 public:
};

ReverseSeqLayerParams::ReverseSeqLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ReverseSeqLayerParams)
}
ReverseSeqLayerParams::ReverseSeqLayerParams(const ReverseSeqLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&batchaxis_, &from.batchaxis_,
    static_cast<size_t>(reinterpret_cast<char*>(&sequenceaxis_) -
    reinterpret_cast<char*>(&batchaxis_)) + sizeof(sequenceaxis_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ReverseSeqLayerParams)
}

inline void ReverseSeqLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&batchaxis_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&sequenceaxis_) -
    reinterpret_cast<char*>(&batchaxis_)) + sizeof(sequenceaxis_));
}

ReverseSeqLayerParams::~ReverseSeqLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ReverseSeqLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReverseSeqLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReverseSeqLayerParams::ArenaDtor(void* object) {
  ReverseSeqLayerParams* _this = reinterpret_cast< ReverseSeqLayerParams* >(object);
  (void)_this;
}
void ReverseSeqLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReverseSeqLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReverseSeqLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ReverseSeqLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&batchaxis_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&sequenceaxis_) -
      reinterpret_cast<char*>(&batchaxis_)) + sizeof(sequenceaxis_));
  _internal_metadata_.Clear<std::string>();
}

const char* ReverseSeqLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 batchAxis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          batchaxis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 sequenceAxis = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          sequenceaxis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReverseSeqLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ReverseSeqLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 batchAxis = 1;
  if (this->_internal_batchaxis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_batchaxis(), target);
  }

  // int64 sequenceAxis = 2;
  if (this->_internal_sequenceaxis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_sequenceaxis(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ReverseSeqLayerParams)
  return target;
}

size_t ReverseSeqLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ReverseSeqLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 batchAxis = 1;
  if (this->_internal_batchaxis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_batchaxis());
  }

  // int64 sequenceAxis = 2;
  if (this->_internal_sequenceaxis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_sequenceaxis());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReverseSeqLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReverseSeqLayerParams*>(
      &from));
}

void ReverseSeqLayerParams::MergeFrom(const ReverseSeqLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ReverseSeqLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_batchaxis() != 0) {
    _internal_set_batchaxis(from._internal_batchaxis());
  }
  if (from._internal_sequenceaxis() != 0) {
    _internal_set_sequenceaxis(from._internal_sequenceaxis());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReverseSeqLayerParams::CopyFrom(const ReverseSeqLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ReverseSeqLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReverseSeqLayerParams::IsInitialized() const {
  return true;
}

void ReverseSeqLayerParams::InternalSwap(ReverseSeqLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReverseSeqLayerParams, sequenceaxis_)
      + sizeof(ReverseSeqLayerParams::sequenceaxis_)
      - PROTOBUF_FIELD_OFFSET(ReverseSeqLayerParams, batchaxis_)>(
          reinterpret_cast<char*>(&batchaxis_),
          reinterpret_cast<char*>(&other->batchaxis_));
}

std::string ReverseSeqLayerParams::GetTypeName() const {
  return "CoreML.Specification.ReverseSeqLayerParams";
}


// ===================================================================

class LoadConstantNDLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::WeightParams& data(const LoadConstantNDLayerParams* msg);
};

const ::CoreML::Specification::WeightParams&
LoadConstantNDLayerParams::_Internal::data(const LoadConstantNDLayerParams* msg) {
  return *msg->data_;
}
LoadConstantNDLayerParams::LoadConstantNDLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  shape_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LoadConstantNDLayerParams)
}
LoadConstantNDLayerParams::LoadConstantNDLayerParams(const LoadConstantNDLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      shape_(from.shape_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_data()) {
    data_ = new ::CoreML::Specification::WeightParams(*from.data_);
  } else {
    data_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LoadConstantNDLayerParams)
}

inline void LoadConstantNDLayerParams::SharedCtor() {
data_ = nullptr;
}

LoadConstantNDLayerParams::~LoadConstantNDLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LoadConstantNDLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LoadConstantNDLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete data_;
}

void LoadConstantNDLayerParams::ArenaDtor(void* object) {
  LoadConstantNDLayerParams* _this = reinterpret_cast< LoadConstantNDLayerParams* >(object);
  (void)_this;
}
void LoadConstantNDLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LoadConstantNDLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LoadConstantNDLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LoadConstantNDLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  shape_.Clear();
  if (GetArenaForAllocation() == nullptr && data_ != nullptr) {
    delete data_;
  }
  data_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* LoadConstantNDLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 shape = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_shape(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_shape(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoadConstantNDLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LoadConstantNDLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 shape = 1;
  {
    int byte_size = _shape_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          1, _internal_shape(), byte_size, target);
    }
  }

  // .CoreML.Specification.WeightParams data = 2;
  if (this->_internal_has_data()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::data(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LoadConstantNDLayerParams)
  return target;
}

size_t LoadConstantNDLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LoadConstantNDLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 shape = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->shape_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _shape_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .CoreML.Specification.WeightParams data = 2;
  if (this->_internal_has_data()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *data_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoadConstantNDLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LoadConstantNDLayerParams*>(
      &from));
}

void LoadConstantNDLayerParams::MergeFrom(const LoadConstantNDLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LoadConstantNDLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  shape_.MergeFrom(from.shape_);
  if (from._internal_has_data()) {
    _internal_mutable_data()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_data());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoadConstantNDLayerParams::CopyFrom(const LoadConstantNDLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LoadConstantNDLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadConstantNDLayerParams::IsInitialized() const {
  return true;
}

void LoadConstantNDLayerParams::InternalSwap(LoadConstantNDLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  shape_.InternalSwap(&other->shape_);
  swap(data_, other->data_);
}

std::string LoadConstantNDLayerParams::GetTypeName() const {
  return "CoreML.Specification.LoadConstantNDLayerParams";
}


// ===================================================================

class FillLikeLayerParams::_Internal {
 public:
};

FillLikeLayerParams::FillLikeLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.FillLikeLayerParams)
}
FillLikeLayerParams::FillLikeLayerParams(const FillLikeLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  value_ = from.value_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.FillLikeLayerParams)
}

inline void FillLikeLayerParams::SharedCtor() {
value_ = 0;
}

FillLikeLayerParams::~FillLikeLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.FillLikeLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FillLikeLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FillLikeLayerParams::ArenaDtor(void* object) {
  FillLikeLayerParams* _this = reinterpret_cast< FillLikeLayerParams* >(object);
  (void)_this;
}
void FillLikeLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FillLikeLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FillLikeLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.FillLikeLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  value_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* FillLikeLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FillLikeLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.FillLikeLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float value = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value = this->_internal_value();
  uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.FillLikeLayerParams)
  return target;
}

size_t FillLikeLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.FillLikeLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float value = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value = this->_internal_value();
  uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FillLikeLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FillLikeLayerParams*>(
      &from));
}

void FillLikeLayerParams::MergeFrom(const FillLikeLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.FillLikeLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value = from._internal_value();
  uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    _internal_set_value(from._internal_value());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FillLikeLayerParams::CopyFrom(const FillLikeLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.FillLikeLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FillLikeLayerParams::IsInitialized() const {
  return true;
}

void FillLikeLayerParams::InternalSwap(FillLikeLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(value_, other->value_);
}

std::string FillLikeLayerParams::GetTypeName() const {
  return "CoreML.Specification.FillLikeLayerParams";
}


// ===================================================================

class FillStaticLayerParams::_Internal {
 public:
};

FillStaticLayerParams::FillStaticLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  targetshape_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.FillStaticLayerParams)
}
FillStaticLayerParams::FillStaticLayerParams(const FillStaticLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      targetshape_(from.targetshape_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  value_ = from.value_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.FillStaticLayerParams)
}

inline void FillStaticLayerParams::SharedCtor() {
value_ = 0;
}

FillStaticLayerParams::~FillStaticLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.FillStaticLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FillStaticLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FillStaticLayerParams::ArenaDtor(void* object) {
  FillStaticLayerParams* _this = reinterpret_cast< FillStaticLayerParams* >(object);
  (void)_this;
}
void FillStaticLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FillStaticLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FillStaticLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.FillStaticLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  targetshape_.Clear();
  value_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* FillStaticLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 targetShape = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_targetshape(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_targetshape(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FillStaticLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.FillStaticLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float value = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value = this->_internal_value();
  uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_value(), target);
  }

  // repeated uint64 targetShape = 2;
  {
    int byte_size = _targetshape_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          2, _internal_targetshape(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.FillStaticLayerParams)
  return target;
}

size_t FillStaticLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.FillStaticLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 targetShape = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->targetshape_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _targetshape_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // float value = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value = this->_internal_value();
  uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FillStaticLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FillStaticLayerParams*>(
      &from));
}

void FillStaticLayerParams::MergeFrom(const FillStaticLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.FillStaticLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  targetshape_.MergeFrom(from.targetshape_);
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value = from._internal_value();
  uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    _internal_set_value(from._internal_value());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FillStaticLayerParams::CopyFrom(const FillStaticLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.FillStaticLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FillStaticLayerParams::IsInitialized() const {
  return true;
}

void FillStaticLayerParams::InternalSwap(FillStaticLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  targetshape_.InternalSwap(&other->targetshape_);
  swap(value_, other->value_);
}

std::string FillStaticLayerParams::GetTypeName() const {
  return "CoreML.Specification.FillStaticLayerParams";
}


// ===================================================================

class FillDynamicLayerParams::_Internal {
 public:
};

FillDynamicLayerParams::FillDynamicLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.FillDynamicLayerParams)
}
FillDynamicLayerParams::FillDynamicLayerParams(const FillDynamicLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  value_ = from.value_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.FillDynamicLayerParams)
}

inline void FillDynamicLayerParams::SharedCtor() {
value_ = 0;
}

FillDynamicLayerParams::~FillDynamicLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.FillDynamicLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FillDynamicLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FillDynamicLayerParams::ArenaDtor(void* object) {
  FillDynamicLayerParams* _this = reinterpret_cast< FillDynamicLayerParams* >(object);
  (void)_this;
}
void FillDynamicLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FillDynamicLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FillDynamicLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.FillDynamicLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  value_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* FillDynamicLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FillDynamicLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.FillDynamicLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float value = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value = this->_internal_value();
  uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.FillDynamicLayerParams)
  return target;
}

size_t FillDynamicLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.FillDynamicLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float value = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value = this->_internal_value();
  uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FillDynamicLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FillDynamicLayerParams*>(
      &from));
}

void FillDynamicLayerParams::MergeFrom(const FillDynamicLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.FillDynamicLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value = from._internal_value();
  uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    _internal_set_value(from._internal_value());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FillDynamicLayerParams::CopyFrom(const FillDynamicLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.FillDynamicLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FillDynamicLayerParams::IsInitialized() const {
  return true;
}

void FillDynamicLayerParams::InternalSwap(FillDynamicLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(value_, other->value_);
}

std::string FillDynamicLayerParams::GetTypeName() const {
  return "CoreML.Specification.FillDynamicLayerParams";
}


// ===================================================================

class WhereBroadcastableLayerParams::_Internal {
 public:
};

WhereBroadcastableLayerParams::WhereBroadcastableLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.WhereBroadcastableLayerParams)
}
WhereBroadcastableLayerParams::WhereBroadcastableLayerParams(const WhereBroadcastableLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.WhereBroadcastableLayerParams)
}

inline void WhereBroadcastableLayerParams::SharedCtor() {
}

WhereBroadcastableLayerParams::~WhereBroadcastableLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.WhereBroadcastableLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void WhereBroadcastableLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WhereBroadcastableLayerParams::ArenaDtor(void* object) {
  WhereBroadcastableLayerParams* _this = reinterpret_cast< WhereBroadcastableLayerParams* >(object);
  (void)_this;
}
void WhereBroadcastableLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WhereBroadcastableLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WhereBroadcastableLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.WhereBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* WhereBroadcastableLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WhereBroadcastableLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.WhereBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.WhereBroadcastableLayerParams)
  return target;
}

size_t WhereBroadcastableLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.WhereBroadcastableLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WhereBroadcastableLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const WhereBroadcastableLayerParams*>(
      &from));
}

void WhereBroadcastableLayerParams::MergeFrom(const WhereBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.WhereBroadcastableLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WhereBroadcastableLayerParams::CopyFrom(const WhereBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.WhereBroadcastableLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WhereBroadcastableLayerParams::IsInitialized() const {
  return true;
}

void WhereBroadcastableLayerParams::InternalSwap(WhereBroadcastableLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string WhereBroadcastableLayerParams::GetTypeName() const {
  return "CoreML.Specification.WhereBroadcastableLayerParams";
}


// ===================================================================

class SinLayerParams::_Internal {
 public:
};

SinLayerParams::SinLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SinLayerParams)
}
SinLayerParams::SinLayerParams(const SinLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SinLayerParams)
}

inline void SinLayerParams::SharedCtor() {
}

SinLayerParams::~SinLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SinLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SinLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SinLayerParams::ArenaDtor(void* object) {
  SinLayerParams* _this = reinterpret_cast< SinLayerParams* >(object);
  (void)_this;
}
void SinLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SinLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SinLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SinLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* SinLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SinLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SinLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SinLayerParams)
  return target;
}

size_t SinLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SinLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SinLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SinLayerParams*>(
      &from));
}

void SinLayerParams::MergeFrom(const SinLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SinLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SinLayerParams::CopyFrom(const SinLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SinLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SinLayerParams::IsInitialized() const {
  return true;
}

void SinLayerParams::InternalSwap(SinLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string SinLayerParams::GetTypeName() const {
  return "CoreML.Specification.SinLayerParams";
}


// ===================================================================

class CosLayerParams::_Internal {
 public:
};

CosLayerParams::CosLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.CosLayerParams)
}
CosLayerParams::CosLayerParams(const CosLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.CosLayerParams)
}

inline void CosLayerParams::SharedCtor() {
}

CosLayerParams::~CosLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.CosLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CosLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CosLayerParams::ArenaDtor(void* object) {
  CosLayerParams* _this = reinterpret_cast< CosLayerParams* >(object);
  (void)_this;
}
void CosLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CosLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CosLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.CosLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CosLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CosLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.CosLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.CosLayerParams)
  return target;
}

size_t CosLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.CosLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CosLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CosLayerParams*>(
      &from));
}

void CosLayerParams::MergeFrom(const CosLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.CosLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CosLayerParams::CopyFrom(const CosLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.CosLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CosLayerParams::IsInitialized() const {
  return true;
}

void CosLayerParams::InternalSwap(CosLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CosLayerParams::GetTypeName() const {
  return "CoreML.Specification.CosLayerParams";
}


// ===================================================================

class TanLayerParams::_Internal {
 public:
};

TanLayerParams::TanLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.TanLayerParams)
}
TanLayerParams::TanLayerParams(const TanLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.TanLayerParams)
}

inline void TanLayerParams::SharedCtor() {
}

TanLayerParams::~TanLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.TanLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TanLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TanLayerParams::ArenaDtor(void* object) {
  TanLayerParams* _this = reinterpret_cast< TanLayerParams* >(object);
  (void)_this;
}
void TanLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TanLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TanLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.TanLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* TanLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TanLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.TanLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.TanLayerParams)
  return target;
}

size_t TanLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.TanLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TanLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TanLayerParams*>(
      &from));
}

void TanLayerParams::MergeFrom(const TanLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.TanLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TanLayerParams::CopyFrom(const TanLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.TanLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TanLayerParams::IsInitialized() const {
  return true;
}

void TanLayerParams::InternalSwap(TanLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string TanLayerParams::GetTypeName() const {
  return "CoreML.Specification.TanLayerParams";
}


// ===================================================================

class AsinLayerParams::_Internal {
 public:
};

AsinLayerParams::AsinLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.AsinLayerParams)
}
AsinLayerParams::AsinLayerParams(const AsinLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.AsinLayerParams)
}

inline void AsinLayerParams::SharedCtor() {
}

AsinLayerParams::~AsinLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.AsinLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AsinLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AsinLayerParams::ArenaDtor(void* object) {
  AsinLayerParams* _this = reinterpret_cast< AsinLayerParams* >(object);
  (void)_this;
}
void AsinLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AsinLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AsinLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.AsinLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* AsinLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AsinLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.AsinLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.AsinLayerParams)
  return target;
}

size_t AsinLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.AsinLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AsinLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AsinLayerParams*>(
      &from));
}

void AsinLayerParams::MergeFrom(const AsinLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.AsinLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AsinLayerParams::CopyFrom(const AsinLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.AsinLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AsinLayerParams::IsInitialized() const {
  return true;
}

void AsinLayerParams::InternalSwap(AsinLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string AsinLayerParams::GetTypeName() const {
  return "CoreML.Specification.AsinLayerParams";
}


// ===================================================================

class AcosLayerParams::_Internal {
 public:
};

AcosLayerParams::AcosLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.AcosLayerParams)
}
AcosLayerParams::AcosLayerParams(const AcosLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.AcosLayerParams)
}

inline void AcosLayerParams::SharedCtor() {
}

AcosLayerParams::~AcosLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.AcosLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AcosLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AcosLayerParams::ArenaDtor(void* object) {
  AcosLayerParams* _this = reinterpret_cast< AcosLayerParams* >(object);
  (void)_this;
}
void AcosLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AcosLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AcosLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.AcosLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* AcosLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AcosLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.AcosLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.AcosLayerParams)
  return target;
}

size_t AcosLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.AcosLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AcosLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AcosLayerParams*>(
      &from));
}

void AcosLayerParams::MergeFrom(const AcosLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.AcosLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AcosLayerParams::CopyFrom(const AcosLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.AcosLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AcosLayerParams::IsInitialized() const {
  return true;
}

void AcosLayerParams::InternalSwap(AcosLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string AcosLayerParams::GetTypeName() const {
  return "CoreML.Specification.AcosLayerParams";
}


// ===================================================================

class AtanLayerParams::_Internal {
 public:
};

AtanLayerParams::AtanLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.AtanLayerParams)
}
AtanLayerParams::AtanLayerParams(const AtanLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.AtanLayerParams)
}

inline void AtanLayerParams::SharedCtor() {
}

AtanLayerParams::~AtanLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.AtanLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AtanLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AtanLayerParams::ArenaDtor(void* object) {
  AtanLayerParams* _this = reinterpret_cast< AtanLayerParams* >(object);
  (void)_this;
}
void AtanLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AtanLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AtanLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.AtanLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* AtanLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AtanLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.AtanLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.AtanLayerParams)
  return target;
}

size_t AtanLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.AtanLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AtanLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AtanLayerParams*>(
      &from));
}

void AtanLayerParams::MergeFrom(const AtanLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.AtanLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AtanLayerParams::CopyFrom(const AtanLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.AtanLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AtanLayerParams::IsInitialized() const {
  return true;
}

void AtanLayerParams::InternalSwap(AtanLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string AtanLayerParams::GetTypeName() const {
  return "CoreML.Specification.AtanLayerParams";
}


// ===================================================================

class SinhLayerParams::_Internal {
 public:
};

SinhLayerParams::SinhLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SinhLayerParams)
}
SinhLayerParams::SinhLayerParams(const SinhLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SinhLayerParams)
}

inline void SinhLayerParams::SharedCtor() {
}

SinhLayerParams::~SinhLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SinhLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SinhLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SinhLayerParams::ArenaDtor(void* object) {
  SinhLayerParams* _this = reinterpret_cast< SinhLayerParams* >(object);
  (void)_this;
}
void SinhLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SinhLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SinhLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SinhLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* SinhLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SinhLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SinhLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SinhLayerParams)
  return target;
}

size_t SinhLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SinhLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SinhLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SinhLayerParams*>(
      &from));
}

void SinhLayerParams::MergeFrom(const SinhLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SinhLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SinhLayerParams::CopyFrom(const SinhLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SinhLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SinhLayerParams::IsInitialized() const {
  return true;
}

void SinhLayerParams::InternalSwap(SinhLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string SinhLayerParams::GetTypeName() const {
  return "CoreML.Specification.SinhLayerParams";
}


// ===================================================================

class CoshLayerParams::_Internal {
 public:
};

CoshLayerParams::CoshLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.CoshLayerParams)
}
CoshLayerParams::CoshLayerParams(const CoshLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.CoshLayerParams)
}

inline void CoshLayerParams::SharedCtor() {
}

CoshLayerParams::~CoshLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.CoshLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CoshLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CoshLayerParams::ArenaDtor(void* object) {
  CoshLayerParams* _this = reinterpret_cast< CoshLayerParams* >(object);
  (void)_this;
}
void CoshLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CoshLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CoshLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.CoshLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CoshLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CoshLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.CoshLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.CoshLayerParams)
  return target;
}

size_t CoshLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.CoshLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CoshLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CoshLayerParams*>(
      &from));
}

void CoshLayerParams::MergeFrom(const CoshLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.CoshLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CoshLayerParams::CopyFrom(const CoshLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.CoshLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoshLayerParams::IsInitialized() const {
  return true;
}

void CoshLayerParams::InternalSwap(CoshLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CoshLayerParams::GetTypeName() const {
  return "CoreML.Specification.CoshLayerParams";
}


// ===================================================================

class TanhLayerParams::_Internal {
 public:
};

TanhLayerParams::TanhLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.TanhLayerParams)
}
TanhLayerParams::TanhLayerParams(const TanhLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.TanhLayerParams)
}

inline void TanhLayerParams::SharedCtor() {
}

TanhLayerParams::~TanhLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.TanhLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TanhLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TanhLayerParams::ArenaDtor(void* object) {
  TanhLayerParams* _this = reinterpret_cast< TanhLayerParams* >(object);
  (void)_this;
}
void TanhLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TanhLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TanhLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.TanhLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* TanhLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TanhLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.TanhLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.TanhLayerParams)
  return target;
}

size_t TanhLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.TanhLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TanhLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TanhLayerParams*>(
      &from));
}

void TanhLayerParams::MergeFrom(const TanhLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.TanhLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TanhLayerParams::CopyFrom(const TanhLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.TanhLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TanhLayerParams::IsInitialized() const {
  return true;
}

void TanhLayerParams::InternalSwap(TanhLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string TanhLayerParams::GetTypeName() const {
  return "CoreML.Specification.TanhLayerParams";
}


// ===================================================================

class AsinhLayerParams::_Internal {
 public:
};

AsinhLayerParams::AsinhLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.AsinhLayerParams)
}
AsinhLayerParams::AsinhLayerParams(const AsinhLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.AsinhLayerParams)
}

inline void AsinhLayerParams::SharedCtor() {
}

AsinhLayerParams::~AsinhLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.AsinhLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AsinhLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AsinhLayerParams::ArenaDtor(void* object) {
  AsinhLayerParams* _this = reinterpret_cast< AsinhLayerParams* >(object);
  (void)_this;
}
void AsinhLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AsinhLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AsinhLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.AsinhLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* AsinhLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AsinhLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.AsinhLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.AsinhLayerParams)
  return target;
}

size_t AsinhLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.AsinhLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AsinhLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AsinhLayerParams*>(
      &from));
}

void AsinhLayerParams::MergeFrom(const AsinhLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.AsinhLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AsinhLayerParams::CopyFrom(const AsinhLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.AsinhLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AsinhLayerParams::IsInitialized() const {
  return true;
}

void AsinhLayerParams::InternalSwap(AsinhLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string AsinhLayerParams::GetTypeName() const {
  return "CoreML.Specification.AsinhLayerParams";
}


// ===================================================================

class AcoshLayerParams::_Internal {
 public:
};

AcoshLayerParams::AcoshLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.AcoshLayerParams)
}
AcoshLayerParams::AcoshLayerParams(const AcoshLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.AcoshLayerParams)
}

inline void AcoshLayerParams::SharedCtor() {
}

AcoshLayerParams::~AcoshLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.AcoshLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AcoshLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AcoshLayerParams::ArenaDtor(void* object) {
  AcoshLayerParams* _this = reinterpret_cast< AcoshLayerParams* >(object);
  (void)_this;
}
void AcoshLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AcoshLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AcoshLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.AcoshLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* AcoshLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AcoshLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.AcoshLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.AcoshLayerParams)
  return target;
}

size_t AcoshLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.AcoshLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AcoshLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AcoshLayerParams*>(
      &from));
}

void AcoshLayerParams::MergeFrom(const AcoshLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.AcoshLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AcoshLayerParams::CopyFrom(const AcoshLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.AcoshLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AcoshLayerParams::IsInitialized() const {
  return true;
}

void AcoshLayerParams::InternalSwap(AcoshLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string AcoshLayerParams::GetTypeName() const {
  return "CoreML.Specification.AcoshLayerParams";
}


// ===================================================================

class AtanhLayerParams::_Internal {
 public:
};

AtanhLayerParams::AtanhLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.AtanhLayerParams)
}
AtanhLayerParams::AtanhLayerParams(const AtanhLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.AtanhLayerParams)
}

inline void AtanhLayerParams::SharedCtor() {
}

AtanhLayerParams::~AtanhLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.AtanhLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AtanhLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AtanhLayerParams::ArenaDtor(void* object) {
  AtanhLayerParams* _this = reinterpret_cast< AtanhLayerParams* >(object);
  (void)_this;
}
void AtanhLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AtanhLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AtanhLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.AtanhLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* AtanhLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AtanhLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.AtanhLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.AtanhLayerParams)
  return target;
}

size_t AtanhLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.AtanhLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AtanhLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AtanhLayerParams*>(
      &from));
}

void AtanhLayerParams::MergeFrom(const AtanhLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.AtanhLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AtanhLayerParams::CopyFrom(const AtanhLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.AtanhLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AtanhLayerParams::IsInitialized() const {
  return true;
}

void AtanhLayerParams::InternalSwap(AtanhLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string AtanhLayerParams::GetTypeName() const {
  return "CoreML.Specification.AtanhLayerParams";
}


// ===================================================================

class PowBroadcastableLayerParams::_Internal {
 public:
};

PowBroadcastableLayerParams::PowBroadcastableLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.PowBroadcastableLayerParams)
}
PowBroadcastableLayerParams::PowBroadcastableLayerParams(const PowBroadcastableLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.PowBroadcastableLayerParams)
}

inline void PowBroadcastableLayerParams::SharedCtor() {
}

PowBroadcastableLayerParams::~PowBroadcastableLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.PowBroadcastableLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PowBroadcastableLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PowBroadcastableLayerParams::ArenaDtor(void* object) {
  PowBroadcastableLayerParams* _this = reinterpret_cast< PowBroadcastableLayerParams* >(object);
  (void)_this;
}
void PowBroadcastableLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PowBroadcastableLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PowBroadcastableLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.PowBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* PowBroadcastableLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PowBroadcastableLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.PowBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.PowBroadcastableLayerParams)
  return target;
}

size_t PowBroadcastableLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.PowBroadcastableLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PowBroadcastableLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PowBroadcastableLayerParams*>(
      &from));
}

void PowBroadcastableLayerParams::MergeFrom(const PowBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.PowBroadcastableLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PowBroadcastableLayerParams::CopyFrom(const PowBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.PowBroadcastableLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PowBroadcastableLayerParams::IsInitialized() const {
  return true;
}

void PowBroadcastableLayerParams::InternalSwap(PowBroadcastableLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string PowBroadcastableLayerParams::GetTypeName() const {
  return "CoreML.Specification.PowBroadcastableLayerParams";
}


// ===================================================================

class Exp2LayerParams::_Internal {
 public:
};

Exp2LayerParams::Exp2LayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.Exp2LayerParams)
}
Exp2LayerParams::Exp2LayerParams(const Exp2LayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Exp2LayerParams)
}

inline void Exp2LayerParams::SharedCtor() {
}

Exp2LayerParams::~Exp2LayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Exp2LayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Exp2LayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Exp2LayerParams::ArenaDtor(void* object) {
  Exp2LayerParams* _this = reinterpret_cast< Exp2LayerParams* >(object);
  (void)_this;
}
void Exp2LayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Exp2LayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Exp2LayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Exp2LayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* Exp2LayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Exp2LayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.Exp2LayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.Exp2LayerParams)
  return target;
}

size_t Exp2LayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Exp2LayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Exp2LayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Exp2LayerParams*>(
      &from));
}

void Exp2LayerParams::MergeFrom(const Exp2LayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Exp2LayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Exp2LayerParams::CopyFrom(const Exp2LayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Exp2LayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Exp2LayerParams::IsInitialized() const {
  return true;
}

void Exp2LayerParams::InternalSwap(Exp2LayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string Exp2LayerParams::GetTypeName() const {
  return "CoreML.Specification.Exp2LayerParams";
}


// ===================================================================

class WhereNonZeroLayerParams::_Internal {
 public:
};

WhereNonZeroLayerParams::WhereNonZeroLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.WhereNonZeroLayerParams)
}
WhereNonZeroLayerParams::WhereNonZeroLayerParams(const WhereNonZeroLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.WhereNonZeroLayerParams)
}

inline void WhereNonZeroLayerParams::SharedCtor() {
}

WhereNonZeroLayerParams::~WhereNonZeroLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.WhereNonZeroLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void WhereNonZeroLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WhereNonZeroLayerParams::ArenaDtor(void* object) {
  WhereNonZeroLayerParams* _this = reinterpret_cast< WhereNonZeroLayerParams* >(object);
  (void)_this;
}
void WhereNonZeroLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WhereNonZeroLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WhereNonZeroLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.WhereNonZeroLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* WhereNonZeroLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WhereNonZeroLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.WhereNonZeroLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.WhereNonZeroLayerParams)
  return target;
}

size_t WhereNonZeroLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.WhereNonZeroLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WhereNonZeroLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const WhereNonZeroLayerParams*>(
      &from));
}

void WhereNonZeroLayerParams::MergeFrom(const WhereNonZeroLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.WhereNonZeroLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WhereNonZeroLayerParams::CopyFrom(const WhereNonZeroLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.WhereNonZeroLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WhereNonZeroLayerParams::IsInitialized() const {
  return true;
}

void WhereNonZeroLayerParams::InternalSwap(WhereNonZeroLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string WhereNonZeroLayerParams::GetTypeName() const {
  return "CoreML.Specification.WhereNonZeroLayerParams";
}


// ===================================================================

class MatrixBandPartLayerParams::_Internal {
 public:
};

MatrixBandPartLayerParams::MatrixBandPartLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MatrixBandPartLayerParams)
}
MatrixBandPartLayerParams::MatrixBandPartLayerParams(const MatrixBandPartLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&numlower_, &from.numlower_,
    static_cast<size_t>(reinterpret_cast<char*>(&numupper_) -
    reinterpret_cast<char*>(&numlower_)) + sizeof(numupper_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MatrixBandPartLayerParams)
}

inline void MatrixBandPartLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&numlower_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&numupper_) -
    reinterpret_cast<char*>(&numlower_)) + sizeof(numupper_));
}

MatrixBandPartLayerParams::~MatrixBandPartLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MatrixBandPartLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void MatrixBandPartLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MatrixBandPartLayerParams::ArenaDtor(void* object) {
  MatrixBandPartLayerParams* _this = reinterpret_cast< MatrixBandPartLayerParams* >(object);
  (void)_this;
}
void MatrixBandPartLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MatrixBandPartLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MatrixBandPartLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MatrixBandPartLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&numlower_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&numupper_) -
      reinterpret_cast<char*>(&numlower_)) + sizeof(numupper_));
  _internal_metadata_.Clear<std::string>();
}

const char* MatrixBandPartLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 numLower = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          numlower_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 numUpper = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          numupper_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MatrixBandPartLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MatrixBandPartLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 numLower = 1;
  if (this->_internal_numlower() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_numlower(), target);
  }

  // int64 numUpper = 2;
  if (this->_internal_numupper() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_numupper(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MatrixBandPartLayerParams)
  return target;
}

size_t MatrixBandPartLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MatrixBandPartLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 numLower = 1;
  if (this->_internal_numlower() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_numlower());
  }

  // int64 numUpper = 2;
  if (this->_internal_numupper() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_numupper());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MatrixBandPartLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MatrixBandPartLayerParams*>(
      &from));
}

void MatrixBandPartLayerParams::MergeFrom(const MatrixBandPartLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MatrixBandPartLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_numlower() != 0) {
    _internal_set_numlower(from._internal_numlower());
  }
  if (from._internal_numupper() != 0) {
    _internal_set_numupper(from._internal_numupper());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MatrixBandPartLayerParams::CopyFrom(const MatrixBandPartLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MatrixBandPartLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatrixBandPartLayerParams::IsInitialized() const {
  return true;
}

void MatrixBandPartLayerParams::InternalSwap(MatrixBandPartLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MatrixBandPartLayerParams, numupper_)
      + sizeof(MatrixBandPartLayerParams::numupper_)
      - PROTOBUF_FIELD_OFFSET(MatrixBandPartLayerParams, numlower_)>(
          reinterpret_cast<char*>(&numlower_),
          reinterpret_cast<char*>(&other->numlower_));
}

std::string MatrixBandPartLayerParams::GetTypeName() const {
  return "CoreML.Specification.MatrixBandPartLayerParams";
}


// ===================================================================

class UpperTriangularLayerParams::_Internal {
 public:
};

UpperTriangularLayerParams::UpperTriangularLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.UpperTriangularLayerParams)
}
UpperTriangularLayerParams::UpperTriangularLayerParams(const UpperTriangularLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  k_ = from.k_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.UpperTriangularLayerParams)
}

inline void UpperTriangularLayerParams::SharedCtor() {
k_ = int64_t{0};
}

UpperTriangularLayerParams::~UpperTriangularLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.UpperTriangularLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void UpperTriangularLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UpperTriangularLayerParams::ArenaDtor(void* object) {
  UpperTriangularLayerParams* _this = reinterpret_cast< UpperTriangularLayerParams* >(object);
  (void)_this;
}
void UpperTriangularLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UpperTriangularLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UpperTriangularLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.UpperTriangularLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  k_ = int64_t{0};
  _internal_metadata_.Clear<std::string>();
}

const char* UpperTriangularLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 k = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          k_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpperTriangularLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.UpperTriangularLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 k = 1;
  if (this->_internal_k() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_k(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.UpperTriangularLayerParams)
  return target;
}

size_t UpperTriangularLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.UpperTriangularLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 k = 1;
  if (this->_internal_k() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_k());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UpperTriangularLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UpperTriangularLayerParams*>(
      &from));
}

void UpperTriangularLayerParams::MergeFrom(const UpperTriangularLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.UpperTriangularLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_k() != 0) {
    _internal_set_k(from._internal_k());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UpperTriangularLayerParams::CopyFrom(const UpperTriangularLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.UpperTriangularLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpperTriangularLayerParams::IsInitialized() const {
  return true;
}

void UpperTriangularLayerParams::InternalSwap(UpperTriangularLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(k_, other->k_);
}

std::string UpperTriangularLayerParams::GetTypeName() const {
  return "CoreML.Specification.UpperTriangularLayerParams";
}


// ===================================================================

class LowerTriangularLayerParams::_Internal {
 public:
};

LowerTriangularLayerParams::LowerTriangularLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LowerTriangularLayerParams)
}
LowerTriangularLayerParams::LowerTriangularLayerParams(const LowerTriangularLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  k_ = from.k_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LowerTriangularLayerParams)
}

inline void LowerTriangularLayerParams::SharedCtor() {
k_ = int64_t{0};
}

LowerTriangularLayerParams::~LowerTriangularLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LowerTriangularLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LowerTriangularLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LowerTriangularLayerParams::ArenaDtor(void* object) {
  LowerTriangularLayerParams* _this = reinterpret_cast< LowerTriangularLayerParams* >(object);
  (void)_this;
}
void LowerTriangularLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LowerTriangularLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LowerTriangularLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LowerTriangularLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  k_ = int64_t{0};
  _internal_metadata_.Clear<std::string>();
}

const char* LowerTriangularLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 k = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          k_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LowerTriangularLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LowerTriangularLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 k = 1;
  if (this->_internal_k() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_k(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LowerTriangularLayerParams)
  return target;
}

size_t LowerTriangularLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LowerTriangularLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 k = 1;
  if (this->_internal_k() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_k());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LowerTriangularLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LowerTriangularLayerParams*>(
      &from));
}

void LowerTriangularLayerParams::MergeFrom(const LowerTriangularLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LowerTriangularLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_k() != 0) {
    _internal_set_k(from._internal_k());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LowerTriangularLayerParams::CopyFrom(const LowerTriangularLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LowerTriangularLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LowerTriangularLayerParams::IsInitialized() const {
  return true;
}

void LowerTriangularLayerParams::InternalSwap(LowerTriangularLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(k_, other->k_);
}

std::string LowerTriangularLayerParams::GetTypeName() const {
  return "CoreML.Specification.LowerTriangularLayerParams";
}


// ===================================================================

class BroadcastToLikeLayerParams::_Internal {
 public:
};

BroadcastToLikeLayerParams::BroadcastToLikeLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.BroadcastToLikeLayerParams)
}
BroadcastToLikeLayerParams::BroadcastToLikeLayerParams(const BroadcastToLikeLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.BroadcastToLikeLayerParams)
}

inline void BroadcastToLikeLayerParams::SharedCtor() {
}

BroadcastToLikeLayerParams::~BroadcastToLikeLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.BroadcastToLikeLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BroadcastToLikeLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BroadcastToLikeLayerParams::ArenaDtor(void* object) {
  BroadcastToLikeLayerParams* _this = reinterpret_cast< BroadcastToLikeLayerParams* >(object);
  (void)_this;
}
void BroadcastToLikeLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BroadcastToLikeLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BroadcastToLikeLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.BroadcastToLikeLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* BroadcastToLikeLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BroadcastToLikeLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.BroadcastToLikeLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.BroadcastToLikeLayerParams)
  return target;
}

size_t BroadcastToLikeLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.BroadcastToLikeLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BroadcastToLikeLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BroadcastToLikeLayerParams*>(
      &from));
}

void BroadcastToLikeLayerParams::MergeFrom(const BroadcastToLikeLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.BroadcastToLikeLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BroadcastToLikeLayerParams::CopyFrom(const BroadcastToLikeLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.BroadcastToLikeLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BroadcastToLikeLayerParams::IsInitialized() const {
  return true;
}

void BroadcastToLikeLayerParams::InternalSwap(BroadcastToLikeLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string BroadcastToLikeLayerParams::GetTypeName() const {
  return "CoreML.Specification.BroadcastToLikeLayerParams";
}


// ===================================================================

class BroadcastToStaticLayerParams::_Internal {
 public:
};

BroadcastToStaticLayerParams::BroadcastToStaticLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  targetshape_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.BroadcastToStaticLayerParams)
}
BroadcastToStaticLayerParams::BroadcastToStaticLayerParams(const BroadcastToStaticLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      targetshape_(from.targetshape_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.BroadcastToStaticLayerParams)
}

inline void BroadcastToStaticLayerParams::SharedCtor() {
}

BroadcastToStaticLayerParams::~BroadcastToStaticLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.BroadcastToStaticLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BroadcastToStaticLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BroadcastToStaticLayerParams::ArenaDtor(void* object) {
  BroadcastToStaticLayerParams* _this = reinterpret_cast< BroadcastToStaticLayerParams* >(object);
  (void)_this;
}
void BroadcastToStaticLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BroadcastToStaticLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BroadcastToStaticLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.BroadcastToStaticLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  targetshape_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BroadcastToStaticLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 targetShape = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_targetshape(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_targetshape(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BroadcastToStaticLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.BroadcastToStaticLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 targetShape = 1;
  {
    int byte_size = _targetshape_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          1, _internal_targetshape(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.BroadcastToStaticLayerParams)
  return target;
}

size_t BroadcastToStaticLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.BroadcastToStaticLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 targetShape = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->targetshape_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _targetshape_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BroadcastToStaticLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BroadcastToStaticLayerParams*>(
      &from));
}

void BroadcastToStaticLayerParams::MergeFrom(const BroadcastToStaticLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.BroadcastToStaticLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  targetshape_.MergeFrom(from.targetshape_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BroadcastToStaticLayerParams::CopyFrom(const BroadcastToStaticLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.BroadcastToStaticLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BroadcastToStaticLayerParams::IsInitialized() const {
  return true;
}

void BroadcastToStaticLayerParams::InternalSwap(BroadcastToStaticLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  targetshape_.InternalSwap(&other->targetshape_);
}

std::string BroadcastToStaticLayerParams::GetTypeName() const {
  return "CoreML.Specification.BroadcastToStaticLayerParams";
}


// ===================================================================

class BroadcastToDynamicLayerParams::_Internal {
 public:
};

BroadcastToDynamicLayerParams::BroadcastToDynamicLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.BroadcastToDynamicLayerParams)
}
BroadcastToDynamicLayerParams::BroadcastToDynamicLayerParams(const BroadcastToDynamicLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.BroadcastToDynamicLayerParams)
}

inline void BroadcastToDynamicLayerParams::SharedCtor() {
}

BroadcastToDynamicLayerParams::~BroadcastToDynamicLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.BroadcastToDynamicLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BroadcastToDynamicLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BroadcastToDynamicLayerParams::ArenaDtor(void* object) {
  BroadcastToDynamicLayerParams* _this = reinterpret_cast< BroadcastToDynamicLayerParams* >(object);
  (void)_this;
}
void BroadcastToDynamicLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BroadcastToDynamicLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BroadcastToDynamicLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.BroadcastToDynamicLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* BroadcastToDynamicLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BroadcastToDynamicLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.BroadcastToDynamicLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.BroadcastToDynamicLayerParams)
  return target;
}

size_t BroadcastToDynamicLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.BroadcastToDynamicLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BroadcastToDynamicLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BroadcastToDynamicLayerParams*>(
      &from));
}

void BroadcastToDynamicLayerParams::MergeFrom(const BroadcastToDynamicLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.BroadcastToDynamicLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BroadcastToDynamicLayerParams::CopyFrom(const BroadcastToDynamicLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.BroadcastToDynamicLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BroadcastToDynamicLayerParams::IsInitialized() const {
  return true;
}

void BroadcastToDynamicLayerParams::InternalSwap(BroadcastToDynamicLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string BroadcastToDynamicLayerParams::GetTypeName() const {
  return "CoreML.Specification.BroadcastToDynamicLayerParams";
}


// ===================================================================

class AddBroadcastableLayerParams::_Internal {
 public:
};

AddBroadcastableLayerParams::AddBroadcastableLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.AddBroadcastableLayerParams)
}
AddBroadcastableLayerParams::AddBroadcastableLayerParams(const AddBroadcastableLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.AddBroadcastableLayerParams)
}

inline void AddBroadcastableLayerParams::SharedCtor() {
}

AddBroadcastableLayerParams::~AddBroadcastableLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.AddBroadcastableLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AddBroadcastableLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AddBroadcastableLayerParams::ArenaDtor(void* object) {
  AddBroadcastableLayerParams* _this = reinterpret_cast< AddBroadcastableLayerParams* >(object);
  (void)_this;
}
void AddBroadcastableLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AddBroadcastableLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AddBroadcastableLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.AddBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* AddBroadcastableLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AddBroadcastableLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.AddBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.AddBroadcastableLayerParams)
  return target;
}

size_t AddBroadcastableLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.AddBroadcastableLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AddBroadcastableLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AddBroadcastableLayerParams*>(
      &from));
}

void AddBroadcastableLayerParams::MergeFrom(const AddBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.AddBroadcastableLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AddBroadcastableLayerParams::CopyFrom(const AddBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.AddBroadcastableLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddBroadcastableLayerParams::IsInitialized() const {
  return true;
}

void AddBroadcastableLayerParams::InternalSwap(AddBroadcastableLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string AddBroadcastableLayerParams::GetTypeName() const {
  return "CoreML.Specification.AddBroadcastableLayerParams";
}


// ===================================================================

class MaxBroadcastableLayerParams::_Internal {
 public:
};

MaxBroadcastableLayerParams::MaxBroadcastableLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MaxBroadcastableLayerParams)
}
MaxBroadcastableLayerParams::MaxBroadcastableLayerParams(const MaxBroadcastableLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MaxBroadcastableLayerParams)
}

inline void MaxBroadcastableLayerParams::SharedCtor() {
}

MaxBroadcastableLayerParams::~MaxBroadcastableLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MaxBroadcastableLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void MaxBroadcastableLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MaxBroadcastableLayerParams::ArenaDtor(void* object) {
  MaxBroadcastableLayerParams* _this = reinterpret_cast< MaxBroadcastableLayerParams* >(object);
  (void)_this;
}
void MaxBroadcastableLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MaxBroadcastableLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MaxBroadcastableLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MaxBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* MaxBroadcastableLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MaxBroadcastableLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MaxBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MaxBroadcastableLayerParams)
  return target;
}

size_t MaxBroadcastableLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MaxBroadcastableLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MaxBroadcastableLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MaxBroadcastableLayerParams*>(
      &from));
}

void MaxBroadcastableLayerParams::MergeFrom(const MaxBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MaxBroadcastableLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MaxBroadcastableLayerParams::CopyFrom(const MaxBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MaxBroadcastableLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MaxBroadcastableLayerParams::IsInitialized() const {
  return true;
}

void MaxBroadcastableLayerParams::InternalSwap(MaxBroadcastableLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string MaxBroadcastableLayerParams::GetTypeName() const {
  return "CoreML.Specification.MaxBroadcastableLayerParams";
}


// ===================================================================

class MinBroadcastableLayerParams::_Internal {
 public:
};

MinBroadcastableLayerParams::MinBroadcastableLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MinBroadcastableLayerParams)
}
MinBroadcastableLayerParams::MinBroadcastableLayerParams(const MinBroadcastableLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MinBroadcastableLayerParams)
}

inline void MinBroadcastableLayerParams::SharedCtor() {
}

MinBroadcastableLayerParams::~MinBroadcastableLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MinBroadcastableLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void MinBroadcastableLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MinBroadcastableLayerParams::ArenaDtor(void* object) {
  MinBroadcastableLayerParams* _this = reinterpret_cast< MinBroadcastableLayerParams* >(object);
  (void)_this;
}
void MinBroadcastableLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MinBroadcastableLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MinBroadcastableLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MinBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* MinBroadcastableLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MinBroadcastableLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MinBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MinBroadcastableLayerParams)
  return target;
}

size_t MinBroadcastableLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MinBroadcastableLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MinBroadcastableLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MinBroadcastableLayerParams*>(
      &from));
}

void MinBroadcastableLayerParams::MergeFrom(const MinBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MinBroadcastableLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MinBroadcastableLayerParams::CopyFrom(const MinBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MinBroadcastableLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MinBroadcastableLayerParams::IsInitialized() const {
  return true;
}

void MinBroadcastableLayerParams::InternalSwap(MinBroadcastableLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string MinBroadcastableLayerParams::GetTypeName() const {
  return "CoreML.Specification.MinBroadcastableLayerParams";
}


// ===================================================================

class ModBroadcastableLayerParams::_Internal {
 public:
};

ModBroadcastableLayerParams::ModBroadcastableLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ModBroadcastableLayerParams)
}
ModBroadcastableLayerParams::ModBroadcastableLayerParams(const ModBroadcastableLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ModBroadcastableLayerParams)
}

inline void ModBroadcastableLayerParams::SharedCtor() {
}

ModBroadcastableLayerParams::~ModBroadcastableLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ModBroadcastableLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ModBroadcastableLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModBroadcastableLayerParams::ArenaDtor(void* object) {
  ModBroadcastableLayerParams* _this = reinterpret_cast< ModBroadcastableLayerParams* >(object);
  (void)_this;
}
void ModBroadcastableLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModBroadcastableLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModBroadcastableLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ModBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ModBroadcastableLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModBroadcastableLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ModBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ModBroadcastableLayerParams)
  return target;
}

size_t ModBroadcastableLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ModBroadcastableLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ModBroadcastableLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ModBroadcastableLayerParams*>(
      &from));
}

void ModBroadcastableLayerParams::MergeFrom(const ModBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ModBroadcastableLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ModBroadcastableLayerParams::CopyFrom(const ModBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ModBroadcastableLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModBroadcastableLayerParams::IsInitialized() const {
  return true;
}

void ModBroadcastableLayerParams::InternalSwap(ModBroadcastableLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ModBroadcastableLayerParams::GetTypeName() const {
  return "CoreML.Specification.ModBroadcastableLayerParams";
}


// ===================================================================

class FloorDivBroadcastableLayerParams::_Internal {
 public:
};

FloorDivBroadcastableLayerParams::FloorDivBroadcastableLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.FloorDivBroadcastableLayerParams)
}
FloorDivBroadcastableLayerParams::FloorDivBroadcastableLayerParams(const FloorDivBroadcastableLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.FloorDivBroadcastableLayerParams)
}

inline void FloorDivBroadcastableLayerParams::SharedCtor() {
}

FloorDivBroadcastableLayerParams::~FloorDivBroadcastableLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.FloorDivBroadcastableLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FloorDivBroadcastableLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FloorDivBroadcastableLayerParams::ArenaDtor(void* object) {
  FloorDivBroadcastableLayerParams* _this = reinterpret_cast< FloorDivBroadcastableLayerParams* >(object);
  (void)_this;
}
void FloorDivBroadcastableLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FloorDivBroadcastableLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FloorDivBroadcastableLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.FloorDivBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* FloorDivBroadcastableLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FloorDivBroadcastableLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.FloorDivBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.FloorDivBroadcastableLayerParams)
  return target;
}

size_t FloorDivBroadcastableLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.FloorDivBroadcastableLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FloorDivBroadcastableLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FloorDivBroadcastableLayerParams*>(
      &from));
}

void FloorDivBroadcastableLayerParams::MergeFrom(const FloorDivBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.FloorDivBroadcastableLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FloorDivBroadcastableLayerParams::CopyFrom(const FloorDivBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.FloorDivBroadcastableLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FloorDivBroadcastableLayerParams::IsInitialized() const {
  return true;
}

void FloorDivBroadcastableLayerParams::InternalSwap(FloorDivBroadcastableLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string FloorDivBroadcastableLayerParams::GetTypeName() const {
  return "CoreML.Specification.FloorDivBroadcastableLayerParams";
}


// ===================================================================

class SubtractBroadcastableLayerParams::_Internal {
 public:
};

SubtractBroadcastableLayerParams::SubtractBroadcastableLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SubtractBroadcastableLayerParams)
}
SubtractBroadcastableLayerParams::SubtractBroadcastableLayerParams(const SubtractBroadcastableLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SubtractBroadcastableLayerParams)
}

inline void SubtractBroadcastableLayerParams::SharedCtor() {
}

SubtractBroadcastableLayerParams::~SubtractBroadcastableLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SubtractBroadcastableLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SubtractBroadcastableLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SubtractBroadcastableLayerParams::ArenaDtor(void* object) {
  SubtractBroadcastableLayerParams* _this = reinterpret_cast< SubtractBroadcastableLayerParams* >(object);
  (void)_this;
}
void SubtractBroadcastableLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SubtractBroadcastableLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SubtractBroadcastableLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SubtractBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* SubtractBroadcastableLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SubtractBroadcastableLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SubtractBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SubtractBroadcastableLayerParams)
  return target;
}

size_t SubtractBroadcastableLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SubtractBroadcastableLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SubtractBroadcastableLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SubtractBroadcastableLayerParams*>(
      &from));
}

void SubtractBroadcastableLayerParams::MergeFrom(const SubtractBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SubtractBroadcastableLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SubtractBroadcastableLayerParams::CopyFrom(const SubtractBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SubtractBroadcastableLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubtractBroadcastableLayerParams::IsInitialized() const {
  return true;
}

void SubtractBroadcastableLayerParams::InternalSwap(SubtractBroadcastableLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string SubtractBroadcastableLayerParams::GetTypeName() const {
  return "CoreML.Specification.SubtractBroadcastableLayerParams";
}


// ===================================================================

class MultiplyBroadcastableLayerParams::_Internal {
 public:
};

MultiplyBroadcastableLayerParams::MultiplyBroadcastableLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MultiplyBroadcastableLayerParams)
}
MultiplyBroadcastableLayerParams::MultiplyBroadcastableLayerParams(const MultiplyBroadcastableLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MultiplyBroadcastableLayerParams)
}

inline void MultiplyBroadcastableLayerParams::SharedCtor() {
}

MultiplyBroadcastableLayerParams::~MultiplyBroadcastableLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MultiplyBroadcastableLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void MultiplyBroadcastableLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MultiplyBroadcastableLayerParams::ArenaDtor(void* object) {
  MultiplyBroadcastableLayerParams* _this = reinterpret_cast< MultiplyBroadcastableLayerParams* >(object);
  (void)_this;
}
void MultiplyBroadcastableLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MultiplyBroadcastableLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MultiplyBroadcastableLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MultiplyBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* MultiplyBroadcastableLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MultiplyBroadcastableLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MultiplyBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MultiplyBroadcastableLayerParams)
  return target;
}

size_t MultiplyBroadcastableLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MultiplyBroadcastableLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MultiplyBroadcastableLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MultiplyBroadcastableLayerParams*>(
      &from));
}

void MultiplyBroadcastableLayerParams::MergeFrom(const MultiplyBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MultiplyBroadcastableLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MultiplyBroadcastableLayerParams::CopyFrom(const MultiplyBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MultiplyBroadcastableLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultiplyBroadcastableLayerParams::IsInitialized() const {
  return true;
}

void MultiplyBroadcastableLayerParams::InternalSwap(MultiplyBroadcastableLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string MultiplyBroadcastableLayerParams::GetTypeName() const {
  return "CoreML.Specification.MultiplyBroadcastableLayerParams";
}


// ===================================================================

class DivideBroadcastableLayerParams::_Internal {
 public:
};

DivideBroadcastableLayerParams::DivideBroadcastableLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.DivideBroadcastableLayerParams)
}
DivideBroadcastableLayerParams::DivideBroadcastableLayerParams(const DivideBroadcastableLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DivideBroadcastableLayerParams)
}

inline void DivideBroadcastableLayerParams::SharedCtor() {
}

DivideBroadcastableLayerParams::~DivideBroadcastableLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DivideBroadcastableLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void DivideBroadcastableLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DivideBroadcastableLayerParams::ArenaDtor(void* object) {
  DivideBroadcastableLayerParams* _this = reinterpret_cast< DivideBroadcastableLayerParams* >(object);
  (void)_this;
}
void DivideBroadcastableLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DivideBroadcastableLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DivideBroadcastableLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DivideBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* DivideBroadcastableLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DivideBroadcastableLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.DivideBroadcastableLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.DivideBroadcastableLayerParams)
  return target;
}

size_t DivideBroadcastableLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DivideBroadcastableLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DivideBroadcastableLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DivideBroadcastableLayerParams*>(
      &from));
}

void DivideBroadcastableLayerParams::MergeFrom(const DivideBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DivideBroadcastableLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DivideBroadcastableLayerParams::CopyFrom(const DivideBroadcastableLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DivideBroadcastableLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DivideBroadcastableLayerParams::IsInitialized() const {
  return true;
}

void DivideBroadcastableLayerParams::InternalSwap(DivideBroadcastableLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string DivideBroadcastableLayerParams::GetTypeName() const {
  return "CoreML.Specification.DivideBroadcastableLayerParams";
}


// ===================================================================

class GatherLayerParams::_Internal {
 public:
};

GatherLayerParams::GatherLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.GatherLayerParams)
}
GatherLayerParams::GatherLayerParams(const GatherLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  axis_ = from.axis_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.GatherLayerParams)
}

inline void GatherLayerParams::SharedCtor() {
axis_ = int64_t{0};
}

GatherLayerParams::~GatherLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.GatherLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GatherLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GatherLayerParams::ArenaDtor(void* object) {
  GatherLayerParams* _this = reinterpret_cast< GatherLayerParams* >(object);
  (void)_this;
}
void GatherLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GatherLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GatherLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.GatherLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axis_ = int64_t{0};
  _internal_metadata_.Clear<std::string>();
}

const char* GatherLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 axis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GatherLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.GatherLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_axis(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.GatherLayerParams)
  return target;
}

size_t GatherLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.GatherLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_axis());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GatherLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GatherLayerParams*>(
      &from));
}

void GatherLayerParams::MergeFrom(const GatherLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.GatherLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GatherLayerParams::CopyFrom(const GatherLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.GatherLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GatherLayerParams::IsInitialized() const {
  return true;
}

void GatherLayerParams::InternalSwap(GatherLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(axis_, other->axis_);
}

std::string GatherLayerParams::GetTypeName() const {
  return "CoreML.Specification.GatherLayerParams";
}


// ===================================================================

class ScatterLayerParams::_Internal {
 public:
};

ScatterLayerParams::ScatterLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ScatterLayerParams)
}
ScatterLayerParams::ScatterLayerParams(const ScatterLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&axis_, &from.axis_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ScatterLayerParams)
}

inline void ScatterLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&axis_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(mode_));
}

ScatterLayerParams::~ScatterLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ScatterLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ScatterLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ScatterLayerParams::ArenaDtor(void* object) {
  ScatterLayerParams* _this = reinterpret_cast< ScatterLayerParams* >(object);
  (void)_this;
}
void ScatterLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ScatterLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ScatterLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ScatterLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&axis_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mode_) -
      reinterpret_cast<char*>(&axis_)) + sizeof(mode_));
  _internal_metadata_.Clear<std::string>();
}

const char* ScatterLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 axis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ScatterMode mode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mode(static_cast<::CoreML::Specification::ScatterMode>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScatterLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ScatterLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_axis(), target);
  }

  // .CoreML.Specification.ScatterMode mode = 2;
  if (this->_internal_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ScatterLayerParams)
  return target;
}

size_t ScatterLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ScatterLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_axis());
  }

  // .CoreML.Specification.ScatterMode mode = 2;
  if (this->_internal_mode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ScatterLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ScatterLayerParams*>(
      &from));
}

void ScatterLayerParams::MergeFrom(const ScatterLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ScatterLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  if (from._internal_mode() != 0) {
    _internal_set_mode(from._internal_mode());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ScatterLayerParams::CopyFrom(const ScatterLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ScatterLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScatterLayerParams::IsInitialized() const {
  return true;
}

void ScatterLayerParams::InternalSwap(ScatterLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScatterLayerParams, mode_)
      + sizeof(ScatterLayerParams::mode_)
      - PROTOBUF_FIELD_OFFSET(ScatterLayerParams, axis_)>(
          reinterpret_cast<char*>(&axis_),
          reinterpret_cast<char*>(&other->axis_));
}

std::string ScatterLayerParams::GetTypeName() const {
  return "CoreML.Specification.ScatterLayerParams";
}


// ===================================================================

class GatherNDLayerParams::_Internal {
 public:
};

GatherNDLayerParams::GatherNDLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.GatherNDLayerParams)
}
GatherNDLayerParams::GatherNDLayerParams(const GatherNDLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.GatherNDLayerParams)
}

inline void GatherNDLayerParams::SharedCtor() {
}

GatherNDLayerParams::~GatherNDLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.GatherNDLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GatherNDLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GatherNDLayerParams::ArenaDtor(void* object) {
  GatherNDLayerParams* _this = reinterpret_cast< GatherNDLayerParams* >(object);
  (void)_this;
}
void GatherNDLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GatherNDLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GatherNDLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.GatherNDLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* GatherNDLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GatherNDLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.GatherNDLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.GatherNDLayerParams)
  return target;
}

size_t GatherNDLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.GatherNDLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GatherNDLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GatherNDLayerParams*>(
      &from));
}

void GatherNDLayerParams::MergeFrom(const GatherNDLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.GatherNDLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GatherNDLayerParams::CopyFrom(const GatherNDLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.GatherNDLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GatherNDLayerParams::IsInitialized() const {
  return true;
}

void GatherNDLayerParams::InternalSwap(GatherNDLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string GatherNDLayerParams::GetTypeName() const {
  return "CoreML.Specification.GatherNDLayerParams";
}


// ===================================================================

class ScatterNDLayerParams::_Internal {
 public:
};

ScatterNDLayerParams::ScatterNDLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ScatterNDLayerParams)
}
ScatterNDLayerParams::ScatterNDLayerParams(const ScatterNDLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  mode_ = from.mode_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ScatterNDLayerParams)
}

inline void ScatterNDLayerParams::SharedCtor() {
mode_ = 0;
}

ScatterNDLayerParams::~ScatterNDLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ScatterNDLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ScatterNDLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ScatterNDLayerParams::ArenaDtor(void* object) {
  ScatterNDLayerParams* _this = reinterpret_cast< ScatterNDLayerParams* >(object);
  (void)_this;
}
void ScatterNDLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ScatterNDLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ScatterNDLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ScatterNDLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mode_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* ScatterNDLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.ScatterMode mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mode(static_cast<::CoreML::Specification::ScatterMode>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScatterNDLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ScatterNDLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.ScatterMode mode = 1;
  if (this->_internal_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ScatterNDLayerParams)
  return target;
}

size_t ScatterNDLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ScatterNDLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.ScatterMode mode = 1;
  if (this->_internal_mode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ScatterNDLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ScatterNDLayerParams*>(
      &from));
}

void ScatterNDLayerParams::MergeFrom(const ScatterNDLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ScatterNDLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_mode() != 0) {
    _internal_set_mode(from._internal_mode());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ScatterNDLayerParams::CopyFrom(const ScatterNDLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ScatterNDLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScatterNDLayerParams::IsInitialized() const {
  return true;
}

void ScatterNDLayerParams::InternalSwap(ScatterNDLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(mode_, other->mode_);
}

std::string ScatterNDLayerParams::GetTypeName() const {
  return "CoreML.Specification.ScatterNDLayerParams";
}


// ===================================================================

class GatherAlongAxisLayerParams::_Internal {
 public:
};

GatherAlongAxisLayerParams::GatherAlongAxisLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.GatherAlongAxisLayerParams)
}
GatherAlongAxisLayerParams::GatherAlongAxisLayerParams(const GatherAlongAxisLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  axis_ = from.axis_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.GatherAlongAxisLayerParams)
}

inline void GatherAlongAxisLayerParams::SharedCtor() {
axis_ = int64_t{0};
}

GatherAlongAxisLayerParams::~GatherAlongAxisLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.GatherAlongAxisLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GatherAlongAxisLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GatherAlongAxisLayerParams::ArenaDtor(void* object) {
  GatherAlongAxisLayerParams* _this = reinterpret_cast< GatherAlongAxisLayerParams* >(object);
  (void)_this;
}
void GatherAlongAxisLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GatherAlongAxisLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GatherAlongAxisLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.GatherAlongAxisLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axis_ = int64_t{0};
  _internal_metadata_.Clear<std::string>();
}

const char* GatherAlongAxisLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 axis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GatherAlongAxisLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.GatherAlongAxisLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_axis(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.GatherAlongAxisLayerParams)
  return target;
}

size_t GatherAlongAxisLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.GatherAlongAxisLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_axis());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GatherAlongAxisLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GatherAlongAxisLayerParams*>(
      &from));
}

void GatherAlongAxisLayerParams::MergeFrom(const GatherAlongAxisLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.GatherAlongAxisLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GatherAlongAxisLayerParams::CopyFrom(const GatherAlongAxisLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.GatherAlongAxisLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GatherAlongAxisLayerParams::IsInitialized() const {
  return true;
}

void GatherAlongAxisLayerParams::InternalSwap(GatherAlongAxisLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(axis_, other->axis_);
}

std::string GatherAlongAxisLayerParams::GetTypeName() const {
  return "CoreML.Specification.GatherAlongAxisLayerParams";
}


// ===================================================================

class ScatterAlongAxisLayerParams::_Internal {
 public:
};

ScatterAlongAxisLayerParams::ScatterAlongAxisLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ScatterAlongAxisLayerParams)
}
ScatterAlongAxisLayerParams::ScatterAlongAxisLayerParams(const ScatterAlongAxisLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&axis_, &from.axis_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ScatterAlongAxisLayerParams)
}

inline void ScatterAlongAxisLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&axis_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(mode_));
}

ScatterAlongAxisLayerParams::~ScatterAlongAxisLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ScatterAlongAxisLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ScatterAlongAxisLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ScatterAlongAxisLayerParams::ArenaDtor(void* object) {
  ScatterAlongAxisLayerParams* _this = reinterpret_cast< ScatterAlongAxisLayerParams* >(object);
  (void)_this;
}
void ScatterAlongAxisLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ScatterAlongAxisLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ScatterAlongAxisLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ScatterAlongAxisLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&axis_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mode_) -
      reinterpret_cast<char*>(&axis_)) + sizeof(mode_));
  _internal_metadata_.Clear<std::string>();
}

const char* ScatterAlongAxisLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 axis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.ScatterMode mode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mode(static_cast<::CoreML::Specification::ScatterMode>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScatterAlongAxisLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ScatterAlongAxisLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_axis(), target);
  }

  // .CoreML.Specification.ScatterMode mode = 2;
  if (this->_internal_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ScatterAlongAxisLayerParams)
  return target;
}

size_t ScatterAlongAxisLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ScatterAlongAxisLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_axis());
  }

  // .CoreML.Specification.ScatterMode mode = 2;
  if (this->_internal_mode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ScatterAlongAxisLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ScatterAlongAxisLayerParams*>(
      &from));
}

void ScatterAlongAxisLayerParams::MergeFrom(const ScatterAlongAxisLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ScatterAlongAxisLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  if (from._internal_mode() != 0) {
    _internal_set_mode(from._internal_mode());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ScatterAlongAxisLayerParams::CopyFrom(const ScatterAlongAxisLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ScatterAlongAxisLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScatterAlongAxisLayerParams::IsInitialized() const {
  return true;
}

void ScatterAlongAxisLayerParams::InternalSwap(ScatterAlongAxisLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScatterAlongAxisLayerParams, mode_)
      + sizeof(ScatterAlongAxisLayerParams::mode_)
      - PROTOBUF_FIELD_OFFSET(ScatterAlongAxisLayerParams, axis_)>(
          reinterpret_cast<char*>(&axis_),
          reinterpret_cast<char*>(&other->axis_));
}

std::string ScatterAlongAxisLayerParams::GetTypeName() const {
  return "CoreML.Specification.ScatterAlongAxisLayerParams";
}


// ===================================================================

class StackLayerParams::_Internal {
 public:
};

StackLayerParams::StackLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.StackLayerParams)
}
StackLayerParams::StackLayerParams(const StackLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  axis_ = from.axis_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.StackLayerParams)
}

inline void StackLayerParams::SharedCtor() {
axis_ = int64_t{0};
}

StackLayerParams::~StackLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.StackLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void StackLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StackLayerParams::ArenaDtor(void* object) {
  StackLayerParams* _this = reinterpret_cast< StackLayerParams* >(object);
  (void)_this;
}
void StackLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StackLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StackLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.StackLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axis_ = int64_t{0};
  _internal_metadata_.Clear<std::string>();
}

const char* StackLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 axis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StackLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.StackLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_axis(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.StackLayerParams)
  return target;
}

size_t StackLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.StackLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_axis());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StackLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StackLayerParams*>(
      &from));
}

void StackLayerParams::MergeFrom(const StackLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.StackLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StackLayerParams::CopyFrom(const StackLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.StackLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StackLayerParams::IsInitialized() const {
  return true;
}

void StackLayerParams::InternalSwap(StackLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(axis_, other->axis_);
}

std::string StackLayerParams::GetTypeName() const {
  return "CoreML.Specification.StackLayerParams";
}


// ===================================================================

class RankPreservingReshapeLayerParams::_Internal {
 public:
};

RankPreservingReshapeLayerParams::RankPreservingReshapeLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  targetshape_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.RankPreservingReshapeLayerParams)
}
RankPreservingReshapeLayerParams::RankPreservingReshapeLayerParams(const RankPreservingReshapeLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      targetshape_(from.targetshape_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.RankPreservingReshapeLayerParams)
}

inline void RankPreservingReshapeLayerParams::SharedCtor() {
}

RankPreservingReshapeLayerParams::~RankPreservingReshapeLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.RankPreservingReshapeLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RankPreservingReshapeLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RankPreservingReshapeLayerParams::ArenaDtor(void* object) {
  RankPreservingReshapeLayerParams* _this = reinterpret_cast< RankPreservingReshapeLayerParams* >(object);
  (void)_this;
}
void RankPreservingReshapeLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RankPreservingReshapeLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RankPreservingReshapeLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.RankPreservingReshapeLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  targetshape_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RankPreservingReshapeLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 targetShape = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_targetshape(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_targetshape(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RankPreservingReshapeLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.RankPreservingReshapeLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 targetShape = 1;
  {
    int byte_size = _targetshape_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_targetshape(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.RankPreservingReshapeLayerParams)
  return target;
}

size_t RankPreservingReshapeLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.RankPreservingReshapeLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 targetShape = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->targetshape_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _targetshape_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RankPreservingReshapeLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RankPreservingReshapeLayerParams*>(
      &from));
}

void RankPreservingReshapeLayerParams::MergeFrom(const RankPreservingReshapeLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.RankPreservingReshapeLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  targetshape_.MergeFrom(from.targetshape_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RankPreservingReshapeLayerParams::CopyFrom(const RankPreservingReshapeLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.RankPreservingReshapeLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RankPreservingReshapeLayerParams::IsInitialized() const {
  return true;
}

void RankPreservingReshapeLayerParams::InternalSwap(RankPreservingReshapeLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  targetshape_.InternalSwap(&other->targetshape_);
}

std::string RankPreservingReshapeLayerParams::GetTypeName() const {
  return "CoreML.Specification.RankPreservingReshapeLayerParams";
}


// ===================================================================

class ConstantPaddingLayerParams::_Internal {
 public:
};

ConstantPaddingLayerParams::ConstantPaddingLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  padamounts_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ConstantPaddingLayerParams)
}
ConstantPaddingLayerParams::ConstantPaddingLayerParams(const ConstantPaddingLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      padamounts_(from.padamounts_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&value_, &from.value_,
    static_cast<size_t>(reinterpret_cast<char*>(&padtogivenoutputsizemode_) -
    reinterpret_cast<char*>(&value_)) + sizeof(padtogivenoutputsizemode_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ConstantPaddingLayerParams)
}

inline void ConstantPaddingLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&value_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&padtogivenoutputsizemode_) -
    reinterpret_cast<char*>(&value_)) + sizeof(padtogivenoutputsizemode_));
}

ConstantPaddingLayerParams::~ConstantPaddingLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ConstantPaddingLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ConstantPaddingLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ConstantPaddingLayerParams::ArenaDtor(void* object) {
  ConstantPaddingLayerParams* _this = reinterpret_cast< ConstantPaddingLayerParams* >(object);
  (void)_this;
}
void ConstantPaddingLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConstantPaddingLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConstantPaddingLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ConstantPaddingLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  padamounts_.Clear();
  ::memset(&value_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&padtogivenoutputsizemode_) -
      reinterpret_cast<char*>(&value_)) + sizeof(padtogivenoutputsizemode_));
  _internal_metadata_.Clear<std::string>();
}

const char* ConstantPaddingLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 padAmounts = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_padamounts(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_padamounts(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool padToGivenOutputSizeMode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          padtogivenoutputsizemode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConstantPaddingLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ConstantPaddingLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float value = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value = this->_internal_value();
  uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_value(), target);
  }

  // repeated uint64 padAmounts = 2;
  {
    int byte_size = _padamounts_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          2, _internal_padamounts(), byte_size, target);
    }
  }

  // bool padToGivenOutputSizeMode = 3;
  if (this->_internal_padtogivenoutputsizemode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_padtogivenoutputsizemode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ConstantPaddingLayerParams)
  return target;
}

size_t ConstantPaddingLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ConstantPaddingLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 padAmounts = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->padamounts_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _padamounts_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // float value = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value = this->_internal_value();
  uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    total_size += 1 + 4;
  }

  // bool padToGivenOutputSizeMode = 3;
  if (this->_internal_padtogivenoutputsizemode() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConstantPaddingLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ConstantPaddingLayerParams*>(
      &from));
}

void ConstantPaddingLayerParams::MergeFrom(const ConstantPaddingLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ConstantPaddingLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  padamounts_.MergeFrom(from.padamounts_);
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value = from._internal_value();
  uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    _internal_set_value(from._internal_value());
  }
  if (from._internal_padtogivenoutputsizemode() != 0) {
    _internal_set_padtogivenoutputsizemode(from._internal_padtogivenoutputsizemode());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConstantPaddingLayerParams::CopyFrom(const ConstantPaddingLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ConstantPaddingLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConstantPaddingLayerParams::IsInitialized() const {
  return true;
}

void ConstantPaddingLayerParams::InternalSwap(ConstantPaddingLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  padamounts_.InternalSwap(&other->padamounts_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConstantPaddingLayerParams, padtogivenoutputsizemode_)
      + sizeof(ConstantPaddingLayerParams::padtogivenoutputsizemode_)
      - PROTOBUF_FIELD_OFFSET(ConstantPaddingLayerParams, value_)>(
          reinterpret_cast<char*>(&value_),
          reinterpret_cast<char*>(&other->value_));
}

std::string ConstantPaddingLayerParams::GetTypeName() const {
  return "CoreML.Specification.ConstantPaddingLayerParams";
}


// ===================================================================

class RandomNormalLikeLayerParams::_Internal {
 public:
};

RandomNormalLikeLayerParams::RandomNormalLikeLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.RandomNormalLikeLayerParams)
}
RandomNormalLikeLayerParams::RandomNormalLikeLayerParams(const RandomNormalLikeLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&seed_, &from.seed_,
    static_cast<size_t>(reinterpret_cast<char*>(&stddev_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(stddev_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.RandomNormalLikeLayerParams)
}

inline void RandomNormalLikeLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seed_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&stddev_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(stddev_));
}

RandomNormalLikeLayerParams::~RandomNormalLikeLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.RandomNormalLikeLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RandomNormalLikeLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RandomNormalLikeLayerParams::ArenaDtor(void* object) {
  RandomNormalLikeLayerParams* _this = reinterpret_cast< RandomNormalLikeLayerParams* >(object);
  (void)_this;
}
void RandomNormalLikeLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RandomNormalLikeLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RandomNormalLikeLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.RandomNormalLikeLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&seed_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&stddev_) -
      reinterpret_cast<char*>(&seed_)) + sizeof(stddev_));
  _internal_metadata_.Clear<std::string>();
}

const char* RandomNormalLikeLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 seed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float mean = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          mean_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float stdDev = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          stddev_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RandomNormalLikeLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.RandomNormalLikeLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_seed(), target);
  }

  // float mean = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mean = this->_internal_mean();
  uint32_t raw_mean;
  memcpy(&raw_mean, &tmp_mean, sizeof(tmp_mean));
  if (raw_mean != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_mean(), target);
  }

  // float stdDev = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_stddev = this->_internal_stddev();
  uint32_t raw_stddev;
  memcpy(&raw_stddev, &tmp_stddev, sizeof(tmp_stddev));
  if (raw_stddev != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_stddev(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.RandomNormalLikeLayerParams)
  return target;
}

size_t RandomNormalLikeLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.RandomNormalLikeLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_seed());
  }

  // float mean = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mean = this->_internal_mean();
  uint32_t raw_mean;
  memcpy(&raw_mean, &tmp_mean, sizeof(tmp_mean));
  if (raw_mean != 0) {
    total_size += 1 + 4;
  }

  // float stdDev = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_stddev = this->_internal_stddev();
  uint32_t raw_stddev;
  memcpy(&raw_stddev, &tmp_stddev, sizeof(tmp_stddev));
  if (raw_stddev != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RandomNormalLikeLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RandomNormalLikeLayerParams*>(
      &from));
}

void RandomNormalLikeLayerParams::MergeFrom(const RandomNormalLikeLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.RandomNormalLikeLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_seed() != 0) {
    _internal_set_seed(from._internal_seed());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mean = from._internal_mean();
  uint32_t raw_mean;
  memcpy(&raw_mean, &tmp_mean, sizeof(tmp_mean));
  if (raw_mean != 0) {
    _internal_set_mean(from._internal_mean());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_stddev = from._internal_stddev();
  uint32_t raw_stddev;
  memcpy(&raw_stddev, &tmp_stddev, sizeof(tmp_stddev));
  if (raw_stddev != 0) {
    _internal_set_stddev(from._internal_stddev());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RandomNormalLikeLayerParams::CopyFrom(const RandomNormalLikeLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.RandomNormalLikeLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RandomNormalLikeLayerParams::IsInitialized() const {
  return true;
}

void RandomNormalLikeLayerParams::InternalSwap(RandomNormalLikeLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RandomNormalLikeLayerParams, stddev_)
      + sizeof(RandomNormalLikeLayerParams::stddev_)
      - PROTOBUF_FIELD_OFFSET(RandomNormalLikeLayerParams, seed_)>(
          reinterpret_cast<char*>(&seed_),
          reinterpret_cast<char*>(&other->seed_));
}

std::string RandomNormalLikeLayerParams::GetTypeName() const {
  return "CoreML.Specification.RandomNormalLikeLayerParams";
}


// ===================================================================

class RandomNormalStaticLayerParams::_Internal {
 public:
};

RandomNormalStaticLayerParams::RandomNormalStaticLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  outputshape_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.RandomNormalStaticLayerParams)
}
RandomNormalStaticLayerParams::RandomNormalStaticLayerParams(const RandomNormalStaticLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      outputshape_(from.outputshape_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&seed_, &from.seed_,
    static_cast<size_t>(reinterpret_cast<char*>(&stddev_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(stddev_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.RandomNormalStaticLayerParams)
}

inline void RandomNormalStaticLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seed_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&stddev_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(stddev_));
}

RandomNormalStaticLayerParams::~RandomNormalStaticLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.RandomNormalStaticLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RandomNormalStaticLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RandomNormalStaticLayerParams::ArenaDtor(void* object) {
  RandomNormalStaticLayerParams* _this = reinterpret_cast< RandomNormalStaticLayerParams* >(object);
  (void)_this;
}
void RandomNormalStaticLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RandomNormalStaticLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RandomNormalStaticLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.RandomNormalStaticLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  outputshape_.Clear();
  ::memset(&seed_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&stddev_) -
      reinterpret_cast<char*>(&seed_)) + sizeof(stddev_));
  _internal_metadata_.Clear<std::string>();
}

const char* RandomNormalStaticLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 seed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float mean = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          mean_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float stdDev = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          stddev_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 outputShape = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_outputshape(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_outputshape(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RandomNormalStaticLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.RandomNormalStaticLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_seed(), target);
  }

  // float mean = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mean = this->_internal_mean();
  uint32_t raw_mean;
  memcpy(&raw_mean, &tmp_mean, sizeof(tmp_mean));
  if (raw_mean != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_mean(), target);
  }

  // float stdDev = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_stddev = this->_internal_stddev();
  uint32_t raw_stddev;
  memcpy(&raw_stddev, &tmp_stddev, sizeof(tmp_stddev));
  if (raw_stddev != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_stddev(), target);
  }

  // repeated uint64 outputShape = 4;
  {
    int byte_size = _outputshape_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          4, _internal_outputshape(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.RandomNormalStaticLayerParams)
  return target;
}

size_t RandomNormalStaticLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.RandomNormalStaticLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 outputShape = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->outputshape_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _outputshape_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_seed());
  }

  // float mean = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mean = this->_internal_mean();
  uint32_t raw_mean;
  memcpy(&raw_mean, &tmp_mean, sizeof(tmp_mean));
  if (raw_mean != 0) {
    total_size += 1 + 4;
  }

  // float stdDev = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_stddev = this->_internal_stddev();
  uint32_t raw_stddev;
  memcpy(&raw_stddev, &tmp_stddev, sizeof(tmp_stddev));
  if (raw_stddev != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RandomNormalStaticLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RandomNormalStaticLayerParams*>(
      &from));
}

void RandomNormalStaticLayerParams::MergeFrom(const RandomNormalStaticLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.RandomNormalStaticLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  outputshape_.MergeFrom(from.outputshape_);
  if (from._internal_seed() != 0) {
    _internal_set_seed(from._internal_seed());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mean = from._internal_mean();
  uint32_t raw_mean;
  memcpy(&raw_mean, &tmp_mean, sizeof(tmp_mean));
  if (raw_mean != 0) {
    _internal_set_mean(from._internal_mean());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_stddev = from._internal_stddev();
  uint32_t raw_stddev;
  memcpy(&raw_stddev, &tmp_stddev, sizeof(tmp_stddev));
  if (raw_stddev != 0) {
    _internal_set_stddev(from._internal_stddev());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RandomNormalStaticLayerParams::CopyFrom(const RandomNormalStaticLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.RandomNormalStaticLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RandomNormalStaticLayerParams::IsInitialized() const {
  return true;
}

void RandomNormalStaticLayerParams::InternalSwap(RandomNormalStaticLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  outputshape_.InternalSwap(&other->outputshape_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RandomNormalStaticLayerParams, stddev_)
      + sizeof(RandomNormalStaticLayerParams::stddev_)
      - PROTOBUF_FIELD_OFFSET(RandomNormalStaticLayerParams, seed_)>(
          reinterpret_cast<char*>(&seed_),
          reinterpret_cast<char*>(&other->seed_));
}

std::string RandomNormalStaticLayerParams::GetTypeName() const {
  return "CoreML.Specification.RandomNormalStaticLayerParams";
}


// ===================================================================

class RandomNormalDynamicLayerParams::_Internal {
 public:
};

RandomNormalDynamicLayerParams::RandomNormalDynamicLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.RandomNormalDynamicLayerParams)
}
RandomNormalDynamicLayerParams::RandomNormalDynamicLayerParams(const RandomNormalDynamicLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&seed_, &from.seed_,
    static_cast<size_t>(reinterpret_cast<char*>(&stddev_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(stddev_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.RandomNormalDynamicLayerParams)
}

inline void RandomNormalDynamicLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seed_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&stddev_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(stddev_));
}

RandomNormalDynamicLayerParams::~RandomNormalDynamicLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.RandomNormalDynamicLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RandomNormalDynamicLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RandomNormalDynamicLayerParams::ArenaDtor(void* object) {
  RandomNormalDynamicLayerParams* _this = reinterpret_cast< RandomNormalDynamicLayerParams* >(object);
  (void)_this;
}
void RandomNormalDynamicLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RandomNormalDynamicLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RandomNormalDynamicLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.RandomNormalDynamicLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&seed_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&stddev_) -
      reinterpret_cast<char*>(&seed_)) + sizeof(stddev_));
  _internal_metadata_.Clear<std::string>();
}

const char* RandomNormalDynamicLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 seed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float mean = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          mean_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float stdDev = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          stddev_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RandomNormalDynamicLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.RandomNormalDynamicLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_seed(), target);
  }

  // float mean = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mean = this->_internal_mean();
  uint32_t raw_mean;
  memcpy(&raw_mean, &tmp_mean, sizeof(tmp_mean));
  if (raw_mean != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_mean(), target);
  }

  // float stdDev = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_stddev = this->_internal_stddev();
  uint32_t raw_stddev;
  memcpy(&raw_stddev, &tmp_stddev, sizeof(tmp_stddev));
  if (raw_stddev != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_stddev(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.RandomNormalDynamicLayerParams)
  return target;
}

size_t RandomNormalDynamicLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.RandomNormalDynamicLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_seed());
  }

  // float mean = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mean = this->_internal_mean();
  uint32_t raw_mean;
  memcpy(&raw_mean, &tmp_mean, sizeof(tmp_mean));
  if (raw_mean != 0) {
    total_size += 1 + 4;
  }

  // float stdDev = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_stddev = this->_internal_stddev();
  uint32_t raw_stddev;
  memcpy(&raw_stddev, &tmp_stddev, sizeof(tmp_stddev));
  if (raw_stddev != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RandomNormalDynamicLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RandomNormalDynamicLayerParams*>(
      &from));
}

void RandomNormalDynamicLayerParams::MergeFrom(const RandomNormalDynamicLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.RandomNormalDynamicLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_seed() != 0) {
    _internal_set_seed(from._internal_seed());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mean = from._internal_mean();
  uint32_t raw_mean;
  memcpy(&raw_mean, &tmp_mean, sizeof(tmp_mean));
  if (raw_mean != 0) {
    _internal_set_mean(from._internal_mean());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_stddev = from._internal_stddev();
  uint32_t raw_stddev;
  memcpy(&raw_stddev, &tmp_stddev, sizeof(tmp_stddev));
  if (raw_stddev != 0) {
    _internal_set_stddev(from._internal_stddev());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RandomNormalDynamicLayerParams::CopyFrom(const RandomNormalDynamicLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.RandomNormalDynamicLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RandomNormalDynamicLayerParams::IsInitialized() const {
  return true;
}

void RandomNormalDynamicLayerParams::InternalSwap(RandomNormalDynamicLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RandomNormalDynamicLayerParams, stddev_)
      + sizeof(RandomNormalDynamicLayerParams::stddev_)
      - PROTOBUF_FIELD_OFFSET(RandomNormalDynamicLayerParams, seed_)>(
          reinterpret_cast<char*>(&seed_),
          reinterpret_cast<char*>(&other->seed_));
}

std::string RandomNormalDynamicLayerParams::GetTypeName() const {
  return "CoreML.Specification.RandomNormalDynamicLayerParams";
}


// ===================================================================

class RandomUniformLikeLayerParams::_Internal {
 public:
};

RandomUniformLikeLayerParams::RandomUniformLikeLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.RandomUniformLikeLayerParams)
}
RandomUniformLikeLayerParams::RandomUniformLikeLayerParams(const RandomUniformLikeLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&seed_, &from.seed_,
    static_cast<size_t>(reinterpret_cast<char*>(&maxval_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(maxval_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.RandomUniformLikeLayerParams)
}

inline void RandomUniformLikeLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seed_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&maxval_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(maxval_));
}

RandomUniformLikeLayerParams::~RandomUniformLikeLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.RandomUniformLikeLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RandomUniformLikeLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RandomUniformLikeLayerParams::ArenaDtor(void* object) {
  RandomUniformLikeLayerParams* _this = reinterpret_cast< RandomUniformLikeLayerParams* >(object);
  (void)_this;
}
void RandomUniformLikeLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RandomUniformLikeLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RandomUniformLikeLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.RandomUniformLikeLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&seed_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&maxval_) -
      reinterpret_cast<char*>(&seed_)) + sizeof(maxval_));
  _internal_metadata_.Clear<std::string>();
}

const char* RandomUniformLikeLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 seed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float minVal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          minval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float maxVal = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          maxval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RandomUniformLikeLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.RandomUniformLikeLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_seed(), target);
  }

  // float minVal = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_minval = this->_internal_minval();
  uint32_t raw_minval;
  memcpy(&raw_minval, &tmp_minval, sizeof(tmp_minval));
  if (raw_minval != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_minval(), target);
  }

  // float maxVal = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxval = this->_internal_maxval();
  uint32_t raw_maxval;
  memcpy(&raw_maxval, &tmp_maxval, sizeof(tmp_maxval));
  if (raw_maxval != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_maxval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.RandomUniformLikeLayerParams)
  return target;
}

size_t RandomUniformLikeLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.RandomUniformLikeLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_seed());
  }

  // float minVal = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_minval = this->_internal_minval();
  uint32_t raw_minval;
  memcpy(&raw_minval, &tmp_minval, sizeof(tmp_minval));
  if (raw_minval != 0) {
    total_size += 1 + 4;
  }

  // float maxVal = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxval = this->_internal_maxval();
  uint32_t raw_maxval;
  memcpy(&raw_maxval, &tmp_maxval, sizeof(tmp_maxval));
  if (raw_maxval != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RandomUniformLikeLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RandomUniformLikeLayerParams*>(
      &from));
}

void RandomUniformLikeLayerParams::MergeFrom(const RandomUniformLikeLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.RandomUniformLikeLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_seed() != 0) {
    _internal_set_seed(from._internal_seed());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_minval = from._internal_minval();
  uint32_t raw_minval;
  memcpy(&raw_minval, &tmp_minval, sizeof(tmp_minval));
  if (raw_minval != 0) {
    _internal_set_minval(from._internal_minval());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxval = from._internal_maxval();
  uint32_t raw_maxval;
  memcpy(&raw_maxval, &tmp_maxval, sizeof(tmp_maxval));
  if (raw_maxval != 0) {
    _internal_set_maxval(from._internal_maxval());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RandomUniformLikeLayerParams::CopyFrom(const RandomUniformLikeLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.RandomUniformLikeLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RandomUniformLikeLayerParams::IsInitialized() const {
  return true;
}

void RandomUniformLikeLayerParams::InternalSwap(RandomUniformLikeLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RandomUniformLikeLayerParams, maxval_)
      + sizeof(RandomUniformLikeLayerParams::maxval_)
      - PROTOBUF_FIELD_OFFSET(RandomUniformLikeLayerParams, seed_)>(
          reinterpret_cast<char*>(&seed_),
          reinterpret_cast<char*>(&other->seed_));
}

std::string RandomUniformLikeLayerParams::GetTypeName() const {
  return "CoreML.Specification.RandomUniformLikeLayerParams";
}


// ===================================================================

class RandomUniformStaticLayerParams::_Internal {
 public:
};

RandomUniformStaticLayerParams::RandomUniformStaticLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  outputshape_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.RandomUniformStaticLayerParams)
}
RandomUniformStaticLayerParams::RandomUniformStaticLayerParams(const RandomUniformStaticLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      outputshape_(from.outputshape_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&seed_, &from.seed_,
    static_cast<size_t>(reinterpret_cast<char*>(&maxval_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(maxval_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.RandomUniformStaticLayerParams)
}

inline void RandomUniformStaticLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seed_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&maxval_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(maxval_));
}

RandomUniformStaticLayerParams::~RandomUniformStaticLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.RandomUniformStaticLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RandomUniformStaticLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RandomUniformStaticLayerParams::ArenaDtor(void* object) {
  RandomUniformStaticLayerParams* _this = reinterpret_cast< RandomUniformStaticLayerParams* >(object);
  (void)_this;
}
void RandomUniformStaticLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RandomUniformStaticLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RandomUniformStaticLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.RandomUniformStaticLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  outputshape_.Clear();
  ::memset(&seed_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&maxval_) -
      reinterpret_cast<char*>(&seed_)) + sizeof(maxval_));
  _internal_metadata_.Clear<std::string>();
}

const char* RandomUniformStaticLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 seed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float minVal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          minval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float maxVal = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          maxval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 outputShape = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_outputshape(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_outputshape(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RandomUniformStaticLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.RandomUniformStaticLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_seed(), target);
  }

  // float minVal = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_minval = this->_internal_minval();
  uint32_t raw_minval;
  memcpy(&raw_minval, &tmp_minval, sizeof(tmp_minval));
  if (raw_minval != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_minval(), target);
  }

  // float maxVal = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxval = this->_internal_maxval();
  uint32_t raw_maxval;
  memcpy(&raw_maxval, &tmp_maxval, sizeof(tmp_maxval));
  if (raw_maxval != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_maxval(), target);
  }

  // repeated uint64 outputShape = 4;
  {
    int byte_size = _outputshape_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          4, _internal_outputshape(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.RandomUniformStaticLayerParams)
  return target;
}

size_t RandomUniformStaticLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.RandomUniformStaticLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 outputShape = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->outputshape_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _outputshape_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_seed());
  }

  // float minVal = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_minval = this->_internal_minval();
  uint32_t raw_minval;
  memcpy(&raw_minval, &tmp_minval, sizeof(tmp_minval));
  if (raw_minval != 0) {
    total_size += 1 + 4;
  }

  // float maxVal = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxval = this->_internal_maxval();
  uint32_t raw_maxval;
  memcpy(&raw_maxval, &tmp_maxval, sizeof(tmp_maxval));
  if (raw_maxval != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RandomUniformStaticLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RandomUniformStaticLayerParams*>(
      &from));
}

void RandomUniformStaticLayerParams::MergeFrom(const RandomUniformStaticLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.RandomUniformStaticLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  outputshape_.MergeFrom(from.outputshape_);
  if (from._internal_seed() != 0) {
    _internal_set_seed(from._internal_seed());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_minval = from._internal_minval();
  uint32_t raw_minval;
  memcpy(&raw_minval, &tmp_minval, sizeof(tmp_minval));
  if (raw_minval != 0) {
    _internal_set_minval(from._internal_minval());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxval = from._internal_maxval();
  uint32_t raw_maxval;
  memcpy(&raw_maxval, &tmp_maxval, sizeof(tmp_maxval));
  if (raw_maxval != 0) {
    _internal_set_maxval(from._internal_maxval());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RandomUniformStaticLayerParams::CopyFrom(const RandomUniformStaticLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.RandomUniformStaticLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RandomUniformStaticLayerParams::IsInitialized() const {
  return true;
}

void RandomUniformStaticLayerParams::InternalSwap(RandomUniformStaticLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  outputshape_.InternalSwap(&other->outputshape_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RandomUniformStaticLayerParams, maxval_)
      + sizeof(RandomUniformStaticLayerParams::maxval_)
      - PROTOBUF_FIELD_OFFSET(RandomUniformStaticLayerParams, seed_)>(
          reinterpret_cast<char*>(&seed_),
          reinterpret_cast<char*>(&other->seed_));
}

std::string RandomUniformStaticLayerParams::GetTypeName() const {
  return "CoreML.Specification.RandomUniformStaticLayerParams";
}


// ===================================================================

class RandomUniformDynamicLayerParams::_Internal {
 public:
};

RandomUniformDynamicLayerParams::RandomUniformDynamicLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.RandomUniformDynamicLayerParams)
}
RandomUniformDynamicLayerParams::RandomUniformDynamicLayerParams(const RandomUniformDynamicLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&seed_, &from.seed_,
    static_cast<size_t>(reinterpret_cast<char*>(&maxval_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(maxval_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.RandomUniformDynamicLayerParams)
}

inline void RandomUniformDynamicLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seed_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&maxval_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(maxval_));
}

RandomUniformDynamicLayerParams::~RandomUniformDynamicLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.RandomUniformDynamicLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RandomUniformDynamicLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RandomUniformDynamicLayerParams::ArenaDtor(void* object) {
  RandomUniformDynamicLayerParams* _this = reinterpret_cast< RandomUniformDynamicLayerParams* >(object);
  (void)_this;
}
void RandomUniformDynamicLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RandomUniformDynamicLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RandomUniformDynamicLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.RandomUniformDynamicLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&seed_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&maxval_) -
      reinterpret_cast<char*>(&seed_)) + sizeof(maxval_));
  _internal_metadata_.Clear<std::string>();
}

const char* RandomUniformDynamicLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 seed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float minVal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          minval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float maxVal = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          maxval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RandomUniformDynamicLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.RandomUniformDynamicLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_seed(), target);
  }

  // float minVal = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_minval = this->_internal_minval();
  uint32_t raw_minval;
  memcpy(&raw_minval, &tmp_minval, sizeof(tmp_minval));
  if (raw_minval != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_minval(), target);
  }

  // float maxVal = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxval = this->_internal_maxval();
  uint32_t raw_maxval;
  memcpy(&raw_maxval, &tmp_maxval, sizeof(tmp_maxval));
  if (raw_maxval != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_maxval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.RandomUniformDynamicLayerParams)
  return target;
}

size_t RandomUniformDynamicLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.RandomUniformDynamicLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_seed());
  }

  // float minVal = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_minval = this->_internal_minval();
  uint32_t raw_minval;
  memcpy(&raw_minval, &tmp_minval, sizeof(tmp_minval));
  if (raw_minval != 0) {
    total_size += 1 + 4;
  }

  // float maxVal = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxval = this->_internal_maxval();
  uint32_t raw_maxval;
  memcpy(&raw_maxval, &tmp_maxval, sizeof(tmp_maxval));
  if (raw_maxval != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RandomUniformDynamicLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RandomUniformDynamicLayerParams*>(
      &from));
}

void RandomUniformDynamicLayerParams::MergeFrom(const RandomUniformDynamicLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.RandomUniformDynamicLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_seed() != 0) {
    _internal_set_seed(from._internal_seed());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_minval = from._internal_minval();
  uint32_t raw_minval;
  memcpy(&raw_minval, &tmp_minval, sizeof(tmp_minval));
  if (raw_minval != 0) {
    _internal_set_minval(from._internal_minval());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxval = from._internal_maxval();
  uint32_t raw_maxval;
  memcpy(&raw_maxval, &tmp_maxval, sizeof(tmp_maxval));
  if (raw_maxval != 0) {
    _internal_set_maxval(from._internal_maxval());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RandomUniformDynamicLayerParams::CopyFrom(const RandomUniformDynamicLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.RandomUniformDynamicLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RandomUniformDynamicLayerParams::IsInitialized() const {
  return true;
}

void RandomUniformDynamicLayerParams::InternalSwap(RandomUniformDynamicLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RandomUniformDynamicLayerParams, maxval_)
      + sizeof(RandomUniformDynamicLayerParams::maxval_)
      - PROTOBUF_FIELD_OFFSET(RandomUniformDynamicLayerParams, seed_)>(
          reinterpret_cast<char*>(&seed_),
          reinterpret_cast<char*>(&other->seed_));
}

std::string RandomUniformDynamicLayerParams::GetTypeName() const {
  return "CoreML.Specification.RandomUniformDynamicLayerParams";
}


// ===================================================================

class RandomBernoulliLikeLayerParams::_Internal {
 public:
};

RandomBernoulliLikeLayerParams::RandomBernoulliLikeLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.RandomBernoulliLikeLayerParams)
}
RandomBernoulliLikeLayerParams::RandomBernoulliLikeLayerParams(const RandomBernoulliLikeLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&seed_, &from.seed_,
    static_cast<size_t>(reinterpret_cast<char*>(&prob_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(prob_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.RandomBernoulliLikeLayerParams)
}

inline void RandomBernoulliLikeLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seed_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&prob_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(prob_));
}

RandomBernoulliLikeLayerParams::~RandomBernoulliLikeLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.RandomBernoulliLikeLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RandomBernoulliLikeLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RandomBernoulliLikeLayerParams::ArenaDtor(void* object) {
  RandomBernoulliLikeLayerParams* _this = reinterpret_cast< RandomBernoulliLikeLayerParams* >(object);
  (void)_this;
}
void RandomBernoulliLikeLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RandomBernoulliLikeLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RandomBernoulliLikeLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.RandomBernoulliLikeLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&seed_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&prob_) -
      reinterpret_cast<char*>(&seed_)) + sizeof(prob_));
  _internal_metadata_.Clear<std::string>();
}

const char* RandomBernoulliLikeLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 seed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float prob = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          prob_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RandomBernoulliLikeLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.RandomBernoulliLikeLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_seed(), target);
  }

  // float prob = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_prob = this->_internal_prob();
  uint32_t raw_prob;
  memcpy(&raw_prob, &tmp_prob, sizeof(tmp_prob));
  if (raw_prob != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_prob(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.RandomBernoulliLikeLayerParams)
  return target;
}

size_t RandomBernoulliLikeLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.RandomBernoulliLikeLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_seed());
  }

  // float prob = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_prob = this->_internal_prob();
  uint32_t raw_prob;
  memcpy(&raw_prob, &tmp_prob, sizeof(tmp_prob));
  if (raw_prob != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RandomBernoulliLikeLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RandomBernoulliLikeLayerParams*>(
      &from));
}

void RandomBernoulliLikeLayerParams::MergeFrom(const RandomBernoulliLikeLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.RandomBernoulliLikeLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_seed() != 0) {
    _internal_set_seed(from._internal_seed());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_prob = from._internal_prob();
  uint32_t raw_prob;
  memcpy(&raw_prob, &tmp_prob, sizeof(tmp_prob));
  if (raw_prob != 0) {
    _internal_set_prob(from._internal_prob());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RandomBernoulliLikeLayerParams::CopyFrom(const RandomBernoulliLikeLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.RandomBernoulliLikeLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RandomBernoulliLikeLayerParams::IsInitialized() const {
  return true;
}

void RandomBernoulliLikeLayerParams::InternalSwap(RandomBernoulliLikeLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RandomBernoulliLikeLayerParams, prob_)
      + sizeof(RandomBernoulliLikeLayerParams::prob_)
      - PROTOBUF_FIELD_OFFSET(RandomBernoulliLikeLayerParams, seed_)>(
          reinterpret_cast<char*>(&seed_),
          reinterpret_cast<char*>(&other->seed_));
}

std::string RandomBernoulliLikeLayerParams::GetTypeName() const {
  return "CoreML.Specification.RandomBernoulliLikeLayerParams";
}


// ===================================================================

class RandomBernoulliStaticLayerParams::_Internal {
 public:
};

RandomBernoulliStaticLayerParams::RandomBernoulliStaticLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  outputshape_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.RandomBernoulliStaticLayerParams)
}
RandomBernoulliStaticLayerParams::RandomBernoulliStaticLayerParams(const RandomBernoulliStaticLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      outputshape_(from.outputshape_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&seed_, &from.seed_,
    static_cast<size_t>(reinterpret_cast<char*>(&prob_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(prob_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.RandomBernoulliStaticLayerParams)
}

inline void RandomBernoulliStaticLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seed_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&prob_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(prob_));
}

RandomBernoulliStaticLayerParams::~RandomBernoulliStaticLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.RandomBernoulliStaticLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RandomBernoulliStaticLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RandomBernoulliStaticLayerParams::ArenaDtor(void* object) {
  RandomBernoulliStaticLayerParams* _this = reinterpret_cast< RandomBernoulliStaticLayerParams* >(object);
  (void)_this;
}
void RandomBernoulliStaticLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RandomBernoulliStaticLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RandomBernoulliStaticLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.RandomBernoulliStaticLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  outputshape_.Clear();
  ::memset(&seed_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&prob_) -
      reinterpret_cast<char*>(&seed_)) + sizeof(prob_));
  _internal_metadata_.Clear<std::string>();
}

const char* RandomBernoulliStaticLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 seed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float prob = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          prob_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 outputShape = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_outputshape(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_outputshape(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RandomBernoulliStaticLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.RandomBernoulliStaticLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_seed(), target);
  }

  // float prob = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_prob = this->_internal_prob();
  uint32_t raw_prob;
  memcpy(&raw_prob, &tmp_prob, sizeof(tmp_prob));
  if (raw_prob != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_prob(), target);
  }

  // repeated uint64 outputShape = 3;
  {
    int byte_size = _outputshape_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          3, _internal_outputshape(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.RandomBernoulliStaticLayerParams)
  return target;
}

size_t RandomBernoulliStaticLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.RandomBernoulliStaticLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 outputShape = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->outputshape_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _outputshape_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_seed());
  }

  // float prob = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_prob = this->_internal_prob();
  uint32_t raw_prob;
  memcpy(&raw_prob, &tmp_prob, sizeof(tmp_prob));
  if (raw_prob != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RandomBernoulliStaticLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RandomBernoulliStaticLayerParams*>(
      &from));
}

void RandomBernoulliStaticLayerParams::MergeFrom(const RandomBernoulliStaticLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.RandomBernoulliStaticLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  outputshape_.MergeFrom(from.outputshape_);
  if (from._internal_seed() != 0) {
    _internal_set_seed(from._internal_seed());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_prob = from._internal_prob();
  uint32_t raw_prob;
  memcpy(&raw_prob, &tmp_prob, sizeof(tmp_prob));
  if (raw_prob != 0) {
    _internal_set_prob(from._internal_prob());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RandomBernoulliStaticLayerParams::CopyFrom(const RandomBernoulliStaticLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.RandomBernoulliStaticLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RandomBernoulliStaticLayerParams::IsInitialized() const {
  return true;
}

void RandomBernoulliStaticLayerParams::InternalSwap(RandomBernoulliStaticLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  outputshape_.InternalSwap(&other->outputshape_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RandomBernoulliStaticLayerParams, prob_)
      + sizeof(RandomBernoulliStaticLayerParams::prob_)
      - PROTOBUF_FIELD_OFFSET(RandomBernoulliStaticLayerParams, seed_)>(
          reinterpret_cast<char*>(&seed_),
          reinterpret_cast<char*>(&other->seed_));
}

std::string RandomBernoulliStaticLayerParams::GetTypeName() const {
  return "CoreML.Specification.RandomBernoulliStaticLayerParams";
}


// ===================================================================

class RandomBernoulliDynamicLayerParams::_Internal {
 public:
};

RandomBernoulliDynamicLayerParams::RandomBernoulliDynamicLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.RandomBernoulliDynamicLayerParams)
}
RandomBernoulliDynamicLayerParams::RandomBernoulliDynamicLayerParams(const RandomBernoulliDynamicLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&seed_, &from.seed_,
    static_cast<size_t>(reinterpret_cast<char*>(&prob_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(prob_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.RandomBernoulliDynamicLayerParams)
}

inline void RandomBernoulliDynamicLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seed_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&prob_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(prob_));
}

RandomBernoulliDynamicLayerParams::~RandomBernoulliDynamicLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.RandomBernoulliDynamicLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RandomBernoulliDynamicLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RandomBernoulliDynamicLayerParams::ArenaDtor(void* object) {
  RandomBernoulliDynamicLayerParams* _this = reinterpret_cast< RandomBernoulliDynamicLayerParams* >(object);
  (void)_this;
}
void RandomBernoulliDynamicLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RandomBernoulliDynamicLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RandomBernoulliDynamicLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.RandomBernoulliDynamicLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&seed_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&prob_) -
      reinterpret_cast<char*>(&seed_)) + sizeof(prob_));
  _internal_metadata_.Clear<std::string>();
}

const char* RandomBernoulliDynamicLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 seed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float prob = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          prob_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RandomBernoulliDynamicLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.RandomBernoulliDynamicLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_seed(), target);
  }

  // float prob = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_prob = this->_internal_prob();
  uint32_t raw_prob;
  memcpy(&raw_prob, &tmp_prob, sizeof(tmp_prob));
  if (raw_prob != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_prob(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.RandomBernoulliDynamicLayerParams)
  return target;
}

size_t RandomBernoulliDynamicLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.RandomBernoulliDynamicLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_seed());
  }

  // float prob = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_prob = this->_internal_prob();
  uint32_t raw_prob;
  memcpy(&raw_prob, &tmp_prob, sizeof(tmp_prob));
  if (raw_prob != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RandomBernoulliDynamicLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RandomBernoulliDynamicLayerParams*>(
      &from));
}

void RandomBernoulliDynamicLayerParams::MergeFrom(const RandomBernoulliDynamicLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.RandomBernoulliDynamicLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_seed() != 0) {
    _internal_set_seed(from._internal_seed());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_prob = from._internal_prob();
  uint32_t raw_prob;
  memcpy(&raw_prob, &tmp_prob, sizeof(tmp_prob));
  if (raw_prob != 0) {
    _internal_set_prob(from._internal_prob());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RandomBernoulliDynamicLayerParams::CopyFrom(const RandomBernoulliDynamicLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.RandomBernoulliDynamicLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RandomBernoulliDynamicLayerParams::IsInitialized() const {
  return true;
}

void RandomBernoulliDynamicLayerParams::InternalSwap(RandomBernoulliDynamicLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RandomBernoulliDynamicLayerParams, prob_)
      + sizeof(RandomBernoulliDynamicLayerParams::prob_)
      - PROTOBUF_FIELD_OFFSET(RandomBernoulliDynamicLayerParams, seed_)>(
          reinterpret_cast<char*>(&seed_),
          reinterpret_cast<char*>(&other->seed_));
}

std::string RandomBernoulliDynamicLayerParams::GetTypeName() const {
  return "CoreML.Specification.RandomBernoulliDynamicLayerParams";
}


// ===================================================================

class CategoricalDistributionLayerParams::_Internal {
 public:
};

CategoricalDistributionLayerParams::CategoricalDistributionLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.CategoricalDistributionLayerParams)
}
CategoricalDistributionLayerParams::CategoricalDistributionLayerParams(const CategoricalDistributionLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&seed_, &from.seed_,
    static_cast<size_t>(reinterpret_cast<char*>(&temperature_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(temperature_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.CategoricalDistributionLayerParams)
}

inline void CategoricalDistributionLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seed_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&temperature_) -
    reinterpret_cast<char*>(&seed_)) + sizeof(temperature_));
}

CategoricalDistributionLayerParams::~CategoricalDistributionLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.CategoricalDistributionLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CategoricalDistributionLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CategoricalDistributionLayerParams::ArenaDtor(void* object) {
  CategoricalDistributionLayerParams* _this = reinterpret_cast< CategoricalDistributionLayerParams* >(object);
  (void)_this;
}
void CategoricalDistributionLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CategoricalDistributionLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CategoricalDistributionLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.CategoricalDistributionLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&seed_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&temperature_) -
      reinterpret_cast<char*>(&seed_)) + sizeof(temperature_));
  _internal_metadata_.Clear<std::string>();
}

const char* CategoricalDistributionLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 seed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 numSamples = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          numsamples_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isLogits = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          islogits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float eps = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          eps_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float temperature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          temperature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CategoricalDistributionLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.CategoricalDistributionLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_seed(), target);
  }

  // int64 numSamples = 2;
  if (this->_internal_numsamples() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_numsamples(), target);
  }

  // bool isLogits = 3;
  if (this->_internal_islogits() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_islogits(), target);
  }

  // float eps = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eps = this->_internal_eps();
  uint32_t raw_eps;
  memcpy(&raw_eps, &tmp_eps, sizeof(tmp_eps));
  if (raw_eps != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_eps(), target);
  }

  // float temperature = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_temperature = this->_internal_temperature();
  uint32_t raw_temperature;
  memcpy(&raw_temperature, &tmp_temperature, sizeof(tmp_temperature));
  if (raw_temperature != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_temperature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.CategoricalDistributionLayerParams)
  return target;
}

size_t CategoricalDistributionLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.CategoricalDistributionLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 seed = 1;
  if (this->_internal_seed() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_seed());
  }

  // int64 numSamples = 2;
  if (this->_internal_numsamples() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_numsamples());
  }

  // bool isLogits = 3;
  if (this->_internal_islogits() != 0) {
    total_size += 1 + 1;
  }

  // float eps = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eps = this->_internal_eps();
  uint32_t raw_eps;
  memcpy(&raw_eps, &tmp_eps, sizeof(tmp_eps));
  if (raw_eps != 0) {
    total_size += 1 + 4;
  }

  // float temperature = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_temperature = this->_internal_temperature();
  uint32_t raw_temperature;
  memcpy(&raw_temperature, &tmp_temperature, sizeof(tmp_temperature));
  if (raw_temperature != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CategoricalDistributionLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CategoricalDistributionLayerParams*>(
      &from));
}

void CategoricalDistributionLayerParams::MergeFrom(const CategoricalDistributionLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.CategoricalDistributionLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_seed() != 0) {
    _internal_set_seed(from._internal_seed());
  }
  if (from._internal_numsamples() != 0) {
    _internal_set_numsamples(from._internal_numsamples());
  }
  if (from._internal_islogits() != 0) {
    _internal_set_islogits(from._internal_islogits());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eps = from._internal_eps();
  uint32_t raw_eps;
  memcpy(&raw_eps, &tmp_eps, sizeof(tmp_eps));
  if (raw_eps != 0) {
    _internal_set_eps(from._internal_eps());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_temperature = from._internal_temperature();
  uint32_t raw_temperature;
  memcpy(&raw_temperature, &tmp_temperature, sizeof(tmp_temperature));
  if (raw_temperature != 0) {
    _internal_set_temperature(from._internal_temperature());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CategoricalDistributionLayerParams::CopyFrom(const CategoricalDistributionLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.CategoricalDistributionLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CategoricalDistributionLayerParams::IsInitialized() const {
  return true;
}

void CategoricalDistributionLayerParams::InternalSwap(CategoricalDistributionLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CategoricalDistributionLayerParams, temperature_)
      + sizeof(CategoricalDistributionLayerParams::temperature_)
      - PROTOBUF_FIELD_OFFSET(CategoricalDistributionLayerParams, seed_)>(
          reinterpret_cast<char*>(&seed_),
          reinterpret_cast<char*>(&other->seed_));
}

std::string CategoricalDistributionLayerParams::GetTypeName() const {
  return "CoreML.Specification.CategoricalDistributionLayerParams";
}


// ===================================================================

class ReduceL1LayerParams::_Internal {
 public:
};

ReduceL1LayerParams::ReduceL1LayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  axes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ReduceL1LayerParams)
}
ReduceL1LayerParams::ReduceL1LayerParams(const ReduceL1LayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      axes_(from.axes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&keepdims_, &from.keepdims_,
    static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ReduceL1LayerParams)
}

inline void ReduceL1LayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&keepdims_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
}

ReduceL1LayerParams::~ReduceL1LayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ReduceL1LayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReduceL1LayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReduceL1LayerParams::ArenaDtor(void* object) {
  ReduceL1LayerParams* _this = reinterpret_cast< ReduceL1LayerParams* >(object);
  (void)_this;
}
void ReduceL1LayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReduceL1LayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReduceL1LayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ReduceL1LayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axes_.Clear();
  ::memset(&keepdims_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reduceall_) -
      reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  _internal_metadata_.Clear<std::string>();
}

const char* ReduceL1LayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 axes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_axes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_axes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool keepDims = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          keepdims_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reduceAll = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          reduceall_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReduceL1LayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ReduceL1LayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    int byte_size = _axes_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_axes(), byte_size, target);
    }
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_keepdims(), target);
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_reduceall(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ReduceL1LayerParams)
  return target;
}

size_t ReduceL1LayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ReduceL1LayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->axes_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _axes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    total_size += 1 + 1;
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReduceL1LayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReduceL1LayerParams*>(
      &from));
}

void ReduceL1LayerParams::MergeFrom(const ReduceL1LayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ReduceL1LayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  axes_.MergeFrom(from.axes_);
  if (from._internal_keepdims() != 0) {
    _internal_set_keepdims(from._internal_keepdims());
  }
  if (from._internal_reduceall() != 0) {
    _internal_set_reduceall(from._internal_reduceall());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReduceL1LayerParams::CopyFrom(const ReduceL1LayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ReduceL1LayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReduceL1LayerParams::IsInitialized() const {
  return true;
}

void ReduceL1LayerParams::InternalSwap(ReduceL1LayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  axes_.InternalSwap(&other->axes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReduceL1LayerParams, reduceall_)
      + sizeof(ReduceL1LayerParams::reduceall_)
      - PROTOBUF_FIELD_OFFSET(ReduceL1LayerParams, keepdims_)>(
          reinterpret_cast<char*>(&keepdims_),
          reinterpret_cast<char*>(&other->keepdims_));
}

std::string ReduceL1LayerParams::GetTypeName() const {
  return "CoreML.Specification.ReduceL1LayerParams";
}


// ===================================================================

class ReduceL2LayerParams::_Internal {
 public:
};

ReduceL2LayerParams::ReduceL2LayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  axes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ReduceL2LayerParams)
}
ReduceL2LayerParams::ReduceL2LayerParams(const ReduceL2LayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      axes_(from.axes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&keepdims_, &from.keepdims_,
    static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ReduceL2LayerParams)
}

inline void ReduceL2LayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&keepdims_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
}

ReduceL2LayerParams::~ReduceL2LayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ReduceL2LayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReduceL2LayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReduceL2LayerParams::ArenaDtor(void* object) {
  ReduceL2LayerParams* _this = reinterpret_cast< ReduceL2LayerParams* >(object);
  (void)_this;
}
void ReduceL2LayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReduceL2LayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReduceL2LayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ReduceL2LayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axes_.Clear();
  ::memset(&keepdims_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reduceall_) -
      reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  _internal_metadata_.Clear<std::string>();
}

const char* ReduceL2LayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 axes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_axes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_axes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool keepDims = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          keepdims_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reduceAll = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          reduceall_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReduceL2LayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ReduceL2LayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    int byte_size = _axes_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_axes(), byte_size, target);
    }
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_keepdims(), target);
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_reduceall(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ReduceL2LayerParams)
  return target;
}

size_t ReduceL2LayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ReduceL2LayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->axes_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _axes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    total_size += 1 + 1;
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReduceL2LayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReduceL2LayerParams*>(
      &from));
}

void ReduceL2LayerParams::MergeFrom(const ReduceL2LayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ReduceL2LayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  axes_.MergeFrom(from.axes_);
  if (from._internal_keepdims() != 0) {
    _internal_set_keepdims(from._internal_keepdims());
  }
  if (from._internal_reduceall() != 0) {
    _internal_set_reduceall(from._internal_reduceall());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReduceL2LayerParams::CopyFrom(const ReduceL2LayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ReduceL2LayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReduceL2LayerParams::IsInitialized() const {
  return true;
}

void ReduceL2LayerParams::InternalSwap(ReduceL2LayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  axes_.InternalSwap(&other->axes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReduceL2LayerParams, reduceall_)
      + sizeof(ReduceL2LayerParams::reduceall_)
      - PROTOBUF_FIELD_OFFSET(ReduceL2LayerParams, keepdims_)>(
          reinterpret_cast<char*>(&keepdims_),
          reinterpret_cast<char*>(&other->keepdims_));
}

std::string ReduceL2LayerParams::GetTypeName() const {
  return "CoreML.Specification.ReduceL2LayerParams";
}


// ===================================================================

class ReduceMaxLayerParams::_Internal {
 public:
};

ReduceMaxLayerParams::ReduceMaxLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  axes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ReduceMaxLayerParams)
}
ReduceMaxLayerParams::ReduceMaxLayerParams(const ReduceMaxLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      axes_(from.axes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&keepdims_, &from.keepdims_,
    static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ReduceMaxLayerParams)
}

inline void ReduceMaxLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&keepdims_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
}

ReduceMaxLayerParams::~ReduceMaxLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ReduceMaxLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReduceMaxLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReduceMaxLayerParams::ArenaDtor(void* object) {
  ReduceMaxLayerParams* _this = reinterpret_cast< ReduceMaxLayerParams* >(object);
  (void)_this;
}
void ReduceMaxLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReduceMaxLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReduceMaxLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ReduceMaxLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axes_.Clear();
  ::memset(&keepdims_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reduceall_) -
      reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  _internal_metadata_.Clear<std::string>();
}

const char* ReduceMaxLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 axes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_axes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_axes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool keepDims = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          keepdims_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reduceAll = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          reduceall_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReduceMaxLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ReduceMaxLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    int byte_size = _axes_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_axes(), byte_size, target);
    }
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_keepdims(), target);
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_reduceall(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ReduceMaxLayerParams)
  return target;
}

size_t ReduceMaxLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ReduceMaxLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->axes_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _axes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    total_size += 1 + 1;
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReduceMaxLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReduceMaxLayerParams*>(
      &from));
}

void ReduceMaxLayerParams::MergeFrom(const ReduceMaxLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ReduceMaxLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  axes_.MergeFrom(from.axes_);
  if (from._internal_keepdims() != 0) {
    _internal_set_keepdims(from._internal_keepdims());
  }
  if (from._internal_reduceall() != 0) {
    _internal_set_reduceall(from._internal_reduceall());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReduceMaxLayerParams::CopyFrom(const ReduceMaxLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ReduceMaxLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReduceMaxLayerParams::IsInitialized() const {
  return true;
}

void ReduceMaxLayerParams::InternalSwap(ReduceMaxLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  axes_.InternalSwap(&other->axes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReduceMaxLayerParams, reduceall_)
      + sizeof(ReduceMaxLayerParams::reduceall_)
      - PROTOBUF_FIELD_OFFSET(ReduceMaxLayerParams, keepdims_)>(
          reinterpret_cast<char*>(&keepdims_),
          reinterpret_cast<char*>(&other->keepdims_));
}

std::string ReduceMaxLayerParams::GetTypeName() const {
  return "CoreML.Specification.ReduceMaxLayerParams";
}


// ===================================================================

class ReduceMinLayerParams::_Internal {
 public:
};

ReduceMinLayerParams::ReduceMinLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  axes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ReduceMinLayerParams)
}
ReduceMinLayerParams::ReduceMinLayerParams(const ReduceMinLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      axes_(from.axes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&keepdims_, &from.keepdims_,
    static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ReduceMinLayerParams)
}

inline void ReduceMinLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&keepdims_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
}

ReduceMinLayerParams::~ReduceMinLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ReduceMinLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReduceMinLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReduceMinLayerParams::ArenaDtor(void* object) {
  ReduceMinLayerParams* _this = reinterpret_cast< ReduceMinLayerParams* >(object);
  (void)_this;
}
void ReduceMinLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReduceMinLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReduceMinLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ReduceMinLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axes_.Clear();
  ::memset(&keepdims_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reduceall_) -
      reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  _internal_metadata_.Clear<std::string>();
}

const char* ReduceMinLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 axes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_axes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_axes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool keepDims = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          keepdims_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reduceAll = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          reduceall_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReduceMinLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ReduceMinLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    int byte_size = _axes_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_axes(), byte_size, target);
    }
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_keepdims(), target);
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_reduceall(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ReduceMinLayerParams)
  return target;
}

size_t ReduceMinLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ReduceMinLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->axes_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _axes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    total_size += 1 + 1;
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReduceMinLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReduceMinLayerParams*>(
      &from));
}

void ReduceMinLayerParams::MergeFrom(const ReduceMinLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ReduceMinLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  axes_.MergeFrom(from.axes_);
  if (from._internal_keepdims() != 0) {
    _internal_set_keepdims(from._internal_keepdims());
  }
  if (from._internal_reduceall() != 0) {
    _internal_set_reduceall(from._internal_reduceall());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReduceMinLayerParams::CopyFrom(const ReduceMinLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ReduceMinLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReduceMinLayerParams::IsInitialized() const {
  return true;
}

void ReduceMinLayerParams::InternalSwap(ReduceMinLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  axes_.InternalSwap(&other->axes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReduceMinLayerParams, reduceall_)
      + sizeof(ReduceMinLayerParams::reduceall_)
      - PROTOBUF_FIELD_OFFSET(ReduceMinLayerParams, keepdims_)>(
          reinterpret_cast<char*>(&keepdims_),
          reinterpret_cast<char*>(&other->keepdims_));
}

std::string ReduceMinLayerParams::GetTypeName() const {
  return "CoreML.Specification.ReduceMinLayerParams";
}


// ===================================================================

class ReduceSumLayerParams::_Internal {
 public:
};

ReduceSumLayerParams::ReduceSumLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  axes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ReduceSumLayerParams)
}
ReduceSumLayerParams::ReduceSumLayerParams(const ReduceSumLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      axes_(from.axes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&keepdims_, &from.keepdims_,
    static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ReduceSumLayerParams)
}

inline void ReduceSumLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&keepdims_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
}

ReduceSumLayerParams::~ReduceSumLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ReduceSumLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReduceSumLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReduceSumLayerParams::ArenaDtor(void* object) {
  ReduceSumLayerParams* _this = reinterpret_cast< ReduceSumLayerParams* >(object);
  (void)_this;
}
void ReduceSumLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReduceSumLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReduceSumLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ReduceSumLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axes_.Clear();
  ::memset(&keepdims_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reduceall_) -
      reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  _internal_metadata_.Clear<std::string>();
}

const char* ReduceSumLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 axes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_axes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_axes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool keepDims = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          keepdims_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reduceAll = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          reduceall_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReduceSumLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ReduceSumLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    int byte_size = _axes_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_axes(), byte_size, target);
    }
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_keepdims(), target);
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_reduceall(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ReduceSumLayerParams)
  return target;
}

size_t ReduceSumLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ReduceSumLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->axes_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _axes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    total_size += 1 + 1;
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReduceSumLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReduceSumLayerParams*>(
      &from));
}

void ReduceSumLayerParams::MergeFrom(const ReduceSumLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ReduceSumLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  axes_.MergeFrom(from.axes_);
  if (from._internal_keepdims() != 0) {
    _internal_set_keepdims(from._internal_keepdims());
  }
  if (from._internal_reduceall() != 0) {
    _internal_set_reduceall(from._internal_reduceall());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReduceSumLayerParams::CopyFrom(const ReduceSumLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ReduceSumLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReduceSumLayerParams::IsInitialized() const {
  return true;
}

void ReduceSumLayerParams::InternalSwap(ReduceSumLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  axes_.InternalSwap(&other->axes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReduceSumLayerParams, reduceall_)
      + sizeof(ReduceSumLayerParams::reduceall_)
      - PROTOBUF_FIELD_OFFSET(ReduceSumLayerParams, keepdims_)>(
          reinterpret_cast<char*>(&keepdims_),
          reinterpret_cast<char*>(&other->keepdims_));
}

std::string ReduceSumLayerParams::GetTypeName() const {
  return "CoreML.Specification.ReduceSumLayerParams";
}


// ===================================================================

class ReduceProdLayerParams::_Internal {
 public:
};

ReduceProdLayerParams::ReduceProdLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  axes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ReduceProdLayerParams)
}
ReduceProdLayerParams::ReduceProdLayerParams(const ReduceProdLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      axes_(from.axes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&keepdims_, &from.keepdims_,
    static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ReduceProdLayerParams)
}

inline void ReduceProdLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&keepdims_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
}

ReduceProdLayerParams::~ReduceProdLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ReduceProdLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReduceProdLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReduceProdLayerParams::ArenaDtor(void* object) {
  ReduceProdLayerParams* _this = reinterpret_cast< ReduceProdLayerParams* >(object);
  (void)_this;
}
void ReduceProdLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReduceProdLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReduceProdLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ReduceProdLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axes_.Clear();
  ::memset(&keepdims_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reduceall_) -
      reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  _internal_metadata_.Clear<std::string>();
}

const char* ReduceProdLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 axes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_axes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_axes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool keepDims = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          keepdims_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reduceAll = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          reduceall_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReduceProdLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ReduceProdLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    int byte_size = _axes_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_axes(), byte_size, target);
    }
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_keepdims(), target);
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_reduceall(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ReduceProdLayerParams)
  return target;
}

size_t ReduceProdLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ReduceProdLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->axes_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _axes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    total_size += 1 + 1;
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReduceProdLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReduceProdLayerParams*>(
      &from));
}

void ReduceProdLayerParams::MergeFrom(const ReduceProdLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ReduceProdLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  axes_.MergeFrom(from.axes_);
  if (from._internal_keepdims() != 0) {
    _internal_set_keepdims(from._internal_keepdims());
  }
  if (from._internal_reduceall() != 0) {
    _internal_set_reduceall(from._internal_reduceall());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReduceProdLayerParams::CopyFrom(const ReduceProdLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ReduceProdLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReduceProdLayerParams::IsInitialized() const {
  return true;
}

void ReduceProdLayerParams::InternalSwap(ReduceProdLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  axes_.InternalSwap(&other->axes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReduceProdLayerParams, reduceall_)
      + sizeof(ReduceProdLayerParams::reduceall_)
      - PROTOBUF_FIELD_OFFSET(ReduceProdLayerParams, keepdims_)>(
          reinterpret_cast<char*>(&keepdims_),
          reinterpret_cast<char*>(&other->keepdims_));
}

std::string ReduceProdLayerParams::GetTypeName() const {
  return "CoreML.Specification.ReduceProdLayerParams";
}


// ===================================================================

class ReduceMeanLayerParams::_Internal {
 public:
};

ReduceMeanLayerParams::ReduceMeanLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  axes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ReduceMeanLayerParams)
}
ReduceMeanLayerParams::ReduceMeanLayerParams(const ReduceMeanLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      axes_(from.axes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&keepdims_, &from.keepdims_,
    static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ReduceMeanLayerParams)
}

inline void ReduceMeanLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&keepdims_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
}

ReduceMeanLayerParams::~ReduceMeanLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ReduceMeanLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReduceMeanLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReduceMeanLayerParams::ArenaDtor(void* object) {
  ReduceMeanLayerParams* _this = reinterpret_cast< ReduceMeanLayerParams* >(object);
  (void)_this;
}
void ReduceMeanLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReduceMeanLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReduceMeanLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ReduceMeanLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axes_.Clear();
  ::memset(&keepdims_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reduceall_) -
      reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  _internal_metadata_.Clear<std::string>();
}

const char* ReduceMeanLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 axes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_axes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_axes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool keepDims = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          keepdims_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reduceAll = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          reduceall_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReduceMeanLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ReduceMeanLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    int byte_size = _axes_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_axes(), byte_size, target);
    }
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_keepdims(), target);
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_reduceall(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ReduceMeanLayerParams)
  return target;
}

size_t ReduceMeanLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ReduceMeanLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->axes_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _axes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    total_size += 1 + 1;
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReduceMeanLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReduceMeanLayerParams*>(
      &from));
}

void ReduceMeanLayerParams::MergeFrom(const ReduceMeanLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ReduceMeanLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  axes_.MergeFrom(from.axes_);
  if (from._internal_keepdims() != 0) {
    _internal_set_keepdims(from._internal_keepdims());
  }
  if (from._internal_reduceall() != 0) {
    _internal_set_reduceall(from._internal_reduceall());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReduceMeanLayerParams::CopyFrom(const ReduceMeanLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ReduceMeanLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReduceMeanLayerParams::IsInitialized() const {
  return true;
}

void ReduceMeanLayerParams::InternalSwap(ReduceMeanLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  axes_.InternalSwap(&other->axes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReduceMeanLayerParams, reduceall_)
      + sizeof(ReduceMeanLayerParams::reduceall_)
      - PROTOBUF_FIELD_OFFSET(ReduceMeanLayerParams, keepdims_)>(
          reinterpret_cast<char*>(&keepdims_),
          reinterpret_cast<char*>(&other->keepdims_));
}

std::string ReduceMeanLayerParams::GetTypeName() const {
  return "CoreML.Specification.ReduceMeanLayerParams";
}


// ===================================================================

class ReduceLogSumLayerParams::_Internal {
 public:
};

ReduceLogSumLayerParams::ReduceLogSumLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  axes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ReduceLogSumLayerParams)
}
ReduceLogSumLayerParams::ReduceLogSumLayerParams(const ReduceLogSumLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      axes_(from.axes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&keepdims_, &from.keepdims_,
    static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ReduceLogSumLayerParams)
}

inline void ReduceLogSumLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&keepdims_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
}

ReduceLogSumLayerParams::~ReduceLogSumLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ReduceLogSumLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReduceLogSumLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReduceLogSumLayerParams::ArenaDtor(void* object) {
  ReduceLogSumLayerParams* _this = reinterpret_cast< ReduceLogSumLayerParams* >(object);
  (void)_this;
}
void ReduceLogSumLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReduceLogSumLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReduceLogSumLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ReduceLogSumLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axes_.Clear();
  ::memset(&keepdims_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reduceall_) -
      reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  _internal_metadata_.Clear<std::string>();
}

const char* ReduceLogSumLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 axes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_axes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_axes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool keepDims = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          keepdims_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reduceAll = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          reduceall_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReduceLogSumLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ReduceLogSumLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    int byte_size = _axes_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_axes(), byte_size, target);
    }
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_keepdims(), target);
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_reduceall(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ReduceLogSumLayerParams)
  return target;
}

size_t ReduceLogSumLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ReduceLogSumLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->axes_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _axes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    total_size += 1 + 1;
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReduceLogSumLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReduceLogSumLayerParams*>(
      &from));
}

void ReduceLogSumLayerParams::MergeFrom(const ReduceLogSumLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ReduceLogSumLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  axes_.MergeFrom(from.axes_);
  if (from._internal_keepdims() != 0) {
    _internal_set_keepdims(from._internal_keepdims());
  }
  if (from._internal_reduceall() != 0) {
    _internal_set_reduceall(from._internal_reduceall());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReduceLogSumLayerParams::CopyFrom(const ReduceLogSumLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ReduceLogSumLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReduceLogSumLayerParams::IsInitialized() const {
  return true;
}

void ReduceLogSumLayerParams::InternalSwap(ReduceLogSumLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  axes_.InternalSwap(&other->axes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReduceLogSumLayerParams, reduceall_)
      + sizeof(ReduceLogSumLayerParams::reduceall_)
      - PROTOBUF_FIELD_OFFSET(ReduceLogSumLayerParams, keepdims_)>(
          reinterpret_cast<char*>(&keepdims_),
          reinterpret_cast<char*>(&other->keepdims_));
}

std::string ReduceLogSumLayerParams::GetTypeName() const {
  return "CoreML.Specification.ReduceLogSumLayerParams";
}


// ===================================================================

class ReduceSumSquareLayerParams::_Internal {
 public:
};

ReduceSumSquareLayerParams::ReduceSumSquareLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  axes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ReduceSumSquareLayerParams)
}
ReduceSumSquareLayerParams::ReduceSumSquareLayerParams(const ReduceSumSquareLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      axes_(from.axes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&keepdims_, &from.keepdims_,
    static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ReduceSumSquareLayerParams)
}

inline void ReduceSumSquareLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&keepdims_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
}

ReduceSumSquareLayerParams::~ReduceSumSquareLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ReduceSumSquareLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReduceSumSquareLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReduceSumSquareLayerParams::ArenaDtor(void* object) {
  ReduceSumSquareLayerParams* _this = reinterpret_cast< ReduceSumSquareLayerParams* >(object);
  (void)_this;
}
void ReduceSumSquareLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReduceSumSquareLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReduceSumSquareLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ReduceSumSquareLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axes_.Clear();
  ::memset(&keepdims_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reduceall_) -
      reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  _internal_metadata_.Clear<std::string>();
}

const char* ReduceSumSquareLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 axes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_axes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_axes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool keepDims = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          keepdims_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reduceAll = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          reduceall_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReduceSumSquareLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ReduceSumSquareLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    int byte_size = _axes_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_axes(), byte_size, target);
    }
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_keepdims(), target);
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_reduceall(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ReduceSumSquareLayerParams)
  return target;
}

size_t ReduceSumSquareLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ReduceSumSquareLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->axes_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _axes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    total_size += 1 + 1;
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReduceSumSquareLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReduceSumSquareLayerParams*>(
      &from));
}

void ReduceSumSquareLayerParams::MergeFrom(const ReduceSumSquareLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ReduceSumSquareLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  axes_.MergeFrom(from.axes_);
  if (from._internal_keepdims() != 0) {
    _internal_set_keepdims(from._internal_keepdims());
  }
  if (from._internal_reduceall() != 0) {
    _internal_set_reduceall(from._internal_reduceall());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReduceSumSquareLayerParams::CopyFrom(const ReduceSumSquareLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ReduceSumSquareLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReduceSumSquareLayerParams::IsInitialized() const {
  return true;
}

void ReduceSumSquareLayerParams::InternalSwap(ReduceSumSquareLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  axes_.InternalSwap(&other->axes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReduceSumSquareLayerParams, reduceall_)
      + sizeof(ReduceSumSquareLayerParams::reduceall_)
      - PROTOBUF_FIELD_OFFSET(ReduceSumSquareLayerParams, keepdims_)>(
          reinterpret_cast<char*>(&keepdims_),
          reinterpret_cast<char*>(&other->keepdims_));
}

std::string ReduceSumSquareLayerParams::GetTypeName() const {
  return "CoreML.Specification.ReduceSumSquareLayerParams";
}


// ===================================================================

class ReduceLogSumExpLayerParams::_Internal {
 public:
};

ReduceLogSumExpLayerParams::ReduceLogSumExpLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  axes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ReduceLogSumExpLayerParams)
}
ReduceLogSumExpLayerParams::ReduceLogSumExpLayerParams(const ReduceLogSumExpLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      axes_(from.axes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&keepdims_, &from.keepdims_,
    static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ReduceLogSumExpLayerParams)
}

inline void ReduceLogSumExpLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&keepdims_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reduceall_) -
    reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
}

ReduceLogSumExpLayerParams::~ReduceLogSumExpLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ReduceLogSumExpLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReduceLogSumExpLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReduceLogSumExpLayerParams::ArenaDtor(void* object) {
  ReduceLogSumExpLayerParams* _this = reinterpret_cast< ReduceLogSumExpLayerParams* >(object);
  (void)_this;
}
void ReduceLogSumExpLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReduceLogSumExpLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReduceLogSumExpLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ReduceLogSumExpLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axes_.Clear();
  ::memset(&keepdims_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reduceall_) -
      reinterpret_cast<char*>(&keepdims_)) + sizeof(reduceall_));
  _internal_metadata_.Clear<std::string>();
}

const char* ReduceLogSumExpLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 axes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_axes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_axes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool keepDims = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          keepdims_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reduceAll = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          reduceall_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReduceLogSumExpLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ReduceLogSumExpLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    int byte_size = _axes_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_axes(), byte_size, target);
    }
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_keepdims(), target);
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_reduceall(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ReduceLogSumExpLayerParams)
  return target;
}

size_t ReduceLogSumExpLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ReduceLogSumExpLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->axes_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _axes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // bool keepDims = 2;
  if (this->_internal_keepdims() != 0) {
    total_size += 1 + 1;
  }

  // bool reduceAll = 3;
  if (this->_internal_reduceall() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReduceLogSumExpLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReduceLogSumExpLayerParams*>(
      &from));
}

void ReduceLogSumExpLayerParams::MergeFrom(const ReduceLogSumExpLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ReduceLogSumExpLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  axes_.MergeFrom(from.axes_);
  if (from._internal_keepdims() != 0) {
    _internal_set_keepdims(from._internal_keepdims());
  }
  if (from._internal_reduceall() != 0) {
    _internal_set_reduceall(from._internal_reduceall());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReduceLogSumExpLayerParams::CopyFrom(const ReduceLogSumExpLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ReduceLogSumExpLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReduceLogSumExpLayerParams::IsInitialized() const {
  return true;
}

void ReduceLogSumExpLayerParams::InternalSwap(ReduceLogSumExpLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  axes_.InternalSwap(&other->axes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReduceLogSumExpLayerParams, reduceall_)
      + sizeof(ReduceLogSumExpLayerParams::reduceall_)
      - PROTOBUF_FIELD_OFFSET(ReduceLogSumExpLayerParams, keepdims_)>(
          reinterpret_cast<char*>(&keepdims_),
          reinterpret_cast<char*>(&other->keepdims_));
}

std::string ReduceLogSumExpLayerParams::GetTypeName() const {
  return "CoreML.Specification.ReduceLogSumExpLayerParams";
}


// ===================================================================

class ExpandDimsLayerParams::_Internal {
 public:
};

ExpandDimsLayerParams::ExpandDimsLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  axes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ExpandDimsLayerParams)
}
ExpandDimsLayerParams::ExpandDimsLayerParams(const ExpandDimsLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      axes_(from.axes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ExpandDimsLayerParams)
}

inline void ExpandDimsLayerParams::SharedCtor() {
}

ExpandDimsLayerParams::~ExpandDimsLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ExpandDimsLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ExpandDimsLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ExpandDimsLayerParams::ArenaDtor(void* object) {
  ExpandDimsLayerParams* _this = reinterpret_cast< ExpandDimsLayerParams* >(object);
  (void)_this;
}
void ExpandDimsLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ExpandDimsLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ExpandDimsLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ExpandDimsLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axes_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ExpandDimsLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 axes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_axes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_axes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExpandDimsLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ExpandDimsLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    int byte_size = _axes_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_axes(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ExpandDimsLayerParams)
  return target;
}

size_t ExpandDimsLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ExpandDimsLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->axes_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _axes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExpandDimsLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ExpandDimsLayerParams*>(
      &from));
}

void ExpandDimsLayerParams::MergeFrom(const ExpandDimsLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ExpandDimsLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  axes_.MergeFrom(from.axes_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExpandDimsLayerParams::CopyFrom(const ExpandDimsLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ExpandDimsLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExpandDimsLayerParams::IsInitialized() const {
  return true;
}

void ExpandDimsLayerParams::InternalSwap(ExpandDimsLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  axes_.InternalSwap(&other->axes_);
}

std::string ExpandDimsLayerParams::GetTypeName() const {
  return "CoreML.Specification.ExpandDimsLayerParams";
}


// ===================================================================

class FlattenTo2DLayerParams::_Internal {
 public:
};

FlattenTo2DLayerParams::FlattenTo2DLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.FlattenTo2DLayerParams)
}
FlattenTo2DLayerParams::FlattenTo2DLayerParams(const FlattenTo2DLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  axis_ = from.axis_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.FlattenTo2DLayerParams)
}

inline void FlattenTo2DLayerParams::SharedCtor() {
axis_ = int64_t{0};
}

FlattenTo2DLayerParams::~FlattenTo2DLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.FlattenTo2DLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FlattenTo2DLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FlattenTo2DLayerParams::ArenaDtor(void* object) {
  FlattenTo2DLayerParams* _this = reinterpret_cast< FlattenTo2DLayerParams* >(object);
  (void)_this;
}
void FlattenTo2DLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FlattenTo2DLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FlattenTo2DLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.FlattenTo2DLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axis_ = int64_t{0};
  _internal_metadata_.Clear<std::string>();
}

const char* FlattenTo2DLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 axis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlattenTo2DLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.FlattenTo2DLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_axis(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.FlattenTo2DLayerParams)
  return target;
}

size_t FlattenTo2DLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.FlattenTo2DLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_axis());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FlattenTo2DLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FlattenTo2DLayerParams*>(
      &from));
}

void FlattenTo2DLayerParams::MergeFrom(const FlattenTo2DLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.FlattenTo2DLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FlattenTo2DLayerParams::CopyFrom(const FlattenTo2DLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.FlattenTo2DLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlattenTo2DLayerParams::IsInitialized() const {
  return true;
}

void FlattenTo2DLayerParams::InternalSwap(FlattenTo2DLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(axis_, other->axis_);
}

std::string FlattenTo2DLayerParams::GetTypeName() const {
  return "CoreML.Specification.FlattenTo2DLayerParams";
}


// ===================================================================

class ReshapeStaticLayerParams::_Internal {
 public:
};

ReshapeStaticLayerParams::ReshapeStaticLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  targetshape_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ReshapeStaticLayerParams)
}
ReshapeStaticLayerParams::ReshapeStaticLayerParams(const ReshapeStaticLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      targetshape_(from.targetshape_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ReshapeStaticLayerParams)
}

inline void ReshapeStaticLayerParams::SharedCtor() {
}

ReshapeStaticLayerParams::~ReshapeStaticLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ReshapeStaticLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReshapeStaticLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReshapeStaticLayerParams::ArenaDtor(void* object) {
  ReshapeStaticLayerParams* _this = reinterpret_cast< ReshapeStaticLayerParams* >(object);
  (void)_this;
}
void ReshapeStaticLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReshapeStaticLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReshapeStaticLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ReshapeStaticLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  targetshape_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ReshapeStaticLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 targetShape = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_targetshape(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_targetshape(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReshapeStaticLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ReshapeStaticLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 targetShape = 1;
  {
    int byte_size = _targetshape_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_targetshape(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ReshapeStaticLayerParams)
  return target;
}

size_t ReshapeStaticLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ReshapeStaticLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 targetShape = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->targetshape_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _targetshape_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReshapeStaticLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReshapeStaticLayerParams*>(
      &from));
}

void ReshapeStaticLayerParams::MergeFrom(const ReshapeStaticLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ReshapeStaticLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  targetshape_.MergeFrom(from.targetshape_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReshapeStaticLayerParams::CopyFrom(const ReshapeStaticLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ReshapeStaticLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReshapeStaticLayerParams::IsInitialized() const {
  return true;
}

void ReshapeStaticLayerParams::InternalSwap(ReshapeStaticLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  targetshape_.InternalSwap(&other->targetshape_);
}

std::string ReshapeStaticLayerParams::GetTypeName() const {
  return "CoreML.Specification.ReshapeStaticLayerParams";
}


// ===================================================================

class ReshapeLikeLayerParams::_Internal {
 public:
};

ReshapeLikeLayerParams::ReshapeLikeLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ReshapeLikeLayerParams)
}
ReshapeLikeLayerParams::ReshapeLikeLayerParams(const ReshapeLikeLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ReshapeLikeLayerParams)
}

inline void ReshapeLikeLayerParams::SharedCtor() {
}

ReshapeLikeLayerParams::~ReshapeLikeLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ReshapeLikeLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReshapeLikeLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReshapeLikeLayerParams::ArenaDtor(void* object) {
  ReshapeLikeLayerParams* _this = reinterpret_cast< ReshapeLikeLayerParams* >(object);
  (void)_this;
}
void ReshapeLikeLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReshapeLikeLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReshapeLikeLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ReshapeLikeLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ReshapeLikeLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReshapeLikeLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ReshapeLikeLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ReshapeLikeLayerParams)
  return target;
}

size_t ReshapeLikeLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ReshapeLikeLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReshapeLikeLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReshapeLikeLayerParams*>(
      &from));
}

void ReshapeLikeLayerParams::MergeFrom(const ReshapeLikeLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ReshapeLikeLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReshapeLikeLayerParams::CopyFrom(const ReshapeLikeLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ReshapeLikeLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReshapeLikeLayerParams::IsInitialized() const {
  return true;
}

void ReshapeLikeLayerParams::InternalSwap(ReshapeLikeLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ReshapeLikeLayerParams::GetTypeName() const {
  return "CoreML.Specification.ReshapeLikeLayerParams";
}


// ===================================================================

class ReshapeDynamicLayerParams::_Internal {
 public:
};

ReshapeDynamicLayerParams::ReshapeDynamicLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ReshapeDynamicLayerParams)
}
ReshapeDynamicLayerParams::ReshapeDynamicLayerParams(const ReshapeDynamicLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ReshapeDynamicLayerParams)
}

inline void ReshapeDynamicLayerParams::SharedCtor() {
}

ReshapeDynamicLayerParams::~ReshapeDynamicLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ReshapeDynamicLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ReshapeDynamicLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReshapeDynamicLayerParams::ArenaDtor(void* object) {
  ReshapeDynamicLayerParams* _this = reinterpret_cast< ReshapeDynamicLayerParams* >(object);
  (void)_this;
}
void ReshapeDynamicLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReshapeDynamicLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReshapeDynamicLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ReshapeDynamicLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ReshapeDynamicLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReshapeDynamicLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ReshapeDynamicLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ReshapeDynamicLayerParams)
  return target;
}

size_t ReshapeDynamicLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ReshapeDynamicLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReshapeDynamicLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ReshapeDynamicLayerParams*>(
      &from));
}

void ReshapeDynamicLayerParams::MergeFrom(const ReshapeDynamicLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ReshapeDynamicLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReshapeDynamicLayerParams::CopyFrom(const ReshapeDynamicLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ReshapeDynamicLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReshapeDynamicLayerParams::IsInitialized() const {
  return true;
}

void ReshapeDynamicLayerParams::InternalSwap(ReshapeDynamicLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ReshapeDynamicLayerParams::GetTypeName() const {
  return "CoreML.Specification.ReshapeDynamicLayerParams";
}


// ===================================================================

class SqueezeLayerParams::_Internal {
 public:
};

SqueezeLayerParams::SqueezeLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  axes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SqueezeLayerParams)
}
SqueezeLayerParams::SqueezeLayerParams(const SqueezeLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      axes_(from.axes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  squeezeall_ = from.squeezeall_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SqueezeLayerParams)
}

inline void SqueezeLayerParams::SharedCtor() {
squeezeall_ = false;
}

SqueezeLayerParams::~SqueezeLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SqueezeLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SqueezeLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SqueezeLayerParams::ArenaDtor(void* object) {
  SqueezeLayerParams* _this = reinterpret_cast< SqueezeLayerParams* >(object);
  (void)_this;
}
void SqueezeLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SqueezeLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SqueezeLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SqueezeLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  axes_.Clear();
  squeezeall_ = false;
  _internal_metadata_.Clear<std::string>();
}

const char* SqueezeLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 axes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_axes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_axes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool squeezeAll = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          squeezeall_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SqueezeLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SqueezeLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    int byte_size = _axes_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_axes(), byte_size, target);
    }
  }

  // bool squeezeAll = 2;
  if (this->_internal_squeezeall() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_squeezeall(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SqueezeLayerParams)
  return target;
}

size_t SqueezeLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SqueezeLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 axes = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->axes_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _axes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // bool squeezeAll = 2;
  if (this->_internal_squeezeall() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SqueezeLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SqueezeLayerParams*>(
      &from));
}

void SqueezeLayerParams::MergeFrom(const SqueezeLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SqueezeLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  axes_.MergeFrom(from.axes_);
  if (from._internal_squeezeall() != 0) {
    _internal_set_squeezeall(from._internal_squeezeall());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SqueezeLayerParams::CopyFrom(const SqueezeLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SqueezeLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SqueezeLayerParams::IsInitialized() const {
  return true;
}

void SqueezeLayerParams::InternalSwap(SqueezeLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  axes_.InternalSwap(&other->axes_);
  swap(squeezeall_, other->squeezeall_);
}

std::string SqueezeLayerParams::GetTypeName() const {
  return "CoreML.Specification.SqueezeLayerParams";
}


// ===================================================================

class TopKLayerParams::_Internal {
 public:
};

TopKLayerParams::TopKLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.TopKLayerParams)
}
TopKLayerParams::TopKLayerParams(const TopKLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&axis_, &from.axis_,
    static_cast<size_t>(reinterpret_cast<char*>(&usebottomk_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(usebottomk_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.TopKLayerParams)
}

inline void TopKLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&axis_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&usebottomk_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(usebottomk_));
}

TopKLayerParams::~TopKLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.TopKLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TopKLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TopKLayerParams::ArenaDtor(void* object) {
  TopKLayerParams* _this = reinterpret_cast< TopKLayerParams* >(object);
  (void)_this;
}
void TopKLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TopKLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TopKLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.TopKLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&axis_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&usebottomk_) -
      reinterpret_cast<char*>(&axis_)) + sizeof(usebottomk_));
  _internal_metadata_.Clear<std::string>();
}

const char* TopKLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 axis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 K = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          k_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool useBottomK = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          usebottomk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TopKLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.TopKLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_axis(), target);
  }

  // uint64 K = 2;
  if (this->_internal_k() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_k(), target);
  }

  // bool useBottomK = 3;
  if (this->_internal_usebottomk() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_usebottomk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.TopKLayerParams)
  return target;
}

size_t TopKLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.TopKLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_axis());
  }

  // uint64 K = 2;
  if (this->_internal_k() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_k());
  }

  // bool useBottomK = 3;
  if (this->_internal_usebottomk() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TopKLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TopKLayerParams*>(
      &from));
}

void TopKLayerParams::MergeFrom(const TopKLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.TopKLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  if (from._internal_k() != 0) {
    _internal_set_k(from._internal_k());
  }
  if (from._internal_usebottomk() != 0) {
    _internal_set_usebottomk(from._internal_usebottomk());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TopKLayerParams::CopyFrom(const TopKLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.TopKLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopKLayerParams::IsInitialized() const {
  return true;
}

void TopKLayerParams::InternalSwap(TopKLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TopKLayerParams, usebottomk_)
      + sizeof(TopKLayerParams::usebottomk_)
      - PROTOBUF_FIELD_OFFSET(TopKLayerParams, axis_)>(
          reinterpret_cast<char*>(&axis_),
          reinterpret_cast<char*>(&other->axis_));
}

std::string TopKLayerParams::GetTypeName() const {
  return "CoreML.Specification.TopKLayerParams";
}


// ===================================================================

class ArgMaxLayerParams::_Internal {
 public:
};

ArgMaxLayerParams::ArgMaxLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ArgMaxLayerParams)
}
ArgMaxLayerParams::ArgMaxLayerParams(const ArgMaxLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&axis_, &from.axis_,
    static_cast<size_t>(reinterpret_cast<char*>(&removedim_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(removedim_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ArgMaxLayerParams)
}

inline void ArgMaxLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&axis_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&removedim_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(removedim_));
}

ArgMaxLayerParams::~ArgMaxLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ArgMaxLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ArgMaxLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ArgMaxLayerParams::ArenaDtor(void* object) {
  ArgMaxLayerParams* _this = reinterpret_cast< ArgMaxLayerParams* >(object);
  (void)_this;
}
void ArgMaxLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ArgMaxLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArgMaxLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ArgMaxLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&axis_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&removedim_) -
      reinterpret_cast<char*>(&axis_)) + sizeof(removedim_));
  _internal_metadata_.Clear<std::string>();
}

const char* ArgMaxLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 axis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool removeDim = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          removedim_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArgMaxLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ArgMaxLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_axis(), target);
  }

  // bool removeDim = 2;
  if (this->_internal_removedim() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_removedim(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ArgMaxLayerParams)
  return target;
}

size_t ArgMaxLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ArgMaxLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_axis());
  }

  // bool removeDim = 2;
  if (this->_internal_removedim() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ArgMaxLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ArgMaxLayerParams*>(
      &from));
}

void ArgMaxLayerParams::MergeFrom(const ArgMaxLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ArgMaxLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  if (from._internal_removedim() != 0) {
    _internal_set_removedim(from._internal_removedim());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ArgMaxLayerParams::CopyFrom(const ArgMaxLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ArgMaxLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArgMaxLayerParams::IsInitialized() const {
  return true;
}

void ArgMaxLayerParams::InternalSwap(ArgMaxLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArgMaxLayerParams, removedim_)
      + sizeof(ArgMaxLayerParams::removedim_)
      - PROTOBUF_FIELD_OFFSET(ArgMaxLayerParams, axis_)>(
          reinterpret_cast<char*>(&axis_),
          reinterpret_cast<char*>(&other->axis_));
}

std::string ArgMaxLayerParams::GetTypeName() const {
  return "CoreML.Specification.ArgMaxLayerParams";
}


// ===================================================================

class ArgMinLayerParams::_Internal {
 public:
};

ArgMinLayerParams::ArgMinLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ArgMinLayerParams)
}
ArgMinLayerParams::ArgMinLayerParams(const ArgMinLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&axis_, &from.axis_,
    static_cast<size_t>(reinterpret_cast<char*>(&removedim_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(removedim_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ArgMinLayerParams)
}

inline void ArgMinLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&axis_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&removedim_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(removedim_));
}

ArgMinLayerParams::~ArgMinLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ArgMinLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ArgMinLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ArgMinLayerParams::ArenaDtor(void* object) {
  ArgMinLayerParams* _this = reinterpret_cast< ArgMinLayerParams* >(object);
  (void)_this;
}
void ArgMinLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ArgMinLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArgMinLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ArgMinLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&axis_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&removedim_) -
      reinterpret_cast<char*>(&axis_)) + sizeof(removedim_));
  _internal_metadata_.Clear<std::string>();
}

const char* ArgMinLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 axis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool removeDim = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          removedim_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArgMinLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ArgMinLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_axis(), target);
  }

  // bool removeDim = 2;
  if (this->_internal_removedim() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_removedim(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ArgMinLayerParams)
  return target;
}

size_t ArgMinLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ArgMinLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_axis());
  }

  // bool removeDim = 2;
  if (this->_internal_removedim() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ArgMinLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ArgMinLayerParams*>(
      &from));
}

void ArgMinLayerParams::MergeFrom(const ArgMinLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ArgMinLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  if (from._internal_removedim() != 0) {
    _internal_set_removedim(from._internal_removedim());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ArgMinLayerParams::CopyFrom(const ArgMinLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ArgMinLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArgMinLayerParams::IsInitialized() const {
  return true;
}

void ArgMinLayerParams::InternalSwap(ArgMinLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArgMinLayerParams, removedim_)
      + sizeof(ArgMinLayerParams::removedim_)
      - PROTOBUF_FIELD_OFFSET(ArgMinLayerParams, axis_)>(
          reinterpret_cast<char*>(&axis_),
          reinterpret_cast<char*>(&other->axis_));
}

std::string ArgMinLayerParams::GetTypeName() const {
  return "CoreML.Specification.ArgMinLayerParams";
}


// ===================================================================

class SplitNDLayerParams::_Internal {
 public:
};

SplitNDLayerParams::SplitNDLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  splitsizes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SplitNDLayerParams)
}
SplitNDLayerParams::SplitNDLayerParams(const SplitNDLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      splitsizes_(from.splitsizes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&axis_, &from.axis_,
    static_cast<size_t>(reinterpret_cast<char*>(&numsplits_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(numsplits_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SplitNDLayerParams)
}

inline void SplitNDLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&axis_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&numsplits_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(numsplits_));
}

SplitNDLayerParams::~SplitNDLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SplitNDLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SplitNDLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SplitNDLayerParams::ArenaDtor(void* object) {
  SplitNDLayerParams* _this = reinterpret_cast< SplitNDLayerParams* >(object);
  (void)_this;
}
void SplitNDLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SplitNDLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SplitNDLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SplitNDLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  splitsizes_.Clear();
  ::memset(&axis_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&numsplits_) -
      reinterpret_cast<char*>(&axis_)) + sizeof(numsplits_));
  _internal_metadata_.Clear<std::string>();
}

const char* SplitNDLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 axis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 numSplits = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          numsplits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 splitSizes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_splitsizes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_splitsizes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SplitNDLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SplitNDLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_axis(), target);
  }

  // uint64 numSplits = 2;
  if (this->_internal_numsplits() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_numsplits(), target);
  }

  // repeated uint64 splitSizes = 3;
  {
    int byte_size = _splitsizes_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          3, _internal_splitsizes(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SplitNDLayerParams)
  return target;
}

size_t SplitNDLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SplitNDLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 splitSizes = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->splitsizes_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _splitsizes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_axis());
  }

  // uint64 numSplits = 2;
  if (this->_internal_numsplits() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_numsplits());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SplitNDLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SplitNDLayerParams*>(
      &from));
}

void SplitNDLayerParams::MergeFrom(const SplitNDLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SplitNDLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  splitsizes_.MergeFrom(from.splitsizes_);
  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  if (from._internal_numsplits() != 0) {
    _internal_set_numsplits(from._internal_numsplits());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SplitNDLayerParams::CopyFrom(const SplitNDLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SplitNDLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SplitNDLayerParams::IsInitialized() const {
  return true;
}

void SplitNDLayerParams::InternalSwap(SplitNDLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  splitsizes_.InternalSwap(&other->splitsizes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SplitNDLayerParams, numsplits_)
      + sizeof(SplitNDLayerParams::numsplits_)
      - PROTOBUF_FIELD_OFFSET(SplitNDLayerParams, axis_)>(
          reinterpret_cast<char*>(&axis_),
          reinterpret_cast<char*>(&other->axis_));
}

std::string SplitNDLayerParams::GetTypeName() const {
  return "CoreML.Specification.SplitNDLayerParams";
}


// ===================================================================

class CeilLayerParams::_Internal {
 public:
};

CeilLayerParams::CeilLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.CeilLayerParams)
}
CeilLayerParams::CeilLayerParams(const CeilLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.CeilLayerParams)
}

inline void CeilLayerParams::SharedCtor() {
}

CeilLayerParams::~CeilLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.CeilLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CeilLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CeilLayerParams::ArenaDtor(void* object) {
  CeilLayerParams* _this = reinterpret_cast< CeilLayerParams* >(object);
  (void)_this;
}
void CeilLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CeilLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CeilLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.CeilLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CeilLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CeilLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.CeilLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.CeilLayerParams)
  return target;
}

size_t CeilLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.CeilLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CeilLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CeilLayerParams*>(
      &from));
}

void CeilLayerParams::MergeFrom(const CeilLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.CeilLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CeilLayerParams::CopyFrom(const CeilLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.CeilLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CeilLayerParams::IsInitialized() const {
  return true;
}

void CeilLayerParams::InternalSwap(CeilLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CeilLayerParams::GetTypeName() const {
  return "CoreML.Specification.CeilLayerParams";
}


// ===================================================================

class RoundLayerParams::_Internal {
 public:
};

RoundLayerParams::RoundLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.RoundLayerParams)
}
RoundLayerParams::RoundLayerParams(const RoundLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.RoundLayerParams)
}

inline void RoundLayerParams::SharedCtor() {
}

RoundLayerParams::~RoundLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.RoundLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RoundLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RoundLayerParams::ArenaDtor(void* object) {
  RoundLayerParams* _this = reinterpret_cast< RoundLayerParams* >(object);
  (void)_this;
}
void RoundLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RoundLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RoundLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.RoundLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* RoundLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RoundLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.RoundLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.RoundLayerParams)
  return target;
}

size_t RoundLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.RoundLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RoundLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RoundLayerParams*>(
      &from));
}

void RoundLayerParams::MergeFrom(const RoundLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.RoundLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RoundLayerParams::CopyFrom(const RoundLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.RoundLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoundLayerParams::IsInitialized() const {
  return true;
}

void RoundLayerParams::InternalSwap(RoundLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string RoundLayerParams::GetTypeName() const {
  return "CoreML.Specification.RoundLayerParams";
}


// ===================================================================

class FloorLayerParams::_Internal {
 public:
};

FloorLayerParams::FloorLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.FloorLayerParams)
}
FloorLayerParams::FloorLayerParams(const FloorLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.FloorLayerParams)
}

inline void FloorLayerParams::SharedCtor() {
}

FloorLayerParams::~FloorLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.FloorLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FloorLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FloorLayerParams::ArenaDtor(void* object) {
  FloorLayerParams* _this = reinterpret_cast< FloorLayerParams* >(object);
  (void)_this;
}
void FloorLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FloorLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FloorLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.FloorLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* FloorLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FloorLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.FloorLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.FloorLayerParams)
  return target;
}

size_t FloorLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.FloorLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FloorLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FloorLayerParams*>(
      &from));
}

void FloorLayerParams::MergeFrom(const FloorLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.FloorLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FloorLayerParams::CopyFrom(const FloorLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.FloorLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FloorLayerParams::IsInitialized() const {
  return true;
}

void FloorLayerParams::InternalSwap(FloorLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string FloorLayerParams::GetTypeName() const {
  return "CoreML.Specification.FloorLayerParams";
}


// ===================================================================

class SignLayerParams::_Internal {
 public:
};

SignLayerParams::SignLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SignLayerParams)
}
SignLayerParams::SignLayerParams(const SignLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SignLayerParams)
}

inline void SignLayerParams::SharedCtor() {
}

SignLayerParams::~SignLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SignLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SignLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SignLayerParams::ArenaDtor(void* object) {
  SignLayerParams* _this = reinterpret_cast< SignLayerParams* >(object);
  (void)_this;
}
void SignLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SignLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SignLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SignLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* SignLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SignLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SignLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SignLayerParams)
  return target;
}

size_t SignLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SignLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SignLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SignLayerParams*>(
      &from));
}

void SignLayerParams::MergeFrom(const SignLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SignLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SignLayerParams::CopyFrom(const SignLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SignLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignLayerParams::IsInitialized() const {
  return true;
}

void SignLayerParams::InternalSwap(SignLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string SignLayerParams::GetTypeName() const {
  return "CoreML.Specification.SignLayerParams";
}


// ===================================================================

class ClipLayerParams::_Internal {
 public:
};

ClipLayerParams::ClipLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ClipLayerParams)
}
ClipLayerParams::ClipLayerParams(const ClipLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&minval_, &from.minval_,
    static_cast<size_t>(reinterpret_cast<char*>(&maxval_) -
    reinterpret_cast<char*>(&minval_)) + sizeof(maxval_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ClipLayerParams)
}

inline void ClipLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&minval_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&maxval_) -
    reinterpret_cast<char*>(&minval_)) + sizeof(maxval_));
}

ClipLayerParams::~ClipLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ClipLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ClipLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClipLayerParams::ArenaDtor(void* object) {
  ClipLayerParams* _this = reinterpret_cast< ClipLayerParams* >(object);
  (void)_this;
}
void ClipLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ClipLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClipLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ClipLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&minval_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&maxval_) -
      reinterpret_cast<char*>(&minval_)) + sizeof(maxval_));
  _internal_metadata_.Clear<std::string>();
}

const char* ClipLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float minVal = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          minval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float maxVal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          maxval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClipLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ClipLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float minVal = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_minval = this->_internal_minval();
  uint32_t raw_minval;
  memcpy(&raw_minval, &tmp_minval, sizeof(tmp_minval));
  if (raw_minval != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_minval(), target);
  }

  // float maxVal = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxval = this->_internal_maxval();
  uint32_t raw_maxval;
  memcpy(&raw_maxval, &tmp_maxval, sizeof(tmp_maxval));
  if (raw_maxval != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_maxval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ClipLayerParams)
  return target;
}

size_t ClipLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ClipLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float minVal = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_minval = this->_internal_minval();
  uint32_t raw_minval;
  memcpy(&raw_minval, &tmp_minval, sizeof(tmp_minval));
  if (raw_minval != 0) {
    total_size += 1 + 4;
  }

  // float maxVal = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxval = this->_internal_maxval();
  uint32_t raw_maxval;
  memcpy(&raw_maxval, &tmp_maxval, sizeof(tmp_maxval));
  if (raw_maxval != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClipLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ClipLayerParams*>(
      &from));
}

void ClipLayerParams::MergeFrom(const ClipLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ClipLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_minval = from._internal_minval();
  uint32_t raw_minval;
  memcpy(&raw_minval, &tmp_minval, sizeof(tmp_minval));
  if (raw_minval != 0) {
    _internal_set_minval(from._internal_minval());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxval = from._internal_maxval();
  uint32_t raw_maxval;
  memcpy(&raw_maxval, &tmp_maxval, sizeof(tmp_maxval));
  if (raw_maxval != 0) {
    _internal_set_maxval(from._internal_maxval());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClipLayerParams::CopyFrom(const ClipLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ClipLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClipLayerParams::IsInitialized() const {
  return true;
}

void ClipLayerParams::InternalSwap(ClipLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClipLayerParams, maxval_)
      + sizeof(ClipLayerParams::maxval_)
      - PROTOBUF_FIELD_OFFSET(ClipLayerParams, minval_)>(
          reinterpret_cast<char*>(&minval_),
          reinterpret_cast<char*>(&other->minval_));
}

std::string ClipLayerParams::GetTypeName() const {
  return "CoreML.Specification.ClipLayerParams";
}


// ===================================================================

class SliceStaticLayerParams::_Internal {
 public:
};

SliceStaticLayerParams::SliceStaticLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  beginids_(arena),
  beginmasks_(arena),
  endids_(arena),
  endmasks_(arena),
  strides_(arena),
  squeezemasks_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SliceStaticLayerParams)
}
SliceStaticLayerParams::SliceStaticLayerParams(const SliceStaticLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      beginids_(from.beginids_),
      beginmasks_(from.beginmasks_),
      endids_(from.endids_),
      endmasks_(from.endmasks_),
      strides_(from.strides_),
      squeezemasks_(from.squeezemasks_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SliceStaticLayerParams)
}

inline void SliceStaticLayerParams::SharedCtor() {
}

SliceStaticLayerParams::~SliceStaticLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SliceStaticLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SliceStaticLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SliceStaticLayerParams::ArenaDtor(void* object) {
  SliceStaticLayerParams* _this = reinterpret_cast< SliceStaticLayerParams* >(object);
  (void)_this;
}
void SliceStaticLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SliceStaticLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SliceStaticLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SliceStaticLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  beginids_.Clear();
  beginmasks_.Clear();
  endids_.Clear();
  endmasks_.Clear();
  strides_.Clear();
  squeezemasks_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SliceStaticLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 beginIds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_beginids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_beginids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bool beginMasks = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_beginmasks(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_beginmasks(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 endIds = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_endids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_endids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bool endMasks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_endmasks(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_endmasks(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 strides = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_strides(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 40) {
          _internal_add_strides(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bool squeezeMasks = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_squeezemasks(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 48) {
          _internal_add_squeezemasks(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SliceStaticLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SliceStaticLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 beginIds = 1;
  {
    int byte_size = _beginids_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_beginids(), byte_size, target);
    }
  }

  // repeated bool beginMasks = 2;
  if (this->_internal_beginmasks_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_beginmasks(), target);
  }

  // repeated int64 endIds = 3;
  {
    int byte_size = _endids_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          3, _internal_endids(), byte_size, target);
    }
  }

  // repeated bool endMasks = 4;
  if (this->_internal_endmasks_size() > 0) {
    target = stream->WriteFixedPacked(4, _internal_endmasks(), target);
  }

  // repeated int64 strides = 5;
  {
    int byte_size = _strides_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          5, _internal_strides(), byte_size, target);
    }
  }

  // repeated bool squeezeMasks = 6;
  if (this->_internal_squeezemasks_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_squeezemasks(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SliceStaticLayerParams)
  return target;
}

size_t SliceStaticLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SliceStaticLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 beginIds = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->beginids_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _beginids_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated bool beginMasks = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_beginmasks_size());
    size_t data_size = 1UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated int64 endIds = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->endids_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _endids_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated bool endMasks = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_endmasks_size());
    size_t data_size = 1UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated int64 strides = 5;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->strides_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _strides_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated bool squeezeMasks = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_squeezemasks_size());
    size_t data_size = 1UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SliceStaticLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SliceStaticLayerParams*>(
      &from));
}

void SliceStaticLayerParams::MergeFrom(const SliceStaticLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SliceStaticLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  beginids_.MergeFrom(from.beginids_);
  beginmasks_.MergeFrom(from.beginmasks_);
  endids_.MergeFrom(from.endids_);
  endmasks_.MergeFrom(from.endmasks_);
  strides_.MergeFrom(from.strides_);
  squeezemasks_.MergeFrom(from.squeezemasks_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SliceStaticLayerParams::CopyFrom(const SliceStaticLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SliceStaticLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SliceStaticLayerParams::IsInitialized() const {
  return true;
}

void SliceStaticLayerParams::InternalSwap(SliceStaticLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  beginids_.InternalSwap(&other->beginids_);
  beginmasks_.InternalSwap(&other->beginmasks_);
  endids_.InternalSwap(&other->endids_);
  endmasks_.InternalSwap(&other->endmasks_);
  strides_.InternalSwap(&other->strides_);
  squeezemasks_.InternalSwap(&other->squeezemasks_);
}

std::string SliceStaticLayerParams::GetTypeName() const {
  return "CoreML.Specification.SliceStaticLayerParams";
}


// ===================================================================

class SliceDynamicLayerParams::_Internal {
 public:
};

SliceDynamicLayerParams::SliceDynamicLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  beginmasks_(arena),
  endids_(arena),
  endmasks_(arena),
  strides_(arena),
  squeezemasks_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SliceDynamicLayerParams)
}
SliceDynamicLayerParams::SliceDynamicLayerParams(const SliceDynamicLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      beginmasks_(from.beginmasks_),
      endids_(from.endids_),
      endmasks_(from.endmasks_),
      strides_(from.strides_),
      squeezemasks_(from.squeezemasks_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SliceDynamicLayerParams)
}

inline void SliceDynamicLayerParams::SharedCtor() {
}

SliceDynamicLayerParams::~SliceDynamicLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SliceDynamicLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SliceDynamicLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SliceDynamicLayerParams::ArenaDtor(void* object) {
  SliceDynamicLayerParams* _this = reinterpret_cast< SliceDynamicLayerParams* >(object);
  (void)_this;
}
void SliceDynamicLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SliceDynamicLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SliceDynamicLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SliceDynamicLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  beginmasks_.Clear();
  endids_.Clear();
  endmasks_.Clear();
  strides_.Clear();
  squeezemasks_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SliceDynamicLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bool beginMasks = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_beginmasks(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_beginmasks(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 endIds = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_endids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_endids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bool endMasks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_endmasks(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_endmasks(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 strides = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_strides(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 40) {
          _internal_add_strides(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bool squeezeMasks = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_squeezemasks(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 48) {
          _internal_add_squeezemasks(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SliceDynamicLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SliceDynamicLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bool beginMasks = 2;
  if (this->_internal_beginmasks_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_beginmasks(), target);
  }

  // repeated int64 endIds = 3;
  {
    int byte_size = _endids_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          3, _internal_endids(), byte_size, target);
    }
  }

  // repeated bool endMasks = 4;
  if (this->_internal_endmasks_size() > 0) {
    target = stream->WriteFixedPacked(4, _internal_endmasks(), target);
  }

  // repeated int64 strides = 5;
  {
    int byte_size = _strides_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          5, _internal_strides(), byte_size, target);
    }
  }

  // repeated bool squeezeMasks = 6;
  if (this->_internal_squeezemasks_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_squeezemasks(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SliceDynamicLayerParams)
  return target;
}

size_t SliceDynamicLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SliceDynamicLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bool beginMasks = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_beginmasks_size());
    size_t data_size = 1UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated int64 endIds = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->endids_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _endids_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated bool endMasks = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_endmasks_size());
    size_t data_size = 1UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated int64 strides = 5;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->strides_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _strides_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated bool squeezeMasks = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_squeezemasks_size());
    size_t data_size = 1UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SliceDynamicLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SliceDynamicLayerParams*>(
      &from));
}

void SliceDynamicLayerParams::MergeFrom(const SliceDynamicLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SliceDynamicLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  beginmasks_.MergeFrom(from.beginmasks_);
  endids_.MergeFrom(from.endids_);
  endmasks_.MergeFrom(from.endmasks_);
  strides_.MergeFrom(from.strides_);
  squeezemasks_.MergeFrom(from.squeezemasks_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SliceDynamicLayerParams::CopyFrom(const SliceDynamicLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SliceDynamicLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SliceDynamicLayerParams::IsInitialized() const {
  return true;
}

void SliceDynamicLayerParams::InternalSwap(SliceDynamicLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  beginmasks_.InternalSwap(&other->beginmasks_);
  endids_.InternalSwap(&other->endids_);
  endmasks_.InternalSwap(&other->endmasks_);
  strides_.InternalSwap(&other->strides_);
  squeezemasks_.InternalSwap(&other->squeezemasks_);
}

std::string SliceDynamicLayerParams::GetTypeName() const {
  return "CoreML.Specification.SliceDynamicLayerParams";
}


// ===================================================================

class TileLayerParams::_Internal {
 public:
};

TileLayerParams::TileLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  reps_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.TileLayerParams)
}
TileLayerParams::TileLayerParams(const TileLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      reps_(from.reps_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.TileLayerParams)
}

inline void TileLayerParams::SharedCtor() {
}

TileLayerParams::~TileLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.TileLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TileLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TileLayerParams::ArenaDtor(void* object) {
  TileLayerParams* _this = reinterpret_cast< TileLayerParams* >(object);
  (void)_this;
}
void TileLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TileLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TileLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.TileLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  reps_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TileLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 reps = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_reps(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_reps(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TileLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.TileLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 reps = 1;
  {
    int byte_size = _reps_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          1, _internal_reps(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.TileLayerParams)
  return target;
}

size_t TileLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.TileLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 reps = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->reps_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _reps_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TileLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TileLayerParams*>(
      &from));
}

void TileLayerParams::MergeFrom(const TileLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.TileLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  reps_.MergeFrom(from.reps_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TileLayerParams::CopyFrom(const TileLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.TileLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TileLayerParams::IsInitialized() const {
  return true;
}

void TileLayerParams::InternalSwap(TileLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  reps_.InternalSwap(&other->reps_);
}

std::string TileLayerParams::GetTypeName() const {
  return "CoreML.Specification.TileLayerParams";
}


// ===================================================================

class GetShapeLayerParams::_Internal {
 public:
};

GetShapeLayerParams::GetShapeLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.GetShapeLayerParams)
}
GetShapeLayerParams::GetShapeLayerParams(const GetShapeLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.GetShapeLayerParams)
}

inline void GetShapeLayerParams::SharedCtor() {
}

GetShapeLayerParams::~GetShapeLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.GetShapeLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GetShapeLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetShapeLayerParams::ArenaDtor(void* object) {
  GetShapeLayerParams* _this = reinterpret_cast< GetShapeLayerParams* >(object);
  (void)_this;
}
void GetShapeLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetShapeLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetShapeLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.GetShapeLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* GetShapeLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetShapeLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.GetShapeLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.GetShapeLayerParams)
  return target;
}

size_t GetShapeLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.GetShapeLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetShapeLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GetShapeLayerParams*>(
      &from));
}

void GetShapeLayerParams::MergeFrom(const GetShapeLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.GetShapeLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetShapeLayerParams::CopyFrom(const GetShapeLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.GetShapeLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetShapeLayerParams::IsInitialized() const {
  return true;
}

void GetShapeLayerParams::InternalSwap(GetShapeLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string GetShapeLayerParams::GetTypeName() const {
  return "CoreML.Specification.GetShapeLayerParams";
}


// ===================================================================

class ErfLayerParams::_Internal {
 public:
};

ErfLayerParams::ErfLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ErfLayerParams)
}
ErfLayerParams::ErfLayerParams(const ErfLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ErfLayerParams)
}

inline void ErfLayerParams::SharedCtor() {
}

ErfLayerParams::~ErfLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ErfLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ErfLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ErfLayerParams::ArenaDtor(void* object) {
  ErfLayerParams* _this = reinterpret_cast< ErfLayerParams* >(object);
  (void)_this;
}
void ErfLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ErfLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ErfLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ErfLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ErfLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ErfLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ErfLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ErfLayerParams)
  return target;
}

size_t ErfLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ErfLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ErfLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ErfLayerParams*>(
      &from));
}

void ErfLayerParams::MergeFrom(const ErfLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ErfLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ErfLayerParams::CopyFrom(const ErfLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ErfLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ErfLayerParams::IsInitialized() const {
  return true;
}

void ErfLayerParams::InternalSwap(ErfLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ErfLayerParams::GetTypeName() const {
  return "CoreML.Specification.ErfLayerParams";
}


// ===================================================================

class GeluLayerParams::_Internal {
 public:
};

GeluLayerParams::GeluLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.GeluLayerParams)
}
GeluLayerParams::GeluLayerParams(const GeluLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  mode_ = from.mode_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.GeluLayerParams)
}

inline void GeluLayerParams::SharedCtor() {
mode_ = 0;
}

GeluLayerParams::~GeluLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.GeluLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GeluLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GeluLayerParams::ArenaDtor(void* object) {
  GeluLayerParams* _this = reinterpret_cast< GeluLayerParams* >(object);
  (void)_this;
}
void GeluLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GeluLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GeluLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.GeluLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mode_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* GeluLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.GeluLayerParams.GeluMode mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mode(static_cast<::CoreML::Specification::GeluLayerParams_GeluMode>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GeluLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.GeluLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.GeluLayerParams.GeluMode mode = 1;
  if (this->_internal_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.GeluLayerParams)
  return target;
}

size_t GeluLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.GeluLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.GeluLayerParams.GeluMode mode = 1;
  if (this->_internal_mode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GeluLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GeluLayerParams*>(
      &from));
}

void GeluLayerParams::MergeFrom(const GeluLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.GeluLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_mode() != 0) {
    _internal_set_mode(from._internal_mode());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GeluLayerParams::CopyFrom(const GeluLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.GeluLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GeluLayerParams::IsInitialized() const {
  return true;
}

void GeluLayerParams::InternalSwap(GeluLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(mode_, other->mode_);
}

std::string GeluLayerParams::GetTypeName() const {
  return "CoreML.Specification.GeluLayerParams";
}


// ===================================================================

class RangeStaticLayerParams::_Internal {
 public:
};

RangeStaticLayerParams::RangeStaticLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.RangeStaticLayerParams)
}
RangeStaticLayerParams::RangeStaticLayerParams(const RangeStaticLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&endvalue_, &from.endvalue_,
    static_cast<size_t>(reinterpret_cast<char*>(&stepsizevalue_) -
    reinterpret_cast<char*>(&endvalue_)) + sizeof(stepsizevalue_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.RangeStaticLayerParams)
}

inline void RangeStaticLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&endvalue_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&stepsizevalue_) -
    reinterpret_cast<char*>(&endvalue_)) + sizeof(stepsizevalue_));
}

RangeStaticLayerParams::~RangeStaticLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.RangeStaticLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RangeStaticLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RangeStaticLayerParams::ArenaDtor(void* object) {
  RangeStaticLayerParams* _this = reinterpret_cast< RangeStaticLayerParams* >(object);
  (void)_this;
}
void RangeStaticLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RangeStaticLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RangeStaticLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.RangeStaticLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&endvalue_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&stepsizevalue_) -
      reinterpret_cast<char*>(&endvalue_)) + sizeof(stepsizevalue_));
  _internal_metadata_.Clear<std::string>();
}

const char* RangeStaticLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float endValue = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          endvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float startValue = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          startvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float stepSizeValue = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          stepsizevalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RangeStaticLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.RangeStaticLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float endValue = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_endvalue = this->_internal_endvalue();
  uint32_t raw_endvalue;
  memcpy(&raw_endvalue, &tmp_endvalue, sizeof(tmp_endvalue));
  if (raw_endvalue != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_endvalue(), target);
  }

  // float startValue = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_startvalue = this->_internal_startvalue();
  uint32_t raw_startvalue;
  memcpy(&raw_startvalue, &tmp_startvalue, sizeof(tmp_startvalue));
  if (raw_startvalue != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_startvalue(), target);
  }

  // float stepSizeValue = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_stepsizevalue = this->_internal_stepsizevalue();
  uint32_t raw_stepsizevalue;
  memcpy(&raw_stepsizevalue, &tmp_stepsizevalue, sizeof(tmp_stepsizevalue));
  if (raw_stepsizevalue != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_stepsizevalue(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.RangeStaticLayerParams)
  return target;
}

size_t RangeStaticLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.RangeStaticLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float endValue = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_endvalue = this->_internal_endvalue();
  uint32_t raw_endvalue;
  memcpy(&raw_endvalue, &tmp_endvalue, sizeof(tmp_endvalue));
  if (raw_endvalue != 0) {
    total_size += 1 + 4;
  }

  // float startValue = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_startvalue = this->_internal_startvalue();
  uint32_t raw_startvalue;
  memcpy(&raw_startvalue, &tmp_startvalue, sizeof(tmp_startvalue));
  if (raw_startvalue != 0) {
    total_size += 1 + 4;
  }

  // float stepSizeValue = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_stepsizevalue = this->_internal_stepsizevalue();
  uint32_t raw_stepsizevalue;
  memcpy(&raw_stepsizevalue, &tmp_stepsizevalue, sizeof(tmp_stepsizevalue));
  if (raw_stepsizevalue != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RangeStaticLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RangeStaticLayerParams*>(
      &from));
}

void RangeStaticLayerParams::MergeFrom(const RangeStaticLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.RangeStaticLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_endvalue = from._internal_endvalue();
  uint32_t raw_endvalue;
  memcpy(&raw_endvalue, &tmp_endvalue, sizeof(tmp_endvalue));
  if (raw_endvalue != 0) {
    _internal_set_endvalue(from._internal_endvalue());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_startvalue = from._internal_startvalue();
  uint32_t raw_startvalue;
  memcpy(&raw_startvalue, &tmp_startvalue, sizeof(tmp_startvalue));
  if (raw_startvalue != 0) {
    _internal_set_startvalue(from._internal_startvalue());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_stepsizevalue = from._internal_stepsizevalue();
  uint32_t raw_stepsizevalue;
  memcpy(&raw_stepsizevalue, &tmp_stepsizevalue, sizeof(tmp_stepsizevalue));
  if (raw_stepsizevalue != 0) {
    _internal_set_stepsizevalue(from._internal_stepsizevalue());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RangeStaticLayerParams::CopyFrom(const RangeStaticLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.RangeStaticLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeStaticLayerParams::IsInitialized() const {
  return true;
}

void RangeStaticLayerParams::InternalSwap(RangeStaticLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RangeStaticLayerParams, stepsizevalue_)
      + sizeof(RangeStaticLayerParams::stepsizevalue_)
      - PROTOBUF_FIELD_OFFSET(RangeStaticLayerParams, endvalue_)>(
          reinterpret_cast<char*>(&endvalue_),
          reinterpret_cast<char*>(&other->endvalue_));
}

std::string RangeStaticLayerParams::GetTypeName() const {
  return "CoreML.Specification.RangeStaticLayerParams";
}


// ===================================================================

class RangeDynamicLayerParams::_Internal {
 public:
};

RangeDynamicLayerParams::RangeDynamicLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.RangeDynamicLayerParams)
}
RangeDynamicLayerParams::RangeDynamicLayerParams(const RangeDynamicLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&startvalue_, &from.startvalue_,
    static_cast<size_t>(reinterpret_cast<char*>(&stepsizevalue_) -
    reinterpret_cast<char*>(&startvalue_)) + sizeof(stepsizevalue_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.RangeDynamicLayerParams)
}

inline void RangeDynamicLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&startvalue_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&stepsizevalue_) -
    reinterpret_cast<char*>(&startvalue_)) + sizeof(stepsizevalue_));
}

RangeDynamicLayerParams::~RangeDynamicLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.RangeDynamicLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RangeDynamicLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RangeDynamicLayerParams::ArenaDtor(void* object) {
  RangeDynamicLayerParams* _this = reinterpret_cast< RangeDynamicLayerParams* >(object);
  (void)_this;
}
void RangeDynamicLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RangeDynamicLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RangeDynamicLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.RangeDynamicLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&startvalue_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&stepsizevalue_) -
      reinterpret_cast<char*>(&startvalue_)) + sizeof(stepsizevalue_));
  _internal_metadata_.Clear<std::string>();
}

const char* RangeDynamicLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float startValue = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          startvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float stepSizeValue = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          stepsizevalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RangeDynamicLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.RangeDynamicLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float startValue = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_startvalue = this->_internal_startvalue();
  uint32_t raw_startvalue;
  memcpy(&raw_startvalue, &tmp_startvalue, sizeof(tmp_startvalue));
  if (raw_startvalue != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_startvalue(), target);
  }

  // float stepSizeValue = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_stepsizevalue = this->_internal_stepsizevalue();
  uint32_t raw_stepsizevalue;
  memcpy(&raw_stepsizevalue, &tmp_stepsizevalue, sizeof(tmp_stepsizevalue));
  if (raw_stepsizevalue != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_stepsizevalue(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.RangeDynamicLayerParams)
  return target;
}

size_t RangeDynamicLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.RangeDynamicLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float startValue = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_startvalue = this->_internal_startvalue();
  uint32_t raw_startvalue;
  memcpy(&raw_startvalue, &tmp_startvalue, sizeof(tmp_startvalue));
  if (raw_startvalue != 0) {
    total_size += 1 + 4;
  }

  // float stepSizeValue = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_stepsizevalue = this->_internal_stepsizevalue();
  uint32_t raw_stepsizevalue;
  memcpy(&raw_stepsizevalue, &tmp_stepsizevalue, sizeof(tmp_stepsizevalue));
  if (raw_stepsizevalue != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RangeDynamicLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RangeDynamicLayerParams*>(
      &from));
}

void RangeDynamicLayerParams::MergeFrom(const RangeDynamicLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.RangeDynamicLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_startvalue = from._internal_startvalue();
  uint32_t raw_startvalue;
  memcpy(&raw_startvalue, &tmp_startvalue, sizeof(tmp_startvalue));
  if (raw_startvalue != 0) {
    _internal_set_startvalue(from._internal_startvalue());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_stepsizevalue = from._internal_stepsizevalue();
  uint32_t raw_stepsizevalue;
  memcpy(&raw_stepsizevalue, &tmp_stepsizevalue, sizeof(tmp_stepsizevalue));
  if (raw_stepsizevalue != 0) {
    _internal_set_stepsizevalue(from._internal_stepsizevalue());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RangeDynamicLayerParams::CopyFrom(const RangeDynamicLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.RangeDynamicLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeDynamicLayerParams::IsInitialized() const {
  return true;
}

void RangeDynamicLayerParams::InternalSwap(RangeDynamicLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RangeDynamicLayerParams, stepsizevalue_)
      + sizeof(RangeDynamicLayerParams::stepsizevalue_)
      - PROTOBUF_FIELD_OFFSET(RangeDynamicLayerParams, startvalue_)>(
          reinterpret_cast<char*>(&startvalue_),
          reinterpret_cast<char*>(&other->startvalue_));
}

std::string RangeDynamicLayerParams::GetTypeName() const {
  return "CoreML.Specification.RangeDynamicLayerParams";
}


// ===================================================================

class SlidingWindowsLayerParams::_Internal {
 public:
};

SlidingWindowsLayerParams::SlidingWindowsLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SlidingWindowsLayerParams)
}
SlidingWindowsLayerParams::SlidingWindowsLayerParams(const SlidingWindowsLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&axis_, &from.axis_,
    static_cast<size_t>(reinterpret_cast<char*>(&step_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(step_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SlidingWindowsLayerParams)
}

inline void SlidingWindowsLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&axis_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&step_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(step_));
}

SlidingWindowsLayerParams::~SlidingWindowsLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SlidingWindowsLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SlidingWindowsLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SlidingWindowsLayerParams::ArenaDtor(void* object) {
  SlidingWindowsLayerParams* _this = reinterpret_cast< SlidingWindowsLayerParams* >(object);
  (void)_this;
}
void SlidingWindowsLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SlidingWindowsLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SlidingWindowsLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SlidingWindowsLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&axis_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&step_) -
      reinterpret_cast<char*>(&axis_)) + sizeof(step_));
  _internal_metadata_.Clear<std::string>();
}

const char* SlidingWindowsLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 axis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 windowSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          windowsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 step = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          step_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SlidingWindowsLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SlidingWindowsLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_axis(), target);
  }

  // uint64 windowSize = 2;
  if (this->_internal_windowsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_windowsize(), target);
  }

  // uint64 step = 3;
  if (this->_internal_step() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_step(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SlidingWindowsLayerParams)
  return target;
}

size_t SlidingWindowsLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SlidingWindowsLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_axis());
  }

  // uint64 windowSize = 2;
  if (this->_internal_windowsize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_windowsize());
  }

  // uint64 step = 3;
  if (this->_internal_step() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_step());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SlidingWindowsLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SlidingWindowsLayerParams*>(
      &from));
}

void SlidingWindowsLayerParams::MergeFrom(const SlidingWindowsLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SlidingWindowsLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  if (from._internal_windowsize() != 0) {
    _internal_set_windowsize(from._internal_windowsize());
  }
  if (from._internal_step() != 0) {
    _internal_set_step(from._internal_step());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SlidingWindowsLayerParams::CopyFrom(const SlidingWindowsLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SlidingWindowsLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlidingWindowsLayerParams::IsInitialized() const {
  return true;
}

void SlidingWindowsLayerParams::InternalSwap(SlidingWindowsLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SlidingWindowsLayerParams, step_)
      + sizeof(SlidingWindowsLayerParams::step_)
      - PROTOBUF_FIELD_OFFSET(SlidingWindowsLayerParams, axis_)>(
          reinterpret_cast<char*>(&axis_),
          reinterpret_cast<char*>(&other->axis_));
}

std::string SlidingWindowsLayerParams::GetTypeName() const {
  return "CoreML.Specification.SlidingWindowsLayerParams";
}


// ===================================================================

class LayerNormalizationLayerParams::_Internal {
 public:
  static const ::CoreML::Specification::WeightParams& gamma(const LayerNormalizationLayerParams* msg);
  static const ::CoreML::Specification::WeightParams& beta(const LayerNormalizationLayerParams* msg);
};

const ::CoreML::Specification::WeightParams&
LayerNormalizationLayerParams::_Internal::gamma(const LayerNormalizationLayerParams* msg) {
  return *msg->gamma_;
}
const ::CoreML::Specification::WeightParams&
LayerNormalizationLayerParams::_Internal::beta(const LayerNormalizationLayerParams* msg) {
  return *msg->beta_;
}
LayerNormalizationLayerParams::LayerNormalizationLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  normalizedshape_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LayerNormalizationLayerParams)
}
LayerNormalizationLayerParams::LayerNormalizationLayerParams(const LayerNormalizationLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      normalizedshape_(from.normalizedshape_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_gamma()) {
    gamma_ = new ::CoreML::Specification::WeightParams(*from.gamma_);
  } else {
    gamma_ = nullptr;
  }
  if (from._internal_has_beta()) {
    beta_ = new ::CoreML::Specification::WeightParams(*from.beta_);
  } else {
    beta_ = nullptr;
  }
  eps_ = from.eps_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LayerNormalizationLayerParams)
}

inline void LayerNormalizationLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gamma_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&eps_) -
    reinterpret_cast<char*>(&gamma_)) + sizeof(eps_));
}

LayerNormalizationLayerParams::~LayerNormalizationLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LayerNormalizationLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LayerNormalizationLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete gamma_;
  if (this != internal_default_instance()) delete beta_;
}

void LayerNormalizationLayerParams::ArenaDtor(void* object) {
  LayerNormalizationLayerParams* _this = reinterpret_cast< LayerNormalizationLayerParams* >(object);
  (void)_this;
}
void LayerNormalizationLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LayerNormalizationLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LayerNormalizationLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LayerNormalizationLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  normalizedshape_.Clear();
  if (GetArenaForAllocation() == nullptr && gamma_ != nullptr) {
    delete gamma_;
  }
  gamma_ = nullptr;
  if (GetArenaForAllocation() == nullptr && beta_ != nullptr) {
    delete beta_;
  }
  beta_ = nullptr;
  eps_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* LayerNormalizationLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 normalizedShape = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_normalizedshape(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_normalizedshape(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float eps = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          eps_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams gamma = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_gamma(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.WeightParams beta = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_beta(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LayerNormalizationLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LayerNormalizationLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 normalizedShape = 1;
  {
    int byte_size = _normalizedshape_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_normalizedshape(), byte_size, target);
    }
  }

  // float eps = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eps = this->_internal_eps();
  uint32_t raw_eps;
  memcpy(&raw_eps, &tmp_eps, sizeof(tmp_eps));
  if (raw_eps != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_eps(), target);
  }

  // .CoreML.Specification.WeightParams gamma = 3;
  if (this->_internal_has_gamma()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::gamma(this), target, stream);
  }

  // .CoreML.Specification.WeightParams beta = 4;
  if (this->_internal_has_beta()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::beta(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LayerNormalizationLayerParams)
  return target;
}

size_t LayerNormalizationLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LayerNormalizationLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 normalizedShape = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->normalizedshape_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _normalizedshape_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .CoreML.Specification.WeightParams gamma = 3;
  if (this->_internal_has_gamma()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *gamma_);
  }

  // .CoreML.Specification.WeightParams beta = 4;
  if (this->_internal_has_beta()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *beta_);
  }

  // float eps = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eps = this->_internal_eps();
  uint32_t raw_eps;
  memcpy(&raw_eps, &tmp_eps, sizeof(tmp_eps));
  if (raw_eps != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LayerNormalizationLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LayerNormalizationLayerParams*>(
      &from));
}

void LayerNormalizationLayerParams::MergeFrom(const LayerNormalizationLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LayerNormalizationLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  normalizedshape_.MergeFrom(from.normalizedshape_);
  if (from._internal_has_gamma()) {
    _internal_mutable_gamma()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_gamma());
  }
  if (from._internal_has_beta()) {
    _internal_mutable_beta()->::CoreML::Specification::WeightParams::MergeFrom(from._internal_beta());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eps = from._internal_eps();
  uint32_t raw_eps;
  memcpy(&raw_eps, &tmp_eps, sizeof(tmp_eps));
  if (raw_eps != 0) {
    _internal_set_eps(from._internal_eps());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LayerNormalizationLayerParams::CopyFrom(const LayerNormalizationLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LayerNormalizationLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LayerNormalizationLayerParams::IsInitialized() const {
  return true;
}

void LayerNormalizationLayerParams::InternalSwap(LayerNormalizationLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  normalizedshape_.InternalSwap(&other->normalizedshape_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LayerNormalizationLayerParams, eps_)
      + sizeof(LayerNormalizationLayerParams::eps_)
      - PROTOBUF_FIELD_OFFSET(LayerNormalizationLayerParams, gamma_)>(
          reinterpret_cast<char*>(&gamma_),
          reinterpret_cast<char*>(&other->gamma_));
}

std::string LayerNormalizationLayerParams::GetTypeName() const {
  return "CoreML.Specification.LayerNormalizationLayerParams";
}


// ===================================================================

class NonMaximumSuppressionLayerParams::_Internal {
 public:
};

NonMaximumSuppressionLayerParams::NonMaximumSuppressionLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.NonMaximumSuppressionLayerParams)
}
NonMaximumSuppressionLayerParams::NonMaximumSuppressionLayerParams(const NonMaximumSuppressionLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&iouthreshold_, &from.iouthreshold_,
    static_cast<size_t>(reinterpret_cast<char*>(&perclasssuppression_) -
    reinterpret_cast<char*>(&iouthreshold_)) + sizeof(perclasssuppression_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.NonMaximumSuppressionLayerParams)
}

inline void NonMaximumSuppressionLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&iouthreshold_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&perclasssuppression_) -
    reinterpret_cast<char*>(&iouthreshold_)) + sizeof(perclasssuppression_));
}

NonMaximumSuppressionLayerParams::~NonMaximumSuppressionLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.NonMaximumSuppressionLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void NonMaximumSuppressionLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NonMaximumSuppressionLayerParams::ArenaDtor(void* object) {
  NonMaximumSuppressionLayerParams* _this = reinterpret_cast< NonMaximumSuppressionLayerParams* >(object);
  (void)_this;
}
void NonMaximumSuppressionLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NonMaximumSuppressionLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NonMaximumSuppressionLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.NonMaximumSuppressionLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&iouthreshold_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&perclasssuppression_) -
      reinterpret_cast<char*>(&iouthreshold_)) + sizeof(perclasssuppression_));
  _internal_metadata_.Clear<std::string>();
}

const char* NonMaximumSuppressionLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float iouThreshold = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          iouthreshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float scoreThreshold = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          scorethreshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // uint64 maxBoxes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          maxboxes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool perClassSuppression = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          perclasssuppression_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NonMaximumSuppressionLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.NonMaximumSuppressionLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float iouThreshold = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_iouthreshold = this->_internal_iouthreshold();
  uint32_t raw_iouthreshold;
  memcpy(&raw_iouthreshold, &tmp_iouthreshold, sizeof(tmp_iouthreshold));
  if (raw_iouthreshold != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_iouthreshold(), target);
  }

  // float scoreThreshold = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scorethreshold = this->_internal_scorethreshold();
  uint32_t raw_scorethreshold;
  memcpy(&raw_scorethreshold, &tmp_scorethreshold, sizeof(tmp_scorethreshold));
  if (raw_scorethreshold != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_scorethreshold(), target);
  }

  // uint64 maxBoxes = 3;
  if (this->_internal_maxboxes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_maxboxes(), target);
  }

  // bool perClassSuppression = 4;
  if (this->_internal_perclasssuppression() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_perclasssuppression(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.NonMaximumSuppressionLayerParams)
  return target;
}

size_t NonMaximumSuppressionLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.NonMaximumSuppressionLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float iouThreshold = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_iouthreshold = this->_internal_iouthreshold();
  uint32_t raw_iouthreshold;
  memcpy(&raw_iouthreshold, &tmp_iouthreshold, sizeof(tmp_iouthreshold));
  if (raw_iouthreshold != 0) {
    total_size += 1 + 4;
  }

  // float scoreThreshold = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scorethreshold = this->_internal_scorethreshold();
  uint32_t raw_scorethreshold;
  memcpy(&raw_scorethreshold, &tmp_scorethreshold, sizeof(tmp_scorethreshold));
  if (raw_scorethreshold != 0) {
    total_size += 1 + 4;
  }

  // uint64 maxBoxes = 3;
  if (this->_internal_maxboxes() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_maxboxes());
  }

  // bool perClassSuppression = 4;
  if (this->_internal_perclasssuppression() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NonMaximumSuppressionLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const NonMaximumSuppressionLayerParams*>(
      &from));
}

void NonMaximumSuppressionLayerParams::MergeFrom(const NonMaximumSuppressionLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.NonMaximumSuppressionLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_iouthreshold = from._internal_iouthreshold();
  uint32_t raw_iouthreshold;
  memcpy(&raw_iouthreshold, &tmp_iouthreshold, sizeof(tmp_iouthreshold));
  if (raw_iouthreshold != 0) {
    _internal_set_iouthreshold(from._internal_iouthreshold());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scorethreshold = from._internal_scorethreshold();
  uint32_t raw_scorethreshold;
  memcpy(&raw_scorethreshold, &tmp_scorethreshold, sizeof(tmp_scorethreshold));
  if (raw_scorethreshold != 0) {
    _internal_set_scorethreshold(from._internal_scorethreshold());
  }
  if (from._internal_maxboxes() != 0) {
    _internal_set_maxboxes(from._internal_maxboxes());
  }
  if (from._internal_perclasssuppression() != 0) {
    _internal_set_perclasssuppression(from._internal_perclasssuppression());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NonMaximumSuppressionLayerParams::CopyFrom(const NonMaximumSuppressionLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.NonMaximumSuppressionLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NonMaximumSuppressionLayerParams::IsInitialized() const {
  return true;
}

void NonMaximumSuppressionLayerParams::InternalSwap(NonMaximumSuppressionLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NonMaximumSuppressionLayerParams, perclasssuppression_)
      + sizeof(NonMaximumSuppressionLayerParams::perclasssuppression_)
      - PROTOBUF_FIELD_OFFSET(NonMaximumSuppressionLayerParams, iouthreshold_)>(
          reinterpret_cast<char*>(&iouthreshold_),
          reinterpret_cast<char*>(&other->iouthreshold_));
}

std::string NonMaximumSuppressionLayerParams::GetTypeName() const {
  return "CoreML.Specification.NonMaximumSuppressionLayerParams";
}


// ===================================================================

class ClampedReLULayerParams::_Internal {
 public:
};

ClampedReLULayerParams::ClampedReLULayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ClampedReLULayerParams)
}
ClampedReLULayerParams::ClampedReLULayerParams(const ClampedReLULayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&alpha_, &from.alpha_,
    static_cast<size_t>(reinterpret_cast<char*>(&beta_) -
    reinterpret_cast<char*>(&alpha_)) + sizeof(beta_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ClampedReLULayerParams)
}

inline void ClampedReLULayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&alpha_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&beta_) -
    reinterpret_cast<char*>(&alpha_)) + sizeof(beta_));
}

ClampedReLULayerParams::~ClampedReLULayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ClampedReLULayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ClampedReLULayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClampedReLULayerParams::ArenaDtor(void* object) {
  ClampedReLULayerParams* _this = reinterpret_cast< ClampedReLULayerParams* >(object);
  (void)_this;
}
void ClampedReLULayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ClampedReLULayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClampedReLULayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ClampedReLULayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&alpha_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&beta_) -
      reinterpret_cast<char*>(&alpha_)) + sizeof(beta_));
  _internal_metadata_.Clear<std::string>();
}

const char* ClampedReLULayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float alpha = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float beta = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          beta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClampedReLULayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ClampedReLULayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_alpha(), target);
  }

  // float beta = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_beta = this->_internal_beta();
  uint32_t raw_beta;
  memcpy(&raw_beta, &tmp_beta, sizeof(tmp_beta));
  if (raw_beta != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_beta(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ClampedReLULayerParams)
  return target;
}

size_t ClampedReLULayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ClampedReLULayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float alpha = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = this->_internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    total_size += 1 + 4;
  }

  // float beta = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_beta = this->_internal_beta();
  uint32_t raw_beta;
  memcpy(&raw_beta, &tmp_beta, sizeof(tmp_beta));
  if (raw_beta != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClampedReLULayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ClampedReLULayerParams*>(
      &from));
}

void ClampedReLULayerParams::MergeFrom(const ClampedReLULayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ClampedReLULayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alpha = from._internal_alpha();
  uint32_t raw_alpha;
  memcpy(&raw_alpha, &tmp_alpha, sizeof(tmp_alpha));
  if (raw_alpha != 0) {
    _internal_set_alpha(from._internal_alpha());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_beta = from._internal_beta();
  uint32_t raw_beta;
  memcpy(&raw_beta, &tmp_beta, sizeof(tmp_beta));
  if (raw_beta != 0) {
    _internal_set_beta(from._internal_beta());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClampedReLULayerParams::CopyFrom(const ClampedReLULayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ClampedReLULayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClampedReLULayerParams::IsInitialized() const {
  return true;
}

void ClampedReLULayerParams::InternalSwap(ClampedReLULayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClampedReLULayerParams, beta_)
      + sizeof(ClampedReLULayerParams::beta_)
      - PROTOBUF_FIELD_OFFSET(ClampedReLULayerParams, alpha_)>(
          reinterpret_cast<char*>(&alpha_),
          reinterpret_cast<char*>(&other->alpha_));
}

std::string ClampedReLULayerParams::GetTypeName() const {
  return "CoreML.Specification.ClampedReLULayerParams";
}


// ===================================================================

class ArgSortLayerParams::_Internal {
 public:
};

ArgSortLayerParams::ArgSortLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.ArgSortLayerParams)
}
ArgSortLayerParams::ArgSortLayerParams(const ArgSortLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&axis_, &from.axis_,
    static_cast<size_t>(reinterpret_cast<char*>(&descending_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(descending_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.ArgSortLayerParams)
}

inline void ArgSortLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&axis_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&descending_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(descending_));
}

ArgSortLayerParams::~ArgSortLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.ArgSortLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ArgSortLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ArgSortLayerParams::ArenaDtor(void* object) {
  ArgSortLayerParams* _this = reinterpret_cast< ArgSortLayerParams* >(object);
  (void)_this;
}
void ArgSortLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ArgSortLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArgSortLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.ArgSortLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&axis_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&descending_) -
      reinterpret_cast<char*>(&axis_)) + sizeof(descending_));
  _internal_metadata_.Clear<std::string>();
}

const char* ArgSortLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 axis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool descending = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          descending_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArgSortLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.ArgSortLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_axis(), target);
  }

  // bool descending = 2;
  if (this->_internal_descending() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_descending(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.ArgSortLayerParams)
  return target;
}

size_t ArgSortLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.ArgSortLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_axis());
  }

  // bool descending = 2;
  if (this->_internal_descending() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ArgSortLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ArgSortLayerParams*>(
      &from));
}

void ArgSortLayerParams::MergeFrom(const ArgSortLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.ArgSortLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  if (from._internal_descending() != 0) {
    _internal_set_descending(from._internal_descending());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ArgSortLayerParams::CopyFrom(const ArgSortLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.ArgSortLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArgSortLayerParams::IsInitialized() const {
  return true;
}

void ArgSortLayerParams::InternalSwap(ArgSortLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArgSortLayerParams, descending_)
      + sizeof(ArgSortLayerParams::descending_)
      - PROTOBUF_FIELD_OFFSET(ArgSortLayerParams, axis_)>(
          reinterpret_cast<char*>(&axis_),
          reinterpret_cast<char*>(&other->axis_));
}

std::string ArgSortLayerParams::GetTypeName() const {
  return "CoreML.Specification.ArgSortLayerParams";
}


// ===================================================================

class SliceBySizeLayerParams::_Internal {
 public:
};

SliceBySizeLayerParams::SliceBySizeLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SliceBySizeLayerParams)
}
SliceBySizeLayerParams::SliceBySizeLayerParams(const SliceBySizeLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&size_, &from.size_,
    static_cast<size_t>(reinterpret_cast<char*>(&axis_) -
    reinterpret_cast<char*>(&size_)) + sizeof(axis_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SliceBySizeLayerParams)
}

inline void SliceBySizeLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&size_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&axis_) -
    reinterpret_cast<char*>(&size_)) + sizeof(axis_));
}

SliceBySizeLayerParams::~SliceBySizeLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SliceBySizeLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SliceBySizeLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SliceBySizeLayerParams::ArenaDtor(void* object) {
  SliceBySizeLayerParams* _this = reinterpret_cast< SliceBySizeLayerParams* >(object);
  (void)_this;
}
void SliceBySizeLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SliceBySizeLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SliceBySizeLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SliceBySizeLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&axis_) -
      reinterpret_cast<char*>(&size_)) + sizeof(axis_));
  _internal_metadata_.Clear<std::string>();
}

const char* SliceBySizeLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 axis = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SliceBySizeLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SliceBySizeLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 size = 2;
  if (this->_internal_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_size(), target);
  }

  // int64 axis = 3;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_axis(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SliceBySizeLayerParams)
  return target;
}

size_t SliceBySizeLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SliceBySizeLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 size = 2;
  if (this->_internal_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_size());
  }

  // int64 axis = 3;
  if (this->_internal_axis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_axis());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SliceBySizeLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SliceBySizeLayerParams*>(
      &from));
}

void SliceBySizeLayerParams::MergeFrom(const SliceBySizeLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SliceBySizeLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_size() != 0) {
    _internal_set_size(from._internal_size());
  }
  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SliceBySizeLayerParams::CopyFrom(const SliceBySizeLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SliceBySizeLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SliceBySizeLayerParams::IsInitialized() const {
  return true;
}

void SliceBySizeLayerParams::InternalSwap(SliceBySizeLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SliceBySizeLayerParams, axis_)
      + sizeof(SliceBySizeLayerParams::axis_)
      - PROTOBUF_FIELD_OFFSET(SliceBySizeLayerParams, size_)>(
          reinterpret_cast<char*>(&size_),
          reinterpret_cast<char*>(&other->size_));
}

std::string SliceBySizeLayerParams::GetTypeName() const {
  return "CoreML.Specification.SliceBySizeLayerParams";
}


// ===================================================================

class NeuralNetworkClassifier::_Internal {
 public:
  static const ::CoreML::Specification::NetworkUpdateParameters& updateparams(const NeuralNetworkClassifier* msg);
  static const ::CoreML::Specification::StringVector& stringclasslabels(const NeuralNetworkClassifier* msg);
  static const ::CoreML::Specification::Int64Vector& int64classlabels(const NeuralNetworkClassifier* msg);
};

const ::CoreML::Specification::NetworkUpdateParameters&
NeuralNetworkClassifier::_Internal::updateparams(const NeuralNetworkClassifier* msg) {
  return *msg->updateparams_;
}
const ::CoreML::Specification::StringVector&
NeuralNetworkClassifier::_Internal::stringclasslabels(const NeuralNetworkClassifier* msg) {
  return *msg->ClassLabels_.stringclasslabels_;
}
const ::CoreML::Specification::Int64Vector&
NeuralNetworkClassifier::_Internal::int64classlabels(const NeuralNetworkClassifier* msg) {
  return *msg->ClassLabels_.int64classlabels_;
}
void NeuralNetworkClassifier::set_allocated_stringclasslabels(::CoreML::Specification::StringVector* stringclasslabels) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ClassLabels();
  if (stringclasslabels) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stringclasslabels));
    if (message_arena != submessage_arena) {
      stringclasslabels = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stringclasslabels, submessage_arena);
    }
    set_has_stringclasslabels();
    ClassLabels_.stringclasslabels_ = stringclasslabels;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkClassifier.stringClassLabels)
}
void NeuralNetworkClassifier::clear_stringclasslabels() {
  if (_internal_has_stringclasslabels()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ClassLabels_.stringclasslabels_;
    }
    clear_has_ClassLabels();
  }
}
void NeuralNetworkClassifier::set_allocated_int64classlabels(::CoreML::Specification::Int64Vector* int64classlabels) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ClassLabels();
  if (int64classlabels) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(int64classlabels));
    if (message_arena != submessage_arena) {
      int64classlabels = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, int64classlabels, submessage_arena);
    }
    set_has_int64classlabels();
    ClassLabels_.int64classlabels_ = int64classlabels;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkClassifier.int64ClassLabels)
}
void NeuralNetworkClassifier::clear_int64classlabels() {
  if (_internal_has_int64classlabels()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ClassLabels_.int64classlabels_;
    }
    clear_has_ClassLabels();
  }
}
NeuralNetworkClassifier::NeuralNetworkClassifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  layers_(arena),
  preprocessing_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.NeuralNetworkClassifier)
}
NeuralNetworkClassifier::NeuralNetworkClassifier(const NeuralNetworkClassifier& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      layers_(from.layers_),
      preprocessing_(from.preprocessing_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  labelprobabilitylayername_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    labelprobabilitylayername_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_labelprobabilitylayername().empty()) {
    labelprobabilitylayername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_labelprobabilitylayername(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_updateparams()) {
    updateparams_ = new ::CoreML::Specification::NetworkUpdateParameters(*from.updateparams_);
  } else {
    updateparams_ = nullptr;
  }
  ::memcpy(&arrayinputshapemapping_, &from.arrayinputshapemapping_,
    static_cast<size_t>(reinterpret_cast<char*>(&imageinputshapemapping_) -
    reinterpret_cast<char*>(&arrayinputshapemapping_)) + sizeof(imageinputshapemapping_));
  clear_has_ClassLabels();
  switch (from.ClassLabels_case()) {
    case kStringClassLabels: {
      _internal_mutable_stringclasslabels()->::CoreML::Specification::StringVector::MergeFrom(from._internal_stringclasslabels());
      break;
    }
    case kInt64ClassLabels: {
      _internal_mutable_int64classlabels()->::CoreML::Specification::Int64Vector::MergeFrom(from._internal_int64classlabels());
      break;
    }
    case CLASSLABELS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.NeuralNetworkClassifier)
}

inline void NeuralNetworkClassifier::SharedCtor() {
labelprobabilitylayername_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  labelprobabilitylayername_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&updateparams_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&imageinputshapemapping_) -
    reinterpret_cast<char*>(&updateparams_)) + sizeof(imageinputshapemapping_));
clear_has_ClassLabels();
}

NeuralNetworkClassifier::~NeuralNetworkClassifier() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.NeuralNetworkClassifier)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void NeuralNetworkClassifier::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  labelprobabilitylayername_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete updateparams_;
  if (has_ClassLabels()) {
    clear_ClassLabels();
  }
}

void NeuralNetworkClassifier::ArenaDtor(void* object) {
  NeuralNetworkClassifier* _this = reinterpret_cast< NeuralNetworkClassifier* >(object);
  (void)_this;
}
void NeuralNetworkClassifier::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NeuralNetworkClassifier::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NeuralNetworkClassifier::clear_ClassLabels() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.NeuralNetworkClassifier)
  switch (ClassLabels_case()) {
    case kStringClassLabels: {
      if (GetArenaForAllocation() == nullptr) {
        delete ClassLabels_.stringclasslabels_;
      }
      break;
    }
    case kInt64ClassLabels: {
      if (GetArenaForAllocation() == nullptr) {
        delete ClassLabels_.int64classlabels_;
      }
      break;
    }
    case CLASSLABELS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = CLASSLABELS_NOT_SET;
}


void NeuralNetworkClassifier::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.NeuralNetworkClassifier)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  layers_.Clear();
  preprocessing_.Clear();
  labelprobabilitylayername_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && updateparams_ != nullptr) {
    delete updateparams_;
  }
  updateparams_ = nullptr;
  ::memset(&arrayinputshapemapping_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&imageinputshapemapping_) -
      reinterpret_cast<char*>(&arrayinputshapemapping_)) + sizeof(imageinputshapemapping_));
  clear_ClassLabels();
  _internal_metadata_.Clear<std::string>();
}

const char* NeuralNetworkClassifier::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.NeuralNetworkLayer layers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_layers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.NeuralNetworkPreprocessing preprocessing = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_preprocessing(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NeuralNetworkMultiArrayShapeMapping arrayInputShapeMapping = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_arrayinputshapemapping(static_cast<::CoreML::Specification::NeuralNetworkMultiArrayShapeMapping>(val));
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NeuralNetworkImageShapeMapping imageInputShapeMapping = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_imageinputshapemapping(static_cast<::CoreML::Specification::NeuralNetworkImageShapeMapping>(val));
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NetworkUpdateParameters updateParams = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_updateparams(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.StringVector stringClassLabels = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_stringclasslabels(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Int64Vector int64ClassLabels = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_int64classlabels(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string labelProbabilityLayerName = 200;
      case 200:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_labelprobabilitylayername();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NeuralNetworkClassifier::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.NeuralNetworkClassifier)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.NeuralNetworkLayer layers = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_layers_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_layers(i), target, stream);
  }

  // repeated .CoreML.Specification.NeuralNetworkPreprocessing preprocessing = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_preprocessing_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_preprocessing(i), target, stream);
  }

  // .CoreML.Specification.NeuralNetworkMultiArrayShapeMapping arrayInputShapeMapping = 5;
  if (this->_internal_arrayinputshapemapping() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_arrayinputshapemapping(), target);
  }

  // .CoreML.Specification.NeuralNetworkImageShapeMapping imageInputShapeMapping = 6;
  if (this->_internal_imageinputshapemapping() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_imageinputshapemapping(), target);
  }

  // .CoreML.Specification.NetworkUpdateParameters updateParams = 10;
  if (this->_internal_has_updateparams()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::updateparams(this), target, stream);
  }

  // .CoreML.Specification.StringVector stringClassLabels = 100;
  if (_internal_has_stringclasslabels()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        100, _Internal::stringclasslabels(this), target, stream);
  }

  // .CoreML.Specification.Int64Vector int64ClassLabels = 101;
  if (_internal_has_int64classlabels()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        101, _Internal::int64classlabels(this), target, stream);
  }

  // string labelProbabilityLayerName = 200;
  if (!this->_internal_labelprobabilitylayername().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_labelprobabilitylayername().data(), static_cast<int>(this->_internal_labelprobabilitylayername().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.NeuralNetworkClassifier.labelProbabilityLayerName");
    target = stream->WriteStringMaybeAliased(
        200, this->_internal_labelprobabilitylayername(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.NeuralNetworkClassifier)
  return target;
}

size_t NeuralNetworkClassifier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.NeuralNetworkClassifier)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.NeuralNetworkLayer layers = 1;
  total_size += 1UL * this->_internal_layers_size();
  for (const auto& msg : this->layers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CoreML.Specification.NeuralNetworkPreprocessing preprocessing = 2;
  total_size += 1UL * this->_internal_preprocessing_size();
  for (const auto& msg : this->preprocessing_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string labelProbabilityLayerName = 200;
  if (!this->_internal_labelprobabilitylayername().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_labelprobabilitylayername());
  }

  // .CoreML.Specification.NetworkUpdateParameters updateParams = 10;
  if (this->_internal_has_updateparams()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *updateparams_);
  }

  // .CoreML.Specification.NeuralNetworkMultiArrayShapeMapping arrayInputShapeMapping = 5;
  if (this->_internal_arrayinputshapemapping() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_arrayinputshapemapping());
  }

  // .CoreML.Specification.NeuralNetworkImageShapeMapping imageInputShapeMapping = 6;
  if (this->_internal_imageinputshapemapping() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_imageinputshapemapping());
  }

  switch (ClassLabels_case()) {
    // .CoreML.Specification.StringVector stringClassLabels = 100;
    case kStringClassLabels: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ClassLabels_.stringclasslabels_);
      break;
    }
    // .CoreML.Specification.Int64Vector int64ClassLabels = 101;
    case kInt64ClassLabels: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ClassLabels_.int64classlabels_);
      break;
    }
    case CLASSLABELS_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NeuralNetworkClassifier::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const NeuralNetworkClassifier*>(
      &from));
}

void NeuralNetworkClassifier::MergeFrom(const NeuralNetworkClassifier& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.NeuralNetworkClassifier)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  layers_.MergeFrom(from.layers_);
  preprocessing_.MergeFrom(from.preprocessing_);
  if (!from._internal_labelprobabilitylayername().empty()) {
    _internal_set_labelprobabilitylayername(from._internal_labelprobabilitylayername());
  }
  if (from._internal_has_updateparams()) {
    _internal_mutable_updateparams()->::CoreML::Specification::NetworkUpdateParameters::MergeFrom(from._internal_updateparams());
  }
  if (from._internal_arrayinputshapemapping() != 0) {
    _internal_set_arrayinputshapemapping(from._internal_arrayinputshapemapping());
  }
  if (from._internal_imageinputshapemapping() != 0) {
    _internal_set_imageinputshapemapping(from._internal_imageinputshapemapping());
  }
  switch (from.ClassLabels_case()) {
    case kStringClassLabels: {
      _internal_mutable_stringclasslabels()->::CoreML::Specification::StringVector::MergeFrom(from._internal_stringclasslabels());
      break;
    }
    case kInt64ClassLabels: {
      _internal_mutable_int64classlabels()->::CoreML::Specification::Int64Vector::MergeFrom(from._internal_int64classlabels());
      break;
    }
    case CLASSLABELS_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NeuralNetworkClassifier::CopyFrom(const NeuralNetworkClassifier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.NeuralNetworkClassifier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NeuralNetworkClassifier::IsInitialized() const {
  return true;
}

void NeuralNetworkClassifier::InternalSwap(NeuralNetworkClassifier* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  layers_.InternalSwap(&other->layers_);
  preprocessing_.InternalSwap(&other->preprocessing_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &labelprobabilitylayername_, lhs_arena,
      &other->labelprobabilitylayername_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NeuralNetworkClassifier, imageinputshapemapping_)
      + sizeof(NeuralNetworkClassifier::imageinputshapemapping_)
      - PROTOBUF_FIELD_OFFSET(NeuralNetworkClassifier, updateparams_)>(
          reinterpret_cast<char*>(&updateparams_),
          reinterpret_cast<char*>(&other->updateparams_));
  swap(ClassLabels_, other->ClassLabels_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string NeuralNetworkClassifier::GetTypeName() const {
  return "CoreML.Specification.NeuralNetworkClassifier";
}


// ===================================================================

class OneHotLayerParams::_Internal {
 public:
};

OneHotLayerParams::OneHotLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.OneHotLayerParams)
}
OneHotLayerParams::OneHotLayerParams(const OneHotLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&onehotvectorsize_, &from.onehotvectorsize_,
    static_cast<size_t>(reinterpret_cast<char*>(&offvalue_) -
    reinterpret_cast<char*>(&onehotvectorsize_)) + sizeof(offvalue_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.OneHotLayerParams)
}

inline void OneHotLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&onehotvectorsize_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&offvalue_) -
    reinterpret_cast<char*>(&onehotvectorsize_)) + sizeof(offvalue_));
}

OneHotLayerParams::~OneHotLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.OneHotLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void OneHotLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void OneHotLayerParams::ArenaDtor(void* object) {
  OneHotLayerParams* _this = reinterpret_cast< OneHotLayerParams* >(object);
  (void)_this;
}
void OneHotLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void OneHotLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OneHotLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.OneHotLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&onehotvectorsize_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&offvalue_) -
      reinterpret_cast<char*>(&onehotvectorsize_)) + sizeof(offvalue_));
  _internal_metadata_.Clear<std::string>();
}

const char* OneHotLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 oneHotVectorSize = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          onehotvectorsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 axis = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float onValue = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          onvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float offValue = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          offvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OneHotLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.OneHotLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 oneHotVectorSize = 1;
  if (this->_internal_onehotvectorsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_onehotvectorsize(), target);
  }

  // int64 axis = 2;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_axis(), target);
  }

  // float onValue = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_onvalue = this->_internal_onvalue();
  uint32_t raw_onvalue;
  memcpy(&raw_onvalue, &tmp_onvalue, sizeof(tmp_onvalue));
  if (raw_onvalue != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_onvalue(), target);
  }

  // float offValue = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_offvalue = this->_internal_offvalue();
  uint32_t raw_offvalue;
  memcpy(&raw_offvalue, &tmp_offvalue, sizeof(tmp_offvalue));
  if (raw_offvalue != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_offvalue(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.OneHotLayerParams)
  return target;
}

size_t OneHotLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.OneHotLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 oneHotVectorSize = 1;
  if (this->_internal_onehotvectorsize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_onehotvectorsize());
  }

  // int64 axis = 2;
  if (this->_internal_axis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_axis());
  }

  // float onValue = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_onvalue = this->_internal_onvalue();
  uint32_t raw_onvalue;
  memcpy(&raw_onvalue, &tmp_onvalue, sizeof(tmp_onvalue));
  if (raw_onvalue != 0) {
    total_size += 1 + 4;
  }

  // float offValue = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_offvalue = this->_internal_offvalue();
  uint32_t raw_offvalue;
  memcpy(&raw_offvalue, &tmp_offvalue, sizeof(tmp_offvalue));
  if (raw_offvalue != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OneHotLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const OneHotLayerParams*>(
      &from));
}

void OneHotLayerParams::MergeFrom(const OneHotLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.OneHotLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_onehotvectorsize() != 0) {
    _internal_set_onehotvectorsize(from._internal_onehotvectorsize());
  }
  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_onvalue = from._internal_onvalue();
  uint32_t raw_onvalue;
  memcpy(&raw_onvalue, &tmp_onvalue, sizeof(tmp_onvalue));
  if (raw_onvalue != 0) {
    _internal_set_onvalue(from._internal_onvalue());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_offvalue = from._internal_offvalue();
  uint32_t raw_offvalue;
  memcpy(&raw_offvalue, &tmp_offvalue, sizeof(tmp_offvalue));
  if (raw_offvalue != 0) {
    _internal_set_offvalue(from._internal_offvalue());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OneHotLayerParams::CopyFrom(const OneHotLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.OneHotLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OneHotLayerParams::IsInitialized() const {
  return true;
}

void OneHotLayerParams::InternalSwap(OneHotLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OneHotLayerParams, offvalue_)
      + sizeof(OneHotLayerParams::offvalue_)
      - PROTOBUF_FIELD_OFFSET(OneHotLayerParams, onehotvectorsize_)>(
          reinterpret_cast<char*>(&onehotvectorsize_),
          reinterpret_cast<char*>(&other->onehotvectorsize_));
}

std::string OneHotLayerParams::GetTypeName() const {
  return "CoreML.Specification.OneHotLayerParams";
}


// ===================================================================

class CumSumLayerParams::_Internal {
 public:
};

CumSumLayerParams::CumSumLayerParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.CumSumLayerParams)
}
CumSumLayerParams::CumSumLayerParams(const CumSumLayerParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&axis_, &from.axis_,
    static_cast<size_t>(reinterpret_cast<char*>(&reverse_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(reverse_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.CumSumLayerParams)
}

inline void CumSumLayerParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&axis_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reverse_) -
    reinterpret_cast<char*>(&axis_)) + sizeof(reverse_));
}

CumSumLayerParams::~CumSumLayerParams() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.CumSumLayerParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CumSumLayerParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CumSumLayerParams::ArenaDtor(void* object) {
  CumSumLayerParams* _this = reinterpret_cast< CumSumLayerParams* >(object);
  (void)_this;
}
void CumSumLayerParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CumSumLayerParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CumSumLayerParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.CumSumLayerParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&axis_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reverse_) -
      reinterpret_cast<char*>(&axis_)) + sizeof(reverse_));
  _internal_metadata_.Clear<std::string>();
}

const char* CumSumLayerParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 axis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool excludeFinalSum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          excludefinalsum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reverse = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          reverse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CumSumLayerParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.CumSumLayerParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_axis(), target);
  }

  // bool excludeFinalSum = 2;
  if (this->_internal_excludefinalsum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_excludefinalsum(), target);
  }

  // bool reverse = 3;
  if (this->_internal_reverse() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_reverse(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.CumSumLayerParams)
  return target;
}

size_t CumSumLayerParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.CumSumLayerParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 axis = 1;
  if (this->_internal_axis() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_axis());
  }

  // bool excludeFinalSum = 2;
  if (this->_internal_excludefinalsum() != 0) {
    total_size += 1 + 1;
  }

  // bool reverse = 3;
  if (this->_internal_reverse() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CumSumLayerParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CumSumLayerParams*>(
      &from));
}

void CumSumLayerParams::MergeFrom(const CumSumLayerParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.CumSumLayerParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_axis() != 0) {
    _internal_set_axis(from._internal_axis());
  }
  if (from._internal_excludefinalsum() != 0) {
    _internal_set_excludefinalsum(from._internal_excludefinalsum());
  }
  if (from._internal_reverse() != 0) {
    _internal_set_reverse(from._internal_reverse());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CumSumLayerParams::CopyFrom(const CumSumLayerParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.CumSumLayerParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CumSumLayerParams::IsInitialized() const {
  return true;
}

void CumSumLayerParams::InternalSwap(CumSumLayerParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CumSumLayerParams, reverse_)
      + sizeof(CumSumLayerParams::reverse_)
      - PROTOBUF_FIELD_OFFSET(CumSumLayerParams, axis_)>(
          reinterpret_cast<char*>(&axis_),
          reinterpret_cast<char*>(&other->axis_));
}

std::string CumSumLayerParams::GetTypeName() const {
  return "CoreML.Specification.CumSumLayerParams";
}


// ===================================================================

class NeuralNetworkRegressor::_Internal {
 public:
  static const ::CoreML::Specification::NetworkUpdateParameters& updateparams(const NeuralNetworkRegressor* msg);
};

const ::CoreML::Specification::NetworkUpdateParameters&
NeuralNetworkRegressor::_Internal::updateparams(const NeuralNetworkRegressor* msg) {
  return *msg->updateparams_;
}
NeuralNetworkRegressor::NeuralNetworkRegressor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  layers_(arena),
  preprocessing_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.NeuralNetworkRegressor)
}
NeuralNetworkRegressor::NeuralNetworkRegressor(const NeuralNetworkRegressor& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      layers_(from.layers_),
      preprocessing_(from.preprocessing_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_updateparams()) {
    updateparams_ = new ::CoreML::Specification::NetworkUpdateParameters(*from.updateparams_);
  } else {
    updateparams_ = nullptr;
  }
  ::memcpy(&arrayinputshapemapping_, &from.arrayinputshapemapping_,
    static_cast<size_t>(reinterpret_cast<char*>(&imageinputshapemapping_) -
    reinterpret_cast<char*>(&arrayinputshapemapping_)) + sizeof(imageinputshapemapping_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.NeuralNetworkRegressor)
}

inline void NeuralNetworkRegressor::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&updateparams_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&imageinputshapemapping_) -
    reinterpret_cast<char*>(&updateparams_)) + sizeof(imageinputshapemapping_));
}

NeuralNetworkRegressor::~NeuralNetworkRegressor() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.NeuralNetworkRegressor)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void NeuralNetworkRegressor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete updateparams_;
}

void NeuralNetworkRegressor::ArenaDtor(void* object) {
  NeuralNetworkRegressor* _this = reinterpret_cast< NeuralNetworkRegressor* >(object);
  (void)_this;
}
void NeuralNetworkRegressor::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NeuralNetworkRegressor::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NeuralNetworkRegressor::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.NeuralNetworkRegressor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  layers_.Clear();
  preprocessing_.Clear();
  if (GetArenaForAllocation() == nullptr && updateparams_ != nullptr) {
    delete updateparams_;
  }
  updateparams_ = nullptr;
  ::memset(&arrayinputshapemapping_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&imageinputshapemapping_) -
      reinterpret_cast<char*>(&arrayinputshapemapping_)) + sizeof(imageinputshapemapping_));
  _internal_metadata_.Clear<std::string>();
}

const char* NeuralNetworkRegressor::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.NeuralNetworkLayer layers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_layers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CoreML.Specification.NeuralNetworkPreprocessing preprocessing = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_preprocessing(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NeuralNetworkMultiArrayShapeMapping arrayInputShapeMapping = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_arrayinputshapemapping(static_cast<::CoreML::Specification::NeuralNetworkMultiArrayShapeMapping>(val));
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NeuralNetworkImageShapeMapping imageInputShapeMapping = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_imageinputshapemapping(static_cast<::CoreML::Specification::NeuralNetworkImageShapeMapping>(val));
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.NetworkUpdateParameters updateParams = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_updateparams(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NeuralNetworkRegressor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.NeuralNetworkRegressor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.NeuralNetworkLayer layers = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_layers_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_layers(i), target, stream);
  }

  // repeated .CoreML.Specification.NeuralNetworkPreprocessing preprocessing = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_preprocessing_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_preprocessing(i), target, stream);
  }

  // .CoreML.Specification.NeuralNetworkMultiArrayShapeMapping arrayInputShapeMapping = 5;
  if (this->_internal_arrayinputshapemapping() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_arrayinputshapemapping(), target);
  }

  // .CoreML.Specification.NeuralNetworkImageShapeMapping imageInputShapeMapping = 6;
  if (this->_internal_imageinputshapemapping() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_imageinputshapemapping(), target);
  }

  // .CoreML.Specification.NetworkUpdateParameters updateParams = 10;
  if (this->_internal_has_updateparams()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::updateparams(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.NeuralNetworkRegressor)
  return target;
}

size_t NeuralNetworkRegressor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.NeuralNetworkRegressor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.NeuralNetworkLayer layers = 1;
  total_size += 1UL * this->_internal_layers_size();
  for (const auto& msg : this->layers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CoreML.Specification.NeuralNetworkPreprocessing preprocessing = 2;
  total_size += 1UL * this->_internal_preprocessing_size();
  for (const auto& msg : this->preprocessing_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .CoreML.Specification.NetworkUpdateParameters updateParams = 10;
  if (this->_internal_has_updateparams()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *updateparams_);
  }

  // .CoreML.Specification.NeuralNetworkMultiArrayShapeMapping arrayInputShapeMapping = 5;
  if (this->_internal_arrayinputshapemapping() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_arrayinputshapemapping());
  }

  // .CoreML.Specification.NeuralNetworkImageShapeMapping imageInputShapeMapping = 6;
  if (this->_internal_imageinputshapemapping() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_imageinputshapemapping());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NeuralNetworkRegressor::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const NeuralNetworkRegressor*>(
      &from));
}

void NeuralNetworkRegressor::MergeFrom(const NeuralNetworkRegressor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.NeuralNetworkRegressor)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  layers_.MergeFrom(from.layers_);
  preprocessing_.MergeFrom(from.preprocessing_);
  if (from._internal_has_updateparams()) {
    _internal_mutable_updateparams()->::CoreML::Specification::NetworkUpdateParameters::MergeFrom(from._internal_updateparams());
  }
  if (from._internal_arrayinputshapemapping() != 0) {
    _internal_set_arrayinputshapemapping(from._internal_arrayinputshapemapping());
  }
  if (from._internal_imageinputshapemapping() != 0) {
    _internal_set_imageinputshapemapping(from._internal_imageinputshapemapping());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NeuralNetworkRegressor::CopyFrom(const NeuralNetworkRegressor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.NeuralNetworkRegressor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NeuralNetworkRegressor::IsInitialized() const {
  return true;
}

void NeuralNetworkRegressor::InternalSwap(NeuralNetworkRegressor* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  layers_.InternalSwap(&other->layers_);
  preprocessing_.InternalSwap(&other->preprocessing_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NeuralNetworkRegressor, imageinputshapemapping_)
      + sizeof(NeuralNetworkRegressor::imageinputshapemapping_)
      - PROTOBUF_FIELD_OFFSET(NeuralNetworkRegressor, updateparams_)>(
          reinterpret_cast<char*>(&updateparams_),
          reinterpret_cast<char*>(&other->updateparams_));
}

std::string NeuralNetworkRegressor::GetTypeName() const {
  return "CoreML.Specification.NeuralNetworkRegressor";
}


// ===================================================================

class NetworkUpdateParameters::_Internal {
 public:
  static const ::CoreML::Specification::Optimizer& optimizer(const NetworkUpdateParameters* msg);
  static const ::CoreML::Specification::Int64Parameter& epochs(const NetworkUpdateParameters* msg);
  static const ::CoreML::Specification::BoolParameter& shuffle(const NetworkUpdateParameters* msg);
  static const ::CoreML::Specification::Int64Parameter& seed(const NetworkUpdateParameters* msg);
};

const ::CoreML::Specification::Optimizer&
NetworkUpdateParameters::_Internal::optimizer(const NetworkUpdateParameters* msg) {
  return *msg->optimizer_;
}
const ::CoreML::Specification::Int64Parameter&
NetworkUpdateParameters::_Internal::epochs(const NetworkUpdateParameters* msg) {
  return *msg->epochs_;
}
const ::CoreML::Specification::BoolParameter&
NetworkUpdateParameters::_Internal::shuffle(const NetworkUpdateParameters* msg) {
  return *msg->shuffle_;
}
const ::CoreML::Specification::Int64Parameter&
NetworkUpdateParameters::_Internal::seed(const NetworkUpdateParameters* msg) {
  return *msg->seed_;
}
void NetworkUpdateParameters::clear_epochs() {
  if (GetArenaForAllocation() == nullptr && epochs_ != nullptr) {
    delete epochs_;
  }
  epochs_ = nullptr;
}
void NetworkUpdateParameters::clear_shuffle() {
  if (GetArenaForAllocation() == nullptr && shuffle_ != nullptr) {
    delete shuffle_;
  }
  shuffle_ = nullptr;
}
void NetworkUpdateParameters::clear_seed() {
  if (GetArenaForAllocation() == nullptr && seed_ != nullptr) {
    delete seed_;
  }
  seed_ = nullptr;
}
NetworkUpdateParameters::NetworkUpdateParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  losslayers_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.NetworkUpdateParameters)
}
NetworkUpdateParameters::NetworkUpdateParameters(const NetworkUpdateParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      losslayers_(from.losslayers_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_optimizer()) {
    optimizer_ = new ::CoreML::Specification::Optimizer(*from.optimizer_);
  } else {
    optimizer_ = nullptr;
  }
  if (from._internal_has_epochs()) {
    epochs_ = new ::CoreML::Specification::Int64Parameter(*from.epochs_);
  } else {
    epochs_ = nullptr;
  }
  if (from._internal_has_shuffle()) {
    shuffle_ = new ::CoreML::Specification::BoolParameter(*from.shuffle_);
  } else {
    shuffle_ = nullptr;
  }
  if (from._internal_has_seed()) {
    seed_ = new ::CoreML::Specification::Int64Parameter(*from.seed_);
  } else {
    seed_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.NetworkUpdateParameters)
}

inline void NetworkUpdateParameters::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&optimizer_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&seed_) -
    reinterpret_cast<char*>(&optimizer_)) + sizeof(seed_));
}

NetworkUpdateParameters::~NetworkUpdateParameters() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.NetworkUpdateParameters)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void NetworkUpdateParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete optimizer_;
  if (this != internal_default_instance()) delete epochs_;
  if (this != internal_default_instance()) delete shuffle_;
  if (this != internal_default_instance()) delete seed_;
}

void NetworkUpdateParameters::ArenaDtor(void* object) {
  NetworkUpdateParameters* _this = reinterpret_cast< NetworkUpdateParameters* >(object);
  (void)_this;
}
void NetworkUpdateParameters::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NetworkUpdateParameters::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NetworkUpdateParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.NetworkUpdateParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  losslayers_.Clear();
  if (GetArenaForAllocation() == nullptr && optimizer_ != nullptr) {
    delete optimizer_;
  }
  optimizer_ = nullptr;
  if (GetArenaForAllocation() == nullptr && epochs_ != nullptr) {
    delete epochs_;
  }
  epochs_ = nullptr;
  if (GetArenaForAllocation() == nullptr && shuffle_ != nullptr) {
    delete shuffle_;
  }
  shuffle_ = nullptr;
  if (GetArenaForAllocation() == nullptr && seed_ != nullptr) {
    delete seed_;
  }
  seed_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* NetworkUpdateParameters::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CoreML.Specification.LossLayer lossLayers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_losslayers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Optimizer optimizer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_optimizer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Int64Parameter epochs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_epochs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.BoolParameter shuffle = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_shuffle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Int64Parameter seed = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_seed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NetworkUpdateParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.NetworkUpdateParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.LossLayer lossLayers = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_losslayers_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_losslayers(i), target, stream);
  }

  // .CoreML.Specification.Optimizer optimizer = 2;
  if (this->_internal_has_optimizer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::optimizer(this), target, stream);
  }

  // .CoreML.Specification.Int64Parameter epochs = 3;
  if (this->_internal_has_epochs()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::epochs(this), target, stream);
  }

  // .CoreML.Specification.BoolParameter shuffle = 10;
  if (this->_internal_has_shuffle()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::shuffle(this), target, stream);
  }

  // .CoreML.Specification.Int64Parameter seed = 20;
  if (this->_internal_has_seed()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::seed(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.NetworkUpdateParameters)
  return target;
}

size_t NetworkUpdateParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.NetworkUpdateParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CoreML.Specification.LossLayer lossLayers = 1;
  total_size += 1UL * this->_internal_losslayers_size();
  for (const auto& msg : this->losslayers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .CoreML.Specification.Optimizer optimizer = 2;
  if (this->_internal_has_optimizer()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *optimizer_);
  }

  // .CoreML.Specification.Int64Parameter epochs = 3;
  if (this->_internal_has_epochs()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *epochs_);
  }

  // .CoreML.Specification.BoolParameter shuffle = 10;
  if (this->_internal_has_shuffle()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *shuffle_);
  }

  // .CoreML.Specification.Int64Parameter seed = 20;
  if (this->_internal_has_seed()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *seed_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NetworkUpdateParameters::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const NetworkUpdateParameters*>(
      &from));
}

void NetworkUpdateParameters::MergeFrom(const NetworkUpdateParameters& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.NetworkUpdateParameters)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  losslayers_.MergeFrom(from.losslayers_);
  if (from._internal_has_optimizer()) {
    _internal_mutable_optimizer()->::CoreML::Specification::Optimizer::MergeFrom(from._internal_optimizer());
  }
  if (from._internal_has_epochs()) {
    _internal_mutable_epochs()->::CoreML::Specification::Int64Parameter::MergeFrom(from._internal_epochs());
  }
  if (from._internal_has_shuffle()) {
    _internal_mutable_shuffle()->::CoreML::Specification::BoolParameter::MergeFrom(from._internal_shuffle());
  }
  if (from._internal_has_seed()) {
    _internal_mutable_seed()->::CoreML::Specification::Int64Parameter::MergeFrom(from._internal_seed());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetworkUpdateParameters::CopyFrom(const NetworkUpdateParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.NetworkUpdateParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkUpdateParameters::IsInitialized() const {
  return true;
}

void NetworkUpdateParameters::InternalSwap(NetworkUpdateParameters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  losslayers_.InternalSwap(&other->losslayers_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NetworkUpdateParameters, seed_)
      + sizeof(NetworkUpdateParameters::seed_)
      - PROTOBUF_FIELD_OFFSET(NetworkUpdateParameters, optimizer_)>(
          reinterpret_cast<char*>(&optimizer_),
          reinterpret_cast<char*>(&other->optimizer_));
}

std::string NetworkUpdateParameters::GetTypeName() const {
  return "CoreML.Specification.NetworkUpdateParameters";
}


// ===================================================================

class LossLayer::_Internal {
 public:
  static const ::CoreML::Specification::CategoricalCrossEntropyLossLayer& categoricalcrossentropylosslayer(const LossLayer* msg);
  static const ::CoreML::Specification::MeanSquaredErrorLossLayer& meansquarederrorlosslayer(const LossLayer* msg);
};

const ::CoreML::Specification::CategoricalCrossEntropyLossLayer&
LossLayer::_Internal::categoricalcrossentropylosslayer(const LossLayer* msg) {
  return *msg->LossLayerType_.categoricalcrossentropylosslayer_;
}
const ::CoreML::Specification::MeanSquaredErrorLossLayer&
LossLayer::_Internal::meansquarederrorlosslayer(const LossLayer* msg) {
  return *msg->LossLayerType_.meansquarederrorlosslayer_;
}
void LossLayer::set_allocated_categoricalcrossentropylosslayer(::CoreML::Specification::CategoricalCrossEntropyLossLayer* categoricalcrossentropylosslayer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_LossLayerType();
  if (categoricalcrossentropylosslayer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::CategoricalCrossEntropyLossLayer>::GetOwningArena(categoricalcrossentropylosslayer);
    if (message_arena != submessage_arena) {
      categoricalcrossentropylosslayer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, categoricalcrossentropylosslayer, submessage_arena);
    }
    set_has_categoricalcrossentropylosslayer();
    LossLayerType_.categoricalcrossentropylosslayer_ = categoricalcrossentropylosslayer;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.LossLayer.categoricalCrossEntropyLossLayer)
}
void LossLayer::set_allocated_meansquarederrorlosslayer(::CoreML::Specification::MeanSquaredErrorLossLayer* meansquarederrorlosslayer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_LossLayerType();
  if (meansquarederrorlosslayer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::MeanSquaredErrorLossLayer>::GetOwningArena(meansquarederrorlosslayer);
    if (message_arena != submessage_arena) {
      meansquarederrorlosslayer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meansquarederrorlosslayer, submessage_arena);
    }
    set_has_meansquarederrorlosslayer();
    LossLayerType_.meansquarederrorlosslayer_ = meansquarederrorlosslayer;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.LossLayer.meanSquaredErrorLossLayer)
}
LossLayer::LossLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.LossLayer)
}
LossLayer::LossLayer(const LossLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  clear_has_LossLayerType();
  switch (from.LossLayerType_case()) {
    case kCategoricalCrossEntropyLossLayer: {
      _internal_mutable_categoricalcrossentropylosslayer()->::CoreML::Specification::CategoricalCrossEntropyLossLayer::MergeFrom(from._internal_categoricalcrossentropylosslayer());
      break;
    }
    case kMeanSquaredErrorLossLayer: {
      _internal_mutable_meansquarederrorlosslayer()->::CoreML::Specification::MeanSquaredErrorLossLayer::MergeFrom(from._internal_meansquarederrorlosslayer());
      break;
    }
    case LOSSLAYERTYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LossLayer)
}

inline void LossLayer::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
clear_has_LossLayerType();
}

LossLayer::~LossLayer() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LossLayer)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void LossLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (has_LossLayerType()) {
    clear_LossLayerType();
  }
}

void LossLayer::ArenaDtor(void* object) {
  LossLayer* _this = reinterpret_cast< LossLayer* >(object);
  (void)_this;
}
void LossLayer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LossLayer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LossLayer::clear_LossLayerType() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.LossLayer)
  switch (LossLayerType_case()) {
    case kCategoricalCrossEntropyLossLayer: {
      if (GetArenaForAllocation() == nullptr) {
        delete LossLayerType_.categoricalcrossentropylosslayer_;
      }
      break;
    }
    case kMeanSquaredErrorLossLayer: {
      if (GetArenaForAllocation() == nullptr) {
        delete LossLayerType_.meansquarederrorlosslayer_;
      }
      break;
    }
    case LOSSLAYERTYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = LOSSLAYERTYPE_NOT_SET;
}


void LossLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LossLayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  clear_LossLayerType();
  _internal_metadata_.Clear<std::string>();
}

const char* LossLayer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.CategoricalCrossEntropyLossLayer categoricalCrossEntropyLossLayer = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_categoricalcrossentropylosslayer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.MeanSquaredErrorLossLayer meanSquaredErrorLossLayer = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_meansquarederrorlosslayer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LossLayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.LossLayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.LossLayer.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .CoreML.Specification.CategoricalCrossEntropyLossLayer categoricalCrossEntropyLossLayer = 10;
  if (_internal_has_categoricalcrossentropylosslayer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::categoricalcrossentropylosslayer(this), target, stream);
  }

  // .CoreML.Specification.MeanSquaredErrorLossLayer meanSquaredErrorLossLayer = 11;
  if (_internal_has_meansquarederrorlosslayer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::meansquarederrorlosslayer(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.LossLayer)
  return target;
}

size_t LossLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LossLayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  switch (LossLayerType_case()) {
    // .CoreML.Specification.CategoricalCrossEntropyLossLayer categoricalCrossEntropyLossLayer = 10;
    case kCategoricalCrossEntropyLossLayer: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *LossLayerType_.categoricalcrossentropylosslayer_);
      break;
    }
    // .CoreML.Specification.MeanSquaredErrorLossLayer meanSquaredErrorLossLayer = 11;
    case kMeanSquaredErrorLossLayer: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *LossLayerType_.meansquarederrorlosslayer_);
      break;
    }
    case LOSSLAYERTYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LossLayer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LossLayer*>(
      &from));
}

void LossLayer::MergeFrom(const LossLayer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LossLayer)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  switch (from.LossLayerType_case()) {
    case kCategoricalCrossEntropyLossLayer: {
      _internal_mutable_categoricalcrossentropylosslayer()->::CoreML::Specification::CategoricalCrossEntropyLossLayer::MergeFrom(from._internal_categoricalcrossentropylosslayer());
      break;
    }
    case kMeanSquaredErrorLossLayer: {
      _internal_mutable_meansquarederrorlosslayer()->::CoreML::Specification::MeanSquaredErrorLossLayer::MergeFrom(from._internal_meansquarederrorlosslayer());
      break;
    }
    case LOSSLAYERTYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LossLayer::CopyFrom(const LossLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LossLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LossLayer::IsInitialized() const {
  return true;
}

void LossLayer::InternalSwap(LossLayer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(LossLayerType_, other->LossLayerType_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string LossLayer::GetTypeName() const {
  return "CoreML.Specification.LossLayer";
}


// ===================================================================

class CategoricalCrossEntropyLossLayer::_Internal {
 public:
};

CategoricalCrossEntropyLossLayer::CategoricalCrossEntropyLossLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.CategoricalCrossEntropyLossLayer)
}
CategoricalCrossEntropyLossLayer::CategoricalCrossEntropyLossLayer(const CategoricalCrossEntropyLossLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  input_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    input_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_input().empty()) {
    input_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_input(), 
      GetArenaForAllocation());
  }
  target_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    target_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_target().empty()) {
    target_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_target(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.CategoricalCrossEntropyLossLayer)
}

inline void CategoricalCrossEntropyLossLayer::SharedCtor() {
input_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  input_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
target_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  target_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CategoricalCrossEntropyLossLayer::~CategoricalCrossEntropyLossLayer() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.CategoricalCrossEntropyLossLayer)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CategoricalCrossEntropyLossLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  input_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  target_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CategoricalCrossEntropyLossLayer::ArenaDtor(void* object) {
  CategoricalCrossEntropyLossLayer* _this = reinterpret_cast< CategoricalCrossEntropyLossLayer* >(object);
  (void)_this;
}
void CategoricalCrossEntropyLossLayer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CategoricalCrossEntropyLossLayer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CategoricalCrossEntropyLossLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.CategoricalCrossEntropyLossLayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  input_.ClearToEmpty();
  target_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* CategoricalCrossEntropyLossLayer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string input = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_input();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string target = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_target();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CategoricalCrossEntropyLossLayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.CategoricalCrossEntropyLossLayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string input = 1;
  if (!this->_internal_input().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_input().data(), static_cast<int>(this->_internal_input().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.CategoricalCrossEntropyLossLayer.input");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_input(), target);
  }

  // string target = 2;
  if (!this->_internal_target().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_target().data(), static_cast<int>(this->_internal_target().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.CategoricalCrossEntropyLossLayer.target");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_target(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.CategoricalCrossEntropyLossLayer)
  return target;
}

size_t CategoricalCrossEntropyLossLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.CategoricalCrossEntropyLossLayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string input = 1;
  if (!this->_internal_input().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_input());
  }

  // string target = 2;
  if (!this->_internal_target().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_target());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CategoricalCrossEntropyLossLayer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CategoricalCrossEntropyLossLayer*>(
      &from));
}

void CategoricalCrossEntropyLossLayer::MergeFrom(const CategoricalCrossEntropyLossLayer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.CategoricalCrossEntropyLossLayer)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_input().empty()) {
    _internal_set_input(from._internal_input());
  }
  if (!from._internal_target().empty()) {
    _internal_set_target(from._internal_target());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CategoricalCrossEntropyLossLayer::CopyFrom(const CategoricalCrossEntropyLossLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.CategoricalCrossEntropyLossLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CategoricalCrossEntropyLossLayer::IsInitialized() const {
  return true;
}

void CategoricalCrossEntropyLossLayer::InternalSwap(CategoricalCrossEntropyLossLayer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &input_, lhs_arena,
      &other->input_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &target_, lhs_arena,
      &other->target_, rhs_arena
  );
}

std::string CategoricalCrossEntropyLossLayer::GetTypeName() const {
  return "CoreML.Specification.CategoricalCrossEntropyLossLayer";
}


// ===================================================================

class MeanSquaredErrorLossLayer::_Internal {
 public:
};

MeanSquaredErrorLossLayer::MeanSquaredErrorLossLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.MeanSquaredErrorLossLayer)
}
MeanSquaredErrorLossLayer::MeanSquaredErrorLossLayer(const MeanSquaredErrorLossLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  input_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    input_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_input().empty()) {
    input_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_input(), 
      GetArenaForAllocation());
  }
  target_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    target_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_target().empty()) {
    target_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_target(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.MeanSquaredErrorLossLayer)
}

inline void MeanSquaredErrorLossLayer::SharedCtor() {
input_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  input_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
target_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  target_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MeanSquaredErrorLossLayer::~MeanSquaredErrorLossLayer() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.MeanSquaredErrorLossLayer)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void MeanSquaredErrorLossLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  input_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  target_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void MeanSquaredErrorLossLayer::ArenaDtor(void* object) {
  MeanSquaredErrorLossLayer* _this = reinterpret_cast< MeanSquaredErrorLossLayer* >(object);
  (void)_this;
}
void MeanSquaredErrorLossLayer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MeanSquaredErrorLossLayer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MeanSquaredErrorLossLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.MeanSquaredErrorLossLayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  input_.ClearToEmpty();
  target_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* MeanSquaredErrorLossLayer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string input = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_input();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string target = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_target();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MeanSquaredErrorLossLayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.MeanSquaredErrorLossLayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string input = 1;
  if (!this->_internal_input().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_input().data(), static_cast<int>(this->_internal_input().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.MeanSquaredErrorLossLayer.input");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_input(), target);
  }

  // string target = 2;
  if (!this->_internal_target().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_target().data(), static_cast<int>(this->_internal_target().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.MeanSquaredErrorLossLayer.target");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_target(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.MeanSquaredErrorLossLayer)
  return target;
}

size_t MeanSquaredErrorLossLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.MeanSquaredErrorLossLayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string input = 1;
  if (!this->_internal_input().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_input());
  }

  // string target = 2;
  if (!this->_internal_target().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_target());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MeanSquaredErrorLossLayer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MeanSquaredErrorLossLayer*>(
      &from));
}

void MeanSquaredErrorLossLayer::MergeFrom(const MeanSquaredErrorLossLayer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.MeanSquaredErrorLossLayer)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_input().empty()) {
    _internal_set_input(from._internal_input());
  }
  if (!from._internal_target().empty()) {
    _internal_set_target(from._internal_target());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MeanSquaredErrorLossLayer::CopyFrom(const MeanSquaredErrorLossLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.MeanSquaredErrorLossLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MeanSquaredErrorLossLayer::IsInitialized() const {
  return true;
}

void MeanSquaredErrorLossLayer::InternalSwap(MeanSquaredErrorLossLayer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &input_, lhs_arena,
      &other->input_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &target_, lhs_arena,
      &other->target_, rhs_arena
  );
}

std::string MeanSquaredErrorLossLayer::GetTypeName() const {
  return "CoreML.Specification.MeanSquaredErrorLossLayer";
}


// ===================================================================

class Optimizer::_Internal {
 public:
  static const ::CoreML::Specification::SGDOptimizer& sgdoptimizer(const Optimizer* msg);
  static const ::CoreML::Specification::AdamOptimizer& adamoptimizer(const Optimizer* msg);
};

const ::CoreML::Specification::SGDOptimizer&
Optimizer::_Internal::sgdoptimizer(const Optimizer* msg) {
  return *msg->OptimizerType_.sgdoptimizer_;
}
const ::CoreML::Specification::AdamOptimizer&
Optimizer::_Internal::adamoptimizer(const Optimizer* msg) {
  return *msg->OptimizerType_.adamoptimizer_;
}
void Optimizer::set_allocated_sgdoptimizer(::CoreML::Specification::SGDOptimizer* sgdoptimizer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_OptimizerType();
  if (sgdoptimizer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SGDOptimizer>::GetOwningArena(sgdoptimizer);
    if (message_arena != submessage_arena) {
      sgdoptimizer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sgdoptimizer, submessage_arena);
    }
    set_has_sgdoptimizer();
    OptimizerType_.sgdoptimizer_ = sgdoptimizer;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Optimizer.sgdOptimizer)
}
void Optimizer::set_allocated_adamoptimizer(::CoreML::Specification::AdamOptimizer* adamoptimizer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_OptimizerType();
  if (adamoptimizer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::AdamOptimizer>::GetOwningArena(adamoptimizer);
    if (message_arena != submessage_arena) {
      adamoptimizer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adamoptimizer, submessage_arena);
    }
    set_has_adamoptimizer();
    OptimizerType_.adamoptimizer_ = adamoptimizer;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Optimizer.adamOptimizer)
}
Optimizer::Optimizer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.Optimizer)
}
Optimizer::Optimizer(const Optimizer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_OptimizerType();
  switch (from.OptimizerType_case()) {
    case kSgdOptimizer: {
      _internal_mutable_sgdoptimizer()->::CoreML::Specification::SGDOptimizer::MergeFrom(from._internal_sgdoptimizer());
      break;
    }
    case kAdamOptimizer: {
      _internal_mutable_adamoptimizer()->::CoreML::Specification::AdamOptimizer::MergeFrom(from._internal_adamoptimizer());
      break;
    }
    case OPTIMIZERTYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Optimizer)
}

inline void Optimizer::SharedCtor() {
clear_has_OptimizerType();
}

Optimizer::~Optimizer() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Optimizer)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Optimizer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_OptimizerType()) {
    clear_OptimizerType();
  }
}

void Optimizer::ArenaDtor(void* object) {
  Optimizer* _this = reinterpret_cast< Optimizer* >(object);
  (void)_this;
}
void Optimizer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Optimizer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Optimizer::clear_OptimizerType() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.Optimizer)
  switch (OptimizerType_case()) {
    case kSgdOptimizer: {
      if (GetArenaForAllocation() == nullptr) {
        delete OptimizerType_.sgdoptimizer_;
      }
      break;
    }
    case kAdamOptimizer: {
      if (GetArenaForAllocation() == nullptr) {
        delete OptimizerType_.adamoptimizer_;
      }
      break;
    }
    case OPTIMIZERTYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = OPTIMIZERTYPE_NOT_SET;
}


void Optimizer::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Optimizer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_OptimizerType();
  _internal_metadata_.Clear<std::string>();
}

const char* Optimizer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.SGDOptimizer sgdOptimizer = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_sgdoptimizer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.AdamOptimizer adamOptimizer = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_adamoptimizer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Optimizer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.Optimizer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.SGDOptimizer sgdOptimizer = 10;
  if (_internal_has_sgdoptimizer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::sgdoptimizer(this), target, stream);
  }

  // .CoreML.Specification.AdamOptimizer adamOptimizer = 11;
  if (_internal_has_adamoptimizer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::adamoptimizer(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.Optimizer)
  return target;
}

size_t Optimizer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Optimizer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (OptimizerType_case()) {
    // .CoreML.Specification.SGDOptimizer sgdOptimizer = 10;
    case kSgdOptimizer: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *OptimizerType_.sgdoptimizer_);
      break;
    }
    // .CoreML.Specification.AdamOptimizer adamOptimizer = 11;
    case kAdamOptimizer: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *OptimizerType_.adamoptimizer_);
      break;
    }
    case OPTIMIZERTYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Optimizer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Optimizer*>(
      &from));
}

void Optimizer::MergeFrom(const Optimizer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Optimizer)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.OptimizerType_case()) {
    case kSgdOptimizer: {
      _internal_mutable_sgdoptimizer()->::CoreML::Specification::SGDOptimizer::MergeFrom(from._internal_sgdoptimizer());
      break;
    }
    case kAdamOptimizer: {
      _internal_mutable_adamoptimizer()->::CoreML::Specification::AdamOptimizer::MergeFrom(from._internal_adamoptimizer());
      break;
    }
    case OPTIMIZERTYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Optimizer::CopyFrom(const Optimizer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Optimizer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optimizer::IsInitialized() const {
  return true;
}

void Optimizer::InternalSwap(Optimizer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(OptimizerType_, other->OptimizerType_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string Optimizer::GetTypeName() const {
  return "CoreML.Specification.Optimizer";
}


// ===================================================================

class SGDOptimizer::_Internal {
 public:
  static const ::CoreML::Specification::DoubleParameter& learningrate(const SGDOptimizer* msg);
  static const ::CoreML::Specification::Int64Parameter& minibatchsize(const SGDOptimizer* msg);
  static const ::CoreML::Specification::DoubleParameter& momentum(const SGDOptimizer* msg);
};

const ::CoreML::Specification::DoubleParameter&
SGDOptimizer::_Internal::learningrate(const SGDOptimizer* msg) {
  return *msg->learningrate_;
}
const ::CoreML::Specification::Int64Parameter&
SGDOptimizer::_Internal::minibatchsize(const SGDOptimizer* msg) {
  return *msg->minibatchsize_;
}
const ::CoreML::Specification::DoubleParameter&
SGDOptimizer::_Internal::momentum(const SGDOptimizer* msg) {
  return *msg->momentum_;
}
void SGDOptimizer::clear_learningrate() {
  if (GetArenaForAllocation() == nullptr && learningrate_ != nullptr) {
    delete learningrate_;
  }
  learningrate_ = nullptr;
}
void SGDOptimizer::clear_minibatchsize() {
  if (GetArenaForAllocation() == nullptr && minibatchsize_ != nullptr) {
    delete minibatchsize_;
  }
  minibatchsize_ = nullptr;
}
void SGDOptimizer::clear_momentum() {
  if (GetArenaForAllocation() == nullptr && momentum_ != nullptr) {
    delete momentum_;
  }
  momentum_ = nullptr;
}
SGDOptimizer::SGDOptimizer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.SGDOptimizer)
}
SGDOptimizer::SGDOptimizer(const SGDOptimizer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_learningrate()) {
    learningrate_ = new ::CoreML::Specification::DoubleParameter(*from.learningrate_);
  } else {
    learningrate_ = nullptr;
  }
  if (from._internal_has_minibatchsize()) {
    minibatchsize_ = new ::CoreML::Specification::Int64Parameter(*from.minibatchsize_);
  } else {
    minibatchsize_ = nullptr;
  }
  if (from._internal_has_momentum()) {
    momentum_ = new ::CoreML::Specification::DoubleParameter(*from.momentum_);
  } else {
    momentum_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SGDOptimizer)
}

inline void SGDOptimizer::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&learningrate_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&momentum_) -
    reinterpret_cast<char*>(&learningrate_)) + sizeof(momentum_));
}

SGDOptimizer::~SGDOptimizer() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SGDOptimizer)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SGDOptimizer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete learningrate_;
  if (this != internal_default_instance()) delete minibatchsize_;
  if (this != internal_default_instance()) delete momentum_;
}

void SGDOptimizer::ArenaDtor(void* object) {
  SGDOptimizer* _this = reinterpret_cast< SGDOptimizer* >(object);
  (void)_this;
}
void SGDOptimizer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SGDOptimizer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SGDOptimizer::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SGDOptimizer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && learningrate_ != nullptr) {
    delete learningrate_;
  }
  learningrate_ = nullptr;
  if (GetArenaForAllocation() == nullptr && minibatchsize_ != nullptr) {
    delete minibatchsize_;
  }
  minibatchsize_ = nullptr;
  if (GetArenaForAllocation() == nullptr && momentum_ != nullptr) {
    delete momentum_;
  }
  momentum_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* SGDOptimizer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.DoubleParameter learningRate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_learningrate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Int64Parameter miniBatchSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_minibatchsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.DoubleParameter momentum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_momentum(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SGDOptimizer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.SGDOptimizer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.DoubleParameter learningRate = 1;
  if (this->_internal_has_learningrate()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::learningrate(this), target, stream);
  }

  // .CoreML.Specification.Int64Parameter miniBatchSize = 2;
  if (this->_internal_has_minibatchsize()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::minibatchsize(this), target, stream);
  }

  // .CoreML.Specification.DoubleParameter momentum = 3;
  if (this->_internal_has_momentum()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::momentum(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.SGDOptimizer)
  return target;
}

size_t SGDOptimizer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SGDOptimizer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.DoubleParameter learningRate = 1;
  if (this->_internal_has_learningrate()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *learningrate_);
  }

  // .CoreML.Specification.Int64Parameter miniBatchSize = 2;
  if (this->_internal_has_minibatchsize()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *minibatchsize_);
  }

  // .CoreML.Specification.DoubleParameter momentum = 3;
  if (this->_internal_has_momentum()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *momentum_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SGDOptimizer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SGDOptimizer*>(
      &from));
}

void SGDOptimizer::MergeFrom(const SGDOptimizer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SGDOptimizer)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_learningrate()) {
    _internal_mutable_learningrate()->::CoreML::Specification::DoubleParameter::MergeFrom(from._internal_learningrate());
  }
  if (from._internal_has_minibatchsize()) {
    _internal_mutable_minibatchsize()->::CoreML::Specification::Int64Parameter::MergeFrom(from._internal_minibatchsize());
  }
  if (from._internal_has_momentum()) {
    _internal_mutable_momentum()->::CoreML::Specification::DoubleParameter::MergeFrom(from._internal_momentum());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SGDOptimizer::CopyFrom(const SGDOptimizer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SGDOptimizer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SGDOptimizer::IsInitialized() const {
  return true;
}

void SGDOptimizer::InternalSwap(SGDOptimizer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SGDOptimizer, momentum_)
      + sizeof(SGDOptimizer::momentum_)
      - PROTOBUF_FIELD_OFFSET(SGDOptimizer, learningrate_)>(
          reinterpret_cast<char*>(&learningrate_),
          reinterpret_cast<char*>(&other->learningrate_));
}

std::string SGDOptimizer::GetTypeName() const {
  return "CoreML.Specification.SGDOptimizer";
}


// ===================================================================

class AdamOptimizer::_Internal {
 public:
  static const ::CoreML::Specification::DoubleParameter& learningrate(const AdamOptimizer* msg);
  static const ::CoreML::Specification::Int64Parameter& minibatchsize(const AdamOptimizer* msg);
  static const ::CoreML::Specification::DoubleParameter& beta1(const AdamOptimizer* msg);
  static const ::CoreML::Specification::DoubleParameter& beta2(const AdamOptimizer* msg);
  static const ::CoreML::Specification::DoubleParameter& eps(const AdamOptimizer* msg);
};

const ::CoreML::Specification::DoubleParameter&
AdamOptimizer::_Internal::learningrate(const AdamOptimizer* msg) {
  return *msg->learningrate_;
}
const ::CoreML::Specification::Int64Parameter&
AdamOptimizer::_Internal::minibatchsize(const AdamOptimizer* msg) {
  return *msg->minibatchsize_;
}
const ::CoreML::Specification::DoubleParameter&
AdamOptimizer::_Internal::beta1(const AdamOptimizer* msg) {
  return *msg->beta1_;
}
const ::CoreML::Specification::DoubleParameter&
AdamOptimizer::_Internal::beta2(const AdamOptimizer* msg) {
  return *msg->beta2_;
}
const ::CoreML::Specification::DoubleParameter&
AdamOptimizer::_Internal::eps(const AdamOptimizer* msg) {
  return *msg->eps_;
}
void AdamOptimizer::clear_learningrate() {
  if (GetArenaForAllocation() == nullptr && learningrate_ != nullptr) {
    delete learningrate_;
  }
  learningrate_ = nullptr;
}
void AdamOptimizer::clear_minibatchsize() {
  if (GetArenaForAllocation() == nullptr && minibatchsize_ != nullptr) {
    delete minibatchsize_;
  }
  minibatchsize_ = nullptr;
}
void AdamOptimizer::clear_beta1() {
  if (GetArenaForAllocation() == nullptr && beta1_ != nullptr) {
    delete beta1_;
  }
  beta1_ = nullptr;
}
void AdamOptimizer::clear_beta2() {
  if (GetArenaForAllocation() == nullptr && beta2_ != nullptr) {
    delete beta2_;
  }
  beta2_ = nullptr;
}
void AdamOptimizer::clear_eps() {
  if (GetArenaForAllocation() == nullptr && eps_ != nullptr) {
    delete eps_;
  }
  eps_ = nullptr;
}
AdamOptimizer::AdamOptimizer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CoreML.Specification.AdamOptimizer)
}
AdamOptimizer::AdamOptimizer(const AdamOptimizer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_learningrate()) {
    learningrate_ = new ::CoreML::Specification::DoubleParameter(*from.learningrate_);
  } else {
    learningrate_ = nullptr;
  }
  if (from._internal_has_minibatchsize()) {
    minibatchsize_ = new ::CoreML::Specification::Int64Parameter(*from.minibatchsize_);
  } else {
    minibatchsize_ = nullptr;
  }
  if (from._internal_has_beta1()) {
    beta1_ = new ::CoreML::Specification::DoubleParameter(*from.beta1_);
  } else {
    beta1_ = nullptr;
  }
  if (from._internal_has_beta2()) {
    beta2_ = new ::CoreML::Specification::DoubleParameter(*from.beta2_);
  } else {
    beta2_ = nullptr;
  }
  if (from._internal_has_eps()) {
    eps_ = new ::CoreML::Specification::DoubleParameter(*from.eps_);
  } else {
    eps_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.AdamOptimizer)
}

inline void AdamOptimizer::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&learningrate_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&eps_) -
    reinterpret_cast<char*>(&learningrate_)) + sizeof(eps_));
}

AdamOptimizer::~AdamOptimizer() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.AdamOptimizer)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AdamOptimizer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete learningrate_;
  if (this != internal_default_instance()) delete minibatchsize_;
  if (this != internal_default_instance()) delete beta1_;
  if (this != internal_default_instance()) delete beta2_;
  if (this != internal_default_instance()) delete eps_;
}

void AdamOptimizer::ArenaDtor(void* object) {
  AdamOptimizer* _this = reinterpret_cast< AdamOptimizer* >(object);
  (void)_this;
}
void AdamOptimizer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AdamOptimizer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AdamOptimizer::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.AdamOptimizer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && learningrate_ != nullptr) {
    delete learningrate_;
  }
  learningrate_ = nullptr;
  if (GetArenaForAllocation() == nullptr && minibatchsize_ != nullptr) {
    delete minibatchsize_;
  }
  minibatchsize_ = nullptr;
  if (GetArenaForAllocation() == nullptr && beta1_ != nullptr) {
    delete beta1_;
  }
  beta1_ = nullptr;
  if (GetArenaForAllocation() == nullptr && beta2_ != nullptr) {
    delete beta2_;
  }
  beta2_ = nullptr;
  if (GetArenaForAllocation() == nullptr && eps_ != nullptr) {
    delete eps_;
  }
  eps_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* AdamOptimizer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CoreML.Specification.DoubleParameter learningRate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_learningrate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.Int64Parameter miniBatchSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_minibatchsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.DoubleParameter beta1 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_beta1(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.DoubleParameter beta2 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_beta2(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CoreML.Specification.DoubleParameter eps = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_eps(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AdamOptimizer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CoreML.Specification.AdamOptimizer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.DoubleParameter learningRate = 1;
  if (this->_internal_has_learningrate()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::learningrate(this), target, stream);
  }

  // .CoreML.Specification.Int64Parameter miniBatchSize = 2;
  if (this->_internal_has_minibatchsize()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::minibatchsize(this), target, stream);
  }

  // .CoreML.Specification.DoubleParameter beta1 = 3;
  if (this->_internal_has_beta1()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::beta1(this), target, stream);
  }

  // .CoreML.Specification.DoubleParameter beta2 = 4;
  if (this->_internal_has_beta2()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::beta2(this), target, stream);
  }

  // .CoreML.Specification.DoubleParameter eps = 5;
  if (this->_internal_has_eps()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::eps(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CoreML.Specification.AdamOptimizer)
  return target;
}

size_t AdamOptimizer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.AdamOptimizer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CoreML.Specification.DoubleParameter learningRate = 1;
  if (this->_internal_has_learningrate()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *learningrate_);
  }

  // .CoreML.Specification.Int64Parameter miniBatchSize = 2;
  if (this->_internal_has_minibatchsize()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *minibatchsize_);
  }

  // .CoreML.Specification.DoubleParameter beta1 = 3;
  if (this->_internal_has_beta1()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *beta1_);
  }

  // .CoreML.Specification.DoubleParameter beta2 = 4;
  if (this->_internal_has_beta2()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *beta2_);
  }

  // .CoreML.Specification.DoubleParameter eps = 5;
  if (this->_internal_has_eps()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *eps_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AdamOptimizer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AdamOptimizer*>(
      &from));
}

void AdamOptimizer::MergeFrom(const AdamOptimizer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.AdamOptimizer)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_learningrate()) {
    _internal_mutable_learningrate()->::CoreML::Specification::DoubleParameter::MergeFrom(from._internal_learningrate());
  }
  if (from._internal_has_minibatchsize()) {
    _internal_mutable_minibatchsize()->::CoreML::Specification::Int64Parameter::MergeFrom(from._internal_minibatchsize());
  }
  if (from._internal_has_beta1()) {
    _internal_mutable_beta1()->::CoreML::Specification::DoubleParameter::MergeFrom(from._internal_beta1());
  }
  if (from._internal_has_beta2()) {
    _internal_mutable_beta2()->::CoreML::Specification::DoubleParameter::MergeFrom(from._internal_beta2());
  }
  if (from._internal_has_eps()) {
    _internal_mutable_eps()->::CoreML::Specification::DoubleParameter::MergeFrom(from._internal_eps());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AdamOptimizer::CopyFrom(const AdamOptimizer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.AdamOptimizer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdamOptimizer::IsInitialized() const {
  return true;
}

void AdamOptimizer::InternalSwap(AdamOptimizer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AdamOptimizer, eps_)
      + sizeof(AdamOptimizer::eps_)
      - PROTOBUF_FIELD_OFFSET(AdamOptimizer, learningrate_)>(
          reinterpret_cast<char*>(&learningrate_),
          reinterpret_cast<char*>(&other->learningrate_));
}

std::string AdamOptimizer::GetTypeName() const {
  return "CoreML.Specification.AdamOptimizer";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace Specification
}  // namespace CoreML
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CoreML::Specification::NeuralNetwork* Arena::CreateMaybeMessage< ::CoreML::Specification::NeuralNetwork >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::NeuralNetwork >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::NeuralNetworkImageScaler* Arena::CreateMaybeMessage< ::CoreML::Specification::NeuralNetworkImageScaler >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::NeuralNetworkImageScaler >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::NeuralNetworkMeanImage* Arena::CreateMaybeMessage< ::CoreML::Specification::NeuralNetworkMeanImage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::NeuralNetworkMeanImage >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::NeuralNetworkPreprocessing* Arena::CreateMaybeMessage< ::CoreML::Specification::NeuralNetworkPreprocessing >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::NeuralNetworkPreprocessing >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ActivationReLU* Arena::CreateMaybeMessage< ::CoreML::Specification::ActivationReLU >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ActivationReLU >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ActivationLeakyReLU* Arena::CreateMaybeMessage< ::CoreML::Specification::ActivationLeakyReLU >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ActivationLeakyReLU >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ActivationTanh* Arena::CreateMaybeMessage< ::CoreML::Specification::ActivationTanh >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ActivationTanh >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ActivationScaledTanh* Arena::CreateMaybeMessage< ::CoreML::Specification::ActivationScaledTanh >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ActivationScaledTanh >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ActivationSigmoid* Arena::CreateMaybeMessage< ::CoreML::Specification::ActivationSigmoid >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ActivationSigmoid >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ActivationLinear* Arena::CreateMaybeMessage< ::CoreML::Specification::ActivationLinear >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ActivationLinear >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ActivationSigmoidHard* Arena::CreateMaybeMessage< ::CoreML::Specification::ActivationSigmoidHard >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ActivationSigmoidHard >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ActivationPReLU* Arena::CreateMaybeMessage< ::CoreML::Specification::ActivationPReLU >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ActivationPReLU >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ActivationELU* Arena::CreateMaybeMessage< ::CoreML::Specification::ActivationELU >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ActivationELU >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ActivationThresholdedReLU* Arena::CreateMaybeMessage< ::CoreML::Specification::ActivationThresholdedReLU >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ActivationThresholdedReLU >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ActivationSoftsign* Arena::CreateMaybeMessage< ::CoreML::Specification::ActivationSoftsign >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ActivationSoftsign >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ActivationSoftplus* Arena::CreateMaybeMessage< ::CoreML::Specification::ActivationSoftplus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ActivationSoftplus >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ActivationParametricSoftplus* Arena::CreateMaybeMessage< ::CoreML::Specification::ActivationParametricSoftplus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ActivationParametricSoftplus >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ActivationParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ActivationParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ActivationParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Tensor* Arena::CreateMaybeMessage< ::CoreML::Specification::Tensor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Tensor >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::NeuralNetworkLayer* Arena::CreateMaybeMessage< ::CoreML::Specification::NeuralNetworkLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::NeuralNetworkLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::BranchLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::BranchLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::BranchLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LoopLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::LoopLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LoopLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LoopBreakLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::LoopBreakLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LoopBreakLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LoopContinueLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::LoopContinueLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LoopContinueLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::CopyLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::CopyLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::CopyLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::GreaterThanLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::GreaterThanLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::GreaterThanLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::GreaterEqualLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::GreaterEqualLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::GreaterEqualLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LessThanLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::LessThanLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LessThanLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LessEqualLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::LessEqualLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LessEqualLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::EqualLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::EqualLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::EqualLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::NotEqualLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::NotEqualLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::NotEqualLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LogicalAndLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::LogicalAndLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LogicalAndLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LogicalOrLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::LogicalOrLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LogicalOrLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LogicalXorLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::LogicalXorLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LogicalXorLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LogicalNotLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::LogicalNotLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LogicalNotLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::BorderAmounts_EdgeSizes* Arena::CreateMaybeMessage< ::CoreML::Specification::BorderAmounts_EdgeSizes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::BorderAmounts_EdgeSizes >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::BorderAmounts* Arena::CreateMaybeMessage< ::CoreML::Specification::BorderAmounts >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::BorderAmounts >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ValidPadding* Arena::CreateMaybeMessage< ::CoreML::Specification::ValidPadding >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ValidPadding >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SamePadding* Arena::CreateMaybeMessage< ::CoreML::Specification::SamePadding >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SamePadding >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SamplingMode* Arena::CreateMaybeMessage< ::CoreML::Specification::SamplingMode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SamplingMode >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::BoxCoordinatesMode* Arena::CreateMaybeMessage< ::CoreML::Specification::BoxCoordinatesMode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::BoxCoordinatesMode >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::WeightParams* Arena::CreateMaybeMessage< ::CoreML::Specification::WeightParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::WeightParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::QuantizationParams* Arena::CreateMaybeMessage< ::CoreML::Specification::QuantizationParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::QuantizationParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LinearQuantizationParams* Arena::CreateMaybeMessage< ::CoreML::Specification::LinearQuantizationParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LinearQuantizationParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LookUpTableQuantizationParams* Arena::CreateMaybeMessage< ::CoreML::Specification::LookUpTableQuantizationParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LookUpTableQuantizationParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ConvolutionLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ConvolutionLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ConvolutionLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Convolution3DLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::Convolution3DLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Convolution3DLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::InnerProductLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::InnerProductLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::InnerProductLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::EmbeddingLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::EmbeddingLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::EmbeddingLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::EmbeddingNDLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::EmbeddingNDLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::EmbeddingNDLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::BatchnormLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::BatchnormLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::BatchnormLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::PoolingLayerParams_ValidCompletePadding* Arena::CreateMaybeMessage< ::CoreML::Specification::PoolingLayerParams_ValidCompletePadding >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::PoolingLayerParams_ValidCompletePadding >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::PoolingLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::PoolingLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::PoolingLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Pooling3DLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::Pooling3DLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Pooling3DLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::GlobalPooling3DLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::GlobalPooling3DLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::GlobalPooling3DLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::PaddingLayerParams_PaddingConstant* Arena::CreateMaybeMessage< ::CoreML::Specification::PaddingLayerParams_PaddingConstant >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::PaddingLayerParams_PaddingConstant >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::PaddingLayerParams_PaddingReflection* Arena::CreateMaybeMessage< ::CoreML::Specification::PaddingLayerParams_PaddingReflection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::PaddingLayerParams_PaddingReflection >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::PaddingLayerParams_PaddingReplication* Arena::CreateMaybeMessage< ::CoreML::Specification::PaddingLayerParams_PaddingReplication >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::PaddingLayerParams_PaddingReplication >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::PaddingLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::PaddingLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::PaddingLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ConcatLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ConcatLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ConcatLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LRNLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::LRNLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LRNLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SoftmaxLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::SoftmaxLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SoftmaxLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SplitLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::SplitLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SplitLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::AddLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::AddLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::AddLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MultiplyLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::MultiplyLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MultiplyLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::UnaryFunctionLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::UnaryFunctionLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::UnaryFunctionLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::UpsampleLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::UpsampleLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::UpsampleLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ResizeBilinearLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ResizeBilinearLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ResizeBilinearLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::CropResizeLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::CropResizeLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::CropResizeLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::BiasLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::BiasLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::BiasLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ScaleLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ScaleLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ScaleLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LoadConstantLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::LoadConstantLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LoadConstantLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::L2NormalizeLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::L2NormalizeLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::L2NormalizeLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::FlattenLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::FlattenLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::FlattenLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ReshapeLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ReshapeLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ReshapeLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::PermuteLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::PermuteLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::PermuteLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ReorganizeDataLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ReorganizeDataLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ReorganizeDataLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SliceLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::SliceLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SliceLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ReduceLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ReduceLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ReduceLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::CropLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::CropLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::CropLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::AverageLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::AverageLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::AverageLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MaxLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::MaxLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MaxLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MinLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::MinLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MinLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::DotProductLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::DotProductLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::DotProductLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MeanVarianceNormalizeLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::MeanVarianceNormalizeLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MeanVarianceNormalizeLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SequenceRepeatLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::SequenceRepeatLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SequenceRepeatLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SimpleRecurrentLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::SimpleRecurrentLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SimpleRecurrentLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::GRULayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::GRULayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::GRULayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LSTMParams* Arena::CreateMaybeMessage< ::CoreML::Specification::LSTMParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LSTMParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LSTMWeightParams* Arena::CreateMaybeMessage< ::CoreML::Specification::LSTMWeightParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LSTMWeightParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::UniDirectionalLSTMLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::UniDirectionalLSTMLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::UniDirectionalLSTMLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::BiDirectionalLSTMLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::BiDirectionalLSTMLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::BiDirectionalLSTMLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::CustomLayerParams_CustomLayerParamValue* Arena::CreateMaybeMessage< ::CoreML::Specification::CustomLayerParams_CustomLayerParamValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::CustomLayerParams_CustomLayerParamValue >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::CustomLayerParams_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage< ::CoreML::Specification::CustomLayerParams_ParametersEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::CustomLayerParams_ParametersEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::CustomLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::CustomLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::CustomLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::TransposeLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::TransposeLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::TransposeLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::BatchedMatMulLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::BatchedMatMulLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::BatchedMatMulLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ConcatNDLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ConcatNDLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ConcatNDLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SoftmaxNDLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::SoftmaxNDLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SoftmaxNDLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ReverseLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ReverseLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ReverseLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ReverseSeqLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ReverseSeqLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ReverseSeqLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LoadConstantNDLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::LoadConstantNDLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LoadConstantNDLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::FillLikeLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::FillLikeLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::FillLikeLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::FillStaticLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::FillStaticLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::FillStaticLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::FillDynamicLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::FillDynamicLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::FillDynamicLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::WhereBroadcastableLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::WhereBroadcastableLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::WhereBroadcastableLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SinLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::SinLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SinLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::CosLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::CosLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::CosLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::TanLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::TanLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::TanLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::AsinLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::AsinLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::AsinLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::AcosLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::AcosLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::AcosLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::AtanLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::AtanLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::AtanLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SinhLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::SinhLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SinhLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::CoshLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::CoshLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::CoshLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::TanhLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::TanhLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::TanhLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::AsinhLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::AsinhLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::AsinhLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::AcoshLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::AcoshLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::AcoshLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::AtanhLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::AtanhLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::AtanhLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::PowBroadcastableLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::PowBroadcastableLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::PowBroadcastableLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Exp2LayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::Exp2LayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Exp2LayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::WhereNonZeroLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::WhereNonZeroLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::WhereNonZeroLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MatrixBandPartLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::MatrixBandPartLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MatrixBandPartLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::UpperTriangularLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::UpperTriangularLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::UpperTriangularLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LowerTriangularLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::LowerTriangularLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LowerTriangularLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::BroadcastToLikeLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::BroadcastToLikeLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::BroadcastToLikeLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::BroadcastToStaticLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::BroadcastToStaticLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::BroadcastToStaticLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::BroadcastToDynamicLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::BroadcastToDynamicLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::BroadcastToDynamicLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::AddBroadcastableLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::AddBroadcastableLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::AddBroadcastableLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MaxBroadcastableLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::MaxBroadcastableLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MaxBroadcastableLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MinBroadcastableLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::MinBroadcastableLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MinBroadcastableLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ModBroadcastableLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ModBroadcastableLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ModBroadcastableLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::FloorDivBroadcastableLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::FloorDivBroadcastableLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::FloorDivBroadcastableLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SubtractBroadcastableLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::SubtractBroadcastableLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SubtractBroadcastableLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MultiplyBroadcastableLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::MultiplyBroadcastableLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MultiplyBroadcastableLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::DivideBroadcastableLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::DivideBroadcastableLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::DivideBroadcastableLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::GatherLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::GatherLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::GatherLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ScatterLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ScatterLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ScatterLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::GatherNDLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::GatherNDLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::GatherNDLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ScatterNDLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ScatterNDLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ScatterNDLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::GatherAlongAxisLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::GatherAlongAxisLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::GatherAlongAxisLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ScatterAlongAxisLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ScatterAlongAxisLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ScatterAlongAxisLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::StackLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::StackLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::StackLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::RankPreservingReshapeLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::RankPreservingReshapeLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::RankPreservingReshapeLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ConstantPaddingLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ConstantPaddingLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ConstantPaddingLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::RandomNormalLikeLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::RandomNormalLikeLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::RandomNormalLikeLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::RandomNormalStaticLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::RandomNormalStaticLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::RandomNormalStaticLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::RandomNormalDynamicLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::RandomNormalDynamicLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::RandomNormalDynamicLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::RandomUniformLikeLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::RandomUniformLikeLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::RandomUniformLikeLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::RandomUniformStaticLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::RandomUniformStaticLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::RandomUniformStaticLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::RandomUniformDynamicLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::RandomUniformDynamicLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::RandomUniformDynamicLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::RandomBernoulliLikeLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::RandomBernoulliLikeLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::RandomBernoulliLikeLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::RandomBernoulliStaticLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::RandomBernoulliStaticLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::RandomBernoulliStaticLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::RandomBernoulliDynamicLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::RandomBernoulliDynamicLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::RandomBernoulliDynamicLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::CategoricalDistributionLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::CategoricalDistributionLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::CategoricalDistributionLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ReduceL1LayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ReduceL1LayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ReduceL1LayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ReduceL2LayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ReduceL2LayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ReduceL2LayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ReduceMaxLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ReduceMaxLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ReduceMaxLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ReduceMinLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ReduceMinLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ReduceMinLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ReduceSumLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ReduceSumLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ReduceSumLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ReduceProdLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ReduceProdLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ReduceProdLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ReduceMeanLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ReduceMeanLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ReduceMeanLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ReduceLogSumLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ReduceLogSumLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ReduceLogSumLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ReduceSumSquareLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ReduceSumSquareLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ReduceSumSquareLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ReduceLogSumExpLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ReduceLogSumExpLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ReduceLogSumExpLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ExpandDimsLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ExpandDimsLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ExpandDimsLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::FlattenTo2DLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::FlattenTo2DLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::FlattenTo2DLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ReshapeStaticLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ReshapeStaticLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ReshapeStaticLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ReshapeLikeLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ReshapeLikeLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ReshapeLikeLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ReshapeDynamicLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ReshapeDynamicLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ReshapeDynamicLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SqueezeLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::SqueezeLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SqueezeLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::TopKLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::TopKLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::TopKLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ArgMaxLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ArgMaxLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ArgMaxLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ArgMinLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ArgMinLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ArgMinLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SplitNDLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::SplitNDLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SplitNDLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::CeilLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::CeilLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::CeilLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::RoundLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::RoundLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::RoundLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::FloorLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::FloorLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::FloorLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SignLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::SignLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SignLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ClipLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ClipLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ClipLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SliceStaticLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::SliceStaticLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SliceStaticLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SliceDynamicLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::SliceDynamicLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SliceDynamicLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::TileLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::TileLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::TileLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::GetShapeLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::GetShapeLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::GetShapeLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ErfLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ErfLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ErfLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::GeluLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::GeluLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::GeluLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::RangeStaticLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::RangeStaticLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::RangeStaticLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::RangeDynamicLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::RangeDynamicLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::RangeDynamicLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SlidingWindowsLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::SlidingWindowsLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SlidingWindowsLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LayerNormalizationLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::LayerNormalizationLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LayerNormalizationLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::NonMaximumSuppressionLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::NonMaximumSuppressionLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::NonMaximumSuppressionLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ClampedReLULayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ClampedReLULayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ClampedReLULayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::ArgSortLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::ArgSortLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::ArgSortLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SliceBySizeLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::SliceBySizeLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SliceBySizeLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::NeuralNetworkClassifier* Arena::CreateMaybeMessage< ::CoreML::Specification::NeuralNetworkClassifier >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::NeuralNetworkClassifier >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::OneHotLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::OneHotLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::OneHotLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::CumSumLayerParams* Arena::CreateMaybeMessage< ::CoreML::Specification::CumSumLayerParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::CumSumLayerParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::NeuralNetworkRegressor* Arena::CreateMaybeMessage< ::CoreML::Specification::NeuralNetworkRegressor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::NeuralNetworkRegressor >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::NetworkUpdateParameters* Arena::CreateMaybeMessage< ::CoreML::Specification::NetworkUpdateParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::NetworkUpdateParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::LossLayer* Arena::CreateMaybeMessage< ::CoreML::Specification::LossLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::LossLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::CategoricalCrossEntropyLossLayer* Arena::CreateMaybeMessage< ::CoreML::Specification::CategoricalCrossEntropyLossLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::CategoricalCrossEntropyLossLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::MeanSquaredErrorLossLayer* Arena::CreateMaybeMessage< ::CoreML::Specification::MeanSquaredErrorLossLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::MeanSquaredErrorLossLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::Optimizer* Arena::CreateMaybeMessage< ::CoreML::Specification::Optimizer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::Optimizer >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::SGDOptimizer* Arena::CreateMaybeMessage< ::CoreML::Specification::SGDOptimizer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::SGDOptimizer >(arena);
}
template<> PROTOBUF_NOINLINE ::CoreML::Specification::AdamOptimizer* Arena::CreateMaybeMessage< ::CoreML::Specification::AdamOptimizer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CoreML::Specification::AdamOptimizer >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
