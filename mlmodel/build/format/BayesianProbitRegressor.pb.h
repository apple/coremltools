// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BayesianProbitRegressor.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_BayesianProbitRegressor_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_BayesianProbitRegressor_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_BayesianProbitRegressor_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_BayesianProbitRegressor_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace CoreML {
namespace Specification {
class BayesianProbitRegressor;
struct BayesianProbitRegressorDefaultTypeInternal;
extern BayesianProbitRegressorDefaultTypeInternal _BayesianProbitRegressor_default_instance_;
class BayesianProbitRegressor_FeatureValueWeight;
struct BayesianProbitRegressor_FeatureValueWeightDefaultTypeInternal;
extern BayesianProbitRegressor_FeatureValueWeightDefaultTypeInternal _BayesianProbitRegressor_FeatureValueWeight_default_instance_;
class BayesianProbitRegressor_FeatureWeight;
struct BayesianProbitRegressor_FeatureWeightDefaultTypeInternal;
extern BayesianProbitRegressor_FeatureWeightDefaultTypeInternal _BayesianProbitRegressor_FeatureWeight_default_instance_;
class BayesianProbitRegressor_Gaussian;
struct BayesianProbitRegressor_GaussianDefaultTypeInternal;
extern BayesianProbitRegressor_GaussianDefaultTypeInternal _BayesianProbitRegressor_Gaussian_default_instance_;
}  // namespace Specification
}  // namespace CoreML
PROTOBUF_NAMESPACE_OPEN
template<> ::CoreML::Specification::BayesianProbitRegressor* Arena::CreateMaybeMessage<::CoreML::Specification::BayesianProbitRegressor>(Arena*);
template<> ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight* Arena::CreateMaybeMessage<::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight>(Arena*);
template<> ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight* Arena::CreateMaybeMessage<::CoreML::Specification::BayesianProbitRegressor_FeatureWeight>(Arena*);
template<> ::CoreML::Specification::BayesianProbitRegressor_Gaussian* Arena::CreateMaybeMessage<::CoreML::Specification::BayesianProbitRegressor_Gaussian>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace CoreML {
namespace Specification {

// ===================================================================

class BayesianProbitRegressor_Gaussian final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.BayesianProbitRegressor.Gaussian) */ {
 public:
  inline BayesianProbitRegressor_Gaussian() : BayesianProbitRegressor_Gaussian(nullptr) {}
  ~BayesianProbitRegressor_Gaussian() override;
  explicit constexpr BayesianProbitRegressor_Gaussian(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BayesianProbitRegressor_Gaussian(const BayesianProbitRegressor_Gaussian& from);
  BayesianProbitRegressor_Gaussian(BayesianProbitRegressor_Gaussian&& from) noexcept
    : BayesianProbitRegressor_Gaussian() {
    *this = ::std::move(from);
  }

  inline BayesianProbitRegressor_Gaussian& operator=(const BayesianProbitRegressor_Gaussian& from) {
    CopyFrom(from);
    return *this;
  }
  inline BayesianProbitRegressor_Gaussian& operator=(BayesianProbitRegressor_Gaussian&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const BayesianProbitRegressor_Gaussian& default_instance() {
    return *internal_default_instance();
  }
  static inline const BayesianProbitRegressor_Gaussian* internal_default_instance() {
    return reinterpret_cast<const BayesianProbitRegressor_Gaussian*>(
               &_BayesianProbitRegressor_Gaussian_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BayesianProbitRegressor_Gaussian& a, BayesianProbitRegressor_Gaussian& b) {
    a.Swap(&b);
  }
  inline void Swap(BayesianProbitRegressor_Gaussian* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BayesianProbitRegressor_Gaussian* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BayesianProbitRegressor_Gaussian* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BayesianProbitRegressor_Gaussian>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BayesianProbitRegressor_Gaussian& from);
  void MergeFrom(const BayesianProbitRegressor_Gaussian& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BayesianProbitRegressor_Gaussian* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.BayesianProbitRegressor.Gaussian";
  }
  protected:
  explicit BayesianProbitRegressor_Gaussian(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMeanFieldNumber = 1,
    kPrecisionFieldNumber = 2,
  };
  // double mean = 1;
  void clear_mean();
  double mean() const;
  void set_mean(double value);
  private:
  double _internal_mean() const;
  void _internal_set_mean(double value);
  public:

  // double precision = 2;
  void clear_precision();
  double precision() const;
  void set_precision(double value);
  private:
  double _internal_precision() const;
  void _internal_set_precision(double value);
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.BayesianProbitRegressor.Gaussian)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double mean_;
  double precision_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_BayesianProbitRegressor_2eproto;
};
// -------------------------------------------------------------------

class BayesianProbitRegressor_FeatureValueWeight final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight) */ {
 public:
  inline BayesianProbitRegressor_FeatureValueWeight() : BayesianProbitRegressor_FeatureValueWeight(nullptr) {}
  ~BayesianProbitRegressor_FeatureValueWeight() override;
  explicit constexpr BayesianProbitRegressor_FeatureValueWeight(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BayesianProbitRegressor_FeatureValueWeight(const BayesianProbitRegressor_FeatureValueWeight& from);
  BayesianProbitRegressor_FeatureValueWeight(BayesianProbitRegressor_FeatureValueWeight&& from) noexcept
    : BayesianProbitRegressor_FeatureValueWeight() {
    *this = ::std::move(from);
  }

  inline BayesianProbitRegressor_FeatureValueWeight& operator=(const BayesianProbitRegressor_FeatureValueWeight& from) {
    CopyFrom(from);
    return *this;
  }
  inline BayesianProbitRegressor_FeatureValueWeight& operator=(BayesianProbitRegressor_FeatureValueWeight&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const BayesianProbitRegressor_FeatureValueWeight& default_instance() {
    return *internal_default_instance();
  }
  static inline const BayesianProbitRegressor_FeatureValueWeight* internal_default_instance() {
    return reinterpret_cast<const BayesianProbitRegressor_FeatureValueWeight*>(
               &_BayesianProbitRegressor_FeatureValueWeight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BayesianProbitRegressor_FeatureValueWeight& a, BayesianProbitRegressor_FeatureValueWeight& b) {
    a.Swap(&b);
  }
  inline void Swap(BayesianProbitRegressor_FeatureValueWeight* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BayesianProbitRegressor_FeatureValueWeight* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BayesianProbitRegressor_FeatureValueWeight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BayesianProbitRegressor_FeatureValueWeight>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BayesianProbitRegressor_FeatureValueWeight& from);
  void MergeFrom(const BayesianProbitRegressor_FeatureValueWeight& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BayesianProbitRegressor_FeatureValueWeight* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight";
  }
  protected:
  explicit BayesianProbitRegressor_FeatureValueWeight(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureWeightFieldNumber = 2,
    kFeatureValueFieldNumber = 1,
  };
  // .CoreML.Specification.BayesianProbitRegressor.Gaussian featureWeight = 2;
  bool has_featureweight() const;
  private:
  bool _internal_has_featureweight() const;
  public:
  void clear_featureweight();
  const ::CoreML::Specification::BayesianProbitRegressor_Gaussian& featureweight() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::BayesianProbitRegressor_Gaussian* release_featureweight();
  ::CoreML::Specification::BayesianProbitRegressor_Gaussian* mutable_featureweight();
  void set_allocated_featureweight(::CoreML::Specification::BayesianProbitRegressor_Gaussian* featureweight);
  private:
  const ::CoreML::Specification::BayesianProbitRegressor_Gaussian& _internal_featureweight() const;
  ::CoreML::Specification::BayesianProbitRegressor_Gaussian* _internal_mutable_featureweight();
  public:
  void unsafe_arena_set_allocated_featureweight(
      ::CoreML::Specification::BayesianProbitRegressor_Gaussian* featureweight);
  ::CoreML::Specification::BayesianProbitRegressor_Gaussian* unsafe_arena_release_featureweight();

  // uint32 featureValue = 1;
  void clear_featurevalue();
  uint32_t featurevalue() const;
  void set_featurevalue(uint32_t value);
  private:
  uint32_t _internal_featurevalue() const;
  void _internal_set_featurevalue(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::CoreML::Specification::BayesianProbitRegressor_Gaussian* featureweight_;
  uint32_t featurevalue_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_BayesianProbitRegressor_2eproto;
};
// -------------------------------------------------------------------

class BayesianProbitRegressor_FeatureWeight final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.BayesianProbitRegressor.FeatureWeight) */ {
 public:
  inline BayesianProbitRegressor_FeatureWeight() : BayesianProbitRegressor_FeatureWeight(nullptr) {}
  ~BayesianProbitRegressor_FeatureWeight() override;
  explicit constexpr BayesianProbitRegressor_FeatureWeight(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BayesianProbitRegressor_FeatureWeight(const BayesianProbitRegressor_FeatureWeight& from);
  BayesianProbitRegressor_FeatureWeight(BayesianProbitRegressor_FeatureWeight&& from) noexcept
    : BayesianProbitRegressor_FeatureWeight() {
    *this = ::std::move(from);
  }

  inline BayesianProbitRegressor_FeatureWeight& operator=(const BayesianProbitRegressor_FeatureWeight& from) {
    CopyFrom(from);
    return *this;
  }
  inline BayesianProbitRegressor_FeatureWeight& operator=(BayesianProbitRegressor_FeatureWeight&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const BayesianProbitRegressor_FeatureWeight& default_instance() {
    return *internal_default_instance();
  }
  static inline const BayesianProbitRegressor_FeatureWeight* internal_default_instance() {
    return reinterpret_cast<const BayesianProbitRegressor_FeatureWeight*>(
               &_BayesianProbitRegressor_FeatureWeight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BayesianProbitRegressor_FeatureWeight& a, BayesianProbitRegressor_FeatureWeight& b) {
    a.Swap(&b);
  }
  inline void Swap(BayesianProbitRegressor_FeatureWeight* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BayesianProbitRegressor_FeatureWeight* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BayesianProbitRegressor_FeatureWeight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BayesianProbitRegressor_FeatureWeight>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BayesianProbitRegressor_FeatureWeight& from);
  void MergeFrom(const BayesianProbitRegressor_FeatureWeight& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BayesianProbitRegressor_FeatureWeight* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.BayesianProbitRegressor.FeatureWeight";
  }
  protected:
  explicit BayesianProbitRegressor_FeatureWeight(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeightsFieldNumber = 2,
    kFeatureIdFieldNumber = 1,
  };
  // repeated .CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight weights = 2;
  int weights_size() const;
  private:
  int _internal_weights_size() const;
  public:
  void clear_weights();
  ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight* mutable_weights(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight >*
      mutable_weights();
  private:
  const ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight& _internal_weights(int index) const;
  ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight* _internal_add_weights();
  public:
  const ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight& weights(int index) const;
  ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight* add_weights();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight >&
      weights() const;

  // uint32 featureId = 1;
  void clear_featureid();
  uint32_t featureid() const;
  void set_featureid(uint32_t value);
  private:
  uint32_t _internal_featureid() const;
  void _internal_set_featureid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.BayesianProbitRegressor.FeatureWeight)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight > weights_;
  uint32_t featureid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_BayesianProbitRegressor_2eproto;
};
// -------------------------------------------------------------------

class BayesianProbitRegressor final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.BayesianProbitRegressor) */ {
 public:
  inline BayesianProbitRegressor() : BayesianProbitRegressor(nullptr) {}
  ~BayesianProbitRegressor() override;
  explicit constexpr BayesianProbitRegressor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BayesianProbitRegressor(const BayesianProbitRegressor& from);
  BayesianProbitRegressor(BayesianProbitRegressor&& from) noexcept
    : BayesianProbitRegressor() {
    *this = ::std::move(from);
  }

  inline BayesianProbitRegressor& operator=(const BayesianProbitRegressor& from) {
    CopyFrom(from);
    return *this;
  }
  inline BayesianProbitRegressor& operator=(BayesianProbitRegressor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const BayesianProbitRegressor& default_instance() {
    return *internal_default_instance();
  }
  static inline const BayesianProbitRegressor* internal_default_instance() {
    return reinterpret_cast<const BayesianProbitRegressor*>(
               &_BayesianProbitRegressor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BayesianProbitRegressor& a, BayesianProbitRegressor& b) {
    a.Swap(&b);
  }
  inline void Swap(BayesianProbitRegressor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BayesianProbitRegressor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BayesianProbitRegressor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BayesianProbitRegressor>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BayesianProbitRegressor& from);
  void MergeFrom(const BayesianProbitRegressor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BayesianProbitRegressor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.BayesianProbitRegressor";
  }
  protected:
  explicit BayesianProbitRegressor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef BayesianProbitRegressor_Gaussian Gaussian;
  typedef BayesianProbitRegressor_FeatureValueWeight FeatureValueWeight;
  typedef BayesianProbitRegressor_FeatureWeight FeatureWeight;

  // accessors -------------------------------------------------------

  enum : int {
    kFeaturesFieldNumber = 3,
    kRegressionInputFeatureNameFieldNumber = 10,
    kOptimismInputFeatureNameFieldNumber = 11,
    kSamplingScaleInputFeatureNameFieldNumber = 12,
    kSamplingTruncationInputFeatureNameFieldNumber = 13,
    kMeanOutputFeatureNameFieldNumber = 20,
    kVarianceOutputFeatureNameFieldNumber = 21,
    kPessimisticProbabilityOutputFeatureNameFieldNumber = 22,
    kSampledProbabilityOutputFeatureNameFieldNumber = 23,
    kBiasFieldNumber = 2,
    kNumberOfFeaturesFieldNumber = 1,
  };
  // repeated .CoreML.Specification.BayesianProbitRegressor.FeatureWeight features = 3;
  int features_size() const;
  private:
  int _internal_features_size() const;
  public:
  void clear_features();
  ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight* mutable_features(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight >*
      mutable_features();
  private:
  const ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight& _internal_features(int index) const;
  ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight* _internal_add_features();
  public:
  const ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight& features(int index) const;
  ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight* add_features();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight >&
      features() const;

  // string regressionInputFeatureName = 10;
  void clear_regressioninputfeaturename();
  const std::string& regressioninputfeaturename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_regressioninputfeaturename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_regressioninputfeaturename();
  PROTOBUF_NODISCARD std::string* release_regressioninputfeaturename();
  void set_allocated_regressioninputfeaturename(std::string* regressioninputfeaturename);
  private:
  const std::string& _internal_regressioninputfeaturename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_regressioninputfeaturename(const std::string& value);
  std::string* _internal_mutable_regressioninputfeaturename();
  public:

  // string optimismInputFeatureName = 11;
  void clear_optimisminputfeaturename();
  const std::string& optimisminputfeaturename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_optimisminputfeaturename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_optimisminputfeaturename();
  PROTOBUF_NODISCARD std::string* release_optimisminputfeaturename();
  void set_allocated_optimisminputfeaturename(std::string* optimisminputfeaturename);
  private:
  const std::string& _internal_optimisminputfeaturename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_optimisminputfeaturename(const std::string& value);
  std::string* _internal_mutable_optimisminputfeaturename();
  public:

  // string samplingScaleInputFeatureName = 12;
  void clear_samplingscaleinputfeaturename();
  const std::string& samplingscaleinputfeaturename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_samplingscaleinputfeaturename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_samplingscaleinputfeaturename();
  PROTOBUF_NODISCARD std::string* release_samplingscaleinputfeaturename();
  void set_allocated_samplingscaleinputfeaturename(std::string* samplingscaleinputfeaturename);
  private:
  const std::string& _internal_samplingscaleinputfeaturename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_samplingscaleinputfeaturename(const std::string& value);
  std::string* _internal_mutable_samplingscaleinputfeaturename();
  public:

  // string samplingTruncationInputFeatureName = 13;
  void clear_samplingtruncationinputfeaturename();
  const std::string& samplingtruncationinputfeaturename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_samplingtruncationinputfeaturename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_samplingtruncationinputfeaturename();
  PROTOBUF_NODISCARD std::string* release_samplingtruncationinputfeaturename();
  void set_allocated_samplingtruncationinputfeaturename(std::string* samplingtruncationinputfeaturename);
  private:
  const std::string& _internal_samplingtruncationinputfeaturename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_samplingtruncationinputfeaturename(const std::string& value);
  std::string* _internal_mutable_samplingtruncationinputfeaturename();
  public:

  // string meanOutputFeatureName = 20;
  void clear_meanoutputfeaturename();
  const std::string& meanoutputfeaturename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_meanoutputfeaturename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_meanoutputfeaturename();
  PROTOBUF_NODISCARD std::string* release_meanoutputfeaturename();
  void set_allocated_meanoutputfeaturename(std::string* meanoutputfeaturename);
  private:
  const std::string& _internal_meanoutputfeaturename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_meanoutputfeaturename(const std::string& value);
  std::string* _internal_mutable_meanoutputfeaturename();
  public:

  // string varianceOutputFeatureName = 21;
  void clear_varianceoutputfeaturename();
  const std::string& varianceoutputfeaturename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_varianceoutputfeaturename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_varianceoutputfeaturename();
  PROTOBUF_NODISCARD std::string* release_varianceoutputfeaturename();
  void set_allocated_varianceoutputfeaturename(std::string* varianceoutputfeaturename);
  private:
  const std::string& _internal_varianceoutputfeaturename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_varianceoutputfeaturename(const std::string& value);
  std::string* _internal_mutable_varianceoutputfeaturename();
  public:

  // string pessimisticProbabilityOutputFeatureName = 22;
  void clear_pessimisticprobabilityoutputfeaturename();
  const std::string& pessimisticprobabilityoutputfeaturename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pessimisticprobabilityoutputfeaturename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pessimisticprobabilityoutputfeaturename();
  PROTOBUF_NODISCARD std::string* release_pessimisticprobabilityoutputfeaturename();
  void set_allocated_pessimisticprobabilityoutputfeaturename(std::string* pessimisticprobabilityoutputfeaturename);
  private:
  const std::string& _internal_pessimisticprobabilityoutputfeaturename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pessimisticprobabilityoutputfeaturename(const std::string& value);
  std::string* _internal_mutable_pessimisticprobabilityoutputfeaturename();
  public:

  // string sampledProbabilityOutputFeatureName = 23;
  void clear_sampledprobabilityoutputfeaturename();
  const std::string& sampledprobabilityoutputfeaturename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sampledprobabilityoutputfeaturename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sampledprobabilityoutputfeaturename();
  PROTOBUF_NODISCARD std::string* release_sampledprobabilityoutputfeaturename();
  void set_allocated_sampledprobabilityoutputfeaturename(std::string* sampledprobabilityoutputfeaturename);
  private:
  const std::string& _internal_sampledprobabilityoutputfeaturename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sampledprobabilityoutputfeaturename(const std::string& value);
  std::string* _internal_mutable_sampledprobabilityoutputfeaturename();
  public:

  // .CoreML.Specification.BayesianProbitRegressor.Gaussian bias = 2;
  bool has_bias() const;
  private:
  bool _internal_has_bias() const;
  public:
  void clear_bias();
  const ::CoreML::Specification::BayesianProbitRegressor_Gaussian& bias() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::BayesianProbitRegressor_Gaussian* release_bias();
  ::CoreML::Specification::BayesianProbitRegressor_Gaussian* mutable_bias();
  void set_allocated_bias(::CoreML::Specification::BayesianProbitRegressor_Gaussian* bias);
  private:
  const ::CoreML::Specification::BayesianProbitRegressor_Gaussian& _internal_bias() const;
  ::CoreML::Specification::BayesianProbitRegressor_Gaussian* _internal_mutable_bias();
  public:
  void unsafe_arena_set_allocated_bias(
      ::CoreML::Specification::BayesianProbitRegressor_Gaussian* bias);
  ::CoreML::Specification::BayesianProbitRegressor_Gaussian* unsafe_arena_release_bias();

  // uint32 numberOfFeatures = 1;
  void clear_numberoffeatures();
  uint32_t numberoffeatures() const;
  void set_numberoffeatures(uint32_t value);
  private:
  uint32_t _internal_numberoffeatures() const;
  void _internal_set_numberoffeatures(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.BayesianProbitRegressor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight > features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr regressioninputfeaturename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr optimisminputfeaturename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr samplingscaleinputfeaturename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr samplingtruncationinputfeaturename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr meanoutputfeaturename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr varianceoutputfeaturename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pessimisticprobabilityoutputfeaturename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sampledprobabilityoutputfeaturename_;
  ::CoreML::Specification::BayesianProbitRegressor_Gaussian* bias_;
  uint32_t numberoffeatures_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_BayesianProbitRegressor_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BayesianProbitRegressor_Gaussian

// double mean = 1;
inline void BayesianProbitRegressor_Gaussian::clear_mean() {
  mean_ = 0;
}
inline double BayesianProbitRegressor_Gaussian::_internal_mean() const {
  return mean_;
}
inline double BayesianProbitRegressor_Gaussian::mean() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.Gaussian.mean)
  return _internal_mean();
}
inline void BayesianProbitRegressor_Gaussian::_internal_set_mean(double value) {
  
  mean_ = value;
}
inline void BayesianProbitRegressor_Gaussian::set_mean(double value) {
  _internal_set_mean(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.Gaussian.mean)
}

// double precision = 2;
inline void BayesianProbitRegressor_Gaussian::clear_precision() {
  precision_ = 0;
}
inline double BayesianProbitRegressor_Gaussian::_internal_precision() const {
  return precision_;
}
inline double BayesianProbitRegressor_Gaussian::precision() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.Gaussian.precision)
  return _internal_precision();
}
inline void BayesianProbitRegressor_Gaussian::_internal_set_precision(double value) {
  
  precision_ = value;
}
inline void BayesianProbitRegressor_Gaussian::set_precision(double value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.Gaussian.precision)
}

// -------------------------------------------------------------------

// BayesianProbitRegressor_FeatureValueWeight

// uint32 featureValue = 1;
inline void BayesianProbitRegressor_FeatureValueWeight::clear_featurevalue() {
  featurevalue_ = 0u;
}
inline uint32_t BayesianProbitRegressor_FeatureValueWeight::_internal_featurevalue() const {
  return featurevalue_;
}
inline uint32_t BayesianProbitRegressor_FeatureValueWeight::featurevalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight.featureValue)
  return _internal_featurevalue();
}
inline void BayesianProbitRegressor_FeatureValueWeight::_internal_set_featurevalue(uint32_t value) {
  
  featurevalue_ = value;
}
inline void BayesianProbitRegressor_FeatureValueWeight::set_featurevalue(uint32_t value) {
  _internal_set_featurevalue(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight.featureValue)
}

// .CoreML.Specification.BayesianProbitRegressor.Gaussian featureWeight = 2;
inline bool BayesianProbitRegressor_FeatureValueWeight::_internal_has_featureweight() const {
  return this != internal_default_instance() && featureweight_ != nullptr;
}
inline bool BayesianProbitRegressor_FeatureValueWeight::has_featureweight() const {
  return _internal_has_featureweight();
}
inline void BayesianProbitRegressor_FeatureValueWeight::clear_featureweight() {
  if (GetArenaForAllocation() == nullptr && featureweight_ != nullptr) {
    delete featureweight_;
  }
  featureweight_ = nullptr;
}
inline const ::CoreML::Specification::BayesianProbitRegressor_Gaussian& BayesianProbitRegressor_FeatureValueWeight::_internal_featureweight() const {
  const ::CoreML::Specification::BayesianProbitRegressor_Gaussian* p = featureweight_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::BayesianProbitRegressor_Gaussian&>(
      ::CoreML::Specification::_BayesianProbitRegressor_Gaussian_default_instance_);
}
inline const ::CoreML::Specification::BayesianProbitRegressor_Gaussian& BayesianProbitRegressor_FeatureValueWeight::featureweight() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight.featureWeight)
  return _internal_featureweight();
}
inline void BayesianProbitRegressor_FeatureValueWeight::unsafe_arena_set_allocated_featureweight(
    ::CoreML::Specification::BayesianProbitRegressor_Gaussian* featureweight) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(featureweight_);
  }
  featureweight_ = featureweight;
  if (featureweight) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight.featureWeight)
}
inline ::CoreML::Specification::BayesianProbitRegressor_Gaussian* BayesianProbitRegressor_FeatureValueWeight::release_featureweight() {
  
  ::CoreML::Specification::BayesianProbitRegressor_Gaussian* temp = featureweight_;
  featureweight_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::BayesianProbitRegressor_Gaussian* BayesianProbitRegressor_FeatureValueWeight::unsafe_arena_release_featureweight() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight.featureWeight)
  
  ::CoreML::Specification::BayesianProbitRegressor_Gaussian* temp = featureweight_;
  featureweight_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::BayesianProbitRegressor_Gaussian* BayesianProbitRegressor_FeatureValueWeight::_internal_mutable_featureweight() {
  
  if (featureweight_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::BayesianProbitRegressor_Gaussian>(GetArenaForAllocation());
    featureweight_ = p;
  }
  return featureweight_;
}
inline ::CoreML::Specification::BayesianProbitRegressor_Gaussian* BayesianProbitRegressor_FeatureValueWeight::mutable_featureweight() {
  ::CoreML::Specification::BayesianProbitRegressor_Gaussian* _msg = _internal_mutable_featureweight();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight.featureWeight)
  return _msg;
}
inline void BayesianProbitRegressor_FeatureValueWeight::set_allocated_featureweight(::CoreML::Specification::BayesianProbitRegressor_Gaussian* featureweight) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete featureweight_;
  }
  if (featureweight) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::BayesianProbitRegressor_Gaussian>::GetOwningArena(featureweight);
    if (message_arena != submessage_arena) {
      featureweight = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, featureweight, submessage_arena);
    }
    
  } else {
    
  }
  featureweight_ = featureweight;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight.featureWeight)
}

// -------------------------------------------------------------------

// BayesianProbitRegressor_FeatureWeight

// uint32 featureId = 1;
inline void BayesianProbitRegressor_FeatureWeight::clear_featureid() {
  featureid_ = 0u;
}
inline uint32_t BayesianProbitRegressor_FeatureWeight::_internal_featureid() const {
  return featureid_;
}
inline uint32_t BayesianProbitRegressor_FeatureWeight::featureid() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.FeatureWeight.featureId)
  return _internal_featureid();
}
inline void BayesianProbitRegressor_FeatureWeight::_internal_set_featureid(uint32_t value) {
  
  featureid_ = value;
}
inline void BayesianProbitRegressor_FeatureWeight::set_featureid(uint32_t value) {
  _internal_set_featureid(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.FeatureWeight.featureId)
}

// repeated .CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight weights = 2;
inline int BayesianProbitRegressor_FeatureWeight::_internal_weights_size() const {
  return weights_.size();
}
inline int BayesianProbitRegressor_FeatureWeight::weights_size() const {
  return _internal_weights_size();
}
inline void BayesianProbitRegressor_FeatureWeight::clear_weights() {
  weights_.Clear();
}
inline ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight* BayesianProbitRegressor_FeatureWeight::mutable_weights(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.FeatureWeight.weights)
  return weights_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight >*
BayesianProbitRegressor_FeatureWeight::mutable_weights() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.BayesianProbitRegressor.FeatureWeight.weights)
  return &weights_;
}
inline const ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight& BayesianProbitRegressor_FeatureWeight::_internal_weights(int index) const {
  return weights_.Get(index);
}
inline const ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight& BayesianProbitRegressor_FeatureWeight::weights(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.FeatureWeight.weights)
  return _internal_weights(index);
}
inline ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight* BayesianProbitRegressor_FeatureWeight::_internal_add_weights() {
  return weights_.Add();
}
inline ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight* BayesianProbitRegressor_FeatureWeight::add_weights() {
  ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight* _add = _internal_add_weights();
  // @@protoc_insertion_point(field_add:CoreML.Specification.BayesianProbitRegressor.FeatureWeight.weights)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::BayesianProbitRegressor_FeatureValueWeight >&
BayesianProbitRegressor_FeatureWeight::weights() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.BayesianProbitRegressor.FeatureWeight.weights)
  return weights_;
}

// -------------------------------------------------------------------

// BayesianProbitRegressor

// uint32 numberOfFeatures = 1;
inline void BayesianProbitRegressor::clear_numberoffeatures() {
  numberoffeatures_ = 0u;
}
inline uint32_t BayesianProbitRegressor::_internal_numberoffeatures() const {
  return numberoffeatures_;
}
inline uint32_t BayesianProbitRegressor::numberoffeatures() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.numberOfFeatures)
  return _internal_numberoffeatures();
}
inline void BayesianProbitRegressor::_internal_set_numberoffeatures(uint32_t value) {
  
  numberoffeatures_ = value;
}
inline void BayesianProbitRegressor::set_numberoffeatures(uint32_t value) {
  _internal_set_numberoffeatures(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.numberOfFeatures)
}

// .CoreML.Specification.BayesianProbitRegressor.Gaussian bias = 2;
inline bool BayesianProbitRegressor::_internal_has_bias() const {
  return this != internal_default_instance() && bias_ != nullptr;
}
inline bool BayesianProbitRegressor::has_bias() const {
  return _internal_has_bias();
}
inline void BayesianProbitRegressor::clear_bias() {
  if (GetArenaForAllocation() == nullptr && bias_ != nullptr) {
    delete bias_;
  }
  bias_ = nullptr;
}
inline const ::CoreML::Specification::BayesianProbitRegressor_Gaussian& BayesianProbitRegressor::_internal_bias() const {
  const ::CoreML::Specification::BayesianProbitRegressor_Gaussian* p = bias_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::BayesianProbitRegressor_Gaussian&>(
      ::CoreML::Specification::_BayesianProbitRegressor_Gaussian_default_instance_);
}
inline const ::CoreML::Specification::BayesianProbitRegressor_Gaussian& BayesianProbitRegressor::bias() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.bias)
  return _internal_bias();
}
inline void BayesianProbitRegressor::unsafe_arena_set_allocated_bias(
    ::CoreML::Specification::BayesianProbitRegressor_Gaussian* bias) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bias_);
  }
  bias_ = bias;
  if (bias) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.BayesianProbitRegressor.bias)
}
inline ::CoreML::Specification::BayesianProbitRegressor_Gaussian* BayesianProbitRegressor::release_bias() {
  
  ::CoreML::Specification::BayesianProbitRegressor_Gaussian* temp = bias_;
  bias_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::BayesianProbitRegressor_Gaussian* BayesianProbitRegressor::unsafe_arena_release_bias() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.bias)
  
  ::CoreML::Specification::BayesianProbitRegressor_Gaussian* temp = bias_;
  bias_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::BayesianProbitRegressor_Gaussian* BayesianProbitRegressor::_internal_mutable_bias() {
  
  if (bias_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::BayesianProbitRegressor_Gaussian>(GetArenaForAllocation());
    bias_ = p;
  }
  return bias_;
}
inline ::CoreML::Specification::BayesianProbitRegressor_Gaussian* BayesianProbitRegressor::mutable_bias() {
  ::CoreML::Specification::BayesianProbitRegressor_Gaussian* _msg = _internal_mutable_bias();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.bias)
  return _msg;
}
inline void BayesianProbitRegressor::set_allocated_bias(::CoreML::Specification::BayesianProbitRegressor_Gaussian* bias) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bias_;
  }
  if (bias) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::BayesianProbitRegressor_Gaussian>::GetOwningArena(bias);
    if (message_arena != submessage_arena) {
      bias = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bias, submessage_arena);
    }
    
  } else {
    
  }
  bias_ = bias;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.bias)
}

// repeated .CoreML.Specification.BayesianProbitRegressor.FeatureWeight features = 3;
inline int BayesianProbitRegressor::_internal_features_size() const {
  return features_.size();
}
inline int BayesianProbitRegressor::features_size() const {
  return _internal_features_size();
}
inline void BayesianProbitRegressor::clear_features() {
  features_.Clear();
}
inline ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight* BayesianProbitRegressor::mutable_features(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.features)
  return features_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight >*
BayesianProbitRegressor::mutable_features() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.BayesianProbitRegressor.features)
  return &features_;
}
inline const ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight& BayesianProbitRegressor::_internal_features(int index) const {
  return features_.Get(index);
}
inline const ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight& BayesianProbitRegressor::features(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.features)
  return _internal_features(index);
}
inline ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight* BayesianProbitRegressor::_internal_add_features() {
  return features_.Add();
}
inline ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight* BayesianProbitRegressor::add_features() {
  ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight* _add = _internal_add_features();
  // @@protoc_insertion_point(field_add:CoreML.Specification.BayesianProbitRegressor.features)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::BayesianProbitRegressor_FeatureWeight >&
BayesianProbitRegressor::features() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.BayesianProbitRegressor.features)
  return features_;
}

// string regressionInputFeatureName = 10;
inline void BayesianProbitRegressor::clear_regressioninputfeaturename() {
  regressioninputfeaturename_.ClearToEmpty();
}
inline const std::string& BayesianProbitRegressor::regressioninputfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.regressionInputFeatureName)
  return _internal_regressioninputfeaturename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BayesianProbitRegressor::set_regressioninputfeaturename(ArgT0&& arg0, ArgT... args) {
 
 regressioninputfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.regressionInputFeatureName)
}
inline std::string* BayesianProbitRegressor::mutable_regressioninputfeaturename() {
  std::string* _s = _internal_mutable_regressioninputfeaturename();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.regressionInputFeatureName)
  return _s;
}
inline const std::string& BayesianProbitRegressor::_internal_regressioninputfeaturename() const {
  return regressioninputfeaturename_.Get();
}
inline void BayesianProbitRegressor::_internal_set_regressioninputfeaturename(const std::string& value) {
  
  regressioninputfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BayesianProbitRegressor::_internal_mutable_regressioninputfeaturename() {
  
  return regressioninputfeaturename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BayesianProbitRegressor::release_regressioninputfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.regressionInputFeatureName)
  return regressioninputfeaturename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BayesianProbitRegressor::set_allocated_regressioninputfeaturename(std::string* regressioninputfeaturename) {
  if (regressioninputfeaturename != nullptr) {
    
  } else {
    
  }
  regressioninputfeaturename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), regressioninputfeaturename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (regressioninputfeaturename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    regressioninputfeaturename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.regressionInputFeatureName)
}

// string optimismInputFeatureName = 11;
inline void BayesianProbitRegressor::clear_optimisminputfeaturename() {
  optimisminputfeaturename_.ClearToEmpty();
}
inline const std::string& BayesianProbitRegressor::optimisminputfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.optimismInputFeatureName)
  return _internal_optimisminputfeaturename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BayesianProbitRegressor::set_optimisminputfeaturename(ArgT0&& arg0, ArgT... args) {
 
 optimisminputfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.optimismInputFeatureName)
}
inline std::string* BayesianProbitRegressor::mutable_optimisminputfeaturename() {
  std::string* _s = _internal_mutable_optimisminputfeaturename();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.optimismInputFeatureName)
  return _s;
}
inline const std::string& BayesianProbitRegressor::_internal_optimisminputfeaturename() const {
  return optimisminputfeaturename_.Get();
}
inline void BayesianProbitRegressor::_internal_set_optimisminputfeaturename(const std::string& value) {
  
  optimisminputfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BayesianProbitRegressor::_internal_mutable_optimisminputfeaturename() {
  
  return optimisminputfeaturename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BayesianProbitRegressor::release_optimisminputfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.optimismInputFeatureName)
  return optimisminputfeaturename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BayesianProbitRegressor::set_allocated_optimisminputfeaturename(std::string* optimisminputfeaturename) {
  if (optimisminputfeaturename != nullptr) {
    
  } else {
    
  }
  optimisminputfeaturename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), optimisminputfeaturename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (optimisminputfeaturename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    optimisminputfeaturename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.optimismInputFeatureName)
}

// string samplingScaleInputFeatureName = 12;
inline void BayesianProbitRegressor::clear_samplingscaleinputfeaturename() {
  samplingscaleinputfeaturename_.ClearToEmpty();
}
inline const std::string& BayesianProbitRegressor::samplingscaleinputfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.samplingScaleInputFeatureName)
  return _internal_samplingscaleinputfeaturename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BayesianProbitRegressor::set_samplingscaleinputfeaturename(ArgT0&& arg0, ArgT... args) {
 
 samplingscaleinputfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.samplingScaleInputFeatureName)
}
inline std::string* BayesianProbitRegressor::mutable_samplingscaleinputfeaturename() {
  std::string* _s = _internal_mutable_samplingscaleinputfeaturename();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.samplingScaleInputFeatureName)
  return _s;
}
inline const std::string& BayesianProbitRegressor::_internal_samplingscaleinputfeaturename() const {
  return samplingscaleinputfeaturename_.Get();
}
inline void BayesianProbitRegressor::_internal_set_samplingscaleinputfeaturename(const std::string& value) {
  
  samplingscaleinputfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BayesianProbitRegressor::_internal_mutable_samplingscaleinputfeaturename() {
  
  return samplingscaleinputfeaturename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BayesianProbitRegressor::release_samplingscaleinputfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.samplingScaleInputFeatureName)
  return samplingscaleinputfeaturename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BayesianProbitRegressor::set_allocated_samplingscaleinputfeaturename(std::string* samplingscaleinputfeaturename) {
  if (samplingscaleinputfeaturename != nullptr) {
    
  } else {
    
  }
  samplingscaleinputfeaturename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), samplingscaleinputfeaturename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (samplingscaleinputfeaturename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    samplingscaleinputfeaturename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.samplingScaleInputFeatureName)
}

// string samplingTruncationInputFeatureName = 13;
inline void BayesianProbitRegressor::clear_samplingtruncationinputfeaturename() {
  samplingtruncationinputfeaturename_.ClearToEmpty();
}
inline const std::string& BayesianProbitRegressor::samplingtruncationinputfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.samplingTruncationInputFeatureName)
  return _internal_samplingtruncationinputfeaturename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BayesianProbitRegressor::set_samplingtruncationinputfeaturename(ArgT0&& arg0, ArgT... args) {
 
 samplingtruncationinputfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.samplingTruncationInputFeatureName)
}
inline std::string* BayesianProbitRegressor::mutable_samplingtruncationinputfeaturename() {
  std::string* _s = _internal_mutable_samplingtruncationinputfeaturename();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.samplingTruncationInputFeatureName)
  return _s;
}
inline const std::string& BayesianProbitRegressor::_internal_samplingtruncationinputfeaturename() const {
  return samplingtruncationinputfeaturename_.Get();
}
inline void BayesianProbitRegressor::_internal_set_samplingtruncationinputfeaturename(const std::string& value) {
  
  samplingtruncationinputfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BayesianProbitRegressor::_internal_mutable_samplingtruncationinputfeaturename() {
  
  return samplingtruncationinputfeaturename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BayesianProbitRegressor::release_samplingtruncationinputfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.samplingTruncationInputFeatureName)
  return samplingtruncationinputfeaturename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BayesianProbitRegressor::set_allocated_samplingtruncationinputfeaturename(std::string* samplingtruncationinputfeaturename) {
  if (samplingtruncationinputfeaturename != nullptr) {
    
  } else {
    
  }
  samplingtruncationinputfeaturename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), samplingtruncationinputfeaturename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (samplingtruncationinputfeaturename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    samplingtruncationinputfeaturename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.samplingTruncationInputFeatureName)
}

// string meanOutputFeatureName = 20;
inline void BayesianProbitRegressor::clear_meanoutputfeaturename() {
  meanoutputfeaturename_.ClearToEmpty();
}
inline const std::string& BayesianProbitRegressor::meanoutputfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.meanOutputFeatureName)
  return _internal_meanoutputfeaturename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BayesianProbitRegressor::set_meanoutputfeaturename(ArgT0&& arg0, ArgT... args) {
 
 meanoutputfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.meanOutputFeatureName)
}
inline std::string* BayesianProbitRegressor::mutable_meanoutputfeaturename() {
  std::string* _s = _internal_mutable_meanoutputfeaturename();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.meanOutputFeatureName)
  return _s;
}
inline const std::string& BayesianProbitRegressor::_internal_meanoutputfeaturename() const {
  return meanoutputfeaturename_.Get();
}
inline void BayesianProbitRegressor::_internal_set_meanoutputfeaturename(const std::string& value) {
  
  meanoutputfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BayesianProbitRegressor::_internal_mutable_meanoutputfeaturename() {
  
  return meanoutputfeaturename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BayesianProbitRegressor::release_meanoutputfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.meanOutputFeatureName)
  return meanoutputfeaturename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BayesianProbitRegressor::set_allocated_meanoutputfeaturename(std::string* meanoutputfeaturename) {
  if (meanoutputfeaturename != nullptr) {
    
  } else {
    
  }
  meanoutputfeaturename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), meanoutputfeaturename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (meanoutputfeaturename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    meanoutputfeaturename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.meanOutputFeatureName)
}

// string varianceOutputFeatureName = 21;
inline void BayesianProbitRegressor::clear_varianceoutputfeaturename() {
  varianceoutputfeaturename_.ClearToEmpty();
}
inline const std::string& BayesianProbitRegressor::varianceoutputfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.varianceOutputFeatureName)
  return _internal_varianceoutputfeaturename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BayesianProbitRegressor::set_varianceoutputfeaturename(ArgT0&& arg0, ArgT... args) {
 
 varianceoutputfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.varianceOutputFeatureName)
}
inline std::string* BayesianProbitRegressor::mutable_varianceoutputfeaturename() {
  std::string* _s = _internal_mutable_varianceoutputfeaturename();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.varianceOutputFeatureName)
  return _s;
}
inline const std::string& BayesianProbitRegressor::_internal_varianceoutputfeaturename() const {
  return varianceoutputfeaturename_.Get();
}
inline void BayesianProbitRegressor::_internal_set_varianceoutputfeaturename(const std::string& value) {
  
  varianceoutputfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BayesianProbitRegressor::_internal_mutable_varianceoutputfeaturename() {
  
  return varianceoutputfeaturename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BayesianProbitRegressor::release_varianceoutputfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.varianceOutputFeatureName)
  return varianceoutputfeaturename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BayesianProbitRegressor::set_allocated_varianceoutputfeaturename(std::string* varianceoutputfeaturename) {
  if (varianceoutputfeaturename != nullptr) {
    
  } else {
    
  }
  varianceoutputfeaturename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), varianceoutputfeaturename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (varianceoutputfeaturename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    varianceoutputfeaturename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.varianceOutputFeatureName)
}

// string pessimisticProbabilityOutputFeatureName = 22;
inline void BayesianProbitRegressor::clear_pessimisticprobabilityoutputfeaturename() {
  pessimisticprobabilityoutputfeaturename_.ClearToEmpty();
}
inline const std::string& BayesianProbitRegressor::pessimisticprobabilityoutputfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.pessimisticProbabilityOutputFeatureName)
  return _internal_pessimisticprobabilityoutputfeaturename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BayesianProbitRegressor::set_pessimisticprobabilityoutputfeaturename(ArgT0&& arg0, ArgT... args) {
 
 pessimisticprobabilityoutputfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.pessimisticProbabilityOutputFeatureName)
}
inline std::string* BayesianProbitRegressor::mutable_pessimisticprobabilityoutputfeaturename() {
  std::string* _s = _internal_mutable_pessimisticprobabilityoutputfeaturename();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.pessimisticProbabilityOutputFeatureName)
  return _s;
}
inline const std::string& BayesianProbitRegressor::_internal_pessimisticprobabilityoutputfeaturename() const {
  return pessimisticprobabilityoutputfeaturename_.Get();
}
inline void BayesianProbitRegressor::_internal_set_pessimisticprobabilityoutputfeaturename(const std::string& value) {
  
  pessimisticprobabilityoutputfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BayesianProbitRegressor::_internal_mutable_pessimisticprobabilityoutputfeaturename() {
  
  return pessimisticprobabilityoutputfeaturename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BayesianProbitRegressor::release_pessimisticprobabilityoutputfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.pessimisticProbabilityOutputFeatureName)
  return pessimisticprobabilityoutputfeaturename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BayesianProbitRegressor::set_allocated_pessimisticprobabilityoutputfeaturename(std::string* pessimisticprobabilityoutputfeaturename) {
  if (pessimisticprobabilityoutputfeaturename != nullptr) {
    
  } else {
    
  }
  pessimisticprobabilityoutputfeaturename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pessimisticprobabilityoutputfeaturename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pessimisticprobabilityoutputfeaturename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pessimisticprobabilityoutputfeaturename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.pessimisticProbabilityOutputFeatureName)
}

// string sampledProbabilityOutputFeatureName = 23;
inline void BayesianProbitRegressor::clear_sampledprobabilityoutputfeaturename() {
  sampledprobabilityoutputfeaturename_.ClearToEmpty();
}
inline const std::string& BayesianProbitRegressor::sampledprobabilityoutputfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BayesianProbitRegressor.sampledProbabilityOutputFeatureName)
  return _internal_sampledprobabilityoutputfeaturename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BayesianProbitRegressor::set_sampledprobabilityoutputfeaturename(ArgT0&& arg0, ArgT... args) {
 
 sampledprobabilityoutputfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CoreML.Specification.BayesianProbitRegressor.sampledProbabilityOutputFeatureName)
}
inline std::string* BayesianProbitRegressor::mutable_sampledprobabilityoutputfeaturename() {
  std::string* _s = _internal_mutable_sampledprobabilityoutputfeaturename();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BayesianProbitRegressor.sampledProbabilityOutputFeatureName)
  return _s;
}
inline const std::string& BayesianProbitRegressor::_internal_sampledprobabilityoutputfeaturename() const {
  return sampledprobabilityoutputfeaturename_.Get();
}
inline void BayesianProbitRegressor::_internal_set_sampledprobabilityoutputfeaturename(const std::string& value) {
  
  sampledprobabilityoutputfeaturename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BayesianProbitRegressor::_internal_mutable_sampledprobabilityoutputfeaturename() {
  
  return sampledprobabilityoutputfeaturename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BayesianProbitRegressor::release_sampledprobabilityoutputfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BayesianProbitRegressor.sampledProbabilityOutputFeatureName)
  return sampledprobabilityoutputfeaturename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BayesianProbitRegressor::set_allocated_sampledprobabilityoutputfeaturename(std::string* sampledprobabilityoutputfeaturename) {
  if (sampledprobabilityoutputfeaturename != nullptr) {
    
  } else {
    
  }
  sampledprobabilityoutputfeaturename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sampledprobabilityoutputfeaturename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sampledprobabilityoutputfeaturename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sampledprobabilityoutputfeaturename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BayesianProbitRegressor.sampledProbabilityOutputFeatureName)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Specification
}  // namespace CoreML

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_BayesianProbitRegressor_2eproto
