// Copyright (c) 2019, Apple Inc. All rights reserved.
//
// Use of this source code is governed by a BSD-3-clause license that can be
// found in LICENSE.txt or at https://opensource.org/licenses/BSD-3-Clause

/*
 * - A Program is the container with following information
 *     - set of functions: Function defines a program block to be executed
 *     - set of parameters: Parameters being used by Op and stored on disk/known at compile time
 *     - A neural network can have multiple functions defined and will have a single point of entry.
 *       (TODO: Depending on how we decide the behavior/expose API, above comment should change)
 * - A Function consists of
 *     - List of named inputs and output types
 *     - A block defining scope for a function- similar to function in C/C++
 * - A Block consists of 
 *     - List of named inputs and output names
 *     - Topologically sorted Ops
 * - A Op consists of
 *     - List of named inputs and outputs (name, type) pair
 *     - Optionally, blocks for Control-Flow
 * e.g.
 * 
 * main(%x : Float,
 *      %y : Float) {
 *    %c.1 : Int32 = const(val=2)
 *    %condition : Bool = mod(%x, %c.1)
 *    %z : Float = Control-Flow(%condition)
 *         () {
 *             %t : Float = add(%x, %y)
 *         } -> %t : Float
 *         () {
 *             %t : Float = sub(%x, %y)
 *         } -> %t : Float
 * } -> %z : Float
 */
 
//
// NOTE: FOLLOWING PROTO IS WORK IN PROGRESS
// EXPECT RAPID CHANGES IN FOLLOWING SPECIFICATION
//
// TODOs:
//    1. Classifier Version
//    2. Training option
//    3. Optional inputs
//    4. Specifying states
//    5. Renaming NeuralNetworkV2 to generic Graph/Model
//    6. Re-declaring / Merging Types with Model.proto e.g. ScalarType
//    7. Namespace decision
//    8. Place to store hints for each op, for either viz or transferring information to backend.
//
syntax = "proto3";
option optimize_for = LITE_RUNTIME;

package CoreML.Specification.V5;

// A top level container.
//
// TODO: Consideration for renaming `Program` message to more self-explainatory name.
// To make this following message a general execution
// framework instead of neural nets only.
message Program {
    int64 version = 1;

    // Must be unique within the containing Module
    map<string, Function> functions = 2;

    // parameters are generally externally stored (see Value).
    // Key: string formatted input name, Value: Value of the parameter
    map<string, Value> parameters = 3;

    string docString = 4;
}

// A Module-level function.
message Function {

    // Function inputs are unordered (name, ValueType) pairs.
    repeated NamedValueType inputs = 1;

    // output types should be consistent with block.outputs (whose ValueType is
    // defined in the associated Op's outputs
    repeated ValueType outputs = 2;

    // Output of function is the output of the block.
    Block block = 3;
}

// A basic block with a single entry and exit in SSA form.
message Block {
    // Named inputs-
    // Key: parameter name, Value: input name
    // e.g. {'stride' : 'input_01'}
    // Where 'stride' is one of the input being used within current Block
    // and 'input_01' is being passed to current Block
    map<string, string> inputs = 1;

    // ValueType of outputs[i] is Operation[j].outputs[k].type where 
    // i, j and k are indices of block output, block Operation and
    // jth operation's output respectively.
    // this is due to
    // 1. An operation can have more than one output
    // 2. Any one of operation's output could be potentially block's output
    repeated string outputs = 2;

    repeated Operation operations = 3;
}

// A single operation/node/layer.
message Operation {
    string name = 1;

    // Examples: "convolution", "cropResize". Operation type defines the
    // expected inputs and output.
    string type = 2;

    // Named inputs-
    // Key: parameter name, Value: input name
    // e.g. {'stride' : 'input_01'}
    // and 'input_01' will be mapped to 'stride' for current operation
    map<string, string> inputs = 3;

    // Output is positional.
    // Output names MUST be unique within the function scope.
    repeated NamedValueType outputs = 4;

    // Nested blocks for loops and conditionals. For example,
    // a conditional block will have two entries here.
    repeated Block blocks = 5;

    // attributes are generally stored within the proto message (see Value),
    // though for very large attributes external storage may be preferred.
    // Key: string formatted input name, Value: Value of the parameter
    map<string, Value> attributes = 6;
}


// Named Value parameters
// (name, type) pair
message NamedValueType {
    string name = 1;
    ValueType type = 2;
}


/* ========  Types ======= */

// Primer: Two fundamental representations of state:
//
// Variable: Variables are NEVER materialized at compile time and are only
// available at run time. Therefore, for Variables we only have ValueType,
// which may have symbolic shapes in the IR. Variable encompases familiar
// concepts such as placeholder, output of an Op.
//
// Value: Values are ALWAYS materialized at compile time, and MAY be modified
// at runtime (e.g., during on-device training). Value describes notions
// such as parameter, attributes of an op. Value is either stored inside
// proto (e.g., attributes) or outside of proto (e.g. parameters) and
// NEVER contains symbolic shape in the IR.
//
// Comment(daviddai): A Variable with the potential to be materialized at
// compile time (e.g., through constant propagation) does NOT preclude it to
// be a Variable. Certain Ops such as LoadParameter and Const, their output
// has potential to be materialized at compile time but is still represented
// as Variable.

// A type of any kind
message ValueType {
    oneof type {
        ScalarType scalarType = 1;
        TensorType tensorType = 2;
        ListType listType = 3;
        TupleType tupleType = 4;
    };
}

// Supported scalar types
enum ScalarType {
    // Comment: Two schemes of specifying field id: just start with 0
    // without reserving numbers, but keep track of the next field ID. The
    // other is assign blocks of ID to int / float / uint etc.

    // 0-10 reserved for special types
    DYNAMIC = 0;  // undefined / runtime type (e.g., trainable quantization)
    BOOL = 1;
    STRING = 2;  // arbitrary sequence of bytes

    // Floats
    FLOAT16 = 10;
    FLOAT32 = 11;
    FLOAT64 = 12;
    BFLOAT16 = 13;

    // Ints
    INT4 = 20;
    INT8 = 21;
    INT16 = 22;
    INT32 = 23;
    INT64 = 24;

    // UInts
    UINT4 = 30;
    UINT8 = 31;
    UINT16 = 32;
    UINT32 = 33;
    UINT64 = 34;
}


message TensorType {
    // The type of scalar stored in a tensor of this type
    ScalarType scalarType = 1;

    // The number of dimensions in the tensor shape. rank == -1 implies
    // undefined / variadic rank
    int64 rank = 2;

    // Tensor shape values; must be of length "rank"
    repeated Dimension dimension = 3;
}

message ListType {
    // The type of element stored in a list of this type
    ValueType type = 1;

    // The number of elements in a list of this type. May be symbolic (variable
    // length)
    Dimension length = 2;
}

message TupleType {
    // Recursively define TupleType from ValueType.
    repeated ValueType values = 1;
}

message Dimension {
    oneof dimension {
      // symbols starting with * is considered variadic rank (e.g., *s can
      // mean [s1, s2] or [s1]). Same symbol string in NeuralNetworkV2 proto
      // implies the same length. No global list of symbol is provided in IR.
      string symbol = 1;
      int64 size = 2;
    }
}

/* ======== Values ======= */

// See Variable vs Value primer above.
message Value {
    string docString = 1; // optional human-readable texts.
    ValueType type = 2;

    // An immediate value stored within the proto
    message ImmediateValue {
        oneof value {
            float f = 1;
            int64 i = 2;
            bool b = 3;
            bytes s = 4;
            TensorValue tensor = 5;
            TupleValue tuple = 6;
        }
    }

    // A value stored in some other file
    message FileValue {
        // TODO: If we are sure we won't need more than one binary file,
        // then we don't need file_name.
        string fileName = 1;

        // byte offset in a binary file.
        uint64 offset = 2;
    }

    oneof value {
        ImmediateValue immediateValue = 3;
        FileValue fileValue = 4;
    }
}

message TensorValue {
    // Comment: This is basically manual oneof since oneof in
    // Protobuf doesn't allow repeated field.
    repeated float floats = 2 [packed = true];
    repeated int64 ints = 3 [packed = true];
    repeated bool bools = 4 [packed = true];
    repeated bytes strings = 5;
}

message TupleValue {
    // Comment: TupleValue is recursively defined from Value.
    repeated Value value = 1;
}