// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FeatureTypes.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_FeatureTypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_FeatureTypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_FeatureTypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_FeatureTypes_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace CoreML {
namespace Specification {
class ArrayFeatureType;
struct ArrayFeatureTypeDefaultTypeInternal;
extern ArrayFeatureTypeDefaultTypeInternal _ArrayFeatureType_default_instance_;
class ArrayFeatureType_EnumeratedShapes;
struct ArrayFeatureType_EnumeratedShapesDefaultTypeInternal;
extern ArrayFeatureType_EnumeratedShapesDefaultTypeInternal _ArrayFeatureType_EnumeratedShapes_default_instance_;
class ArrayFeatureType_Shape;
struct ArrayFeatureType_ShapeDefaultTypeInternal;
extern ArrayFeatureType_ShapeDefaultTypeInternal _ArrayFeatureType_Shape_default_instance_;
class ArrayFeatureType_ShapeRange;
struct ArrayFeatureType_ShapeRangeDefaultTypeInternal;
extern ArrayFeatureType_ShapeRangeDefaultTypeInternal _ArrayFeatureType_ShapeRange_default_instance_;
class DictionaryFeatureType;
struct DictionaryFeatureTypeDefaultTypeInternal;
extern DictionaryFeatureTypeDefaultTypeInternal _DictionaryFeatureType_default_instance_;
class DoubleFeatureType;
struct DoubleFeatureTypeDefaultTypeInternal;
extern DoubleFeatureTypeDefaultTypeInternal _DoubleFeatureType_default_instance_;
class FeatureType;
struct FeatureTypeDefaultTypeInternal;
extern FeatureTypeDefaultTypeInternal _FeatureType_default_instance_;
class ImageFeatureType;
struct ImageFeatureTypeDefaultTypeInternal;
extern ImageFeatureTypeDefaultTypeInternal _ImageFeatureType_default_instance_;
class ImageFeatureType_EnumeratedImageSizes;
struct ImageFeatureType_EnumeratedImageSizesDefaultTypeInternal;
extern ImageFeatureType_EnumeratedImageSizesDefaultTypeInternal _ImageFeatureType_EnumeratedImageSizes_default_instance_;
class ImageFeatureType_ImageSize;
struct ImageFeatureType_ImageSizeDefaultTypeInternal;
extern ImageFeatureType_ImageSizeDefaultTypeInternal _ImageFeatureType_ImageSize_default_instance_;
class ImageFeatureType_ImageSizeRange;
struct ImageFeatureType_ImageSizeRangeDefaultTypeInternal;
extern ImageFeatureType_ImageSizeRangeDefaultTypeInternal _ImageFeatureType_ImageSizeRange_default_instance_;
class Int64FeatureType;
struct Int64FeatureTypeDefaultTypeInternal;
extern Int64FeatureTypeDefaultTypeInternal _Int64FeatureType_default_instance_;
class SequenceFeatureType;
struct SequenceFeatureTypeDefaultTypeInternal;
extern SequenceFeatureTypeDefaultTypeInternal _SequenceFeatureType_default_instance_;
class SizeRange;
struct SizeRangeDefaultTypeInternal;
extern SizeRangeDefaultTypeInternal _SizeRange_default_instance_;
class StateFeatureType;
struct StateFeatureTypeDefaultTypeInternal;
extern StateFeatureTypeDefaultTypeInternal _StateFeatureType_default_instance_;
class StringFeatureType;
struct StringFeatureTypeDefaultTypeInternal;
extern StringFeatureTypeDefaultTypeInternal _StringFeatureType_default_instance_;
}  // namespace Specification
}  // namespace CoreML
PROTOBUF_NAMESPACE_OPEN
template<> ::CoreML::Specification::ArrayFeatureType* Arena::CreateMaybeMessage<::CoreML::Specification::ArrayFeatureType>(Arena*);
template<> ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* Arena::CreateMaybeMessage<::CoreML::Specification::ArrayFeatureType_EnumeratedShapes>(Arena*);
template<> ::CoreML::Specification::ArrayFeatureType_Shape* Arena::CreateMaybeMessage<::CoreML::Specification::ArrayFeatureType_Shape>(Arena*);
template<> ::CoreML::Specification::ArrayFeatureType_ShapeRange* Arena::CreateMaybeMessage<::CoreML::Specification::ArrayFeatureType_ShapeRange>(Arena*);
template<> ::CoreML::Specification::DictionaryFeatureType* Arena::CreateMaybeMessage<::CoreML::Specification::DictionaryFeatureType>(Arena*);
template<> ::CoreML::Specification::DoubleFeatureType* Arena::CreateMaybeMessage<::CoreML::Specification::DoubleFeatureType>(Arena*);
template<> ::CoreML::Specification::FeatureType* Arena::CreateMaybeMessage<::CoreML::Specification::FeatureType>(Arena*);
template<> ::CoreML::Specification::ImageFeatureType* Arena::CreateMaybeMessage<::CoreML::Specification::ImageFeatureType>(Arena*);
template<> ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* Arena::CreateMaybeMessage<::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes>(Arena*);
template<> ::CoreML::Specification::ImageFeatureType_ImageSize* Arena::CreateMaybeMessage<::CoreML::Specification::ImageFeatureType_ImageSize>(Arena*);
template<> ::CoreML::Specification::ImageFeatureType_ImageSizeRange* Arena::CreateMaybeMessage<::CoreML::Specification::ImageFeatureType_ImageSizeRange>(Arena*);
template<> ::CoreML::Specification::Int64FeatureType* Arena::CreateMaybeMessage<::CoreML::Specification::Int64FeatureType>(Arena*);
template<> ::CoreML::Specification::SequenceFeatureType* Arena::CreateMaybeMessage<::CoreML::Specification::SequenceFeatureType>(Arena*);
template<> ::CoreML::Specification::SizeRange* Arena::CreateMaybeMessage<::CoreML::Specification::SizeRange>(Arena*);
template<> ::CoreML::Specification::StateFeatureType* Arena::CreateMaybeMessage<::CoreML::Specification::StateFeatureType>(Arena*);
template<> ::CoreML::Specification::StringFeatureType* Arena::CreateMaybeMessage<::CoreML::Specification::StringFeatureType>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace CoreML {
namespace Specification {

enum ImageFeatureType_ColorSpace : int {
  ImageFeatureType_ColorSpace_INVALID_COLOR_SPACE = 0,
  ImageFeatureType_ColorSpace_GRAYSCALE = 10,
  ImageFeatureType_ColorSpace_RGB = 20,
  ImageFeatureType_ColorSpace_BGR = 30,
  ImageFeatureType_ColorSpace_GRAYSCALE_FLOAT16 = 40,
  ImageFeatureType_ColorSpace_ImageFeatureType_ColorSpace_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ImageFeatureType_ColorSpace_ImageFeatureType_ColorSpace_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ImageFeatureType_ColorSpace_IsValid(int value);
constexpr ImageFeatureType_ColorSpace ImageFeatureType_ColorSpace_ColorSpace_MIN = ImageFeatureType_ColorSpace_INVALID_COLOR_SPACE;
constexpr ImageFeatureType_ColorSpace ImageFeatureType_ColorSpace_ColorSpace_MAX = ImageFeatureType_ColorSpace_GRAYSCALE_FLOAT16;
constexpr int ImageFeatureType_ColorSpace_ColorSpace_ARRAYSIZE = ImageFeatureType_ColorSpace_ColorSpace_MAX + 1;

const std::string& ImageFeatureType_ColorSpace_Name(ImageFeatureType_ColorSpace value);
template<typename T>
inline const std::string& ImageFeatureType_ColorSpace_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImageFeatureType_ColorSpace>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImageFeatureType_ColorSpace_Name.");
  return ImageFeatureType_ColorSpace_Name(static_cast<ImageFeatureType_ColorSpace>(enum_t_value));
}
bool ImageFeatureType_ColorSpace_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImageFeatureType_ColorSpace* value);
enum ArrayFeatureType_ArrayDataType : int {
  ArrayFeatureType_ArrayDataType_INVALID_ARRAY_DATA_TYPE = 0,
  ArrayFeatureType_ArrayDataType_FLOAT32 = 65568,
  ArrayFeatureType_ArrayDataType_DOUBLE = 65600,
  ArrayFeatureType_ArrayDataType_INT32 = 131104,
  ArrayFeatureType_ArrayDataType_FLOAT16 = 65552,
  ArrayFeatureType_ArrayDataType_ArrayFeatureType_ArrayDataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ArrayFeatureType_ArrayDataType_ArrayFeatureType_ArrayDataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ArrayFeatureType_ArrayDataType_IsValid(int value);
constexpr ArrayFeatureType_ArrayDataType ArrayFeatureType_ArrayDataType_ArrayDataType_MIN = ArrayFeatureType_ArrayDataType_INVALID_ARRAY_DATA_TYPE;
constexpr ArrayFeatureType_ArrayDataType ArrayFeatureType_ArrayDataType_ArrayDataType_MAX = ArrayFeatureType_ArrayDataType_INT32;
constexpr int ArrayFeatureType_ArrayDataType_ArrayDataType_ARRAYSIZE = ArrayFeatureType_ArrayDataType_ArrayDataType_MAX + 1;

const std::string& ArrayFeatureType_ArrayDataType_Name(ArrayFeatureType_ArrayDataType value);
template<typename T>
inline const std::string& ArrayFeatureType_ArrayDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArrayFeatureType_ArrayDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArrayFeatureType_ArrayDataType_Name.");
  return ArrayFeatureType_ArrayDataType_Name(static_cast<ArrayFeatureType_ArrayDataType>(enum_t_value));
}
bool ArrayFeatureType_ArrayDataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ArrayFeatureType_ArrayDataType* value);
// ===================================================================

class Int64FeatureType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.Int64FeatureType) */ {
 public:
  inline Int64FeatureType() : Int64FeatureType(nullptr) {}
  ~Int64FeatureType() override;
  explicit constexpr Int64FeatureType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Int64FeatureType(const Int64FeatureType& from);
  Int64FeatureType(Int64FeatureType&& from) noexcept
    : Int64FeatureType() {
    *this = ::std::move(from);
  }

  inline Int64FeatureType& operator=(const Int64FeatureType& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int64FeatureType& operator=(Int64FeatureType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Int64FeatureType& default_instance() {
    return *internal_default_instance();
  }
  static inline const Int64FeatureType* internal_default_instance() {
    return reinterpret_cast<const Int64FeatureType*>(
               &_Int64FeatureType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Int64FeatureType& a, Int64FeatureType& b) {
    a.Swap(&b);
  }
  inline void Swap(Int64FeatureType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int64FeatureType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int64FeatureType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Int64FeatureType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Int64FeatureType& from);
  void MergeFrom(const Int64FeatureType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Int64FeatureType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.Int64FeatureType";
  }
  protected:
  explicit Int64FeatureType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.Int64FeatureType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FeatureTypes_2eproto;
};
// -------------------------------------------------------------------

class DoubleFeatureType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.DoubleFeatureType) */ {
 public:
  inline DoubleFeatureType() : DoubleFeatureType(nullptr) {}
  ~DoubleFeatureType() override;
  explicit constexpr DoubleFeatureType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoubleFeatureType(const DoubleFeatureType& from);
  DoubleFeatureType(DoubleFeatureType&& from) noexcept
    : DoubleFeatureType() {
    *this = ::std::move(from);
  }

  inline DoubleFeatureType& operator=(const DoubleFeatureType& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleFeatureType& operator=(DoubleFeatureType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DoubleFeatureType& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoubleFeatureType* internal_default_instance() {
    return reinterpret_cast<const DoubleFeatureType*>(
               &_DoubleFeatureType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DoubleFeatureType& a, DoubleFeatureType& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleFeatureType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleFeatureType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleFeatureType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoubleFeatureType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DoubleFeatureType& from);
  void MergeFrom(const DoubleFeatureType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DoubleFeatureType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.DoubleFeatureType";
  }
  protected:
  explicit DoubleFeatureType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.DoubleFeatureType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FeatureTypes_2eproto;
};
// -------------------------------------------------------------------

class StringFeatureType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.StringFeatureType) */ {
 public:
  inline StringFeatureType() : StringFeatureType(nullptr) {}
  ~StringFeatureType() override;
  explicit constexpr StringFeatureType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringFeatureType(const StringFeatureType& from);
  StringFeatureType(StringFeatureType&& from) noexcept
    : StringFeatureType() {
    *this = ::std::move(from);
  }

  inline StringFeatureType& operator=(const StringFeatureType& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringFeatureType& operator=(StringFeatureType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const StringFeatureType& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringFeatureType* internal_default_instance() {
    return reinterpret_cast<const StringFeatureType*>(
               &_StringFeatureType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StringFeatureType& a, StringFeatureType& b) {
    a.Swap(&b);
  }
  inline void Swap(StringFeatureType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringFeatureType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringFeatureType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringFeatureType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StringFeatureType& from);
  void MergeFrom(const StringFeatureType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StringFeatureType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.StringFeatureType";
  }
  protected:
  explicit StringFeatureType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.StringFeatureType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FeatureTypes_2eproto;
};
// -------------------------------------------------------------------

class SizeRange final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.SizeRange) */ {
 public:
  inline SizeRange() : SizeRange(nullptr) {}
  ~SizeRange() override;
  explicit constexpr SizeRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SizeRange(const SizeRange& from);
  SizeRange(SizeRange&& from) noexcept
    : SizeRange() {
    *this = ::std::move(from);
  }

  inline SizeRange& operator=(const SizeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline SizeRange& operator=(SizeRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SizeRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const SizeRange* internal_default_instance() {
    return reinterpret_cast<const SizeRange*>(
               &_SizeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SizeRange& a, SizeRange& b) {
    a.Swap(&b);
  }
  inline void Swap(SizeRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SizeRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SizeRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SizeRange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SizeRange& from);
  void MergeFrom(const SizeRange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SizeRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.SizeRange";
  }
  protected:
  explicit SizeRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowerBoundFieldNumber = 1,
    kUpperBoundFieldNumber = 2,
  };
  // uint64 lowerBound = 1;
  void clear_lowerbound();
  uint64_t lowerbound() const;
  void set_lowerbound(uint64_t value);
  private:
  uint64_t _internal_lowerbound() const;
  void _internal_set_lowerbound(uint64_t value);
  public:

  // int64 upperBound = 2;
  void clear_upperbound();
  int64_t upperbound() const;
  void set_upperbound(int64_t value);
  private:
  int64_t _internal_upperbound() const;
  void _internal_set_upperbound(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.SizeRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t lowerbound_;
  int64_t upperbound_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FeatureTypes_2eproto;
};
// -------------------------------------------------------------------

class ImageFeatureType_ImageSize final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ImageFeatureType.ImageSize) */ {
 public:
  inline ImageFeatureType_ImageSize() : ImageFeatureType_ImageSize(nullptr) {}
  ~ImageFeatureType_ImageSize() override;
  explicit constexpr ImageFeatureType_ImageSize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageFeatureType_ImageSize(const ImageFeatureType_ImageSize& from);
  ImageFeatureType_ImageSize(ImageFeatureType_ImageSize&& from) noexcept
    : ImageFeatureType_ImageSize() {
    *this = ::std::move(from);
  }

  inline ImageFeatureType_ImageSize& operator=(const ImageFeatureType_ImageSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageFeatureType_ImageSize& operator=(ImageFeatureType_ImageSize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ImageFeatureType_ImageSize& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageFeatureType_ImageSize* internal_default_instance() {
    return reinterpret_cast<const ImageFeatureType_ImageSize*>(
               &_ImageFeatureType_ImageSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ImageFeatureType_ImageSize& a, ImageFeatureType_ImageSize& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageFeatureType_ImageSize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageFeatureType_ImageSize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageFeatureType_ImageSize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageFeatureType_ImageSize>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ImageFeatureType_ImageSize& from);
  void MergeFrom(const ImageFeatureType_ImageSize& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImageFeatureType_ImageSize* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.ImageFeatureType.ImageSize";
  }
  protected:
  explicit ImageFeatureType_ImageSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // uint64 width = 1;
  void clear_width();
  uint64_t width() const;
  void set_width(uint64_t value);
  private:
  uint64_t _internal_width() const;
  void _internal_set_width(uint64_t value);
  public:

  // uint64 height = 2;
  void clear_height();
  uint64_t height() const;
  void set_height(uint64_t value);
  private:
  uint64_t _internal_height() const;
  void _internal_set_height(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ImageFeatureType.ImageSize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t width_;
  uint64_t height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FeatureTypes_2eproto;
};
// -------------------------------------------------------------------

class ImageFeatureType_EnumeratedImageSizes final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes) */ {
 public:
  inline ImageFeatureType_EnumeratedImageSizes() : ImageFeatureType_EnumeratedImageSizes(nullptr) {}
  ~ImageFeatureType_EnumeratedImageSizes() override;
  explicit constexpr ImageFeatureType_EnumeratedImageSizes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageFeatureType_EnumeratedImageSizes(const ImageFeatureType_EnumeratedImageSizes& from);
  ImageFeatureType_EnumeratedImageSizes(ImageFeatureType_EnumeratedImageSizes&& from) noexcept
    : ImageFeatureType_EnumeratedImageSizes() {
    *this = ::std::move(from);
  }

  inline ImageFeatureType_EnumeratedImageSizes& operator=(const ImageFeatureType_EnumeratedImageSizes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageFeatureType_EnumeratedImageSizes& operator=(ImageFeatureType_EnumeratedImageSizes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ImageFeatureType_EnumeratedImageSizes& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageFeatureType_EnumeratedImageSizes* internal_default_instance() {
    return reinterpret_cast<const ImageFeatureType_EnumeratedImageSizes*>(
               &_ImageFeatureType_EnumeratedImageSizes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ImageFeatureType_EnumeratedImageSizes& a, ImageFeatureType_EnumeratedImageSizes& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageFeatureType_EnumeratedImageSizes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageFeatureType_EnumeratedImageSizes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageFeatureType_EnumeratedImageSizes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageFeatureType_EnumeratedImageSizes>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ImageFeatureType_EnumeratedImageSizes& from);
  void MergeFrom(const ImageFeatureType_EnumeratedImageSizes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImageFeatureType_EnumeratedImageSizes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.ImageFeatureType.EnumeratedImageSizes";
  }
  protected:
  explicit ImageFeatureType_EnumeratedImageSizes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizesFieldNumber = 1,
  };
  // repeated .CoreML.Specification.ImageFeatureType.ImageSize sizes = 1;
  int sizes_size() const;
  private:
  int _internal_sizes_size() const;
  public:
  void clear_sizes();
  ::CoreML::Specification::ImageFeatureType_ImageSize* mutable_sizes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::ImageFeatureType_ImageSize >*
      mutable_sizes();
  private:
  const ::CoreML::Specification::ImageFeatureType_ImageSize& _internal_sizes(int index) const;
  ::CoreML::Specification::ImageFeatureType_ImageSize* _internal_add_sizes();
  public:
  const ::CoreML::Specification::ImageFeatureType_ImageSize& sizes(int index) const;
  ::CoreML::Specification::ImageFeatureType_ImageSize* add_sizes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::ImageFeatureType_ImageSize >&
      sizes() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::ImageFeatureType_ImageSize > sizes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FeatureTypes_2eproto;
};
// -------------------------------------------------------------------

class ImageFeatureType_ImageSizeRange final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ImageFeatureType.ImageSizeRange) */ {
 public:
  inline ImageFeatureType_ImageSizeRange() : ImageFeatureType_ImageSizeRange(nullptr) {}
  ~ImageFeatureType_ImageSizeRange() override;
  explicit constexpr ImageFeatureType_ImageSizeRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageFeatureType_ImageSizeRange(const ImageFeatureType_ImageSizeRange& from);
  ImageFeatureType_ImageSizeRange(ImageFeatureType_ImageSizeRange&& from) noexcept
    : ImageFeatureType_ImageSizeRange() {
    *this = ::std::move(from);
  }

  inline ImageFeatureType_ImageSizeRange& operator=(const ImageFeatureType_ImageSizeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageFeatureType_ImageSizeRange& operator=(ImageFeatureType_ImageSizeRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ImageFeatureType_ImageSizeRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageFeatureType_ImageSizeRange* internal_default_instance() {
    return reinterpret_cast<const ImageFeatureType_ImageSizeRange*>(
               &_ImageFeatureType_ImageSizeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ImageFeatureType_ImageSizeRange& a, ImageFeatureType_ImageSizeRange& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageFeatureType_ImageSizeRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageFeatureType_ImageSizeRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageFeatureType_ImageSizeRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageFeatureType_ImageSizeRange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ImageFeatureType_ImageSizeRange& from);
  void MergeFrom(const ImageFeatureType_ImageSizeRange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImageFeatureType_ImageSizeRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.ImageFeatureType.ImageSizeRange";
  }
  protected:
  explicit ImageFeatureType_ImageSizeRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthRangeFieldNumber = 1,
    kHeightRangeFieldNumber = 2,
  };
  // .CoreML.Specification.SizeRange widthRange = 1;
  bool has_widthrange() const;
  private:
  bool _internal_has_widthrange() const;
  public:
  void clear_widthrange();
  const ::CoreML::Specification::SizeRange& widthrange() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::SizeRange* release_widthrange();
  ::CoreML::Specification::SizeRange* mutable_widthrange();
  void set_allocated_widthrange(::CoreML::Specification::SizeRange* widthrange);
  private:
  const ::CoreML::Specification::SizeRange& _internal_widthrange() const;
  ::CoreML::Specification::SizeRange* _internal_mutable_widthrange();
  public:
  void unsafe_arena_set_allocated_widthrange(
      ::CoreML::Specification::SizeRange* widthrange);
  ::CoreML::Specification::SizeRange* unsafe_arena_release_widthrange();

  // .CoreML.Specification.SizeRange heightRange = 2;
  bool has_heightrange() const;
  private:
  bool _internal_has_heightrange() const;
  public:
  void clear_heightrange();
  const ::CoreML::Specification::SizeRange& heightrange() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::SizeRange* release_heightrange();
  ::CoreML::Specification::SizeRange* mutable_heightrange();
  void set_allocated_heightrange(::CoreML::Specification::SizeRange* heightrange);
  private:
  const ::CoreML::Specification::SizeRange& _internal_heightrange() const;
  ::CoreML::Specification::SizeRange* _internal_mutable_heightrange();
  public:
  void unsafe_arena_set_allocated_heightrange(
      ::CoreML::Specification::SizeRange* heightrange);
  ::CoreML::Specification::SizeRange* unsafe_arena_release_heightrange();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ImageFeatureType.ImageSizeRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::CoreML::Specification::SizeRange* widthrange_;
  ::CoreML::Specification::SizeRange* heightrange_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FeatureTypes_2eproto;
};
// -------------------------------------------------------------------

class ImageFeatureType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ImageFeatureType) */ {
 public:
  inline ImageFeatureType() : ImageFeatureType(nullptr) {}
  ~ImageFeatureType() override;
  explicit constexpr ImageFeatureType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageFeatureType(const ImageFeatureType& from);
  ImageFeatureType(ImageFeatureType&& from) noexcept
    : ImageFeatureType() {
    *this = ::std::move(from);
  }

  inline ImageFeatureType& operator=(const ImageFeatureType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageFeatureType& operator=(ImageFeatureType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ImageFeatureType& default_instance() {
    return *internal_default_instance();
  }
  enum SizeFlexibilityCase {
    kEnumeratedSizes = 21,
    kImageSizeRange = 31,
    SIZEFLEXIBILITY_NOT_SET = 0,
  };

  static inline const ImageFeatureType* internal_default_instance() {
    return reinterpret_cast<const ImageFeatureType*>(
               &_ImageFeatureType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ImageFeatureType& a, ImageFeatureType& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageFeatureType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageFeatureType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageFeatureType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageFeatureType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ImageFeatureType& from);
  void MergeFrom(const ImageFeatureType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImageFeatureType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.ImageFeatureType";
  }
  protected:
  explicit ImageFeatureType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ImageFeatureType_ImageSize ImageSize;
  typedef ImageFeatureType_EnumeratedImageSizes EnumeratedImageSizes;
  typedef ImageFeatureType_ImageSizeRange ImageSizeRange;

  typedef ImageFeatureType_ColorSpace ColorSpace;
  static constexpr ColorSpace INVALID_COLOR_SPACE =
    ImageFeatureType_ColorSpace_INVALID_COLOR_SPACE;
  static constexpr ColorSpace GRAYSCALE =
    ImageFeatureType_ColorSpace_GRAYSCALE;
  static constexpr ColorSpace RGB =
    ImageFeatureType_ColorSpace_RGB;
  static constexpr ColorSpace BGR =
    ImageFeatureType_ColorSpace_BGR;
  static constexpr ColorSpace GRAYSCALE_FLOAT16 =
    ImageFeatureType_ColorSpace_GRAYSCALE_FLOAT16;
  static inline bool ColorSpace_IsValid(int value) {
    return ImageFeatureType_ColorSpace_IsValid(value);
  }
  static constexpr ColorSpace ColorSpace_MIN =
    ImageFeatureType_ColorSpace_ColorSpace_MIN;
  static constexpr ColorSpace ColorSpace_MAX =
    ImageFeatureType_ColorSpace_ColorSpace_MAX;
  static constexpr int ColorSpace_ARRAYSIZE =
    ImageFeatureType_ColorSpace_ColorSpace_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ColorSpace_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ColorSpace>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ColorSpace_Name.");
    return ImageFeatureType_ColorSpace_Name(enum_t_value);
  }
  static inline bool ColorSpace_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ColorSpace* value) {
    return ImageFeatureType_ColorSpace_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kColorSpaceFieldNumber = 3,
    kEnumeratedSizesFieldNumber = 21,
    kImageSizeRangeFieldNumber = 31,
  };
  // int64 width = 1;
  void clear_width();
  int64_t width() const;
  void set_width(int64_t value);
  private:
  int64_t _internal_width() const;
  void _internal_set_width(int64_t value);
  public:

  // int64 height = 2;
  void clear_height();
  int64_t height() const;
  void set_height(int64_t value);
  private:
  int64_t _internal_height() const;
  void _internal_set_height(int64_t value);
  public:

  // .CoreML.Specification.ImageFeatureType.ColorSpace colorSpace = 3;
  void clear_colorspace();
  ::CoreML::Specification::ImageFeatureType_ColorSpace colorspace() const;
  void set_colorspace(::CoreML::Specification::ImageFeatureType_ColorSpace value);
  private:
  ::CoreML::Specification::ImageFeatureType_ColorSpace _internal_colorspace() const;
  void _internal_set_colorspace(::CoreML::Specification::ImageFeatureType_ColorSpace value);
  public:

  // .CoreML.Specification.ImageFeatureType.EnumeratedImageSizes enumeratedSizes = 21;
  bool has_enumeratedsizes() const;
  private:
  bool _internal_has_enumeratedsizes() const;
  public:
  void clear_enumeratedsizes();
  const ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes& enumeratedsizes() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* release_enumeratedsizes();
  ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* mutable_enumeratedsizes();
  void set_allocated_enumeratedsizes(::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* enumeratedsizes);
  private:
  const ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes& _internal_enumeratedsizes() const;
  ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* _internal_mutable_enumeratedsizes();
  public:
  void unsafe_arena_set_allocated_enumeratedsizes(
      ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* enumeratedsizes);
  ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* unsafe_arena_release_enumeratedsizes();

  // .CoreML.Specification.ImageFeatureType.ImageSizeRange imageSizeRange = 31;
  bool has_imagesizerange() const;
  private:
  bool _internal_has_imagesizerange() const;
  public:
  void clear_imagesizerange();
  const ::CoreML::Specification::ImageFeatureType_ImageSizeRange& imagesizerange() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::ImageFeatureType_ImageSizeRange* release_imagesizerange();
  ::CoreML::Specification::ImageFeatureType_ImageSizeRange* mutable_imagesizerange();
  void set_allocated_imagesizerange(::CoreML::Specification::ImageFeatureType_ImageSizeRange* imagesizerange);
  private:
  const ::CoreML::Specification::ImageFeatureType_ImageSizeRange& _internal_imagesizerange() const;
  ::CoreML::Specification::ImageFeatureType_ImageSizeRange* _internal_mutable_imagesizerange();
  public:
  void unsafe_arena_set_allocated_imagesizerange(
      ::CoreML::Specification::ImageFeatureType_ImageSizeRange* imagesizerange);
  ::CoreML::Specification::ImageFeatureType_ImageSizeRange* unsafe_arena_release_imagesizerange();

  void clear_SizeFlexibility();
  SizeFlexibilityCase SizeFlexibility_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.ImageFeatureType)
 private:
  class _Internal;
  void set_has_enumeratedsizes();
  void set_has_imagesizerange();

  inline bool has_SizeFlexibility() const;
  inline void clear_has_SizeFlexibility();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t width_;
  int64_t height_;
  int colorspace_;
  union SizeFlexibilityUnion {
    constexpr SizeFlexibilityUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* enumeratedsizes_;
    ::CoreML::Specification::ImageFeatureType_ImageSizeRange* imagesizerange_;
  } SizeFlexibility_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_FeatureTypes_2eproto;
};
// -------------------------------------------------------------------

class ArrayFeatureType_Shape final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ArrayFeatureType.Shape) */ {
 public:
  inline ArrayFeatureType_Shape() : ArrayFeatureType_Shape(nullptr) {}
  ~ArrayFeatureType_Shape() override;
  explicit constexpr ArrayFeatureType_Shape(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArrayFeatureType_Shape(const ArrayFeatureType_Shape& from);
  ArrayFeatureType_Shape(ArrayFeatureType_Shape&& from) noexcept
    : ArrayFeatureType_Shape() {
    *this = ::std::move(from);
  }

  inline ArrayFeatureType_Shape& operator=(const ArrayFeatureType_Shape& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArrayFeatureType_Shape& operator=(ArrayFeatureType_Shape&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ArrayFeatureType_Shape& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArrayFeatureType_Shape* internal_default_instance() {
    return reinterpret_cast<const ArrayFeatureType_Shape*>(
               &_ArrayFeatureType_Shape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ArrayFeatureType_Shape& a, ArrayFeatureType_Shape& b) {
    a.Swap(&b);
  }
  inline void Swap(ArrayFeatureType_Shape* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArrayFeatureType_Shape* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArrayFeatureType_Shape* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArrayFeatureType_Shape>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ArrayFeatureType_Shape& from);
  void MergeFrom(const ArrayFeatureType_Shape& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ArrayFeatureType_Shape* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.ArrayFeatureType.Shape";
  }
  protected:
  explicit ArrayFeatureType_Shape(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 1,
  };
  // repeated int64 shape = 1;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int64_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_shape() const;
  void _internal_add_shape(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_shape();
  public:
  int64_t shape(int index) const;
  void set_shape(int index, int64_t value);
  void add_shape(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_shape();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ArrayFeatureType.Shape)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > shape_;
  mutable std::atomic<int> _shape_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FeatureTypes_2eproto;
};
// -------------------------------------------------------------------

class ArrayFeatureType_EnumeratedShapes final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ArrayFeatureType.EnumeratedShapes) */ {
 public:
  inline ArrayFeatureType_EnumeratedShapes() : ArrayFeatureType_EnumeratedShapes(nullptr) {}
  ~ArrayFeatureType_EnumeratedShapes() override;
  explicit constexpr ArrayFeatureType_EnumeratedShapes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArrayFeatureType_EnumeratedShapes(const ArrayFeatureType_EnumeratedShapes& from);
  ArrayFeatureType_EnumeratedShapes(ArrayFeatureType_EnumeratedShapes&& from) noexcept
    : ArrayFeatureType_EnumeratedShapes() {
    *this = ::std::move(from);
  }

  inline ArrayFeatureType_EnumeratedShapes& operator=(const ArrayFeatureType_EnumeratedShapes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArrayFeatureType_EnumeratedShapes& operator=(ArrayFeatureType_EnumeratedShapes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ArrayFeatureType_EnumeratedShapes& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArrayFeatureType_EnumeratedShapes* internal_default_instance() {
    return reinterpret_cast<const ArrayFeatureType_EnumeratedShapes*>(
               &_ArrayFeatureType_EnumeratedShapes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ArrayFeatureType_EnumeratedShapes& a, ArrayFeatureType_EnumeratedShapes& b) {
    a.Swap(&b);
  }
  inline void Swap(ArrayFeatureType_EnumeratedShapes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArrayFeatureType_EnumeratedShapes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArrayFeatureType_EnumeratedShapes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArrayFeatureType_EnumeratedShapes>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ArrayFeatureType_EnumeratedShapes& from);
  void MergeFrom(const ArrayFeatureType_EnumeratedShapes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ArrayFeatureType_EnumeratedShapes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.ArrayFeatureType.EnumeratedShapes";
  }
  protected:
  explicit ArrayFeatureType_EnumeratedShapes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapesFieldNumber = 1,
  };
  // repeated .CoreML.Specification.ArrayFeatureType.Shape shapes = 1;
  int shapes_size() const;
  private:
  int _internal_shapes_size() const;
  public:
  void clear_shapes();
  ::CoreML::Specification::ArrayFeatureType_Shape* mutable_shapes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::ArrayFeatureType_Shape >*
      mutable_shapes();
  private:
  const ::CoreML::Specification::ArrayFeatureType_Shape& _internal_shapes(int index) const;
  ::CoreML::Specification::ArrayFeatureType_Shape* _internal_add_shapes();
  public:
  const ::CoreML::Specification::ArrayFeatureType_Shape& shapes(int index) const;
  ::CoreML::Specification::ArrayFeatureType_Shape* add_shapes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::ArrayFeatureType_Shape >&
      shapes() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::ArrayFeatureType_Shape > shapes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FeatureTypes_2eproto;
};
// -------------------------------------------------------------------

class ArrayFeatureType_ShapeRange final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ArrayFeatureType.ShapeRange) */ {
 public:
  inline ArrayFeatureType_ShapeRange() : ArrayFeatureType_ShapeRange(nullptr) {}
  ~ArrayFeatureType_ShapeRange() override;
  explicit constexpr ArrayFeatureType_ShapeRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArrayFeatureType_ShapeRange(const ArrayFeatureType_ShapeRange& from);
  ArrayFeatureType_ShapeRange(ArrayFeatureType_ShapeRange&& from) noexcept
    : ArrayFeatureType_ShapeRange() {
    *this = ::std::move(from);
  }

  inline ArrayFeatureType_ShapeRange& operator=(const ArrayFeatureType_ShapeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArrayFeatureType_ShapeRange& operator=(ArrayFeatureType_ShapeRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ArrayFeatureType_ShapeRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArrayFeatureType_ShapeRange* internal_default_instance() {
    return reinterpret_cast<const ArrayFeatureType_ShapeRange*>(
               &_ArrayFeatureType_ShapeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ArrayFeatureType_ShapeRange& a, ArrayFeatureType_ShapeRange& b) {
    a.Swap(&b);
  }
  inline void Swap(ArrayFeatureType_ShapeRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArrayFeatureType_ShapeRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArrayFeatureType_ShapeRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArrayFeatureType_ShapeRange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ArrayFeatureType_ShapeRange& from);
  void MergeFrom(const ArrayFeatureType_ShapeRange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ArrayFeatureType_ShapeRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.ArrayFeatureType.ShapeRange";
  }
  protected:
  explicit ArrayFeatureType_ShapeRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeRangesFieldNumber = 1,
  };
  // repeated .CoreML.Specification.SizeRange sizeRanges = 1;
  int sizeranges_size() const;
  private:
  int _internal_sizeranges_size() const;
  public:
  void clear_sizeranges();
  ::CoreML::Specification::SizeRange* mutable_sizeranges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::SizeRange >*
      mutable_sizeranges();
  private:
  const ::CoreML::Specification::SizeRange& _internal_sizeranges(int index) const;
  ::CoreML::Specification::SizeRange* _internal_add_sizeranges();
  public:
  const ::CoreML::Specification::SizeRange& sizeranges(int index) const;
  ::CoreML::Specification::SizeRange* add_sizeranges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::SizeRange >&
      sizeranges() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ArrayFeatureType.ShapeRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::SizeRange > sizeranges_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FeatureTypes_2eproto;
};
// -------------------------------------------------------------------

class ArrayFeatureType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ArrayFeatureType) */ {
 public:
  inline ArrayFeatureType() : ArrayFeatureType(nullptr) {}
  ~ArrayFeatureType() override;
  explicit constexpr ArrayFeatureType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArrayFeatureType(const ArrayFeatureType& from);
  ArrayFeatureType(ArrayFeatureType&& from) noexcept
    : ArrayFeatureType() {
    *this = ::std::move(from);
  }

  inline ArrayFeatureType& operator=(const ArrayFeatureType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArrayFeatureType& operator=(ArrayFeatureType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ArrayFeatureType& default_instance() {
    return *internal_default_instance();
  }
  enum ShapeFlexibilityCase {
    kEnumeratedShapes = 21,
    kShapeRange = 31,
    SHAPEFLEXIBILITY_NOT_SET = 0,
  };

  enum DefaultOptionalValueCase {
    kIntDefaultValue = 41,
    kFloatDefaultValue = 51,
    kDoubleDefaultValue = 61,
    DEFAULTOPTIONALVALUE_NOT_SET = 0,
  };

  static inline const ArrayFeatureType* internal_default_instance() {
    return reinterpret_cast<const ArrayFeatureType*>(
               &_ArrayFeatureType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ArrayFeatureType& a, ArrayFeatureType& b) {
    a.Swap(&b);
  }
  inline void Swap(ArrayFeatureType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArrayFeatureType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArrayFeatureType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArrayFeatureType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ArrayFeatureType& from);
  void MergeFrom(const ArrayFeatureType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ArrayFeatureType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.ArrayFeatureType";
  }
  protected:
  explicit ArrayFeatureType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ArrayFeatureType_Shape Shape;
  typedef ArrayFeatureType_EnumeratedShapes EnumeratedShapes;
  typedef ArrayFeatureType_ShapeRange ShapeRange;

  typedef ArrayFeatureType_ArrayDataType ArrayDataType;
  static constexpr ArrayDataType INVALID_ARRAY_DATA_TYPE =
    ArrayFeatureType_ArrayDataType_INVALID_ARRAY_DATA_TYPE;
  static constexpr ArrayDataType FLOAT32 =
    ArrayFeatureType_ArrayDataType_FLOAT32;
  static constexpr ArrayDataType DOUBLE =
    ArrayFeatureType_ArrayDataType_DOUBLE;
  static constexpr ArrayDataType INT32 =
    ArrayFeatureType_ArrayDataType_INT32;
  static constexpr ArrayDataType FLOAT16 =
    ArrayFeatureType_ArrayDataType_FLOAT16;
  static inline bool ArrayDataType_IsValid(int value) {
    return ArrayFeatureType_ArrayDataType_IsValid(value);
  }
  static constexpr ArrayDataType ArrayDataType_MIN =
    ArrayFeatureType_ArrayDataType_ArrayDataType_MIN;
  static constexpr ArrayDataType ArrayDataType_MAX =
    ArrayFeatureType_ArrayDataType_ArrayDataType_MAX;
  static constexpr int ArrayDataType_ARRAYSIZE =
    ArrayFeatureType_ArrayDataType_ArrayDataType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ArrayDataType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ArrayDataType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ArrayDataType_Name.");
    return ArrayFeatureType_ArrayDataType_Name(enum_t_value);
  }
  static inline bool ArrayDataType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ArrayDataType* value) {
    return ArrayFeatureType_ArrayDataType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 1,
    kDataTypeFieldNumber = 2,
    kEnumeratedShapesFieldNumber = 21,
    kShapeRangeFieldNumber = 31,
    kIntDefaultValueFieldNumber = 41,
    kFloatDefaultValueFieldNumber = 51,
    kDoubleDefaultValueFieldNumber = 61,
  };
  // repeated int64 shape = 1;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int64_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_shape() const;
  void _internal_add_shape(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_shape();
  public:
  int64_t shape(int index) const;
  void set_shape(int index, int64_t value);
  void add_shape(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_shape();

  // .CoreML.Specification.ArrayFeatureType.ArrayDataType dataType = 2;
  void clear_datatype();
  ::CoreML::Specification::ArrayFeatureType_ArrayDataType datatype() const;
  void set_datatype(::CoreML::Specification::ArrayFeatureType_ArrayDataType value);
  private:
  ::CoreML::Specification::ArrayFeatureType_ArrayDataType _internal_datatype() const;
  void _internal_set_datatype(::CoreML::Specification::ArrayFeatureType_ArrayDataType value);
  public:

  // .CoreML.Specification.ArrayFeatureType.EnumeratedShapes enumeratedShapes = 21;
  bool has_enumeratedshapes() const;
  private:
  bool _internal_has_enumeratedshapes() const;
  public:
  void clear_enumeratedshapes();
  const ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes& enumeratedshapes() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* release_enumeratedshapes();
  ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* mutable_enumeratedshapes();
  void set_allocated_enumeratedshapes(::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* enumeratedshapes);
  private:
  const ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes& _internal_enumeratedshapes() const;
  ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* _internal_mutable_enumeratedshapes();
  public:
  void unsafe_arena_set_allocated_enumeratedshapes(
      ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* enumeratedshapes);
  ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* unsafe_arena_release_enumeratedshapes();

  // .CoreML.Specification.ArrayFeatureType.ShapeRange shapeRange = 31;
  bool has_shaperange() const;
  private:
  bool _internal_has_shaperange() const;
  public:
  void clear_shaperange();
  const ::CoreML::Specification::ArrayFeatureType_ShapeRange& shaperange() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::ArrayFeatureType_ShapeRange* release_shaperange();
  ::CoreML::Specification::ArrayFeatureType_ShapeRange* mutable_shaperange();
  void set_allocated_shaperange(::CoreML::Specification::ArrayFeatureType_ShapeRange* shaperange);
  private:
  const ::CoreML::Specification::ArrayFeatureType_ShapeRange& _internal_shaperange() const;
  ::CoreML::Specification::ArrayFeatureType_ShapeRange* _internal_mutable_shaperange();
  public:
  void unsafe_arena_set_allocated_shaperange(
      ::CoreML::Specification::ArrayFeatureType_ShapeRange* shaperange);
  ::CoreML::Specification::ArrayFeatureType_ShapeRange* unsafe_arena_release_shaperange();

  // int32 intDefaultValue = 41;
  bool has_intdefaultvalue() const;
  private:
  bool _internal_has_intdefaultvalue() const;
  public:
  void clear_intdefaultvalue();
  int32_t intdefaultvalue() const;
  void set_intdefaultvalue(int32_t value);
  private:
  int32_t _internal_intdefaultvalue() const;
  void _internal_set_intdefaultvalue(int32_t value);
  public:

  // float floatDefaultValue = 51;
  bool has_floatdefaultvalue() const;
  private:
  bool _internal_has_floatdefaultvalue() const;
  public:
  void clear_floatdefaultvalue();
  float floatdefaultvalue() const;
  void set_floatdefaultvalue(float value);
  private:
  float _internal_floatdefaultvalue() const;
  void _internal_set_floatdefaultvalue(float value);
  public:

  // double doubleDefaultValue = 61;
  bool has_doubledefaultvalue() const;
  private:
  bool _internal_has_doubledefaultvalue() const;
  public:
  void clear_doubledefaultvalue();
  double doubledefaultvalue() const;
  void set_doubledefaultvalue(double value);
  private:
  double _internal_doubledefaultvalue() const;
  void _internal_set_doubledefaultvalue(double value);
  public:

  void clear_ShapeFlexibility();
  ShapeFlexibilityCase ShapeFlexibility_case() const;
  void clear_defaultOptionalValue();
  DefaultOptionalValueCase defaultOptionalValue_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.ArrayFeatureType)
 private:
  class _Internal;
  void set_has_enumeratedshapes();
  void set_has_shaperange();
  void set_has_intdefaultvalue();
  void set_has_floatdefaultvalue();
  void set_has_doubledefaultvalue();

  inline bool has_ShapeFlexibility() const;
  inline void clear_has_ShapeFlexibility();

  inline bool has_defaultOptionalValue() const;
  inline void clear_has_defaultOptionalValue();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > shape_;
  mutable std::atomic<int> _shape_cached_byte_size_;
  int datatype_;
  union ShapeFlexibilityUnion {
    constexpr ShapeFlexibilityUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* enumeratedshapes_;
    ::CoreML::Specification::ArrayFeatureType_ShapeRange* shaperange_;
  } ShapeFlexibility_;
  union DefaultOptionalValueUnion {
    constexpr DefaultOptionalValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int32_t intdefaultvalue_;
    float floatdefaultvalue_;
    double doubledefaultvalue_;
  } defaultOptionalValue_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[2];

  friend struct ::TableStruct_FeatureTypes_2eproto;
};
// -------------------------------------------------------------------

class DictionaryFeatureType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.DictionaryFeatureType) */ {
 public:
  inline DictionaryFeatureType() : DictionaryFeatureType(nullptr) {}
  ~DictionaryFeatureType() override;
  explicit constexpr DictionaryFeatureType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DictionaryFeatureType(const DictionaryFeatureType& from);
  DictionaryFeatureType(DictionaryFeatureType&& from) noexcept
    : DictionaryFeatureType() {
    *this = ::std::move(from);
  }

  inline DictionaryFeatureType& operator=(const DictionaryFeatureType& from) {
    CopyFrom(from);
    return *this;
  }
  inline DictionaryFeatureType& operator=(DictionaryFeatureType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DictionaryFeatureType& default_instance() {
    return *internal_default_instance();
  }
  enum KeyTypeCase {
    kInt64KeyType = 1,
    kStringKeyType = 2,
    KEYTYPE_NOT_SET = 0,
  };

  static inline const DictionaryFeatureType* internal_default_instance() {
    return reinterpret_cast<const DictionaryFeatureType*>(
               &_DictionaryFeatureType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DictionaryFeatureType& a, DictionaryFeatureType& b) {
    a.Swap(&b);
  }
  inline void Swap(DictionaryFeatureType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DictionaryFeatureType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DictionaryFeatureType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DictionaryFeatureType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DictionaryFeatureType& from);
  void MergeFrom(const DictionaryFeatureType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DictionaryFeatureType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.DictionaryFeatureType";
  }
  protected:
  explicit DictionaryFeatureType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInt64KeyTypeFieldNumber = 1,
    kStringKeyTypeFieldNumber = 2,
  };
  // .CoreML.Specification.Int64FeatureType int64KeyType = 1;
  bool has_int64keytype() const;
  private:
  bool _internal_has_int64keytype() const;
  public:
  void clear_int64keytype();
  const ::CoreML::Specification::Int64FeatureType& int64keytype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::Int64FeatureType* release_int64keytype();
  ::CoreML::Specification::Int64FeatureType* mutable_int64keytype();
  void set_allocated_int64keytype(::CoreML::Specification::Int64FeatureType* int64keytype);
  private:
  const ::CoreML::Specification::Int64FeatureType& _internal_int64keytype() const;
  ::CoreML::Specification::Int64FeatureType* _internal_mutable_int64keytype();
  public:
  void unsafe_arena_set_allocated_int64keytype(
      ::CoreML::Specification::Int64FeatureType* int64keytype);
  ::CoreML::Specification::Int64FeatureType* unsafe_arena_release_int64keytype();

  // .CoreML.Specification.StringFeatureType stringKeyType = 2;
  bool has_stringkeytype() const;
  private:
  bool _internal_has_stringkeytype() const;
  public:
  void clear_stringkeytype();
  const ::CoreML::Specification::StringFeatureType& stringkeytype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::StringFeatureType* release_stringkeytype();
  ::CoreML::Specification::StringFeatureType* mutable_stringkeytype();
  void set_allocated_stringkeytype(::CoreML::Specification::StringFeatureType* stringkeytype);
  private:
  const ::CoreML::Specification::StringFeatureType& _internal_stringkeytype() const;
  ::CoreML::Specification::StringFeatureType* _internal_mutable_stringkeytype();
  public:
  void unsafe_arena_set_allocated_stringkeytype(
      ::CoreML::Specification::StringFeatureType* stringkeytype);
  ::CoreML::Specification::StringFeatureType* unsafe_arena_release_stringkeytype();

  void clear_KeyType();
  KeyTypeCase KeyType_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.DictionaryFeatureType)
 private:
  class _Internal;
  void set_has_int64keytype();
  void set_has_stringkeytype();

  inline bool has_KeyType() const;
  inline void clear_has_KeyType();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union KeyTypeUnion {
    constexpr KeyTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CoreML::Specification::Int64FeatureType* int64keytype_;
    ::CoreML::Specification::StringFeatureType* stringkeytype_;
  } KeyType_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_FeatureTypes_2eproto;
};
// -------------------------------------------------------------------

class SequenceFeatureType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.SequenceFeatureType) */ {
 public:
  inline SequenceFeatureType() : SequenceFeatureType(nullptr) {}
  ~SequenceFeatureType() override;
  explicit constexpr SequenceFeatureType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SequenceFeatureType(const SequenceFeatureType& from);
  SequenceFeatureType(SequenceFeatureType&& from) noexcept
    : SequenceFeatureType() {
    *this = ::std::move(from);
  }

  inline SequenceFeatureType& operator=(const SequenceFeatureType& from) {
    CopyFrom(from);
    return *this;
  }
  inline SequenceFeatureType& operator=(SequenceFeatureType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SequenceFeatureType& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kInt64Type = 1,
    kStringType = 3,
    TYPE_NOT_SET = 0,
  };

  static inline const SequenceFeatureType* internal_default_instance() {
    return reinterpret_cast<const SequenceFeatureType*>(
               &_SequenceFeatureType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SequenceFeatureType& a, SequenceFeatureType& b) {
    a.Swap(&b);
  }
  inline void Swap(SequenceFeatureType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SequenceFeatureType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SequenceFeatureType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SequenceFeatureType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SequenceFeatureType& from);
  void MergeFrom(const SequenceFeatureType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SequenceFeatureType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.SequenceFeatureType";
  }
  protected:
  explicit SequenceFeatureType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeRangeFieldNumber = 101,
    kInt64TypeFieldNumber = 1,
    kStringTypeFieldNumber = 3,
  };
  // .CoreML.Specification.SizeRange sizeRange = 101;
  bool has_sizerange() const;
  private:
  bool _internal_has_sizerange() const;
  public:
  void clear_sizerange();
  const ::CoreML::Specification::SizeRange& sizerange() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::SizeRange* release_sizerange();
  ::CoreML::Specification::SizeRange* mutable_sizerange();
  void set_allocated_sizerange(::CoreML::Specification::SizeRange* sizerange);
  private:
  const ::CoreML::Specification::SizeRange& _internal_sizerange() const;
  ::CoreML::Specification::SizeRange* _internal_mutable_sizerange();
  public:
  void unsafe_arena_set_allocated_sizerange(
      ::CoreML::Specification::SizeRange* sizerange);
  ::CoreML::Specification::SizeRange* unsafe_arena_release_sizerange();

  // .CoreML.Specification.Int64FeatureType int64Type = 1;
  bool has_int64type() const;
  private:
  bool _internal_has_int64type() const;
  public:
  void clear_int64type();
  const ::CoreML::Specification::Int64FeatureType& int64type() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::Int64FeatureType* release_int64type();
  ::CoreML::Specification::Int64FeatureType* mutable_int64type();
  void set_allocated_int64type(::CoreML::Specification::Int64FeatureType* int64type);
  private:
  const ::CoreML::Specification::Int64FeatureType& _internal_int64type() const;
  ::CoreML::Specification::Int64FeatureType* _internal_mutable_int64type();
  public:
  void unsafe_arena_set_allocated_int64type(
      ::CoreML::Specification::Int64FeatureType* int64type);
  ::CoreML::Specification::Int64FeatureType* unsafe_arena_release_int64type();

  // .CoreML.Specification.StringFeatureType stringType = 3;
  bool has_stringtype() const;
  private:
  bool _internal_has_stringtype() const;
  public:
  void clear_stringtype();
  const ::CoreML::Specification::StringFeatureType& stringtype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::StringFeatureType* release_stringtype();
  ::CoreML::Specification::StringFeatureType* mutable_stringtype();
  void set_allocated_stringtype(::CoreML::Specification::StringFeatureType* stringtype);
  private:
  const ::CoreML::Specification::StringFeatureType& _internal_stringtype() const;
  ::CoreML::Specification::StringFeatureType* _internal_mutable_stringtype();
  public:
  void unsafe_arena_set_allocated_stringtype(
      ::CoreML::Specification::StringFeatureType* stringtype);
  ::CoreML::Specification::StringFeatureType* unsafe_arena_release_stringtype();

  void clear_Type();
  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.SequenceFeatureType)
 private:
  class _Internal;
  void set_has_int64type();
  void set_has_stringtype();

  inline bool has_Type() const;
  inline void clear_has_Type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::CoreML::Specification::SizeRange* sizerange_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CoreML::Specification::Int64FeatureType* int64type_;
    ::CoreML::Specification::StringFeatureType* stringtype_;
  } Type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_FeatureTypes_2eproto;
};
// -------------------------------------------------------------------

class StateFeatureType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.StateFeatureType) */ {
 public:
  inline StateFeatureType() : StateFeatureType(nullptr) {}
  ~StateFeatureType() override;
  explicit constexpr StateFeatureType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StateFeatureType(const StateFeatureType& from);
  StateFeatureType(StateFeatureType&& from) noexcept
    : StateFeatureType() {
    *this = ::std::move(from);
  }

  inline StateFeatureType& operator=(const StateFeatureType& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateFeatureType& operator=(StateFeatureType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const StateFeatureType& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kArrayType = 1,
    TYPE_NOT_SET = 0,
  };

  static inline const StateFeatureType* internal_default_instance() {
    return reinterpret_cast<const StateFeatureType*>(
               &_StateFeatureType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(StateFeatureType& a, StateFeatureType& b) {
    a.Swap(&b);
  }
  inline void Swap(StateFeatureType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateFeatureType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateFeatureType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateFeatureType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StateFeatureType& from);
  void MergeFrom(const StateFeatureType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StateFeatureType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.StateFeatureType";
  }
  protected:
  explicit StateFeatureType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArrayTypeFieldNumber = 1,
  };
  // .CoreML.Specification.ArrayFeatureType arrayType = 1;
  bool has_arraytype() const;
  private:
  bool _internal_has_arraytype() const;
  public:
  void clear_arraytype();
  const ::CoreML::Specification::ArrayFeatureType& arraytype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::ArrayFeatureType* release_arraytype();
  ::CoreML::Specification::ArrayFeatureType* mutable_arraytype();
  void set_allocated_arraytype(::CoreML::Specification::ArrayFeatureType* arraytype);
  private:
  const ::CoreML::Specification::ArrayFeatureType& _internal_arraytype() const;
  ::CoreML::Specification::ArrayFeatureType* _internal_mutable_arraytype();
  public:
  void unsafe_arena_set_allocated_arraytype(
      ::CoreML::Specification::ArrayFeatureType* arraytype);
  ::CoreML::Specification::ArrayFeatureType* unsafe_arena_release_arraytype();

  void clear_Type();
  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.StateFeatureType)
 private:
  class _Internal;
  void set_has_arraytype();

  inline bool has_Type() const;
  inline void clear_has_Type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CoreML::Specification::ArrayFeatureType* arraytype_;
  } Type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_FeatureTypes_2eproto;
};
// -------------------------------------------------------------------

class FeatureType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.FeatureType) */ {
 public:
  inline FeatureType() : FeatureType(nullptr) {}
  ~FeatureType() override;
  explicit constexpr FeatureType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeatureType(const FeatureType& from);
  FeatureType(FeatureType&& from) noexcept
    : FeatureType() {
    *this = ::std::move(from);
  }

  inline FeatureType& operator=(const FeatureType& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeatureType& operator=(FeatureType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const FeatureType& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kInt64Type = 1,
    kDoubleType = 2,
    kStringType = 3,
    kImageType = 4,
    kMultiArrayType = 5,
    kDictionaryType = 6,
    kSequenceType = 7,
    kStateType = 8,
    TYPE_NOT_SET = 0,
  };

  static inline const FeatureType* internal_default_instance() {
    return reinterpret_cast<const FeatureType*>(
               &_FeatureType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(FeatureType& a, FeatureType& b) {
    a.Swap(&b);
  }
  inline void Swap(FeatureType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeatureType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeatureType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeatureType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FeatureType& from);
  void MergeFrom(const FeatureType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FeatureType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CoreML.Specification.FeatureType";
  }
  protected:
  explicit FeatureType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsOptionalFieldNumber = 1000,
    kInt64TypeFieldNumber = 1,
    kDoubleTypeFieldNumber = 2,
    kStringTypeFieldNumber = 3,
    kImageTypeFieldNumber = 4,
    kMultiArrayTypeFieldNumber = 5,
    kDictionaryTypeFieldNumber = 6,
    kSequenceTypeFieldNumber = 7,
    kStateTypeFieldNumber = 8,
  };
  // bool isOptional = 1000;
  void clear_isoptional();
  bool isoptional() const;
  void set_isoptional(bool value);
  private:
  bool _internal_isoptional() const;
  void _internal_set_isoptional(bool value);
  public:

  // .CoreML.Specification.Int64FeatureType int64Type = 1;
  bool has_int64type() const;
  private:
  bool _internal_has_int64type() const;
  public:
  void clear_int64type();
  const ::CoreML::Specification::Int64FeatureType& int64type() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::Int64FeatureType* release_int64type();
  ::CoreML::Specification::Int64FeatureType* mutable_int64type();
  void set_allocated_int64type(::CoreML::Specification::Int64FeatureType* int64type);
  private:
  const ::CoreML::Specification::Int64FeatureType& _internal_int64type() const;
  ::CoreML::Specification::Int64FeatureType* _internal_mutable_int64type();
  public:
  void unsafe_arena_set_allocated_int64type(
      ::CoreML::Specification::Int64FeatureType* int64type);
  ::CoreML::Specification::Int64FeatureType* unsafe_arena_release_int64type();

  // .CoreML.Specification.DoubleFeatureType doubleType = 2;
  bool has_doubletype() const;
  private:
  bool _internal_has_doubletype() const;
  public:
  void clear_doubletype();
  const ::CoreML::Specification::DoubleFeatureType& doubletype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::DoubleFeatureType* release_doubletype();
  ::CoreML::Specification::DoubleFeatureType* mutable_doubletype();
  void set_allocated_doubletype(::CoreML::Specification::DoubleFeatureType* doubletype);
  private:
  const ::CoreML::Specification::DoubleFeatureType& _internal_doubletype() const;
  ::CoreML::Specification::DoubleFeatureType* _internal_mutable_doubletype();
  public:
  void unsafe_arena_set_allocated_doubletype(
      ::CoreML::Specification::DoubleFeatureType* doubletype);
  ::CoreML::Specification::DoubleFeatureType* unsafe_arena_release_doubletype();

  // .CoreML.Specification.StringFeatureType stringType = 3;
  bool has_stringtype() const;
  private:
  bool _internal_has_stringtype() const;
  public:
  void clear_stringtype();
  const ::CoreML::Specification::StringFeatureType& stringtype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::StringFeatureType* release_stringtype();
  ::CoreML::Specification::StringFeatureType* mutable_stringtype();
  void set_allocated_stringtype(::CoreML::Specification::StringFeatureType* stringtype);
  private:
  const ::CoreML::Specification::StringFeatureType& _internal_stringtype() const;
  ::CoreML::Specification::StringFeatureType* _internal_mutable_stringtype();
  public:
  void unsafe_arena_set_allocated_stringtype(
      ::CoreML::Specification::StringFeatureType* stringtype);
  ::CoreML::Specification::StringFeatureType* unsafe_arena_release_stringtype();

  // .CoreML.Specification.ImageFeatureType imageType = 4;
  bool has_imagetype() const;
  private:
  bool _internal_has_imagetype() const;
  public:
  void clear_imagetype();
  const ::CoreML::Specification::ImageFeatureType& imagetype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::ImageFeatureType* release_imagetype();
  ::CoreML::Specification::ImageFeatureType* mutable_imagetype();
  void set_allocated_imagetype(::CoreML::Specification::ImageFeatureType* imagetype);
  private:
  const ::CoreML::Specification::ImageFeatureType& _internal_imagetype() const;
  ::CoreML::Specification::ImageFeatureType* _internal_mutable_imagetype();
  public:
  void unsafe_arena_set_allocated_imagetype(
      ::CoreML::Specification::ImageFeatureType* imagetype);
  ::CoreML::Specification::ImageFeatureType* unsafe_arena_release_imagetype();

  // .CoreML.Specification.ArrayFeatureType multiArrayType = 5;
  bool has_multiarraytype() const;
  private:
  bool _internal_has_multiarraytype() const;
  public:
  void clear_multiarraytype();
  const ::CoreML::Specification::ArrayFeatureType& multiarraytype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::ArrayFeatureType* release_multiarraytype();
  ::CoreML::Specification::ArrayFeatureType* mutable_multiarraytype();
  void set_allocated_multiarraytype(::CoreML::Specification::ArrayFeatureType* multiarraytype);
  private:
  const ::CoreML::Specification::ArrayFeatureType& _internal_multiarraytype() const;
  ::CoreML::Specification::ArrayFeatureType* _internal_mutable_multiarraytype();
  public:
  void unsafe_arena_set_allocated_multiarraytype(
      ::CoreML::Specification::ArrayFeatureType* multiarraytype);
  ::CoreML::Specification::ArrayFeatureType* unsafe_arena_release_multiarraytype();

  // .CoreML.Specification.DictionaryFeatureType dictionaryType = 6;
  bool has_dictionarytype() const;
  private:
  bool _internal_has_dictionarytype() const;
  public:
  void clear_dictionarytype();
  const ::CoreML::Specification::DictionaryFeatureType& dictionarytype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::DictionaryFeatureType* release_dictionarytype();
  ::CoreML::Specification::DictionaryFeatureType* mutable_dictionarytype();
  void set_allocated_dictionarytype(::CoreML::Specification::DictionaryFeatureType* dictionarytype);
  private:
  const ::CoreML::Specification::DictionaryFeatureType& _internal_dictionarytype() const;
  ::CoreML::Specification::DictionaryFeatureType* _internal_mutable_dictionarytype();
  public:
  void unsafe_arena_set_allocated_dictionarytype(
      ::CoreML::Specification::DictionaryFeatureType* dictionarytype);
  ::CoreML::Specification::DictionaryFeatureType* unsafe_arena_release_dictionarytype();

  // .CoreML.Specification.SequenceFeatureType sequenceType = 7;
  bool has_sequencetype() const;
  private:
  bool _internal_has_sequencetype() const;
  public:
  void clear_sequencetype();
  const ::CoreML::Specification::SequenceFeatureType& sequencetype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::SequenceFeatureType* release_sequencetype();
  ::CoreML::Specification::SequenceFeatureType* mutable_sequencetype();
  void set_allocated_sequencetype(::CoreML::Specification::SequenceFeatureType* sequencetype);
  private:
  const ::CoreML::Specification::SequenceFeatureType& _internal_sequencetype() const;
  ::CoreML::Specification::SequenceFeatureType* _internal_mutable_sequencetype();
  public:
  void unsafe_arena_set_allocated_sequencetype(
      ::CoreML::Specification::SequenceFeatureType* sequencetype);
  ::CoreML::Specification::SequenceFeatureType* unsafe_arena_release_sequencetype();

  // .CoreML.Specification.StateFeatureType stateType = 8;
  bool has_statetype() const;
  private:
  bool _internal_has_statetype() const;
  public:
  void clear_statetype();
  const ::CoreML::Specification::StateFeatureType& statetype() const;
  PROTOBUF_NODISCARD ::CoreML::Specification::StateFeatureType* release_statetype();
  ::CoreML::Specification::StateFeatureType* mutable_statetype();
  void set_allocated_statetype(::CoreML::Specification::StateFeatureType* statetype);
  private:
  const ::CoreML::Specification::StateFeatureType& _internal_statetype() const;
  ::CoreML::Specification::StateFeatureType* _internal_mutable_statetype();
  public:
  void unsafe_arena_set_allocated_statetype(
      ::CoreML::Specification::StateFeatureType* statetype);
  ::CoreML::Specification::StateFeatureType* unsafe_arena_release_statetype();

  void clear_Type();
  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.FeatureType)
 private:
  class _Internal;
  void set_has_int64type();
  void set_has_doubletype();
  void set_has_stringtype();
  void set_has_imagetype();
  void set_has_multiarraytype();
  void set_has_dictionarytype();
  void set_has_sequencetype();
  void set_has_statetype();

  inline bool has_Type() const;
  inline void clear_has_Type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool isoptional_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CoreML::Specification::Int64FeatureType* int64type_;
    ::CoreML::Specification::DoubleFeatureType* doubletype_;
    ::CoreML::Specification::StringFeatureType* stringtype_;
    ::CoreML::Specification::ImageFeatureType* imagetype_;
    ::CoreML::Specification::ArrayFeatureType* multiarraytype_;
    ::CoreML::Specification::DictionaryFeatureType* dictionarytype_;
    ::CoreML::Specification::SequenceFeatureType* sequencetype_;
    ::CoreML::Specification::StateFeatureType* statetype_;
  } Type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_FeatureTypes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Int64FeatureType

// -------------------------------------------------------------------

// DoubleFeatureType

// -------------------------------------------------------------------

// StringFeatureType

// -------------------------------------------------------------------

// SizeRange

// uint64 lowerBound = 1;
inline void SizeRange::clear_lowerbound() {
  lowerbound_ = uint64_t{0u};
}
inline uint64_t SizeRange::_internal_lowerbound() const {
  return lowerbound_;
}
inline uint64_t SizeRange::lowerbound() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SizeRange.lowerBound)
  return _internal_lowerbound();
}
inline void SizeRange::_internal_set_lowerbound(uint64_t value) {
  
  lowerbound_ = value;
}
inline void SizeRange::set_lowerbound(uint64_t value) {
  _internal_set_lowerbound(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.SizeRange.lowerBound)
}

// int64 upperBound = 2;
inline void SizeRange::clear_upperbound() {
  upperbound_ = int64_t{0};
}
inline int64_t SizeRange::_internal_upperbound() const {
  return upperbound_;
}
inline int64_t SizeRange::upperbound() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SizeRange.upperBound)
  return _internal_upperbound();
}
inline void SizeRange::_internal_set_upperbound(int64_t value) {
  
  upperbound_ = value;
}
inline void SizeRange::set_upperbound(int64_t value) {
  _internal_set_upperbound(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.SizeRange.upperBound)
}

// -------------------------------------------------------------------

// ImageFeatureType_ImageSize

// uint64 width = 1;
inline void ImageFeatureType_ImageSize::clear_width() {
  width_ = uint64_t{0u};
}
inline uint64_t ImageFeatureType_ImageSize::_internal_width() const {
  return width_;
}
inline uint64_t ImageFeatureType_ImageSize::width() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.ImageSize.width)
  return _internal_width();
}
inline void ImageFeatureType_ImageSize::_internal_set_width(uint64_t value) {
  
  width_ = value;
}
inline void ImageFeatureType_ImageSize::set_width(uint64_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.ImageSize.width)
}

// uint64 height = 2;
inline void ImageFeatureType_ImageSize::clear_height() {
  height_ = uint64_t{0u};
}
inline uint64_t ImageFeatureType_ImageSize::_internal_height() const {
  return height_;
}
inline uint64_t ImageFeatureType_ImageSize::height() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.ImageSize.height)
  return _internal_height();
}
inline void ImageFeatureType_ImageSize::_internal_set_height(uint64_t value) {
  
  height_ = value;
}
inline void ImageFeatureType_ImageSize::set_height(uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.ImageSize.height)
}

// -------------------------------------------------------------------

// ImageFeatureType_EnumeratedImageSizes

// repeated .CoreML.Specification.ImageFeatureType.ImageSize sizes = 1;
inline int ImageFeatureType_EnumeratedImageSizes::_internal_sizes_size() const {
  return sizes_.size();
}
inline int ImageFeatureType_EnumeratedImageSizes::sizes_size() const {
  return _internal_sizes_size();
}
inline void ImageFeatureType_EnumeratedImageSizes::clear_sizes() {
  sizes_.Clear();
}
inline ::CoreML::Specification::ImageFeatureType_ImageSize* ImageFeatureType_EnumeratedImageSizes::mutable_sizes(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.sizes)
  return sizes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::ImageFeatureType_ImageSize >*
ImageFeatureType_EnumeratedImageSizes::mutable_sizes() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.sizes)
  return &sizes_;
}
inline const ::CoreML::Specification::ImageFeatureType_ImageSize& ImageFeatureType_EnumeratedImageSizes::_internal_sizes(int index) const {
  return sizes_.Get(index);
}
inline const ::CoreML::Specification::ImageFeatureType_ImageSize& ImageFeatureType_EnumeratedImageSizes::sizes(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.sizes)
  return _internal_sizes(index);
}
inline ::CoreML::Specification::ImageFeatureType_ImageSize* ImageFeatureType_EnumeratedImageSizes::_internal_add_sizes() {
  return sizes_.Add();
}
inline ::CoreML::Specification::ImageFeatureType_ImageSize* ImageFeatureType_EnumeratedImageSizes::add_sizes() {
  ::CoreML::Specification::ImageFeatureType_ImageSize* _add = _internal_add_sizes();
  // @@protoc_insertion_point(field_add:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.sizes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::ImageFeatureType_ImageSize >&
ImageFeatureType_EnumeratedImageSizes::sizes() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.sizes)
  return sizes_;
}

// -------------------------------------------------------------------

// ImageFeatureType_ImageSizeRange

// .CoreML.Specification.SizeRange widthRange = 1;
inline bool ImageFeatureType_ImageSizeRange::_internal_has_widthrange() const {
  return this != internal_default_instance() && widthrange_ != nullptr;
}
inline bool ImageFeatureType_ImageSizeRange::has_widthrange() const {
  return _internal_has_widthrange();
}
inline void ImageFeatureType_ImageSizeRange::clear_widthrange() {
  if (GetArenaForAllocation() == nullptr && widthrange_ != nullptr) {
    delete widthrange_;
  }
  widthrange_ = nullptr;
}
inline const ::CoreML::Specification::SizeRange& ImageFeatureType_ImageSizeRange::_internal_widthrange() const {
  const ::CoreML::Specification::SizeRange* p = widthrange_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::SizeRange&>(
      ::CoreML::Specification::_SizeRange_default_instance_);
}
inline const ::CoreML::Specification::SizeRange& ImageFeatureType_ImageSizeRange::widthrange() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.ImageSizeRange.widthRange)
  return _internal_widthrange();
}
inline void ImageFeatureType_ImageSizeRange::unsafe_arena_set_allocated_widthrange(
    ::CoreML::Specification::SizeRange* widthrange) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(widthrange_);
  }
  widthrange_ = widthrange;
  if (widthrange) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.ImageFeatureType.ImageSizeRange.widthRange)
}
inline ::CoreML::Specification::SizeRange* ImageFeatureType_ImageSizeRange::release_widthrange() {
  
  ::CoreML::Specification::SizeRange* temp = widthrange_;
  widthrange_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::SizeRange* ImageFeatureType_ImageSizeRange::unsafe_arena_release_widthrange() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ImageFeatureType.ImageSizeRange.widthRange)
  
  ::CoreML::Specification::SizeRange* temp = widthrange_;
  widthrange_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::SizeRange* ImageFeatureType_ImageSizeRange::_internal_mutable_widthrange() {
  
  if (widthrange_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::SizeRange>(GetArenaForAllocation());
    widthrange_ = p;
  }
  return widthrange_;
}
inline ::CoreML::Specification::SizeRange* ImageFeatureType_ImageSizeRange::mutable_widthrange() {
  ::CoreML::Specification::SizeRange* _msg = _internal_mutable_widthrange();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ImageFeatureType.ImageSizeRange.widthRange)
  return _msg;
}
inline void ImageFeatureType_ImageSizeRange::set_allocated_widthrange(::CoreML::Specification::SizeRange* widthrange) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete widthrange_;
  }
  if (widthrange) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SizeRange>::GetOwningArena(widthrange);
    if (message_arena != submessage_arena) {
      widthrange = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, widthrange, submessage_arena);
    }
    
  } else {
    
  }
  widthrange_ = widthrange;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ImageFeatureType.ImageSizeRange.widthRange)
}

// .CoreML.Specification.SizeRange heightRange = 2;
inline bool ImageFeatureType_ImageSizeRange::_internal_has_heightrange() const {
  return this != internal_default_instance() && heightrange_ != nullptr;
}
inline bool ImageFeatureType_ImageSizeRange::has_heightrange() const {
  return _internal_has_heightrange();
}
inline void ImageFeatureType_ImageSizeRange::clear_heightrange() {
  if (GetArenaForAllocation() == nullptr && heightrange_ != nullptr) {
    delete heightrange_;
  }
  heightrange_ = nullptr;
}
inline const ::CoreML::Specification::SizeRange& ImageFeatureType_ImageSizeRange::_internal_heightrange() const {
  const ::CoreML::Specification::SizeRange* p = heightrange_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::SizeRange&>(
      ::CoreML::Specification::_SizeRange_default_instance_);
}
inline const ::CoreML::Specification::SizeRange& ImageFeatureType_ImageSizeRange::heightrange() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.ImageSizeRange.heightRange)
  return _internal_heightrange();
}
inline void ImageFeatureType_ImageSizeRange::unsafe_arena_set_allocated_heightrange(
    ::CoreML::Specification::SizeRange* heightrange) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heightrange_);
  }
  heightrange_ = heightrange;
  if (heightrange) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.ImageFeatureType.ImageSizeRange.heightRange)
}
inline ::CoreML::Specification::SizeRange* ImageFeatureType_ImageSizeRange::release_heightrange() {
  
  ::CoreML::Specification::SizeRange* temp = heightrange_;
  heightrange_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::SizeRange* ImageFeatureType_ImageSizeRange::unsafe_arena_release_heightrange() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ImageFeatureType.ImageSizeRange.heightRange)
  
  ::CoreML::Specification::SizeRange* temp = heightrange_;
  heightrange_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::SizeRange* ImageFeatureType_ImageSizeRange::_internal_mutable_heightrange() {
  
  if (heightrange_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::SizeRange>(GetArenaForAllocation());
    heightrange_ = p;
  }
  return heightrange_;
}
inline ::CoreML::Specification::SizeRange* ImageFeatureType_ImageSizeRange::mutable_heightrange() {
  ::CoreML::Specification::SizeRange* _msg = _internal_mutable_heightrange();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ImageFeatureType.ImageSizeRange.heightRange)
  return _msg;
}
inline void ImageFeatureType_ImageSizeRange::set_allocated_heightrange(::CoreML::Specification::SizeRange* heightrange) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete heightrange_;
  }
  if (heightrange) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SizeRange>::GetOwningArena(heightrange);
    if (message_arena != submessage_arena) {
      heightrange = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heightrange, submessage_arena);
    }
    
  } else {
    
  }
  heightrange_ = heightrange;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ImageFeatureType.ImageSizeRange.heightRange)
}

// -------------------------------------------------------------------

// ImageFeatureType

// int64 width = 1;
inline void ImageFeatureType::clear_width() {
  width_ = int64_t{0};
}
inline int64_t ImageFeatureType::_internal_width() const {
  return width_;
}
inline int64_t ImageFeatureType::width() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.width)
  return _internal_width();
}
inline void ImageFeatureType::_internal_set_width(int64_t value) {
  
  width_ = value;
}
inline void ImageFeatureType::set_width(int64_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.width)
}

// int64 height = 2;
inline void ImageFeatureType::clear_height() {
  height_ = int64_t{0};
}
inline int64_t ImageFeatureType::_internal_height() const {
  return height_;
}
inline int64_t ImageFeatureType::height() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.height)
  return _internal_height();
}
inline void ImageFeatureType::_internal_set_height(int64_t value) {
  
  height_ = value;
}
inline void ImageFeatureType::set_height(int64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.height)
}

// .CoreML.Specification.ImageFeatureType.EnumeratedImageSizes enumeratedSizes = 21;
inline bool ImageFeatureType::_internal_has_enumeratedsizes() const {
  return SizeFlexibility_case() == kEnumeratedSizes;
}
inline bool ImageFeatureType::has_enumeratedsizes() const {
  return _internal_has_enumeratedsizes();
}
inline void ImageFeatureType::set_has_enumeratedsizes() {
  _oneof_case_[0] = kEnumeratedSizes;
}
inline void ImageFeatureType::clear_enumeratedsizes() {
  if (_internal_has_enumeratedsizes()) {
    if (GetArenaForAllocation() == nullptr) {
      delete SizeFlexibility_.enumeratedsizes_;
    }
    clear_has_SizeFlexibility();
  }
}
inline ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* ImageFeatureType::release_enumeratedsizes() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ImageFeatureType.enumeratedSizes)
  if (_internal_has_enumeratedsizes()) {
    clear_has_SizeFlexibility();
      ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* temp = SizeFlexibility_.enumeratedsizes_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    SizeFlexibility_.enumeratedsizes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes& ImageFeatureType::_internal_enumeratedsizes() const {
  return _internal_has_enumeratedsizes()
      ? *SizeFlexibility_.enumeratedsizes_
      : reinterpret_cast< ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes&>(::CoreML::Specification::_ImageFeatureType_EnumeratedImageSizes_default_instance_);
}
inline const ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes& ImageFeatureType::enumeratedsizes() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.enumeratedSizes)
  return _internal_enumeratedsizes();
}
inline ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* ImageFeatureType::unsafe_arena_release_enumeratedsizes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.ImageFeatureType.enumeratedSizes)
  if (_internal_has_enumeratedsizes()) {
    clear_has_SizeFlexibility();
    ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* temp = SizeFlexibility_.enumeratedsizes_;
    SizeFlexibility_.enumeratedsizes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ImageFeatureType::unsafe_arena_set_allocated_enumeratedsizes(::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* enumeratedsizes) {
  clear_SizeFlexibility();
  if (enumeratedsizes) {
    set_has_enumeratedsizes();
    SizeFlexibility_.enumeratedsizes_ = enumeratedsizes;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.ImageFeatureType.enumeratedSizes)
}
inline ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* ImageFeatureType::_internal_mutable_enumeratedsizes() {
  if (!_internal_has_enumeratedsizes()) {
    clear_SizeFlexibility();
    set_has_enumeratedsizes();
    SizeFlexibility_.enumeratedsizes_ = CreateMaybeMessage< ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes >(GetArenaForAllocation());
  }
  return SizeFlexibility_.enumeratedsizes_;
}
inline ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* ImageFeatureType::mutable_enumeratedsizes() {
  ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* _msg = _internal_mutable_enumeratedsizes();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ImageFeatureType.enumeratedSizes)
  return _msg;
}

// .CoreML.Specification.ImageFeatureType.ImageSizeRange imageSizeRange = 31;
inline bool ImageFeatureType::_internal_has_imagesizerange() const {
  return SizeFlexibility_case() == kImageSizeRange;
}
inline bool ImageFeatureType::has_imagesizerange() const {
  return _internal_has_imagesizerange();
}
inline void ImageFeatureType::set_has_imagesizerange() {
  _oneof_case_[0] = kImageSizeRange;
}
inline void ImageFeatureType::clear_imagesizerange() {
  if (_internal_has_imagesizerange()) {
    if (GetArenaForAllocation() == nullptr) {
      delete SizeFlexibility_.imagesizerange_;
    }
    clear_has_SizeFlexibility();
  }
}
inline ::CoreML::Specification::ImageFeatureType_ImageSizeRange* ImageFeatureType::release_imagesizerange() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ImageFeatureType.imageSizeRange)
  if (_internal_has_imagesizerange()) {
    clear_has_SizeFlexibility();
      ::CoreML::Specification::ImageFeatureType_ImageSizeRange* temp = SizeFlexibility_.imagesizerange_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    SizeFlexibility_.imagesizerange_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::ImageFeatureType_ImageSizeRange& ImageFeatureType::_internal_imagesizerange() const {
  return _internal_has_imagesizerange()
      ? *SizeFlexibility_.imagesizerange_
      : reinterpret_cast< ::CoreML::Specification::ImageFeatureType_ImageSizeRange&>(::CoreML::Specification::_ImageFeatureType_ImageSizeRange_default_instance_);
}
inline const ::CoreML::Specification::ImageFeatureType_ImageSizeRange& ImageFeatureType::imagesizerange() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.imageSizeRange)
  return _internal_imagesizerange();
}
inline ::CoreML::Specification::ImageFeatureType_ImageSizeRange* ImageFeatureType::unsafe_arena_release_imagesizerange() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.ImageFeatureType.imageSizeRange)
  if (_internal_has_imagesizerange()) {
    clear_has_SizeFlexibility();
    ::CoreML::Specification::ImageFeatureType_ImageSizeRange* temp = SizeFlexibility_.imagesizerange_;
    SizeFlexibility_.imagesizerange_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ImageFeatureType::unsafe_arena_set_allocated_imagesizerange(::CoreML::Specification::ImageFeatureType_ImageSizeRange* imagesizerange) {
  clear_SizeFlexibility();
  if (imagesizerange) {
    set_has_imagesizerange();
    SizeFlexibility_.imagesizerange_ = imagesizerange;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.ImageFeatureType.imageSizeRange)
}
inline ::CoreML::Specification::ImageFeatureType_ImageSizeRange* ImageFeatureType::_internal_mutable_imagesizerange() {
  if (!_internal_has_imagesizerange()) {
    clear_SizeFlexibility();
    set_has_imagesizerange();
    SizeFlexibility_.imagesizerange_ = CreateMaybeMessage< ::CoreML::Specification::ImageFeatureType_ImageSizeRange >(GetArenaForAllocation());
  }
  return SizeFlexibility_.imagesizerange_;
}
inline ::CoreML::Specification::ImageFeatureType_ImageSizeRange* ImageFeatureType::mutable_imagesizerange() {
  ::CoreML::Specification::ImageFeatureType_ImageSizeRange* _msg = _internal_mutable_imagesizerange();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ImageFeatureType.imageSizeRange)
  return _msg;
}

// .CoreML.Specification.ImageFeatureType.ColorSpace colorSpace = 3;
inline void ImageFeatureType::clear_colorspace() {
  colorspace_ = 0;
}
inline ::CoreML::Specification::ImageFeatureType_ColorSpace ImageFeatureType::_internal_colorspace() const {
  return static_cast< ::CoreML::Specification::ImageFeatureType_ColorSpace >(colorspace_);
}
inline ::CoreML::Specification::ImageFeatureType_ColorSpace ImageFeatureType::colorspace() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.colorSpace)
  return _internal_colorspace();
}
inline void ImageFeatureType::_internal_set_colorspace(::CoreML::Specification::ImageFeatureType_ColorSpace value) {
  
  colorspace_ = value;
}
inline void ImageFeatureType::set_colorspace(::CoreML::Specification::ImageFeatureType_ColorSpace value) {
  _internal_set_colorspace(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.colorSpace)
}

inline bool ImageFeatureType::has_SizeFlexibility() const {
  return SizeFlexibility_case() != SIZEFLEXIBILITY_NOT_SET;
}
inline void ImageFeatureType::clear_has_SizeFlexibility() {
  _oneof_case_[0] = SIZEFLEXIBILITY_NOT_SET;
}
inline ImageFeatureType::SizeFlexibilityCase ImageFeatureType::SizeFlexibility_case() const {
  return ImageFeatureType::SizeFlexibilityCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ArrayFeatureType_Shape

// repeated int64 shape = 1;
inline int ArrayFeatureType_Shape::_internal_shape_size() const {
  return shape_.size();
}
inline int ArrayFeatureType_Shape::shape_size() const {
  return _internal_shape_size();
}
inline void ArrayFeatureType_Shape::clear_shape() {
  shape_.Clear();
}
inline int64_t ArrayFeatureType_Shape::_internal_shape(int index) const {
  return shape_.Get(index);
}
inline int64_t ArrayFeatureType_Shape::shape(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.Shape.shape)
  return _internal_shape(index);
}
inline void ArrayFeatureType_Shape::set_shape(int index, int64_t value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ArrayFeatureType.Shape.shape)
}
inline void ArrayFeatureType_Shape::_internal_add_shape(int64_t value) {
  shape_.Add(value);
}
inline void ArrayFeatureType_Shape::add_shape(int64_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.ArrayFeatureType.Shape.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ArrayFeatureType_Shape::_internal_shape() const {
  return shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ArrayFeatureType_Shape::shape() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ArrayFeatureType.Shape.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ArrayFeatureType_Shape::_internal_mutable_shape() {
  return &shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ArrayFeatureType_Shape::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ArrayFeatureType.Shape.shape)
  return _internal_mutable_shape();
}

// -------------------------------------------------------------------

// ArrayFeatureType_EnumeratedShapes

// repeated .CoreML.Specification.ArrayFeatureType.Shape shapes = 1;
inline int ArrayFeatureType_EnumeratedShapes::_internal_shapes_size() const {
  return shapes_.size();
}
inline int ArrayFeatureType_EnumeratedShapes::shapes_size() const {
  return _internal_shapes_size();
}
inline void ArrayFeatureType_EnumeratedShapes::clear_shapes() {
  shapes_.Clear();
}
inline ::CoreML::Specification::ArrayFeatureType_Shape* ArrayFeatureType_EnumeratedShapes::mutable_shapes(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ArrayFeatureType.EnumeratedShapes.shapes)
  return shapes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::ArrayFeatureType_Shape >*
ArrayFeatureType_EnumeratedShapes::mutable_shapes() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ArrayFeatureType.EnumeratedShapes.shapes)
  return &shapes_;
}
inline const ::CoreML::Specification::ArrayFeatureType_Shape& ArrayFeatureType_EnumeratedShapes::_internal_shapes(int index) const {
  return shapes_.Get(index);
}
inline const ::CoreML::Specification::ArrayFeatureType_Shape& ArrayFeatureType_EnumeratedShapes::shapes(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.EnumeratedShapes.shapes)
  return _internal_shapes(index);
}
inline ::CoreML::Specification::ArrayFeatureType_Shape* ArrayFeatureType_EnumeratedShapes::_internal_add_shapes() {
  return shapes_.Add();
}
inline ::CoreML::Specification::ArrayFeatureType_Shape* ArrayFeatureType_EnumeratedShapes::add_shapes() {
  ::CoreML::Specification::ArrayFeatureType_Shape* _add = _internal_add_shapes();
  // @@protoc_insertion_point(field_add:CoreML.Specification.ArrayFeatureType.EnumeratedShapes.shapes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::ArrayFeatureType_Shape >&
ArrayFeatureType_EnumeratedShapes::shapes() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ArrayFeatureType.EnumeratedShapes.shapes)
  return shapes_;
}

// -------------------------------------------------------------------

// ArrayFeatureType_ShapeRange

// repeated .CoreML.Specification.SizeRange sizeRanges = 1;
inline int ArrayFeatureType_ShapeRange::_internal_sizeranges_size() const {
  return sizeranges_.size();
}
inline int ArrayFeatureType_ShapeRange::sizeranges_size() const {
  return _internal_sizeranges_size();
}
inline void ArrayFeatureType_ShapeRange::clear_sizeranges() {
  sizeranges_.Clear();
}
inline ::CoreML::Specification::SizeRange* ArrayFeatureType_ShapeRange::mutable_sizeranges(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ArrayFeatureType.ShapeRange.sizeRanges)
  return sizeranges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::SizeRange >*
ArrayFeatureType_ShapeRange::mutable_sizeranges() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ArrayFeatureType.ShapeRange.sizeRanges)
  return &sizeranges_;
}
inline const ::CoreML::Specification::SizeRange& ArrayFeatureType_ShapeRange::_internal_sizeranges(int index) const {
  return sizeranges_.Get(index);
}
inline const ::CoreML::Specification::SizeRange& ArrayFeatureType_ShapeRange::sizeranges(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.ShapeRange.sizeRanges)
  return _internal_sizeranges(index);
}
inline ::CoreML::Specification::SizeRange* ArrayFeatureType_ShapeRange::_internal_add_sizeranges() {
  return sizeranges_.Add();
}
inline ::CoreML::Specification::SizeRange* ArrayFeatureType_ShapeRange::add_sizeranges() {
  ::CoreML::Specification::SizeRange* _add = _internal_add_sizeranges();
  // @@protoc_insertion_point(field_add:CoreML.Specification.ArrayFeatureType.ShapeRange.sizeRanges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CoreML::Specification::SizeRange >&
ArrayFeatureType_ShapeRange::sizeranges() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ArrayFeatureType.ShapeRange.sizeRanges)
  return sizeranges_;
}

// -------------------------------------------------------------------

// ArrayFeatureType

// repeated int64 shape = 1;
inline int ArrayFeatureType::_internal_shape_size() const {
  return shape_.size();
}
inline int ArrayFeatureType::shape_size() const {
  return _internal_shape_size();
}
inline void ArrayFeatureType::clear_shape() {
  shape_.Clear();
}
inline int64_t ArrayFeatureType::_internal_shape(int index) const {
  return shape_.Get(index);
}
inline int64_t ArrayFeatureType::shape(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.shape)
  return _internal_shape(index);
}
inline void ArrayFeatureType::set_shape(int index, int64_t value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ArrayFeatureType.shape)
}
inline void ArrayFeatureType::_internal_add_shape(int64_t value) {
  shape_.Add(value);
}
inline void ArrayFeatureType::add_shape(int64_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.ArrayFeatureType.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ArrayFeatureType::_internal_shape() const {
  return shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ArrayFeatureType::shape() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ArrayFeatureType.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ArrayFeatureType::_internal_mutable_shape() {
  return &shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ArrayFeatureType::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ArrayFeatureType.shape)
  return _internal_mutable_shape();
}

// .CoreML.Specification.ArrayFeatureType.ArrayDataType dataType = 2;
inline void ArrayFeatureType::clear_datatype() {
  datatype_ = 0;
}
inline ::CoreML::Specification::ArrayFeatureType_ArrayDataType ArrayFeatureType::_internal_datatype() const {
  return static_cast< ::CoreML::Specification::ArrayFeatureType_ArrayDataType >(datatype_);
}
inline ::CoreML::Specification::ArrayFeatureType_ArrayDataType ArrayFeatureType::datatype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.dataType)
  return _internal_datatype();
}
inline void ArrayFeatureType::_internal_set_datatype(::CoreML::Specification::ArrayFeatureType_ArrayDataType value) {
  
  datatype_ = value;
}
inline void ArrayFeatureType::set_datatype(::CoreML::Specification::ArrayFeatureType_ArrayDataType value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ArrayFeatureType.dataType)
}

// .CoreML.Specification.ArrayFeatureType.EnumeratedShapes enumeratedShapes = 21;
inline bool ArrayFeatureType::_internal_has_enumeratedshapes() const {
  return ShapeFlexibility_case() == kEnumeratedShapes;
}
inline bool ArrayFeatureType::has_enumeratedshapes() const {
  return _internal_has_enumeratedshapes();
}
inline void ArrayFeatureType::set_has_enumeratedshapes() {
  _oneof_case_[0] = kEnumeratedShapes;
}
inline void ArrayFeatureType::clear_enumeratedshapes() {
  if (_internal_has_enumeratedshapes()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ShapeFlexibility_.enumeratedshapes_;
    }
    clear_has_ShapeFlexibility();
  }
}
inline ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* ArrayFeatureType::release_enumeratedshapes() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ArrayFeatureType.enumeratedShapes)
  if (_internal_has_enumeratedshapes()) {
    clear_has_ShapeFlexibility();
      ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* temp = ShapeFlexibility_.enumeratedshapes_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ShapeFlexibility_.enumeratedshapes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes& ArrayFeatureType::_internal_enumeratedshapes() const {
  return _internal_has_enumeratedshapes()
      ? *ShapeFlexibility_.enumeratedshapes_
      : reinterpret_cast< ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes&>(::CoreML::Specification::_ArrayFeatureType_EnumeratedShapes_default_instance_);
}
inline const ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes& ArrayFeatureType::enumeratedshapes() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.enumeratedShapes)
  return _internal_enumeratedshapes();
}
inline ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* ArrayFeatureType::unsafe_arena_release_enumeratedshapes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.ArrayFeatureType.enumeratedShapes)
  if (_internal_has_enumeratedshapes()) {
    clear_has_ShapeFlexibility();
    ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* temp = ShapeFlexibility_.enumeratedshapes_;
    ShapeFlexibility_.enumeratedshapes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArrayFeatureType::unsafe_arena_set_allocated_enumeratedshapes(::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* enumeratedshapes) {
  clear_ShapeFlexibility();
  if (enumeratedshapes) {
    set_has_enumeratedshapes();
    ShapeFlexibility_.enumeratedshapes_ = enumeratedshapes;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.ArrayFeatureType.enumeratedShapes)
}
inline ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* ArrayFeatureType::_internal_mutable_enumeratedshapes() {
  if (!_internal_has_enumeratedshapes()) {
    clear_ShapeFlexibility();
    set_has_enumeratedshapes();
    ShapeFlexibility_.enumeratedshapes_ = CreateMaybeMessage< ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes >(GetArenaForAllocation());
  }
  return ShapeFlexibility_.enumeratedshapes_;
}
inline ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* ArrayFeatureType::mutable_enumeratedshapes() {
  ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* _msg = _internal_mutable_enumeratedshapes();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ArrayFeatureType.enumeratedShapes)
  return _msg;
}

// .CoreML.Specification.ArrayFeatureType.ShapeRange shapeRange = 31;
inline bool ArrayFeatureType::_internal_has_shaperange() const {
  return ShapeFlexibility_case() == kShapeRange;
}
inline bool ArrayFeatureType::has_shaperange() const {
  return _internal_has_shaperange();
}
inline void ArrayFeatureType::set_has_shaperange() {
  _oneof_case_[0] = kShapeRange;
}
inline void ArrayFeatureType::clear_shaperange() {
  if (_internal_has_shaperange()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ShapeFlexibility_.shaperange_;
    }
    clear_has_ShapeFlexibility();
  }
}
inline ::CoreML::Specification::ArrayFeatureType_ShapeRange* ArrayFeatureType::release_shaperange() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ArrayFeatureType.shapeRange)
  if (_internal_has_shaperange()) {
    clear_has_ShapeFlexibility();
      ::CoreML::Specification::ArrayFeatureType_ShapeRange* temp = ShapeFlexibility_.shaperange_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ShapeFlexibility_.shaperange_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::ArrayFeatureType_ShapeRange& ArrayFeatureType::_internal_shaperange() const {
  return _internal_has_shaperange()
      ? *ShapeFlexibility_.shaperange_
      : reinterpret_cast< ::CoreML::Specification::ArrayFeatureType_ShapeRange&>(::CoreML::Specification::_ArrayFeatureType_ShapeRange_default_instance_);
}
inline const ::CoreML::Specification::ArrayFeatureType_ShapeRange& ArrayFeatureType::shaperange() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.shapeRange)
  return _internal_shaperange();
}
inline ::CoreML::Specification::ArrayFeatureType_ShapeRange* ArrayFeatureType::unsafe_arena_release_shaperange() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.ArrayFeatureType.shapeRange)
  if (_internal_has_shaperange()) {
    clear_has_ShapeFlexibility();
    ::CoreML::Specification::ArrayFeatureType_ShapeRange* temp = ShapeFlexibility_.shaperange_;
    ShapeFlexibility_.shaperange_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArrayFeatureType::unsafe_arena_set_allocated_shaperange(::CoreML::Specification::ArrayFeatureType_ShapeRange* shaperange) {
  clear_ShapeFlexibility();
  if (shaperange) {
    set_has_shaperange();
    ShapeFlexibility_.shaperange_ = shaperange;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.ArrayFeatureType.shapeRange)
}
inline ::CoreML::Specification::ArrayFeatureType_ShapeRange* ArrayFeatureType::_internal_mutable_shaperange() {
  if (!_internal_has_shaperange()) {
    clear_ShapeFlexibility();
    set_has_shaperange();
    ShapeFlexibility_.shaperange_ = CreateMaybeMessage< ::CoreML::Specification::ArrayFeatureType_ShapeRange >(GetArenaForAllocation());
  }
  return ShapeFlexibility_.shaperange_;
}
inline ::CoreML::Specification::ArrayFeatureType_ShapeRange* ArrayFeatureType::mutable_shaperange() {
  ::CoreML::Specification::ArrayFeatureType_ShapeRange* _msg = _internal_mutable_shaperange();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ArrayFeatureType.shapeRange)
  return _msg;
}

// int32 intDefaultValue = 41;
inline bool ArrayFeatureType::_internal_has_intdefaultvalue() const {
  return defaultOptionalValue_case() == kIntDefaultValue;
}
inline bool ArrayFeatureType::has_intdefaultvalue() const {
  return _internal_has_intdefaultvalue();
}
inline void ArrayFeatureType::set_has_intdefaultvalue() {
  _oneof_case_[1] = kIntDefaultValue;
}
inline void ArrayFeatureType::clear_intdefaultvalue() {
  if (_internal_has_intdefaultvalue()) {
    defaultOptionalValue_.intdefaultvalue_ = 0;
    clear_has_defaultOptionalValue();
  }
}
inline int32_t ArrayFeatureType::_internal_intdefaultvalue() const {
  if (_internal_has_intdefaultvalue()) {
    return defaultOptionalValue_.intdefaultvalue_;
  }
  return 0;
}
inline void ArrayFeatureType::_internal_set_intdefaultvalue(int32_t value) {
  if (!_internal_has_intdefaultvalue()) {
    clear_defaultOptionalValue();
    set_has_intdefaultvalue();
  }
  defaultOptionalValue_.intdefaultvalue_ = value;
}
inline int32_t ArrayFeatureType::intdefaultvalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.intDefaultValue)
  return _internal_intdefaultvalue();
}
inline void ArrayFeatureType::set_intdefaultvalue(int32_t value) {
  _internal_set_intdefaultvalue(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ArrayFeatureType.intDefaultValue)
}

// float floatDefaultValue = 51;
inline bool ArrayFeatureType::_internal_has_floatdefaultvalue() const {
  return defaultOptionalValue_case() == kFloatDefaultValue;
}
inline bool ArrayFeatureType::has_floatdefaultvalue() const {
  return _internal_has_floatdefaultvalue();
}
inline void ArrayFeatureType::set_has_floatdefaultvalue() {
  _oneof_case_[1] = kFloatDefaultValue;
}
inline void ArrayFeatureType::clear_floatdefaultvalue() {
  if (_internal_has_floatdefaultvalue()) {
    defaultOptionalValue_.floatdefaultvalue_ = 0;
    clear_has_defaultOptionalValue();
  }
}
inline float ArrayFeatureType::_internal_floatdefaultvalue() const {
  if (_internal_has_floatdefaultvalue()) {
    return defaultOptionalValue_.floatdefaultvalue_;
  }
  return 0;
}
inline void ArrayFeatureType::_internal_set_floatdefaultvalue(float value) {
  if (!_internal_has_floatdefaultvalue()) {
    clear_defaultOptionalValue();
    set_has_floatdefaultvalue();
  }
  defaultOptionalValue_.floatdefaultvalue_ = value;
}
inline float ArrayFeatureType::floatdefaultvalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.floatDefaultValue)
  return _internal_floatdefaultvalue();
}
inline void ArrayFeatureType::set_floatdefaultvalue(float value) {
  _internal_set_floatdefaultvalue(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ArrayFeatureType.floatDefaultValue)
}

// double doubleDefaultValue = 61;
inline bool ArrayFeatureType::_internal_has_doubledefaultvalue() const {
  return defaultOptionalValue_case() == kDoubleDefaultValue;
}
inline bool ArrayFeatureType::has_doubledefaultvalue() const {
  return _internal_has_doubledefaultvalue();
}
inline void ArrayFeatureType::set_has_doubledefaultvalue() {
  _oneof_case_[1] = kDoubleDefaultValue;
}
inline void ArrayFeatureType::clear_doubledefaultvalue() {
  if (_internal_has_doubledefaultvalue()) {
    defaultOptionalValue_.doubledefaultvalue_ = 0;
    clear_has_defaultOptionalValue();
  }
}
inline double ArrayFeatureType::_internal_doubledefaultvalue() const {
  if (_internal_has_doubledefaultvalue()) {
    return defaultOptionalValue_.doubledefaultvalue_;
  }
  return 0;
}
inline void ArrayFeatureType::_internal_set_doubledefaultvalue(double value) {
  if (!_internal_has_doubledefaultvalue()) {
    clear_defaultOptionalValue();
    set_has_doubledefaultvalue();
  }
  defaultOptionalValue_.doubledefaultvalue_ = value;
}
inline double ArrayFeatureType::doubledefaultvalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.doubleDefaultValue)
  return _internal_doubledefaultvalue();
}
inline void ArrayFeatureType::set_doubledefaultvalue(double value) {
  _internal_set_doubledefaultvalue(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ArrayFeatureType.doubleDefaultValue)
}

inline bool ArrayFeatureType::has_ShapeFlexibility() const {
  return ShapeFlexibility_case() != SHAPEFLEXIBILITY_NOT_SET;
}
inline void ArrayFeatureType::clear_has_ShapeFlexibility() {
  _oneof_case_[0] = SHAPEFLEXIBILITY_NOT_SET;
}
inline bool ArrayFeatureType::has_defaultOptionalValue() const {
  return defaultOptionalValue_case() != DEFAULTOPTIONALVALUE_NOT_SET;
}
inline void ArrayFeatureType::clear_has_defaultOptionalValue() {
  _oneof_case_[1] = DEFAULTOPTIONALVALUE_NOT_SET;
}
inline ArrayFeatureType::ShapeFlexibilityCase ArrayFeatureType::ShapeFlexibility_case() const {
  return ArrayFeatureType::ShapeFlexibilityCase(_oneof_case_[0]);
}
inline ArrayFeatureType::DefaultOptionalValueCase ArrayFeatureType::defaultOptionalValue_case() const {
  return ArrayFeatureType::DefaultOptionalValueCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// DictionaryFeatureType

// .CoreML.Specification.Int64FeatureType int64KeyType = 1;
inline bool DictionaryFeatureType::_internal_has_int64keytype() const {
  return KeyType_case() == kInt64KeyType;
}
inline bool DictionaryFeatureType::has_int64keytype() const {
  return _internal_has_int64keytype();
}
inline void DictionaryFeatureType::set_has_int64keytype() {
  _oneof_case_[0] = kInt64KeyType;
}
inline void DictionaryFeatureType::clear_int64keytype() {
  if (_internal_has_int64keytype()) {
    if (GetArenaForAllocation() == nullptr) {
      delete KeyType_.int64keytype_;
    }
    clear_has_KeyType();
  }
}
inline ::CoreML::Specification::Int64FeatureType* DictionaryFeatureType::release_int64keytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.DictionaryFeatureType.int64KeyType)
  if (_internal_has_int64keytype()) {
    clear_has_KeyType();
      ::CoreML::Specification::Int64FeatureType* temp = KeyType_.int64keytype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    KeyType_.int64keytype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::Int64FeatureType& DictionaryFeatureType::_internal_int64keytype() const {
  return _internal_has_int64keytype()
      ? *KeyType_.int64keytype_
      : reinterpret_cast< ::CoreML::Specification::Int64FeatureType&>(::CoreML::Specification::_Int64FeatureType_default_instance_);
}
inline const ::CoreML::Specification::Int64FeatureType& DictionaryFeatureType::int64keytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DictionaryFeatureType.int64KeyType)
  return _internal_int64keytype();
}
inline ::CoreML::Specification::Int64FeatureType* DictionaryFeatureType::unsafe_arena_release_int64keytype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.DictionaryFeatureType.int64KeyType)
  if (_internal_has_int64keytype()) {
    clear_has_KeyType();
    ::CoreML::Specification::Int64FeatureType* temp = KeyType_.int64keytype_;
    KeyType_.int64keytype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DictionaryFeatureType::unsafe_arena_set_allocated_int64keytype(::CoreML::Specification::Int64FeatureType* int64keytype) {
  clear_KeyType();
  if (int64keytype) {
    set_has_int64keytype();
    KeyType_.int64keytype_ = int64keytype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.DictionaryFeatureType.int64KeyType)
}
inline ::CoreML::Specification::Int64FeatureType* DictionaryFeatureType::_internal_mutable_int64keytype() {
  if (!_internal_has_int64keytype()) {
    clear_KeyType();
    set_has_int64keytype();
    KeyType_.int64keytype_ = CreateMaybeMessage< ::CoreML::Specification::Int64FeatureType >(GetArenaForAllocation());
  }
  return KeyType_.int64keytype_;
}
inline ::CoreML::Specification::Int64FeatureType* DictionaryFeatureType::mutable_int64keytype() {
  ::CoreML::Specification::Int64FeatureType* _msg = _internal_mutable_int64keytype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.DictionaryFeatureType.int64KeyType)
  return _msg;
}

// .CoreML.Specification.StringFeatureType stringKeyType = 2;
inline bool DictionaryFeatureType::_internal_has_stringkeytype() const {
  return KeyType_case() == kStringKeyType;
}
inline bool DictionaryFeatureType::has_stringkeytype() const {
  return _internal_has_stringkeytype();
}
inline void DictionaryFeatureType::set_has_stringkeytype() {
  _oneof_case_[0] = kStringKeyType;
}
inline void DictionaryFeatureType::clear_stringkeytype() {
  if (_internal_has_stringkeytype()) {
    if (GetArenaForAllocation() == nullptr) {
      delete KeyType_.stringkeytype_;
    }
    clear_has_KeyType();
  }
}
inline ::CoreML::Specification::StringFeatureType* DictionaryFeatureType::release_stringkeytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.DictionaryFeatureType.stringKeyType)
  if (_internal_has_stringkeytype()) {
    clear_has_KeyType();
      ::CoreML::Specification::StringFeatureType* temp = KeyType_.stringkeytype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    KeyType_.stringkeytype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::StringFeatureType& DictionaryFeatureType::_internal_stringkeytype() const {
  return _internal_has_stringkeytype()
      ? *KeyType_.stringkeytype_
      : reinterpret_cast< ::CoreML::Specification::StringFeatureType&>(::CoreML::Specification::_StringFeatureType_default_instance_);
}
inline const ::CoreML::Specification::StringFeatureType& DictionaryFeatureType::stringkeytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DictionaryFeatureType.stringKeyType)
  return _internal_stringkeytype();
}
inline ::CoreML::Specification::StringFeatureType* DictionaryFeatureType::unsafe_arena_release_stringkeytype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.DictionaryFeatureType.stringKeyType)
  if (_internal_has_stringkeytype()) {
    clear_has_KeyType();
    ::CoreML::Specification::StringFeatureType* temp = KeyType_.stringkeytype_;
    KeyType_.stringkeytype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DictionaryFeatureType::unsafe_arena_set_allocated_stringkeytype(::CoreML::Specification::StringFeatureType* stringkeytype) {
  clear_KeyType();
  if (stringkeytype) {
    set_has_stringkeytype();
    KeyType_.stringkeytype_ = stringkeytype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.DictionaryFeatureType.stringKeyType)
}
inline ::CoreML::Specification::StringFeatureType* DictionaryFeatureType::_internal_mutable_stringkeytype() {
  if (!_internal_has_stringkeytype()) {
    clear_KeyType();
    set_has_stringkeytype();
    KeyType_.stringkeytype_ = CreateMaybeMessage< ::CoreML::Specification::StringFeatureType >(GetArenaForAllocation());
  }
  return KeyType_.stringkeytype_;
}
inline ::CoreML::Specification::StringFeatureType* DictionaryFeatureType::mutable_stringkeytype() {
  ::CoreML::Specification::StringFeatureType* _msg = _internal_mutable_stringkeytype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.DictionaryFeatureType.stringKeyType)
  return _msg;
}

inline bool DictionaryFeatureType::has_KeyType() const {
  return KeyType_case() != KEYTYPE_NOT_SET;
}
inline void DictionaryFeatureType::clear_has_KeyType() {
  _oneof_case_[0] = KEYTYPE_NOT_SET;
}
inline DictionaryFeatureType::KeyTypeCase DictionaryFeatureType::KeyType_case() const {
  return DictionaryFeatureType::KeyTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SequenceFeatureType

// .CoreML.Specification.Int64FeatureType int64Type = 1;
inline bool SequenceFeatureType::_internal_has_int64type() const {
  return Type_case() == kInt64Type;
}
inline bool SequenceFeatureType::has_int64type() const {
  return _internal_has_int64type();
}
inline void SequenceFeatureType::set_has_int64type() {
  _oneof_case_[0] = kInt64Type;
}
inline void SequenceFeatureType::clear_int64type() {
  if (_internal_has_int64type()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.int64type_;
    }
    clear_has_Type();
  }
}
inline ::CoreML::Specification::Int64FeatureType* SequenceFeatureType::release_int64type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SequenceFeatureType.int64Type)
  if (_internal_has_int64type()) {
    clear_has_Type();
      ::CoreML::Specification::Int64FeatureType* temp = Type_.int64type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.int64type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::Int64FeatureType& SequenceFeatureType::_internal_int64type() const {
  return _internal_has_int64type()
      ? *Type_.int64type_
      : reinterpret_cast< ::CoreML::Specification::Int64FeatureType&>(::CoreML::Specification::_Int64FeatureType_default_instance_);
}
inline const ::CoreML::Specification::Int64FeatureType& SequenceFeatureType::int64type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SequenceFeatureType.int64Type)
  return _internal_int64type();
}
inline ::CoreML::Specification::Int64FeatureType* SequenceFeatureType::unsafe_arena_release_int64type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.SequenceFeatureType.int64Type)
  if (_internal_has_int64type()) {
    clear_has_Type();
    ::CoreML::Specification::Int64FeatureType* temp = Type_.int64type_;
    Type_.int64type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SequenceFeatureType::unsafe_arena_set_allocated_int64type(::CoreML::Specification::Int64FeatureType* int64type) {
  clear_Type();
  if (int64type) {
    set_has_int64type();
    Type_.int64type_ = int64type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.SequenceFeatureType.int64Type)
}
inline ::CoreML::Specification::Int64FeatureType* SequenceFeatureType::_internal_mutable_int64type() {
  if (!_internal_has_int64type()) {
    clear_Type();
    set_has_int64type();
    Type_.int64type_ = CreateMaybeMessage< ::CoreML::Specification::Int64FeatureType >(GetArenaForAllocation());
  }
  return Type_.int64type_;
}
inline ::CoreML::Specification::Int64FeatureType* SequenceFeatureType::mutable_int64type() {
  ::CoreML::Specification::Int64FeatureType* _msg = _internal_mutable_int64type();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SequenceFeatureType.int64Type)
  return _msg;
}

// .CoreML.Specification.StringFeatureType stringType = 3;
inline bool SequenceFeatureType::_internal_has_stringtype() const {
  return Type_case() == kStringType;
}
inline bool SequenceFeatureType::has_stringtype() const {
  return _internal_has_stringtype();
}
inline void SequenceFeatureType::set_has_stringtype() {
  _oneof_case_[0] = kStringType;
}
inline void SequenceFeatureType::clear_stringtype() {
  if (_internal_has_stringtype()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.stringtype_;
    }
    clear_has_Type();
  }
}
inline ::CoreML::Specification::StringFeatureType* SequenceFeatureType::release_stringtype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SequenceFeatureType.stringType)
  if (_internal_has_stringtype()) {
    clear_has_Type();
      ::CoreML::Specification::StringFeatureType* temp = Type_.stringtype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.stringtype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::StringFeatureType& SequenceFeatureType::_internal_stringtype() const {
  return _internal_has_stringtype()
      ? *Type_.stringtype_
      : reinterpret_cast< ::CoreML::Specification::StringFeatureType&>(::CoreML::Specification::_StringFeatureType_default_instance_);
}
inline const ::CoreML::Specification::StringFeatureType& SequenceFeatureType::stringtype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SequenceFeatureType.stringType)
  return _internal_stringtype();
}
inline ::CoreML::Specification::StringFeatureType* SequenceFeatureType::unsafe_arena_release_stringtype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.SequenceFeatureType.stringType)
  if (_internal_has_stringtype()) {
    clear_has_Type();
    ::CoreML::Specification::StringFeatureType* temp = Type_.stringtype_;
    Type_.stringtype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SequenceFeatureType::unsafe_arena_set_allocated_stringtype(::CoreML::Specification::StringFeatureType* stringtype) {
  clear_Type();
  if (stringtype) {
    set_has_stringtype();
    Type_.stringtype_ = stringtype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.SequenceFeatureType.stringType)
}
inline ::CoreML::Specification::StringFeatureType* SequenceFeatureType::_internal_mutable_stringtype() {
  if (!_internal_has_stringtype()) {
    clear_Type();
    set_has_stringtype();
    Type_.stringtype_ = CreateMaybeMessage< ::CoreML::Specification::StringFeatureType >(GetArenaForAllocation());
  }
  return Type_.stringtype_;
}
inline ::CoreML::Specification::StringFeatureType* SequenceFeatureType::mutable_stringtype() {
  ::CoreML::Specification::StringFeatureType* _msg = _internal_mutable_stringtype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SequenceFeatureType.stringType)
  return _msg;
}

// .CoreML.Specification.SizeRange sizeRange = 101;
inline bool SequenceFeatureType::_internal_has_sizerange() const {
  return this != internal_default_instance() && sizerange_ != nullptr;
}
inline bool SequenceFeatureType::has_sizerange() const {
  return _internal_has_sizerange();
}
inline void SequenceFeatureType::clear_sizerange() {
  if (GetArenaForAllocation() == nullptr && sizerange_ != nullptr) {
    delete sizerange_;
  }
  sizerange_ = nullptr;
}
inline const ::CoreML::Specification::SizeRange& SequenceFeatureType::_internal_sizerange() const {
  const ::CoreML::Specification::SizeRange* p = sizerange_;
  return p != nullptr ? *p : reinterpret_cast<const ::CoreML::Specification::SizeRange&>(
      ::CoreML::Specification::_SizeRange_default_instance_);
}
inline const ::CoreML::Specification::SizeRange& SequenceFeatureType::sizerange() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SequenceFeatureType.sizeRange)
  return _internal_sizerange();
}
inline void SequenceFeatureType::unsafe_arena_set_allocated_sizerange(
    ::CoreML::Specification::SizeRange* sizerange) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sizerange_);
  }
  sizerange_ = sizerange;
  if (sizerange) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.SequenceFeatureType.sizeRange)
}
inline ::CoreML::Specification::SizeRange* SequenceFeatureType::release_sizerange() {
  
  ::CoreML::Specification::SizeRange* temp = sizerange_;
  sizerange_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CoreML::Specification::SizeRange* SequenceFeatureType::unsafe_arena_release_sizerange() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SequenceFeatureType.sizeRange)
  
  ::CoreML::Specification::SizeRange* temp = sizerange_;
  sizerange_ = nullptr;
  return temp;
}
inline ::CoreML::Specification::SizeRange* SequenceFeatureType::_internal_mutable_sizerange() {
  
  if (sizerange_ == nullptr) {
    auto* p = CreateMaybeMessage<::CoreML::Specification::SizeRange>(GetArenaForAllocation());
    sizerange_ = p;
  }
  return sizerange_;
}
inline ::CoreML::Specification::SizeRange* SequenceFeatureType::mutable_sizerange() {
  ::CoreML::Specification::SizeRange* _msg = _internal_mutable_sizerange();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SequenceFeatureType.sizeRange)
  return _msg;
}
inline void SequenceFeatureType::set_allocated_sizerange(::CoreML::Specification::SizeRange* sizerange) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sizerange_;
  }
  if (sizerange) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CoreML::Specification::SizeRange>::GetOwningArena(sizerange);
    if (message_arena != submessage_arena) {
      sizerange = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sizerange, submessage_arena);
    }
    
  } else {
    
  }
  sizerange_ = sizerange;
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SequenceFeatureType.sizeRange)
}

inline bool SequenceFeatureType::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void SequenceFeatureType::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline SequenceFeatureType::TypeCase SequenceFeatureType::Type_case() const {
  return SequenceFeatureType::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// StateFeatureType

// .CoreML.Specification.ArrayFeatureType arrayType = 1;
inline bool StateFeatureType::_internal_has_arraytype() const {
  return Type_case() == kArrayType;
}
inline bool StateFeatureType::has_arraytype() const {
  return _internal_has_arraytype();
}
inline void StateFeatureType::set_has_arraytype() {
  _oneof_case_[0] = kArrayType;
}
inline void StateFeatureType::clear_arraytype() {
  if (_internal_has_arraytype()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.arraytype_;
    }
    clear_has_Type();
  }
}
inline ::CoreML::Specification::ArrayFeatureType* StateFeatureType::release_arraytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.StateFeatureType.arrayType)
  if (_internal_has_arraytype()) {
    clear_has_Type();
      ::CoreML::Specification::ArrayFeatureType* temp = Type_.arraytype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.arraytype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::ArrayFeatureType& StateFeatureType::_internal_arraytype() const {
  return _internal_has_arraytype()
      ? *Type_.arraytype_
      : reinterpret_cast< ::CoreML::Specification::ArrayFeatureType&>(::CoreML::Specification::_ArrayFeatureType_default_instance_);
}
inline const ::CoreML::Specification::ArrayFeatureType& StateFeatureType::arraytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.StateFeatureType.arrayType)
  return _internal_arraytype();
}
inline ::CoreML::Specification::ArrayFeatureType* StateFeatureType::unsafe_arena_release_arraytype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.StateFeatureType.arrayType)
  if (_internal_has_arraytype()) {
    clear_has_Type();
    ::CoreML::Specification::ArrayFeatureType* temp = Type_.arraytype_;
    Type_.arraytype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateFeatureType::unsafe_arena_set_allocated_arraytype(::CoreML::Specification::ArrayFeatureType* arraytype) {
  clear_Type();
  if (arraytype) {
    set_has_arraytype();
    Type_.arraytype_ = arraytype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.StateFeatureType.arrayType)
}
inline ::CoreML::Specification::ArrayFeatureType* StateFeatureType::_internal_mutable_arraytype() {
  if (!_internal_has_arraytype()) {
    clear_Type();
    set_has_arraytype();
    Type_.arraytype_ = CreateMaybeMessage< ::CoreML::Specification::ArrayFeatureType >(GetArenaForAllocation());
  }
  return Type_.arraytype_;
}
inline ::CoreML::Specification::ArrayFeatureType* StateFeatureType::mutable_arraytype() {
  ::CoreML::Specification::ArrayFeatureType* _msg = _internal_mutable_arraytype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.StateFeatureType.arrayType)
  return _msg;
}

inline bool StateFeatureType::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void StateFeatureType::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline StateFeatureType::TypeCase StateFeatureType::Type_case() const {
  return StateFeatureType::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FeatureType

// .CoreML.Specification.Int64FeatureType int64Type = 1;
inline bool FeatureType::_internal_has_int64type() const {
  return Type_case() == kInt64Type;
}
inline bool FeatureType::has_int64type() const {
  return _internal_has_int64type();
}
inline void FeatureType::set_has_int64type() {
  _oneof_case_[0] = kInt64Type;
}
inline void FeatureType::clear_int64type() {
  if (_internal_has_int64type()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.int64type_;
    }
    clear_has_Type();
  }
}
inline ::CoreML::Specification::Int64FeatureType* FeatureType::release_int64type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.int64Type)
  if (_internal_has_int64type()) {
    clear_has_Type();
      ::CoreML::Specification::Int64FeatureType* temp = Type_.int64type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.int64type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::Int64FeatureType& FeatureType::_internal_int64type() const {
  return _internal_has_int64type()
      ? *Type_.int64type_
      : reinterpret_cast< ::CoreML::Specification::Int64FeatureType&>(::CoreML::Specification::_Int64FeatureType_default_instance_);
}
inline const ::CoreML::Specification::Int64FeatureType& FeatureType::int64type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.int64Type)
  return _internal_int64type();
}
inline ::CoreML::Specification::Int64FeatureType* FeatureType::unsafe_arena_release_int64type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.FeatureType.int64Type)
  if (_internal_has_int64type()) {
    clear_has_Type();
    ::CoreML::Specification::Int64FeatureType* temp = Type_.int64type_;
    Type_.int64type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FeatureType::unsafe_arena_set_allocated_int64type(::CoreML::Specification::Int64FeatureType* int64type) {
  clear_Type();
  if (int64type) {
    set_has_int64type();
    Type_.int64type_ = int64type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.FeatureType.int64Type)
}
inline ::CoreML::Specification::Int64FeatureType* FeatureType::_internal_mutable_int64type() {
  if (!_internal_has_int64type()) {
    clear_Type();
    set_has_int64type();
    Type_.int64type_ = CreateMaybeMessage< ::CoreML::Specification::Int64FeatureType >(GetArenaForAllocation());
  }
  return Type_.int64type_;
}
inline ::CoreML::Specification::Int64FeatureType* FeatureType::mutable_int64type() {
  ::CoreML::Specification::Int64FeatureType* _msg = _internal_mutable_int64type();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.int64Type)
  return _msg;
}

// .CoreML.Specification.DoubleFeatureType doubleType = 2;
inline bool FeatureType::_internal_has_doubletype() const {
  return Type_case() == kDoubleType;
}
inline bool FeatureType::has_doubletype() const {
  return _internal_has_doubletype();
}
inline void FeatureType::set_has_doubletype() {
  _oneof_case_[0] = kDoubleType;
}
inline void FeatureType::clear_doubletype() {
  if (_internal_has_doubletype()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.doubletype_;
    }
    clear_has_Type();
  }
}
inline ::CoreML::Specification::DoubleFeatureType* FeatureType::release_doubletype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.doubleType)
  if (_internal_has_doubletype()) {
    clear_has_Type();
      ::CoreML::Specification::DoubleFeatureType* temp = Type_.doubletype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.doubletype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::DoubleFeatureType& FeatureType::_internal_doubletype() const {
  return _internal_has_doubletype()
      ? *Type_.doubletype_
      : reinterpret_cast< ::CoreML::Specification::DoubleFeatureType&>(::CoreML::Specification::_DoubleFeatureType_default_instance_);
}
inline const ::CoreML::Specification::DoubleFeatureType& FeatureType::doubletype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.doubleType)
  return _internal_doubletype();
}
inline ::CoreML::Specification::DoubleFeatureType* FeatureType::unsafe_arena_release_doubletype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.FeatureType.doubleType)
  if (_internal_has_doubletype()) {
    clear_has_Type();
    ::CoreML::Specification::DoubleFeatureType* temp = Type_.doubletype_;
    Type_.doubletype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FeatureType::unsafe_arena_set_allocated_doubletype(::CoreML::Specification::DoubleFeatureType* doubletype) {
  clear_Type();
  if (doubletype) {
    set_has_doubletype();
    Type_.doubletype_ = doubletype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.FeatureType.doubleType)
}
inline ::CoreML::Specification::DoubleFeatureType* FeatureType::_internal_mutable_doubletype() {
  if (!_internal_has_doubletype()) {
    clear_Type();
    set_has_doubletype();
    Type_.doubletype_ = CreateMaybeMessage< ::CoreML::Specification::DoubleFeatureType >(GetArenaForAllocation());
  }
  return Type_.doubletype_;
}
inline ::CoreML::Specification::DoubleFeatureType* FeatureType::mutable_doubletype() {
  ::CoreML::Specification::DoubleFeatureType* _msg = _internal_mutable_doubletype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.doubleType)
  return _msg;
}

// .CoreML.Specification.StringFeatureType stringType = 3;
inline bool FeatureType::_internal_has_stringtype() const {
  return Type_case() == kStringType;
}
inline bool FeatureType::has_stringtype() const {
  return _internal_has_stringtype();
}
inline void FeatureType::set_has_stringtype() {
  _oneof_case_[0] = kStringType;
}
inline void FeatureType::clear_stringtype() {
  if (_internal_has_stringtype()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.stringtype_;
    }
    clear_has_Type();
  }
}
inline ::CoreML::Specification::StringFeatureType* FeatureType::release_stringtype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.stringType)
  if (_internal_has_stringtype()) {
    clear_has_Type();
      ::CoreML::Specification::StringFeatureType* temp = Type_.stringtype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.stringtype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::StringFeatureType& FeatureType::_internal_stringtype() const {
  return _internal_has_stringtype()
      ? *Type_.stringtype_
      : reinterpret_cast< ::CoreML::Specification::StringFeatureType&>(::CoreML::Specification::_StringFeatureType_default_instance_);
}
inline const ::CoreML::Specification::StringFeatureType& FeatureType::stringtype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.stringType)
  return _internal_stringtype();
}
inline ::CoreML::Specification::StringFeatureType* FeatureType::unsafe_arena_release_stringtype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.FeatureType.stringType)
  if (_internal_has_stringtype()) {
    clear_has_Type();
    ::CoreML::Specification::StringFeatureType* temp = Type_.stringtype_;
    Type_.stringtype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FeatureType::unsafe_arena_set_allocated_stringtype(::CoreML::Specification::StringFeatureType* stringtype) {
  clear_Type();
  if (stringtype) {
    set_has_stringtype();
    Type_.stringtype_ = stringtype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.FeatureType.stringType)
}
inline ::CoreML::Specification::StringFeatureType* FeatureType::_internal_mutable_stringtype() {
  if (!_internal_has_stringtype()) {
    clear_Type();
    set_has_stringtype();
    Type_.stringtype_ = CreateMaybeMessage< ::CoreML::Specification::StringFeatureType >(GetArenaForAllocation());
  }
  return Type_.stringtype_;
}
inline ::CoreML::Specification::StringFeatureType* FeatureType::mutable_stringtype() {
  ::CoreML::Specification::StringFeatureType* _msg = _internal_mutable_stringtype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.stringType)
  return _msg;
}

// .CoreML.Specification.ImageFeatureType imageType = 4;
inline bool FeatureType::_internal_has_imagetype() const {
  return Type_case() == kImageType;
}
inline bool FeatureType::has_imagetype() const {
  return _internal_has_imagetype();
}
inline void FeatureType::set_has_imagetype() {
  _oneof_case_[0] = kImageType;
}
inline void FeatureType::clear_imagetype() {
  if (_internal_has_imagetype()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.imagetype_;
    }
    clear_has_Type();
  }
}
inline ::CoreML::Specification::ImageFeatureType* FeatureType::release_imagetype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.imageType)
  if (_internal_has_imagetype()) {
    clear_has_Type();
      ::CoreML::Specification::ImageFeatureType* temp = Type_.imagetype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.imagetype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::ImageFeatureType& FeatureType::_internal_imagetype() const {
  return _internal_has_imagetype()
      ? *Type_.imagetype_
      : reinterpret_cast< ::CoreML::Specification::ImageFeatureType&>(::CoreML::Specification::_ImageFeatureType_default_instance_);
}
inline const ::CoreML::Specification::ImageFeatureType& FeatureType::imagetype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.imageType)
  return _internal_imagetype();
}
inline ::CoreML::Specification::ImageFeatureType* FeatureType::unsafe_arena_release_imagetype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.FeatureType.imageType)
  if (_internal_has_imagetype()) {
    clear_has_Type();
    ::CoreML::Specification::ImageFeatureType* temp = Type_.imagetype_;
    Type_.imagetype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FeatureType::unsafe_arena_set_allocated_imagetype(::CoreML::Specification::ImageFeatureType* imagetype) {
  clear_Type();
  if (imagetype) {
    set_has_imagetype();
    Type_.imagetype_ = imagetype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.FeatureType.imageType)
}
inline ::CoreML::Specification::ImageFeatureType* FeatureType::_internal_mutable_imagetype() {
  if (!_internal_has_imagetype()) {
    clear_Type();
    set_has_imagetype();
    Type_.imagetype_ = CreateMaybeMessage< ::CoreML::Specification::ImageFeatureType >(GetArenaForAllocation());
  }
  return Type_.imagetype_;
}
inline ::CoreML::Specification::ImageFeatureType* FeatureType::mutable_imagetype() {
  ::CoreML::Specification::ImageFeatureType* _msg = _internal_mutable_imagetype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.imageType)
  return _msg;
}

// .CoreML.Specification.ArrayFeatureType multiArrayType = 5;
inline bool FeatureType::_internal_has_multiarraytype() const {
  return Type_case() == kMultiArrayType;
}
inline bool FeatureType::has_multiarraytype() const {
  return _internal_has_multiarraytype();
}
inline void FeatureType::set_has_multiarraytype() {
  _oneof_case_[0] = kMultiArrayType;
}
inline void FeatureType::clear_multiarraytype() {
  if (_internal_has_multiarraytype()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.multiarraytype_;
    }
    clear_has_Type();
  }
}
inline ::CoreML::Specification::ArrayFeatureType* FeatureType::release_multiarraytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.multiArrayType)
  if (_internal_has_multiarraytype()) {
    clear_has_Type();
      ::CoreML::Specification::ArrayFeatureType* temp = Type_.multiarraytype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.multiarraytype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::ArrayFeatureType& FeatureType::_internal_multiarraytype() const {
  return _internal_has_multiarraytype()
      ? *Type_.multiarraytype_
      : reinterpret_cast< ::CoreML::Specification::ArrayFeatureType&>(::CoreML::Specification::_ArrayFeatureType_default_instance_);
}
inline const ::CoreML::Specification::ArrayFeatureType& FeatureType::multiarraytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.multiArrayType)
  return _internal_multiarraytype();
}
inline ::CoreML::Specification::ArrayFeatureType* FeatureType::unsafe_arena_release_multiarraytype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.FeatureType.multiArrayType)
  if (_internal_has_multiarraytype()) {
    clear_has_Type();
    ::CoreML::Specification::ArrayFeatureType* temp = Type_.multiarraytype_;
    Type_.multiarraytype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FeatureType::unsafe_arena_set_allocated_multiarraytype(::CoreML::Specification::ArrayFeatureType* multiarraytype) {
  clear_Type();
  if (multiarraytype) {
    set_has_multiarraytype();
    Type_.multiarraytype_ = multiarraytype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.FeatureType.multiArrayType)
}
inline ::CoreML::Specification::ArrayFeatureType* FeatureType::_internal_mutable_multiarraytype() {
  if (!_internal_has_multiarraytype()) {
    clear_Type();
    set_has_multiarraytype();
    Type_.multiarraytype_ = CreateMaybeMessage< ::CoreML::Specification::ArrayFeatureType >(GetArenaForAllocation());
  }
  return Type_.multiarraytype_;
}
inline ::CoreML::Specification::ArrayFeatureType* FeatureType::mutable_multiarraytype() {
  ::CoreML::Specification::ArrayFeatureType* _msg = _internal_mutable_multiarraytype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.multiArrayType)
  return _msg;
}

// .CoreML.Specification.DictionaryFeatureType dictionaryType = 6;
inline bool FeatureType::_internal_has_dictionarytype() const {
  return Type_case() == kDictionaryType;
}
inline bool FeatureType::has_dictionarytype() const {
  return _internal_has_dictionarytype();
}
inline void FeatureType::set_has_dictionarytype() {
  _oneof_case_[0] = kDictionaryType;
}
inline void FeatureType::clear_dictionarytype() {
  if (_internal_has_dictionarytype()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.dictionarytype_;
    }
    clear_has_Type();
  }
}
inline ::CoreML::Specification::DictionaryFeatureType* FeatureType::release_dictionarytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.dictionaryType)
  if (_internal_has_dictionarytype()) {
    clear_has_Type();
      ::CoreML::Specification::DictionaryFeatureType* temp = Type_.dictionarytype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.dictionarytype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::DictionaryFeatureType& FeatureType::_internal_dictionarytype() const {
  return _internal_has_dictionarytype()
      ? *Type_.dictionarytype_
      : reinterpret_cast< ::CoreML::Specification::DictionaryFeatureType&>(::CoreML::Specification::_DictionaryFeatureType_default_instance_);
}
inline const ::CoreML::Specification::DictionaryFeatureType& FeatureType::dictionarytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.dictionaryType)
  return _internal_dictionarytype();
}
inline ::CoreML::Specification::DictionaryFeatureType* FeatureType::unsafe_arena_release_dictionarytype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.FeatureType.dictionaryType)
  if (_internal_has_dictionarytype()) {
    clear_has_Type();
    ::CoreML::Specification::DictionaryFeatureType* temp = Type_.dictionarytype_;
    Type_.dictionarytype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FeatureType::unsafe_arena_set_allocated_dictionarytype(::CoreML::Specification::DictionaryFeatureType* dictionarytype) {
  clear_Type();
  if (dictionarytype) {
    set_has_dictionarytype();
    Type_.dictionarytype_ = dictionarytype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.FeatureType.dictionaryType)
}
inline ::CoreML::Specification::DictionaryFeatureType* FeatureType::_internal_mutable_dictionarytype() {
  if (!_internal_has_dictionarytype()) {
    clear_Type();
    set_has_dictionarytype();
    Type_.dictionarytype_ = CreateMaybeMessage< ::CoreML::Specification::DictionaryFeatureType >(GetArenaForAllocation());
  }
  return Type_.dictionarytype_;
}
inline ::CoreML::Specification::DictionaryFeatureType* FeatureType::mutable_dictionarytype() {
  ::CoreML::Specification::DictionaryFeatureType* _msg = _internal_mutable_dictionarytype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.dictionaryType)
  return _msg;
}

// .CoreML.Specification.SequenceFeatureType sequenceType = 7;
inline bool FeatureType::_internal_has_sequencetype() const {
  return Type_case() == kSequenceType;
}
inline bool FeatureType::has_sequencetype() const {
  return _internal_has_sequencetype();
}
inline void FeatureType::set_has_sequencetype() {
  _oneof_case_[0] = kSequenceType;
}
inline void FeatureType::clear_sequencetype() {
  if (_internal_has_sequencetype()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.sequencetype_;
    }
    clear_has_Type();
  }
}
inline ::CoreML::Specification::SequenceFeatureType* FeatureType::release_sequencetype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.sequenceType)
  if (_internal_has_sequencetype()) {
    clear_has_Type();
      ::CoreML::Specification::SequenceFeatureType* temp = Type_.sequencetype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.sequencetype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::SequenceFeatureType& FeatureType::_internal_sequencetype() const {
  return _internal_has_sequencetype()
      ? *Type_.sequencetype_
      : reinterpret_cast< ::CoreML::Specification::SequenceFeatureType&>(::CoreML::Specification::_SequenceFeatureType_default_instance_);
}
inline const ::CoreML::Specification::SequenceFeatureType& FeatureType::sequencetype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.sequenceType)
  return _internal_sequencetype();
}
inline ::CoreML::Specification::SequenceFeatureType* FeatureType::unsafe_arena_release_sequencetype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.FeatureType.sequenceType)
  if (_internal_has_sequencetype()) {
    clear_has_Type();
    ::CoreML::Specification::SequenceFeatureType* temp = Type_.sequencetype_;
    Type_.sequencetype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FeatureType::unsafe_arena_set_allocated_sequencetype(::CoreML::Specification::SequenceFeatureType* sequencetype) {
  clear_Type();
  if (sequencetype) {
    set_has_sequencetype();
    Type_.sequencetype_ = sequencetype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.FeatureType.sequenceType)
}
inline ::CoreML::Specification::SequenceFeatureType* FeatureType::_internal_mutable_sequencetype() {
  if (!_internal_has_sequencetype()) {
    clear_Type();
    set_has_sequencetype();
    Type_.sequencetype_ = CreateMaybeMessage< ::CoreML::Specification::SequenceFeatureType >(GetArenaForAllocation());
  }
  return Type_.sequencetype_;
}
inline ::CoreML::Specification::SequenceFeatureType* FeatureType::mutable_sequencetype() {
  ::CoreML::Specification::SequenceFeatureType* _msg = _internal_mutable_sequencetype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.sequenceType)
  return _msg;
}

// .CoreML.Specification.StateFeatureType stateType = 8;
inline bool FeatureType::_internal_has_statetype() const {
  return Type_case() == kStateType;
}
inline bool FeatureType::has_statetype() const {
  return _internal_has_statetype();
}
inline void FeatureType::set_has_statetype() {
  _oneof_case_[0] = kStateType;
}
inline void FeatureType::clear_statetype() {
  if (_internal_has_statetype()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.statetype_;
    }
    clear_has_Type();
  }
}
inline ::CoreML::Specification::StateFeatureType* FeatureType::release_statetype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.stateType)
  if (_internal_has_statetype()) {
    clear_has_Type();
      ::CoreML::Specification::StateFeatureType* temp = Type_.statetype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.statetype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CoreML::Specification::StateFeatureType& FeatureType::_internal_statetype() const {
  return _internal_has_statetype()
      ? *Type_.statetype_
      : reinterpret_cast< ::CoreML::Specification::StateFeatureType&>(::CoreML::Specification::_StateFeatureType_default_instance_);
}
inline const ::CoreML::Specification::StateFeatureType& FeatureType::statetype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.stateType)
  return _internal_statetype();
}
inline ::CoreML::Specification::StateFeatureType* FeatureType::unsafe_arena_release_statetype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CoreML.Specification.FeatureType.stateType)
  if (_internal_has_statetype()) {
    clear_has_Type();
    ::CoreML::Specification::StateFeatureType* temp = Type_.statetype_;
    Type_.statetype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FeatureType::unsafe_arena_set_allocated_statetype(::CoreML::Specification::StateFeatureType* statetype) {
  clear_Type();
  if (statetype) {
    set_has_statetype();
    Type_.statetype_ = statetype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CoreML.Specification.FeatureType.stateType)
}
inline ::CoreML::Specification::StateFeatureType* FeatureType::_internal_mutable_statetype() {
  if (!_internal_has_statetype()) {
    clear_Type();
    set_has_statetype();
    Type_.statetype_ = CreateMaybeMessage< ::CoreML::Specification::StateFeatureType >(GetArenaForAllocation());
  }
  return Type_.statetype_;
}
inline ::CoreML::Specification::StateFeatureType* FeatureType::mutable_statetype() {
  ::CoreML::Specification::StateFeatureType* _msg = _internal_mutable_statetype();
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.stateType)
  return _msg;
}

// bool isOptional = 1000;
inline void FeatureType::clear_isoptional() {
  isoptional_ = false;
}
inline bool FeatureType::_internal_isoptional() const {
  return isoptional_;
}
inline bool FeatureType::isoptional() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.isOptional)
  return _internal_isoptional();
}
inline void FeatureType::_internal_set_isoptional(bool value) {
  
  isoptional_ = value;
}
inline void FeatureType::set_isoptional(bool value) {
  _internal_set_isoptional(value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.FeatureType.isOptional)
}

inline bool FeatureType::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void FeatureType::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline FeatureType::TypeCase FeatureType::Type_case() const {
  return FeatureType::TypeCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Specification
}  // namespace CoreML

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CoreML::Specification::ImageFeatureType_ColorSpace> : ::std::true_type {};
template <> struct is_proto_enum< ::CoreML::Specification::ArrayFeatureType_ArrayDataType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_FeatureTypes_2eproto
