<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>coremltools.models.ml_program.experimental.torch.debugging_utils &mdash; coremltools API Reference 8.3 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/css/norightmargin.css?v=eea1f72d" />

  
  <!--[if lt IE 9]>
    <script src="../../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../../../_static/documentation_options.js?v=8cc1add8"></script>
        <script src="../../../../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../index.html" class="icon icon-home">
            coremltools API Reference
          </a>
              <div class="version">
                8.3
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">API Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/coremltools.converters.html">Converters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/coremltools.models.html">Model APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/coremltools.converters.mil.html">MIL Builder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/coremltools.converters.mil.input_types.html">MIL Input Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/coremltools.converters.mil.mil.ops.defs.html">MIL Ops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/coremltools.converters.mil.mil.passes.defs.html">MIL Graph Passes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/coremltools.optimize.html">Optimizers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Resources</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://apple.github.io/coremltools/docs-guides/index.html">Guide and Examples</a></li>
<li class="toctree-l1"><a class="reference external" href="https://apple.github.io/coremltools/mlmodel/index.html">Core ML Format Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/api-versions.html">Previous Versions</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/apple/coremltools">GitHub</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../index.html">coremltools API Reference</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">coremltools.models.ml_program.experimental.torch.debugging_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for coremltools.models.ml_program.experimental.torch.debugging_utils</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2025, Apple Inc. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Use of this source code is governed by a BSD-3-clause license that can be</span>
<span class="c1"># found in the LICENSE.txt file or at https://opensource.org/licenses/BSD-3-Clause</span>

<span class="c1"># from coremltools.converters import convert</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">getLogger</span> <span class="k">as</span> <span class="n">_getLogger</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">torch.jit._script</span> <span class="kn">import</span> <span class="n">ScriptModule</span>

<span class="kn">from</span> <span class="nn">coremltools</span> <span class="kn">import</span> <span class="n">proto</span>
<span class="kn">from</span> <span class="nn">coremltools._deps</span> <span class="kn">import</span> <span class="n">_HAS_TORCH_EXPORT_API</span>
<span class="kn">from</span> <span class="nn">coremltools.converters.mil.mil.scope</span> <span class="kn">import</span> <span class="n">ScopeSource</span>

<span class="kn">from</span> <span class="nn">....model</span> <span class="kn">import</span> <span class="n">MLModel</span>
<span class="kn">from</span> <span class="nn">..debugging_utils</span> <span class="kn">import</span> <span class="n">MLModelInspector</span><span class="p">,</span> <span class="n">_retrieve_dependency_names</span><span class="p">,</span> <span class="n">_Status</span>
<span class="kn">from</span> <span class="nn">..remote_device</span> <span class="kn">import</span> <span class="n">Device</span>

<span class="k">if</span> <span class="n">_HAS_TORCH_EXPORT_API</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">torch.export</span> <span class="kn">import</span> <span class="n">ExportedProgram</span>

<span class="n">_logger</span> <span class="o">=</span> <span class="n">_getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">import</span> <span class="nn">tqdm</span>

<div class="viewcode-block" id="TorchScriptNodeInfo">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.TorchScriptNodeInfo">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">TorchScriptNodeInfo</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents information about a node in a torch graph.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    source_range : str</span>
<span class="sd">    The node&#39;s source range.</span>

<span class="sd">    modules : Iterable[&quot;TorchScriptModuleInfo.Key&quot;]</span>
<span class="sd">    The modules to which this node belongs.</span>

<span class="sd">    input_names : List[str]</span>
<span class="sd">    The input names.</span>

<span class="sd">    output_names : List[str]</span>
<span class="sd">    The output names.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">source_range</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">modules</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="s2">&quot;TorchScriptModuleInfo.Key&quot;</span><span class="p">]</span>
    <span class="n">desc</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">input_names</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">output_names</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">owning_module</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;TorchScriptModuleInfo.Key&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="TorchScriptModuleInfo">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.TorchScriptModuleInfo">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">TorchScriptModuleInfo</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents information about a torch module.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">    The name of the module.</span>

<span class="sd">    call_sequence :</span>
<span class="sd">    The sequence number of this module call.</span>

<span class="sd">    hierarchy : List[str]</span>
<span class="sd">    The hierarchical path of the module.</span>

<span class="sd">    output_names : List[str]</span>
<span class="sd">    Names of the module&#39;s outputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Key</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">call_sequence</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">hierarchy</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">input_names</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">output_names</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">submodules</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Key</span><span class="p">]</span>
    <span class="n">code</span><span class="p">:</span> <span class="nb">str</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hierarchy_name</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;TorchScriptModuleInfo.Key&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hierarchy_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_sequence</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">_topological_sort_graph</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">TorchScriptNodeInfo</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">TorchScriptNodeInfo</span><span class="p">]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">TorchScriptNodeInfo</span><span class="p">]:</span>
    <span class="n">in_degrees</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="n">in_degrees</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Create a queue and enqueue all vertices with in-degree 0</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span> <span class="k">if</span> <span class="n">in_degrees</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="n">in_degrees</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">in_degrees</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_build_graph</span><span class="p">(</span>
    <span class="n">nodes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TorchScriptNodeInfo</span><span class="p">],</span>
<span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">()}</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">input_name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input_names</span><span class="p">:</span>
            <span class="n">dep_node</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dep_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">dep_node</span><span class="p">]</span>
            <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_topological_sort_nodes</span><span class="p">(</span>
    <span class="n">nodes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TorchScriptNodeInfo</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;OrderedDict[str, TorchScriptNodeInfo]&quot;</span><span class="p">:</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">_build_graph</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">_topological_sort_graph</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">output_name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">output_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>

    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="TorchScriptModuleAnnotator">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.TorchScriptModuleAnnotator">[docs]</a>
<span class="k">class</span> <span class="nc">TorchScriptModuleAnnotator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for annotating the module graph.</span>

<span class="sd">    This class provides methods to annotate torch modules, track their call sequences,</span>
<span class="sd">    and analyze node dependencies within the graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">ContextManager</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">annotator</span><span class="p">:</span> <span class="s2">&quot;TorchScriptModuleAnnotator&quot;</span><span class="p">,</span>
            <span class="n">module</span><span class="p">:</span> <span class="n">ScriptModule</span><span class="p">,</span>
            <span class="n">module_hierarchy</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
            <span class="n">module_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">graph</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">module</span> <span class="o">=</span> <span class="n">module</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">annotator</span> <span class="o">=</span> <span class="n">annotator</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">module_hierarchy</span> <span class="o">=</span> <span class="n">module_hierarchy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">module_name</span> <span class="o">=</span> <span class="n">module_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span>

        <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">annotator</span><span class="o">.</span><span class="n">enter_module</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="p">,</span>
                <span class="n">hierarchy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">module_hierarchy</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">module_name</span><span class="p">,</span>
                <span class="n">graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">annotator</span><span class="o">.</span><span class="n">exit_module</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;var&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name_prefix</span> <span class="o">=</span> <span class="n">name_prefix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_module</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graphs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_module_call_sequence</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_module_infos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_infos</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_module_call_stack</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_submodules</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="TorchScriptModuleAnnotator.annotate_module">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.TorchScriptModuleAnnotator.annotate_module">[docs]</a>
    <span class="k">def</span> <span class="nf">annotate_module</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">module</span><span class="p">:</span> <span class="n">ScriptModule</span><span class="p">,</span>
        <span class="n">hierarchy</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ContextManager&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a context manager for annotating a module.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hierarchy : Tuple[str]</span>
<span class="sd">            The hierarchical path of the module.</span>

<span class="sd">        name : str</span>
<span class="sd">            The name of the module.</span>

<span class="sd">        graph : _TorchGraph</span>
<span class="sd">            The module graph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ContextManager</span>
<span class="sd">            A context manager for module annotation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TorchScriptModuleAnnotator</span><span class="o">.</span><span class="n">ContextManager</span><span class="p">(</span>
            <span class="n">annotator</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span>
            <span class="n">module_hierarchy</span><span class="o">=</span><span class="n">hierarchy</span><span class="p">,</span>
            <span class="n">module_name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">node_infos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;OrderedDict[str, TorchScriptNodeInfo]&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of the node information dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_infos</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">module_call_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;OrderedDict[TorchScriptModuleInfo.Key, TorchScriptModuleInfo]&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of the module call stack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_module_call_stack</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_module_call_sequence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hierarchy</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">hierarchy</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_module_call_sequence</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_module_call_sequence</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_annotate_graph</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">outputs</span><span class="p">():</span>
                <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name_prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">output</span><span class="o">.</span><span class="n">setDebugName</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_create_node_infos</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">module_key</span><span class="p">:</span> <span class="n">TorchScriptModuleInfo</span><span class="o">.</span><span class="n">Key</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">node_info</span> <span class="o">=</span> <span class="n">TorchScriptNodeInfo</span><span class="p">(</span>
                <span class="n">source_range</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">sourceRange</span><span class="p">(),</span>
                <span class="n">modules</span><span class="o">=</span><span class="p">(</span><span class="n">module_key</span><span class="p">,),</span>
                <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="n">input_names</span><span class="o">=</span><span class="p">(),</span>
                <span class="n">output_names</span><span class="o">=</span><span class="p">(),</span>
                <span class="n">kind</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">kind</span><span class="p">(),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">outputs</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_node_infos</span><span class="p">[</span><span class="n">output</span><span class="o">.</span><span class="n">debugName</span><span class="p">()]</span> <span class="o">=</span> <span class="n">node_info</span>

    <span class="k">def</span> <span class="nf">_update_node_infos</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">module_key</span><span class="p">:</span> <span class="n">TorchScriptModuleInfo</span><span class="o">.</span><span class="n">Key</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">outputs</span><span class="p">():</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">debugName</span><span class="p">()</span>
                <span class="n">node_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_infos</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">input_names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">input</span><span class="o">.</span><span class="n">debugName</span><span class="p">()</span> <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">inputs</span><span class="p">()]</span>
                <span class="n">output_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">output</span><span class="o">.</span><span class="n">debugName</span><span class="p">()</span> <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">outputs</span><span class="p">()]</span>
                <span class="n">modules</span> <span class="o">=</span> <span class="n">node_info</span><span class="o">.</span><span class="n">modules</span>
                <span class="k">if</span> <span class="n">module_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">modules</span><span class="p">:</span>
                    <span class="n">modules</span> <span class="o">=</span> <span class="n">modules</span> <span class="o">+</span> <span class="p">(</span><span class="n">module_key</span><span class="p">,)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_node_infos</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">TorchScriptNodeInfo</span><span class="p">(</span>
                    <span class="n">source_range</span><span class="o">=</span><span class="n">node_info</span><span class="o">.</span><span class="n">source_range</span><span class="p">,</span>
                    <span class="n">modules</span><span class="o">=</span><span class="n">modules</span><span class="p">,</span>
                    <span class="n">input_names</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">input_names</span><span class="p">),</span>
                    <span class="n">output_names</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">output_names</span><span class="p">),</span>
                    <span class="n">kind</span><span class="o">=</span><span class="n">node_info</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span>
                    <span class="n">desc</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">),</span>
                <span class="p">)</span>

<div class="viewcode-block" id="TorchScriptModuleAnnotator.enter_module">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.TorchScriptModuleAnnotator.enter_module">[docs]</a>
    <span class="k">def</span> <span class="nf">enter_module</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">module</span><span class="p">:</span> <span class="n">ScriptModule</span><span class="p">,</span>
        <span class="n">hierarchy</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enters a module context and annotates its graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hierarchy : List[str]</span>
<span class="sd">            The hierarchical path of the module.</span>

<span class="sd">        name : str</span>
<span class="sd">            The name of the module.</span>

<span class="sd">        graph : _TorchGraph</span>
<span class="sd">            The module graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">input_names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">input</span><span class="o">.</span><span class="n">debugName</span><span class="p">()</span> <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">inputs</span><span class="p">()]</span>

        <span class="n">call_sequence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_module_call_sequence</span><span class="p">(</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="n">hierarchy</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_graph</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">)</span>

        <span class="n">module_info</span> <span class="o">=</span> <span class="n">TorchScriptModuleInfo</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">hierarchy</span><span class="p">),</span>
            <span class="n">output_names</span><span class="o">=</span><span class="p">(),</span>
            <span class="n">input_names</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">input_names</span><span class="p">),</span>
            <span class="n">call_sequence</span><span class="o">=</span><span class="n">call_sequence</span><span class="p">,</span>
            <span class="n">code</span><span class="o">=</span><span class="n">module</span><span class="o">.</span><span class="n">code</span><span class="p">,</span>
            <span class="n">submodules</span><span class="o">=</span><span class="p">(),</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_create_node_infos</span><span class="p">(</span>
            <span class="n">module_key</span><span class="o">=</span><span class="n">module_info</span><span class="o">.</span><span class="n">key</span><span class="p">,</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_module_infos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">module_info</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_cleanup_dead_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">output_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="p">[</span><span class="n">output</span><span class="o">.</span><span class="n">debugName</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">outputs</span><span class="p">()]</span>
        <span class="p">)</span>
        <span class="n">keys_to_remove</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">output_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_infos</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">output_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">:</span>
                <span class="n">keys_to_remove</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">output_name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys_to_remove</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node_infos</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_submodules</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">module_key</span><span class="p">,</span> <span class="n">submodule_keys</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_submodules</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">module_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_module_call_stack</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">module_key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">module_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">new_module_info</span> <span class="o">=</span> <span class="n">TorchScriptModuleInfo</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">module_info</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">call_sequence</span><span class="o">=</span><span class="n">module_info</span><span class="o">.</span><span class="n">call_sequence</span><span class="p">,</span>
                <span class="n">hierarchy</span><span class="o">=</span><span class="n">module_info</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">,</span>
                <span class="n">output_names</span><span class="o">=</span><span class="n">module_info</span><span class="o">.</span><span class="n">output_names</span><span class="p">,</span>
                <span class="n">input_names</span><span class="o">=</span><span class="n">module_info</span><span class="o">.</span><span class="n">input_names</span><span class="p">,</span>
                <span class="n">code</span><span class="o">=</span><span class="n">module_info</span><span class="o">.</span><span class="n">code</span><span class="p">,</span>
                <span class="n">submodules</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">submodule_keys</span><span class="p">),</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_module_call_stack</span><span class="p">[</span><span class="n">module_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_module_info</span>

<div class="viewcode-block" id="TorchScriptModuleAnnotator.exit_module">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.TorchScriptModuleAnnotator.exit_module">[docs]</a>
    <span class="k">def</span> <span class="nf">exit_module</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exits a module context and finalizes annotations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graphs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">module_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_module_infos</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">output_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">output</span><span class="o">.</span><span class="n">debugName</span><span class="p">()</span> <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">outputs</span><span class="p">()]</span>
        <span class="n">new_module_info</span> <span class="o">=</span> <span class="n">TorchScriptModuleInfo</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">module_info</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">call_sequence</span><span class="o">=</span><span class="n">module_info</span><span class="o">.</span><span class="n">call_sequence</span><span class="p">,</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="n">module_info</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">,</span>
            <span class="n">output_names</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">output_names</span><span class="p">),</span>
            <span class="n">input_names</span><span class="o">=</span><span class="n">module_info</span><span class="o">.</span><span class="n">input_names</span><span class="p">,</span>
            <span class="n">code</span><span class="o">=</span><span class="n">module_info</span><span class="o">.</span><span class="n">code</span><span class="p">,</span>
            <span class="n">submodules</span><span class="o">=</span><span class="n">module_info</span><span class="o">.</span><span class="n">submodules</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_module_call_stack</span><span class="p">[</span><span class="n">new_module_info</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_module_info</span>
        <span class="n">parent_module_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_module_infos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_module_infos</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">parent_module_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">deps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_submodules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">parent_module_info</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">deps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_module_info</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_submodules</span><span class="p">[</span><span class="n">parent_module_info</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">deps</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_node_infos</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">module_key</span><span class="o">=</span><span class="n">new_module_info</span><span class="o">.</span><span class="n">key</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_module_infos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cleanup_dead_nodes</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node_infos</span> <span class="o">=</span> <span class="n">_topological_sort_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_infos</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_submodules</span><span class="p">()</span></div>
</div>



<span class="k">class</span> <span class="nc">_TorchScriptModuleInliner</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for inlining a TorchScript module.</span>

<span class="sd">    This class provides methods to inline submodules within a TorchScript module,</span>
<span class="sd">    effectively flattening the module hierarchy.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">module</span><span class="p">:</span> <span class="n">ScriptModule</span><span class="p">,</span>
        <span class="n">annotator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TorchScriptModuleAnnotator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the _TorchModuleInliner.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        module : ScriptModule</span>
<span class="sd">            The root torch module to be inlined.</span>

<span class="sd">        annotator : Optional[_TorchScriptModuleAnnotator]</span>
<span class="sd">            An optional annotator for annotating and tracking the nodes in the graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">module</span> <span class="o">=</span> <span class="n">module</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotator</span> <span class="o">=</span> <span class="n">annotator</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_clone_block</span><span class="p">(</span>
        <span class="n">src</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Block</span><span class="p">,</span>
        <span class="n">dst</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Block</span><span class="p">,</span>
        <span class="n">dst_graph</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
        <span class="n">find_value</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Block</span><span class="p">:</span>
        <span class="n">local_value_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">block_find_value</span><span class="p">(</span><span class="n">old_value</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Value</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">local_value_map</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">local_value_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">old_value</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">find_value</span><span class="p">(</span><span class="n">old_value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unable to find corresponding value for </span><span class="si">{</span><span class="n">old_value</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;This error occurs when a value from the original graph cannot be mapped &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;to a value in the new graph. &quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">inputs</span><span class="p">():</span>
            <span class="n">dst_input</span> <span class="o">=</span> <span class="n">dst</span><span class="o">.</span><span class="n">paramNode</span><span class="p">()</span><span class="o">.</span><span class="n">addInput</span><span class="p">()</span>
            <span class="n">dst_input</span><span class="o">.</span><span class="n">copyMetadata</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
            <span class="n">local_value_map</span><span class="p">[</span><span class="nb">input</span><span class="p">]</span> <span class="o">=</span> <span class="n">dst_input</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">_TorchScriptModuleInliner</span><span class="o">.</span><span class="n">_clone_node</span><span class="p">(</span>
                <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
                <span class="n">graph</span><span class="o">=</span><span class="n">dst_graph</span><span class="p">,</span>
                <span class="n">find_value</span><span class="o">=</span><span class="n">find_value</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">dst</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">new_output</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_node</span><span class="o">.</span><span class="n">outputs</span><span class="p">(),</span> <span class="n">node</span><span class="o">.</span><span class="n">outputs</span><span class="p">()):</span>
                <span class="n">local_value_map</span><span class="p">[</span><span class="n">output</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_output</span>
                <span class="n">new_output</span><span class="o">.</span><span class="n">copyMetadata</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">outputs</span><span class="p">():</span>
                <span class="n">dst</span><span class="o">.</span><span class="n">registerOutput</span><span class="p">(</span><span class="n">block_find_value</span><span class="p">(</span><span class="n">output</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">dst</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_clone_node</span><span class="p">(</span>
        <span class="n">node</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
        <span class="n">find_value</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Node</span><span class="p">:</span>
        <span class="n">new_node_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">find_value</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">inputs</span><span class="p">()]</span>

        <span class="n">new_node</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">kind</span><span class="p">(),</span> <span class="n">new_node_inputs</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">outputsSize</span><span class="p">())</span>
        <span class="n">new_node</span><span class="o">.</span><span class="n">copyMetadata</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">new_node</span><span class="o">.</span><span class="n">copyAttributes</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">new_output</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_node</span><span class="o">.</span><span class="n">outputs</span><span class="p">(),</span> <span class="n">node</span><span class="o">.</span><span class="n">outputs</span><span class="p">()):</span>
            <span class="n">new_output</span><span class="o">.</span><span class="n">copyMetadata</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">src_block</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">blocks</span><span class="p">():</span>
            <span class="n">dst_block</span> <span class="o">=</span> <span class="n">new_node</span><span class="o">.</span><span class="n">addBlock</span><span class="p">()</span>
            <span class="n">_TorchScriptModuleInliner</span><span class="o">.</span><span class="n">_clone_block</span><span class="p">(</span>
                <span class="n">src</span><span class="o">=</span><span class="n">src_block</span><span class="p">,</span>
                <span class="n">dst</span><span class="o">=</span><span class="n">dst_block</span><span class="p">,</span>
                <span class="n">dst_graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
                <span class="n">find_value</span><span class="o">=</span><span class="n">find_value</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">new_node</span>

    <span class="k">def</span> <span class="nf">_insert_graph</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
        <span class="n">callee</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span>
        <span class="n">value_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Value</span><span class="p">]:</span>
        <span class="k">def</span> <span class="nf">find_value</span><span class="p">(</span><span class="n">old_value</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Value</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">value_map</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">old_value</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing value for </span><span class="si">{</span><span class="n">old_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">value</span>

        <span class="k">for</span> <span class="n">callee_input</span><span class="p">,</span> <span class="nb">input</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">callee</span><span class="o">.</span><span class="n">inputs</span><span class="p">(),</span> <span class="n">inputs</span><span class="p">):</span>
            <span class="n">value_map</span><span class="p">[</span><span class="n">callee_input</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">callee</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">cloned_node</span> <span class="o">=</span> <span class="n">_TorchScriptModuleInliner</span><span class="o">.</span><span class="n">_clone_node</span><span class="p">(</span>
                <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
                <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
                <span class="n">find_value</span><span class="o">=</span><span class="n">find_value</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">graph</span><span class="o">.</span><span class="n">insertNode</span><span class="p">(</span><span class="n">cloned_node</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">output</span><span class="p">,</span> <span class="n">cloned_output</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">outputs</span><span class="p">(),</span> <span class="n">cloned_node</span><span class="o">.</span><span class="n">outputs</span><span class="p">()):</span>
                <span class="n">cloned_output</span><span class="o">.</span><span class="n">setDebugName</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">debugName</span><span class="p">())</span>
                <span class="n">value_map</span><span class="p">[</span><span class="n">output</span><span class="p">]</span> <span class="o">=</span> <span class="n">cloned_output</span>

        <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">find_value</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">callee</span><span class="o">.</span><span class="n">outputs</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">outputs</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_retrieve_submodule_from_node</span><span class="p">(</span>
        <span class="n">node</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span>
        <span class="n">module</span><span class="p">:</span> <span class="n">ScriptModule</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">ScriptModule</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="k">def</span> <span class="nf">retrieve_submodule</span><span class="p">(</span>
            <span class="n">node</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ScriptModule</span><span class="p">]:</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">curr_node</span> <span class="o">=</span> <span class="n">node</span>
            <span class="k">while</span> <span class="n">curr_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">curr_node</span><span class="o">.</span><span class="n">kind</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;prim::GetAttr&quot;</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">curr_node</span><span class="p">)</span>
                <span class="n">node_input</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">curr_node</span><span class="o">.</span><span class="n">inputs</span><span class="p">(),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">curr_node</span> <span class="o">=</span> <span class="n">node_input</span><span class="o">.</span><span class="n">node</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="n">curr_module</span> <span class="o">=</span> <span class="n">module</span>
            <span class="n">module_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">attr_node</span> <span class="ow">in</span> <span class="n">stack</span><span class="p">:</span>
                <span class="n">module_name</span> <span class="o">=</span> <span class="n">attr_node</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
                <span class="n">module_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">module_name</span><span class="p">)</span>
                <span class="n">curr_module</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">curr_module</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">curr_module</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">curr_module</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">module_names</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">kind</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;prim::CallMethod&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">node_input</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">inputs</span><span class="p">(),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node_input</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">retrieve_submodule</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node_input</span><span class="o">.</span><span class="n">node</span><span class="p">())</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_inline_call_node</span><span class="p">(</span>
        <span class="n">node</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
        <span class="n">callee</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Value</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">kind</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;prim::CallMethod&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid node kind encountered. Expected &#39;prim::CallMethod&#39;, but got &#39;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">kind</span><span class="p">()</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="n">value_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">new_outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">graph</span><span class="o">.</span><span class="n">insert_point_guard</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">new_outputs</span> <span class="o">=</span> <span class="n">_TorchScriptModuleInliner</span><span class="o">.</span><span class="n">_insert_graph</span><span class="p">(</span>
                <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
                <span class="n">callee</span><span class="o">=</span><span class="n">callee</span><span class="p">,</span>
                <span class="n">inputs</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">inputs</span><span class="p">(),</span>
                <span class="n">value_map</span><span class="o">=</span><span class="n">value_map</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">new_output</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_outputs</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">outputs</span><span class="p">()):</span>
                <span class="n">output</span><span class="o">.</span><span class="n">replaceAllUsesWith</span><span class="p">(</span><span class="n">new_output</span><span class="p">)</span>

        <span class="n">node</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">new_outputs</span>

    <span class="k">def</span> <span class="nf">_inline_graph</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
        <span class="n">module</span><span class="p">:</span> <span class="n">ScriptModule</span><span class="p">,</span>
        <span class="n">hierarchy</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="p">):</span>
        <span class="c1"># Create a copy of nodes for iteration as the graph is mutated when inlining.</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()):</span>
            <span class="n">submodule_and_name</span> <span class="o">=</span> <span class="n">_TorchScriptModuleInliner</span><span class="o">.</span><span class="n">_retrieve_submodule_from_node</span><span class="p">(</span>
                <span class="n">node</span><span class="p">,</span>
                <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">submodule_and_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">submodule</span><span class="p">,</span> <span class="n">submodule_name</span> <span class="o">=</span> <span class="n">submodule_and_name</span>
                <span class="n">submodule_graph</span> <span class="o">=</span> <span class="n">submodule</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="n">call_node_inputs</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">inputs</span><span class="p">())</span>
                <span class="n">submodule_graph_inputs</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">submodule_graph</span><span class="o">.</span><span class="n">inputs</span><span class="p">())</span>
                <span class="c1"># Ignore the first input</span>
                <span class="n">_</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">call_node_inputs</span><span class="p">)</span>
                <span class="n">_</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">submodule_graph_inputs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">node_input</span><span class="p">,</span> <span class="n">submodule_graph_input</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="n">call_node_inputs</span><span class="p">,</span> <span class="n">submodule_graph_inputs</span>
                <span class="p">):</span>
                    <span class="n">submodule_graph_input</span><span class="o">.</span><span class="n">setDebugName</span><span class="p">(</span><span class="n">node_input</span><span class="o">.</span><span class="n">debugName</span><span class="p">())</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_inline_module</span><span class="p">(</span>
                    <span class="n">module</span><span class="o">=</span><span class="n">submodule</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">submodule_name</span><span class="p">,</span>
                    <span class="n">hierarchy</span><span class="o">=</span><span class="n">hierarchy</span><span class="p">,</span>
                    <span class="n">graph</span><span class="o">=</span><span class="n">submodule_graph</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">_TorchScriptModuleInliner</span><span class="o">.</span><span class="n">_inline_call_node</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
                    <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
                    <span class="n">callee</span><span class="o">=</span><span class="n">submodule_graph</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">_jit_pass_dce</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_inline_module</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">module</span><span class="p">:</span> <span class="n">ScriptModule</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">hierarchy</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">curr_hierarchy</span> <span class="o">=</span> <span class="n">hierarchy</span> <span class="o">+</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotator</span><span class="o">.</span><span class="n">annotate_module</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
                <span class="n">hierarchy</span><span class="o">=</span><span class="n">curr_hierarchy</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_inline_graph</span><span class="p">(</span>
                    <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
                    <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span>
                    <span class="n">hierarchy</span><span class="o">=</span><span class="n">curr_hierarchy</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inline_graph</span><span class="p">(</span>
                <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
                <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span>
                <span class="n">hierarchy</span><span class="o">=</span><span class="n">curr_hierarchy</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">inline</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the inlining process on the root module.</span>

<span class="sd">        This method initiates the inlining process, starting from the root module</span>
<span class="sd">        and recursively inlining all submodules.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inline_module</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">_TorchModuleInspector</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for inspecting PyTorch modules during forward pass.</span>

<span class="sd">    This class provides methods to inspect specific modules within a PyTorch model,</span>
<span class="sd">    collecting their output tensors during a forward pass.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the TorchModuleInspector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : torch.nn.Module</span>
<span class="sd">            The PyTorch model to be inspected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The &quot;module&quot; parameter must be of type &quot;torch.nn.Module&quot;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">model</span>

    <span class="k">def</span> <span class="nf">inspect</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
        <span class="n">module_info_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TorchScriptModuleInfo</span><span class="o">.</span><span class="n">Key</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[(</span><span class="n">TorchScriptModuleInfo</span><span class="o">.</span><span class="n">Key</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">])]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inspects specified modules during a forward pass of the model.</span>

<span class="sd">        This method registers forward hooks on the specified modules, performs a forward pass</span>
<span class="sd">        with the given inputs, and collects the output tensors for each specified module.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inputs : Tuple[torch.Tensor]</span>
<span class="sd">            The input tensors for the model&#39;s forward pass.</span>

<span class="sd">        module_infos : List[ModuleInfo]</span>
<span class="sd">            A list of ModuleInfo objects specifying which modules to inspect.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[Tuple[ModuleInfo, Optional[torch.Tensor]]]</span>
<span class="sd">            A list of tuples, each containing a ModuleInfo object and its corresponding output tensor (if available).</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The method uses forward hooks to capture module outputs. These hooks are removed after the inspection process.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">module_call_sequences</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">module_info_key</span> <span class="ow">in</span> <span class="n">module_info_keys</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">module_info_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">module_info_key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">register_forward_hook</span><span class="p">(</span><span class="n">module</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">set_module_output</span><span class="p">(</span>
                <span class="n">curr_module</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
                <span class="n">inputs</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
                <span class="n">output</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">nonlocal</span> <span class="n">module_call_sequences</span>
                <span class="k">nonlocal</span> <span class="n">result</span>

                <span class="n">sequence</span> <span class="o">=</span> <span class="n">module_call_sequences</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">module_call_sequences</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">sequence</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">sequence</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">sequence</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">output</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">output</span>

            <span class="k">return</span> <span class="n">module</span><span class="o">.</span><span class="n">register_forward_hook</span><span class="p">(</span><span class="n">set_module_output</span><span class="p">,</span> <span class="n">always_call</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">hooks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">interested_module_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">module_info_key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">module_info_key</span> <span class="ow">in</span> <span class="n">module_info_keys</span><span class="p">]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">interested_module_names</span><span class="p">:</span>
                <span class="n">hook</span> <span class="o">=</span> <span class="n">register_forward_hook</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
                <span class="n">hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hook</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">hook</span> <span class="ow">in</span> <span class="n">hooks</span><span class="p">:</span>
            <span class="n">hook</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>


<div class="viewcode-block" id="TorchScriptModuleMappingInfo">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.TorchScriptModuleMappingInfo">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">TorchScriptModuleMappingInfo</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class that holds mapping information for a TorchScript module</span>
<span class="sd">    and its corresponding operations in the converted Core ML model.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    source : TorchScriptModuleInfo</span>
<span class="sd">        An instance representing the source module that is being mapped.</span>

<span class="sd">    source_to_target_mapping : OrderedDict[TorchScriptNodeInfo, List[proto.MIL_pb2.Operation]]</span>
<span class="sd">        An ordered mapping from nodes in the source TorchScript module to</span>
<span class="sd">        a list of corresponding operations in Core ML. Each key represents</span>
<span class="sd">        a node in the module, while each value is a list of</span>
<span class="sd">        operations that correspond to that node in the target model.</span>

<span class="sd">    deps : Dict[TorchScriptModuleInfo.Key, Iterable[TorchScriptModuleInfo.Key]]:</span>
<span class="sd">        A dictionary mapping each module to its immediate dependencies.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">source</span><span class="p">:</span> <span class="n">TorchScriptModuleInfo</span>
    <span class="n">source_to_target_ops_mapping</span><span class="p">:</span> <span class="s2">&quot;OrderedDict[TorchScriptNodeInfo : List[proto.MIL_pb2.Operation]]&quot;</span>
    <span class="n">deps</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">TorchScriptModuleInfo</span><span class="o">.</span><span class="n">Key</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="s2">&quot;TorchScriptModuleMappingInfo&quot;</span><span class="p">]]</span>
    <span class="n">outputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">]</span>
    <span class="n">submodules</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;TorchScriptModuleMappingInfo&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TorchScriptModuleInfo</span><span class="o">.</span><span class="n">Key</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">key</span>

    <span class="k">def</span> <span class="nf">get_source_ops_for_target_op</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target_op</span><span class="p">:</span> <span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">TorchScriptNodeInfo</span><span class="p">]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">source_op</span><span class="p">,</span> <span class="n">target_ops</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_to_target_ops_mapping</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">target_op</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">target_ops</span><span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source_op</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>



<span class="k">def</span> <span class="nf">_create_output_name_to_op_map_from_spec</span><span class="p">(</span>
    <span class="n">spec</span><span class="p">:</span> <span class="s2">&quot;proto.Model_pb2.Model&quot;</span><span class="p">,</span>
    <span class="n">function_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;OrderedDict[str, proto.MIL_pb2.Operation]&quot;</span><span class="p">:</span>
    <span class="n">func_spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">mlProgram</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="n">function_name</span> <span class="k">if</span> <span class="n">function_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;main&quot;</span><span class="p">,</span> <span class="kc">None</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">func_spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing function for name : </span><span class="si">{</span><span class="n">function_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">block_spec</span> <span class="o">=</span> <span class="n">func_spec</span><span class="o">.</span><span class="n">block_specializations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">func_spec</span><span class="o">.</span><span class="n">opset</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">block_spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing block specialization for opset : </span><span class="si">{</span><span class="n">func_spec</span><span class="o">.</span><span class="n">opset</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">block_spec</span><span class="o">.</span><span class="n">operations</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">output</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_invert_deps</span><span class="p">(</span>
    <span class="n">modules</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">TorchScriptModuleInfo</span><span class="o">.</span><span class="n">Key</span><span class="p">,</span> <span class="n">TorchScriptModuleMappingInfo</span><span class="p">],</span>
    <span class="n">deps</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">TorchScriptModuleInfo</span><span class="o">.</span><span class="n">Key</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">TorchScriptModuleMappingInfo</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">TorchScriptModuleInfo</span><span class="o">.</span><span class="n">Key</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">TorchScriptModuleMappingInfo</span><span class="p">]]:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">module_key</span><span class="p">,</span> <span class="n">module_map_infos</span> <span class="ow">in</span> <span class="n">deps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">dep</span> <span class="o">=</span> <span class="n">modules</span><span class="p">[</span><span class="n">module_key</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">module_map_info</span> <span class="ow">in</span> <span class="n">module_map_infos</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">module_map_info</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dep</span><span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="n">module_map_info</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_get_module_deps</span><span class="p">(</span>
    <span class="n">parent_module</span><span class="p">:</span> <span class="n">TorchScriptModuleInfo</span><span class="p">,</span>
    <span class="n">submodules</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">TorchScriptModuleInfo</span><span class="p">],</span>
    <span class="n">nodes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TorchScriptNodeInfo</span><span class="p">],</span>
    <span class="n">graph</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">TorchScriptNodeInfo</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">TorchScriptNodeInfo</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">TorchScriptModuleInfo</span><span class="o">.</span><span class="n">Key</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">TorchScriptModuleInfo</span><span class="p">]]:</span>
    <span class="n">input_name_to_modules_map</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">submodules</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">input_name</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">input_names</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">input_name_to_modules_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_name</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
            <span class="n">input_name_to_modules_map</span><span class="p">[</span><span class="n">input_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">for</span> <span class="n">output_name</span> <span class="ow">in</span> <span class="n">parent_module</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
        <span class="n">input_name_to_modules_map</span><span class="p">[</span><span class="n">output_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">parent_module</span><span class="p">]</span>

    <span class="n">modules</span> <span class="o">=</span> <span class="p">{</span><span class="n">submodule</span><span class="o">.</span><span class="n">key</span><span class="p">:</span> <span class="n">submodule</span> <span class="k">for</span> <span class="n">submodule</span> <span class="ow">in</span> <span class="n">submodules</span><span class="p">}</span>
    <span class="n">modules</span><span class="p">[</span><span class="n">parent_module</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent_module</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="n">module</span><span class="o">.</span><span class="n">key</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">modules</span><span class="o">.</span><span class="n">values</span><span class="p">()}</span>

    <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">submodules</span><span class="p">:</span>
        <span class="n">module_deps</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">module</span><span class="o">.</span><span class="n">key</span><span class="p">]</span>
        <span class="n">start_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">output_name</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">output_names</span><span class="p">]</span>
        <span class="n">start_nodes</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">start_nodes</span><span class="p">)</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">start_nodes</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">deps</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">output_name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
                <span class="n">deps</span> <span class="o">=</span> <span class="n">input_name_to_modules_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="p">[])</span>
                <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">deps</span><span class="p">:</span>
                    <span class="n">module_deps</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">deps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">[]):</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_invert_deps</span><span class="p">(</span>
        <span class="n">modules</span><span class="o">=</span><span class="n">modules</span><span class="p">,</span>
        <span class="n">deps</span><span class="o">=</span><span class="n">result</span><span class="p">,</span>
    <span class="p">)</span>


<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">_OpTranslationMap</span><span class="p">:</span>
    <span class="n">output_name_to_target_ops</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">]]</span>


<span class="k">def</span> <span class="nf">_retrieve_source_to_target_op_map</span><span class="p">(</span>
    <span class="n">target_model</span><span class="p">:</span> <span class="n">MLModel</span><span class="p">,</span>
    <span class="n">function_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_OpTranslationMap</span><span class="p">:</span>
    <span class="n">output_name_to_op_map</span> <span class="o">=</span> <span class="n">_create_output_name_to_op_map_from_spec</span><span class="p">(</span>
        <span class="n">spec</span><span class="o">=</span><span class="n">target_model</span><span class="o">.</span><span class="n">get_spec</span><span class="p">(),</span>
        <span class="n">function_name</span><span class="o">=</span><span class="n">function_name</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">output_name_to_target_ops</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">program</span> <span class="o">=</span> <span class="n">target_model</span><span class="o">.</span><span class="n">_mil_program</span>
    <span class="n">block</span> <span class="o">=</span> <span class="n">program</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">function_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Program is missing function for name=</span><span class="si">{</span><span class="n">function_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">operations</span><span class="p">:</span>
        <span class="n">module_names</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">scopes</span><span class="p">[</span><span class="n">ScopeSource</span><span class="o">.</span><span class="n">TORCHSCRIPT_MODULE_NAME</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">module_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">source_name</span> <span class="o">=</span> <span class="n">module_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">output_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">output</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">outputs</span><span class="p">]</span>
        <span class="n">target_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">output_name_to_op_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">output_name</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">]</span>
        <span class="n">target_ops</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="n">op</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">target_ops</span><span class="p">))</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="n">output_name_to_target_ops</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">source_name</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">ops</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">target_ops</span><span class="p">)</span>
        <span class="n">output_name_to_target_ops</span><span class="p">[</span><span class="n">source_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ops</span>

    <span class="k">return</span> <span class="n">_OpTranslationMap</span><span class="p">(</span>
        <span class="n">output_name_to_target_ops</span><span class="o">=</span><span class="n">output_name_to_target_ops</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="inline_and_annotate_module">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.inline_and_annotate_module">[docs]</a>
<span class="k">def</span> <span class="nf">inline_and_annotate_module</span><span class="p">(</span>
    <span class="n">model</span><span class="p">:</span> <span class="n">ScriptModule</span><span class="p">,</span>
    <span class="n">name_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;var&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TorchScriptModuleAnnotator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inlines and annotates a TorchScript module.</span>

<span class="sd">    This function takes a TorchScript module and performs two operations:</span>
<span class="sd">        1. Inlining: It inlines the module, which means it replaces calls to submodules</span>
<span class="sd">        with the actual operations performed by those submodules.</span>
<span class="sd">        </span>
<span class="sd">        2. Annotation: It adds annotations to the module, providing additional</span>
<span class="sd">        information about the module&#39;s structure and operations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : ScriptModule</span>
<span class="sd">        The TorchScript module to be inlined and annotated. This should be an</span>
<span class="sd">        instance of ScriptModule, which is a subclass of torch.nn.Module</span>
<span class="sd">        that has been scripted using torch.jit.script().</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    TorchScriptModuleAnnotator</span>
<span class="sd">        An annotator object that contains the inlined and annotated version of</span>
<span class="sd">        the input module.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">annotator</span> <span class="o">=</span> <span class="n">TorchScriptModuleAnnotator</span><span class="p">(</span><span class="n">name_prefix</span><span class="o">=</span><span class="n">name_prefix</span><span class="p">)</span>
    <span class="n">inliner</span> <span class="o">=</span> <span class="n">_TorchScriptModuleInliner</span><span class="p">(</span>
        <span class="n">module</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
        <span class="n">annotator</span><span class="o">=</span><span class="n">annotator</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">inliner</span><span class="o">.</span><span class="n">inline</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">annotator</span></div>


<span class="k">def</span> <span class="nf">_convert_and_retrieve_jit_module_mapping</span><span class="p">(</span>
    <span class="n">model</span><span class="p">:</span> <span class="n">ScriptModule</span><span class="p">,</span>
    <span class="n">annotator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TorchScriptModuleAnnotator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">converter_kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">MLModel</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="n">TorchScriptModuleInfo</span><span class="o">.</span><span class="n">Key</span><span class="p">,</span> <span class="n">TorchScriptModuleMappingInfo</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a TorchScript model to a Core ML model and returns the</span>
<span class="sd">    mapping information mapping between the source TorchScript operations and their</span>
<span class="sd">    corresponding operations in the converted Core ML model.</span>

<span class="sd">    This function takes a TorchScript model, performs  inlining and annotation,</span>
<span class="sd">    converts it to a Core ML model using the specified conversion</span>
<span class="sd">    parameters, and constructs a mapping that associates nodes in the source</span>
<span class="sd">    module with their corresponding operations in the Core ML model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : ScriptModule</span>
<span class="sd">        The source model.</span>

<span class="sd">    annotator : Optional[TorchScriptModuleAnnotator]</span>
<span class="sd">        The TorchScript module annotator, if the module has been annotated.</span>

<span class="sd">    **converter_kwargs:</span>
<span class="sd">        Additional keyword arguments to be passed to the Core ML conversion process.</span>
<span class="sd">        These can include options for optimization, input/output specifications, etc.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Tuple[MLModel, Dict[TorchScriptModuleInfo.Key, TorchScriptModuleMappingInfo]]</span>
<span class="sd">        A tuple containing:</span>
<span class="sd">            - The converted Core ML model.</span>
<span class="sd">            -  A dictionary mapping keys from `TorchScriptModuleInfo` to their corresponding</span>
<span class="sd">               ``TorchModuleMLModelMappingInfo`` instances. This mapping provides detailed</span>
<span class="sd">               information about how each node in the source module corresponds to operations</span>
<span class="sd">               in the target Core ML model.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. sourcecode:: python</span>
<span class="sd">    </span>
<span class="sd">        (</span>
<span class="sd">            target_model,</span>
<span class="sd">            module_mapping,</span>
<span class="sd">        ) = coremltools.models.ml_program.experimental.torch._convert_and_retrieve_jit_module_mapping(</span>
<span class="sd">            model=traced_model,</span>
<span class="sd">            inputs=[</span>
<span class="sd">                coremltools.TensorType(</span>
<span class="sd">                    name=&quot;x&quot;, shape=example_inputs[0].shape, dtype=np.float16</span>
<span class="sd">                ),</span>
<span class="sd">                coremltools.TensorType(</span>
<span class="sd">                    name=&quot;y&quot;, shape=example_inputs[1].shape, dtype=np.float16</span>
<span class="sd">                ),</span>
<span class="sd">            ],</span>
<span class="sd">            minimum_deployment_target=coremltools.target.iOS16,</span>
<span class="sd">            compute_units=coremltools.ComputeUnit.CPU_ONLY,</span>
<span class="sd">            skip_model_load=True,</span>
<span class="sd">        )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Importing here to avoid circular import issues</span>
    <span class="kn">from</span> <span class="nn">.....converters</span> <span class="kn">import</span> <span class="n">convert</span>

    <span class="k">if</span> <span class="n">annotator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">annotator</span> <span class="o">=</span> <span class="n">inline_and_annotate_module</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span>

    <span class="n">target_model</span> <span class="o">=</span> <span class="n">convert</span><span class="p">(</span>
        <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
        <span class="o">**</span><span class="n">converter_kwargs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">op_translation_map</span> <span class="o">=</span> <span class="n">_retrieve_source_to_target_op_map</span><span class="p">(</span>
        <span class="n">target_model</span><span class="o">=</span><span class="n">target_model</span><span class="p">,</span>
        <span class="n">function_name</span><span class="o">=</span><span class="s2">&quot;main&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">module_call_stack</span> <span class="o">=</span> <span class="n">annotator</span><span class="o">.</span><span class="n">module_call_stack</span>
    <span class="n">module_map_infos</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_module_output</span><span class="p">(</span>
        <span class="n">op</span><span class="p">:</span> <span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">,</span> <span class="n">output_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">name</span>
            <span class="k">for</span> <span class="n">output_name</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">output_name</span> <span class="ow">or</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">output_name</span><span class="si">}</span><span class="s2">_cast&quot;</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_get_module_output_names</span><span class="p">(</span>
        <span class="n">module_info</span><span class="p">:</span> <span class="n">TorchScriptModuleInfo</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">node_infos</span> <span class="o">=</span> <span class="n">annotator</span><span class="o">.</span><span class="n">node_infos</span>
        <span class="k">for</span> <span class="n">output_name</span> <span class="ow">in</span> <span class="n">module_info</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
            <span class="n">node_info</span> <span class="o">=</span> <span class="n">node_infos</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node_info</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;prim::TupleConstruct&quot;</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">node_info</span><span class="o">.</span><span class="n">input_names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">for</span> <span class="n">node_info</span> <span class="ow">in</span> <span class="n">annotator</span><span class="o">.</span><span class="n">node_infos</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">module_ops</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">op_translation_map</span><span class="o">.</span><span class="n">output_name_to_target_ops</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node_info</span><span class="o">.</span><span class="n">output_names</span>
        <span class="p">]</span>
        <span class="n">module_ops</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">module_ops</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">for</span> <span class="n">module_key</span> <span class="ow">in</span> <span class="n">node_info</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
            <span class="n">module_info</span> <span class="o">=</span> <span class="n">module_call_stack</span><span class="p">[</span><span class="n">module_key</span><span class="p">]</span>
            <span class="n">module_map_info</span> <span class="o">=</span> <span class="n">module_map_infos</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                <span class="n">module_key</span><span class="p">,</span>
                <span class="n">TorchScriptModuleMappingInfo</span><span class="p">(</span>
                    <span class="n">source</span><span class="o">=</span><span class="n">module_info</span><span class="p">,</span>
                    <span class="n">source_to_target_ops_mapping</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">(),</span>
                    <span class="n">deps</span><span class="o">=</span><span class="p">[],</span>
                    <span class="n">outputs</span><span class="o">=</span><span class="p">[],</span>
                    <span class="n">submodules</span><span class="o">=</span><span class="p">[],</span>
                <span class="p">),</span>
            <span class="p">)</span>

            <span class="n">module_output_names</span> <span class="o">=</span> <span class="n">_get_module_output_names</span><span class="p">(</span><span class="n">module_info</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">module_map_info</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">module_output_names</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">module_ops</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_module_output</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">output_names</span><span class="o">=</span><span class="n">module_output_names</span><span class="p">):</span>
                        <span class="n">module_map_info</span><span class="o">.</span><span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

            <span class="n">ops</span> <span class="o">=</span> <span class="n">module_map_info</span><span class="o">.</span><span class="n">source_to_target_ops_mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node_info</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">ops</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">module_ops</span><span class="p">)</span>
            <span class="n">module_map_info</span><span class="o">.</span><span class="n">source_to_target_ops_mapping</span><span class="p">[</span><span class="n">node_info</span><span class="p">]</span> <span class="o">=</span> <span class="n">ops</span>

    <span class="c1"># Set module deps and submodules</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">_build_graph</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">annotator</span><span class="o">.</span><span class="n">node_infos</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">module_key</span><span class="p">,</span> <span class="n">module_map_info</span> <span class="ow">in</span> <span class="n">module_map_infos</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">submodules</span> <span class="o">=</span> <span class="p">[</span><span class="n">module_call_stack</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">module_map_info</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">submodules</span><span class="p">]</span>
        <span class="n">module_map_info</span><span class="o">.</span><span class="n">submodules</span> <span class="o">=</span> <span class="n">submodules</span>
        <span class="n">deps</span> <span class="o">=</span> <span class="n">_get_module_deps</span><span class="p">(</span>
            <span class="n">parent_module</span><span class="o">=</span><span class="n">module_map_info</span><span class="o">.</span><span class="n">source</span><span class="p">,</span>
            <span class="n">submodules</span><span class="o">=</span><span class="n">submodules</span><span class="p">,</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">annotator</span><span class="o">.</span><span class="n">node_infos</span><span class="p">,</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">module_map_info</span><span class="o">.</span><span class="n">deps</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="p">[</span><span class="n">module_map_infos</span><span class="p">[</span><span class="n">value</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">deps</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">target_model</span><span class="p">,</span> <span class="n">module_map_infos</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_convert_and_retrieve_exported_program_op_mapping</span><span class="p">(</span>
    <span class="n">model</span><span class="p">:</span> <span class="s2">&quot;ExportedProgram&quot;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">converter_kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">MLModel</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts an ``ExportedProgram`` to a Core ML model and returns the</span>
<span class="sd">    mapping information mapping between `torch.fx.Node` and their</span>
<span class="sd">    corresponding operations in the converted Core ML model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : ExportedProgram</span>
<span class="sd">        The source model.</span>

<span class="sd">    **converter_kwargs:</span>
<span class="sd">        Additional keyword arguments to be passed to the Core ML conversion process.</span>
<span class="sd">        These can include options for optimization, input/output specifications, etc.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Tuple[MLModel, Dict[torch.fx.Node, List[proto.MIL_pb2.Operation]]]</span>
<span class="sd">        A tuple containing:</span>
<span class="sd">            - The converted Core ML model.</span>
<span class="sd">            - A dictionary-like object mapping each ``torch.fx.Node`` from the source model</span>
<span class="sd">              to a list of corresponding MIL operations in the Core ML model.</span>
<span class="sd">              This mapping helps trace the origin of operations in the converted</span>
<span class="sd">              model back to the source model for debugging and analysis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. sourcecode:: python</span>
<span class="sd">    </span>
<span class="sd">        (</span>
<span class="sd">            target_model,</span>
<span class="sd">            op_mapping,</span>
<span class="sd">        ) = coremltools.models.ml_program.experimental.torch._convert_and_retrieve_exported_program_op_mapping(</span>
<span class="sd">            model=program,</span>
<span class="sd">            inputs=[</span>
<span class="sd">                coremltools.TensorType(</span>
<span class="sd">                    name=&quot;x&quot;, shape=example_inputs[0].shape, dtype=np.float16</span>
<span class="sd">                ),</span>
<span class="sd">                coremltools.TensorType(</span>
<span class="sd">                    name=&quot;y&quot;, shape=example_inputs[1].shape, dtype=np.float16</span>
<span class="sd">                ),</span>
<span class="sd">            ],</span>
<span class="sd">            minimum_deployment_target=coremltools.target.iOS16,</span>
<span class="sd">            compute_units=coremltools.ComputeUnit.CPU_ONLY,</span>
<span class="sd">            skip_model_load=True,</span>
<span class="sd">        )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Importing here to avoid circular import issues</span>
    <span class="kn">from</span> <span class="nn">.....converters</span> <span class="kn">import</span> <span class="n">convert</span>

    <span class="n">debug_handle</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">source_nodes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">graph_module</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">graph_module</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph_module</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">node</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;debug_handle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">debug_handle</span>
        <span class="n">source_nodes</span><span class="p">[</span><span class="n">debug_handle</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">debug_handle</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">target_model</span> <span class="o">=</span> <span class="n">convert</span><span class="p">(</span>
        <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
        <span class="o">**</span><span class="n">converter_kwargs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">output_name_to_op_map</span> <span class="o">=</span> <span class="n">_create_output_name_to_op_map_from_spec</span><span class="p">(</span>
        <span class="n">spec</span><span class="o">=</span><span class="n">target_model</span><span class="o">.</span><span class="n">get_spec</span><span class="p">(),</span>
        <span class="n">function_name</span><span class="o">=</span><span class="s2">&quot;main&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">program</span> <span class="o">=</span> <span class="n">target_model</span><span class="o">.</span><span class="n">_mil_program</span>
    <span class="n">block</span> <span class="o">=</span> <span class="n">program</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s2">&quot;main&quot;</span><span class="p">]</span>
    <span class="n">source_to_target_ops</span> <span class="o">=</span> <span class="p">{</span><span class="n">source_node</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">source_node</span> <span class="ow">in</span> <span class="n">source_nodes</span><span class="o">.</span><span class="n">values</span><span class="p">()}</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">operations</span><span class="p">:</span>
        <span class="n">scopes</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">scopes</span><span class="p">[</span><span class="n">ScopeSource</span><span class="o">.</span><span class="n">EXIR_DEBUG_HANDLE</span><span class="p">]</span>
        <span class="n">debug_handle</span> <span class="o">=</span> <span class="n">scopes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scopes</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">debug_handle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">source_op</span> <span class="o">=</span> <span class="n">source_nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">debug_handle</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">source_op</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">output</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">outputs</span><span class="p">]</span>
            <span class="n">target_ops</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">output_name_to_op_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">output_name</span> <span class="ow">in</span> <span class="n">output_names</span>
            <span class="p">]</span>
            <span class="n">target_ops</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="n">op</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">target_ops</span><span class="p">))</span>
            <span class="n">source_to_target_ops</span><span class="p">[</span><span class="n">source_op</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">target_ops</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">target_model</span><span class="p">,</span> <span class="n">source_to_target_ops</span><span class="p">)</span>


<span class="n">TorchNode</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">TorchScriptNodeInfo</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">]</span>


<div class="viewcode-block" id="FrameInfo">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.FrameInfo">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FrameInfo</span><span class="p">:</span>
    <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">lineno</span><span class="p">:</span> <span class="nb">int</span></div>



<div class="viewcode-block" id="get_stack_frame_infos">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.get_stack_frame_infos">[docs]</a>
<span class="k">def</span> <span class="nf">get_stack_frame_infos</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">TorchNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">FrameInfo</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts frame infos from the node&#39;s source range.</span>

<span class="sd">    This method parses the stack trace of the node, attempts to extract the filename and line number</span>
<span class="sd">    using a regular expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">source_range</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">TorchScriptNodeInfo</span><span class="p">):</span>
        <span class="n">source_range</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">source_range</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">source_range</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;([^ ]+\.py)\((\d+)\)&quot;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">):</span>
        <span class="n">source_range</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;stack_trace&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;File &quot;(.*?)&quot;, line (\d+), in (.*?)\n&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Expected node of type &#39;TorchScriptNodeInfo&#39; or &#39;torch.fx.Node&#39; but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">source_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">matches</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="n">source_range</span><span class="p">)</span>
    <span class="n">frame_infos</span> <span class="o">=</span> <span class="p">[</span><span class="n">FrameInfo</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">match</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lineno</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">frame_infos</span></div>


<div class="viewcode-block" id="TorchNodeToMILOperationMapping">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.TorchNodeToMILOperationMapping">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">TorchNodeToMILOperationMapping</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class that represents the mapping between PyTorch nodes and MIL operations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">node_to_operations_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">TorchNode</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">]]</span>
    <span class="n">operation_output_name_to_node_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TorchNode</span><span class="p">]</span>

<div class="viewcode-block" id="TorchNodeToMILOperationMapping.get_source_nodes_for_output_name">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.TorchNodeToMILOperationMapping.get_source_nodes_for_output_name">[docs]</a>
    <span class="k">def</span> <span class="nf">get_source_nodes_for_output_name</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">output_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TorchNode</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the source node for a given MIL operation&#39;s output name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        output_name : str</span>
<span class="sd">            The name of the output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Optional[TorchNode]</span>
<span class="sd">            The corresponding TorchNode if found, None otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operation_output_name_to_node_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="TorchNodeToMILOperationMapping.get_source_nodes_for_operation">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.TorchNodeToMILOperationMapping.get_source_nodes_for_operation">[docs]</a>
    <span class="k">def</span> <span class="nf">get_source_nodes_for_operation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">operation</span><span class="p">:</span> <span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">TorchNode</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the source node for a given MIL operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        operation : proto.MIL_pb2.Operation</span>
<span class="sd">            The MIL operation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Optional[TorchNode]</span>
<span class="sd">            The corresponding TorchNode if found, None otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">operation</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_source_nodes_for_output_name</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>
</div>


<div class="viewcode-block" id="convert_and_retrieve_op_mapping">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.convert_and_retrieve_op_mapping">[docs]</a>
<span class="k">def</span> <span class="nf">convert_and_retrieve_op_mapping</span><span class="p">(</span>
    <span class="n">model</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;ExportedProgram&quot;</span><span class="p">,</span> <span class="n">ScriptModule</span><span class="p">],</span>
    <span class="o">**</span><span class="n">converter_kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">MLModel</span><span class="p">,</span> <span class="n">TorchNodeToMILOperationMapping</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a TorchScript model to a Core ML model and returns the</span>
<span class="sd">    mapping information mapping between the source TorchScript operations and their</span>
<span class="sd">    corresponding operations in the converted Core ML model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : ScriptModule or ExportedProgram</span>
<span class="sd">        The source model.</span>

<span class="sd">    **converter_kwargs:</span>
<span class="sd">        Additional keyword arguments to be passed to the Core ML conversion process.</span>
<span class="sd">        These can include options for optimization, input/output specifications, etc.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Tuple[MLModel, TorchNodeToMILOperationMapping]</span>
<span class="sd">        A tuple containing:</span>
<span class="sd">            - The converted Core ML model.</span>
<span class="sd">            - A dictionary-like object mapping each TorchScript node from the original model</span>
<span class="sd">              to a list of corresponding MIL operations in the Core ML model.</span>
<span class="sd">              This mapping helps trace the origin of operations in the converted</span>
<span class="sd">              model back to the source model for debugging and analysis</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. sourcecode:: python</span>

<span class="sd">        (</span>
<span class="sd">            target_model,</span>
<span class="sd">            mapping_info,</span>
<span class="sd">        ) = coremltools.models.ml_program.experimental.torch.convert_and_retrieve_op_mapping(</span>
<span class="sd">            model=traced_model,  # ScriptModule or ExportedProgram</span>
<span class="sd">            inputs=[</span>
<span class="sd">                coremltools.TensorType(</span>
<span class="sd">                    name=&quot;x&quot;, shape=example_inputs[0].shape, dtype=np.float16</span>
<span class="sd">                ),</span>
<span class="sd">                coremltools.TensorType(</span>
<span class="sd">                    name=&quot;y&quot;, shape=example_inputs[1].shape, dtype=np.float16</span>
<span class="sd">                ),</span>
<span class="sd">            ],</span>
<span class="sd">            minimum_deployment_target=coremltools.target.iOS16,</span>
<span class="sd">            compute_units=coremltools.ComputeUnit.CPU_ONLY,</span>
<span class="sd">            skip_model_load=True,</span>
<span class="sd">        )</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_output_name_to_node_mapping</span><span class="p">(</span>
        <span class="n">op_mapping</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">TorchNode</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TorchNode</span><span class="p">]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">source_node</span><span class="p">,</span> <span class="n">target_operations</span> <span class="ow">in</span> <span class="n">op_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">target_operation</span> <span class="ow">in</span> <span class="n">target_operations</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">target_operation</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">output</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">source_node</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="n">converted_model</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">node_to_operations_map</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">ScriptModule</span><span class="p">):</span>
        <span class="n">converted_model</span><span class="p">,</span> <span class="n">module_mapping</span> <span class="o">=</span> <span class="n">_convert_and_retrieve_jit_module_mapping</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
            <span class="o">**</span><span class="n">converter_kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">node_to_operations_map</span> <span class="o">=</span> <span class="n">module_mapping</span><span class="p">[(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span><span class="o">.</span><span class="n">source_to_target_ops_mapping</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">ExportedProgram</span><span class="p">):</span>
        <span class="n">converted_model</span><span class="p">,</span> <span class="n">node_to_operations_map</span> <span class="o">=</span> <span class="n">_convert_and_retrieve_exported_program_op_mapping</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="o">**</span><span class="n">converter_kwargs</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unsupported model type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">model</span><span class="p">)</span><span class="si">}</span><span class="s2">. Expected either ScriptModule or ExportedProgram.&quot;</span>
        <span class="p">)</span>

    <span class="n">mapping</span> <span class="o">=</span> <span class="n">TorchNodeToMILOperationMapping</span><span class="p">(</span>
        <span class="n">node_to_operations_map</span><span class="o">=</span><span class="n">node_to_operations_map</span><span class="p">,</span>
        <span class="n">operation_output_name_to_node_map</span><span class="o">=</span><span class="n">get_output_name_to_node_mapping</span><span class="p">(</span><span class="n">node_to_operations_map</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">converted_model</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">_get_model_input_names</span><span class="p">(</span>
    <span class="n">model</span><span class="p">:</span> <span class="n">MLModel</span><span class="p">,</span>
    <span class="n">function_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="n">spec</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_spec</span><span class="p">()</span>
    <span class="n">function</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">mlProgram</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">function_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Program is missing function for name=</span><span class="si">{</span><span class="n">function_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="nb">input</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">function</span><span class="o">.</span><span class="n">inputs</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_flatten</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_flatten</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="TorchScriptMLModelComparator">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.TorchScriptMLModelComparator">[docs]</a>
<span class="k">class</span> <span class="nc">TorchScriptMLModelComparator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for comparing the the intermediate outputs of a torch model with its converted Core ML model.</span>

<span class="sd">    This class provides functionality to compare the intermediate outputs of a torch model and</span>
<span class="sd">    the converted Core ML model, helping to identify the torch modules that produce different results.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">CompareOutputs</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span>
        <span class="p">[</span>
            <span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="nb">bool</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">_is_failure_source</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">module_map_info</span><span class="p">:</span> <span class="n">TorchScriptModuleMappingInfo</span><span class="p">,</span>
        <span class="n">statuses</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">TorchScriptModuleInfo</span><span class="o">.</span><span class="n">Key</span><span class="p">,</span> <span class="n">_Status</span><span class="p">],</span>
        <span class="n">deps</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">TorchScriptModuleInfo</span><span class="o">.</span><span class="n">Key</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">TorchScriptModuleMappingInfo</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">statuses</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">module_map_info</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_Status</span><span class="o">.</span><span class="n">FAIL</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">add_deps</span><span class="p">(</span><span class="n">curr</span><span class="p">:</span> <span class="n">TorchScriptModuleMappingInfo</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">deps</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dep</span><span class="p">)</span>

        <span class="n">add_deps</span><span class="p">(</span><span class="n">module_map_info</span><span class="p">)</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dep</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">statuses</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dep</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">status</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">status</span> <span class="o">==</span> <span class="n">_Status</span><span class="o">.</span><span class="n">FAIL</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">status</span> <span class="o">==</span> <span class="n">_Status</span><span class="o">.</span><span class="n">UNKNOWN</span><span class="p">:</span>
                <span class="c1"># If the dep status is unknown then we check its direct dependencies.</span>
                <span class="n">add_deps</span><span class="p">(</span><span class="n">dep</span><span class="p">)</span>

        <span class="c1"># The module itself is likely the source of the failure, as its dependencies have passed</span>
        <span class="c1"># the validation check.</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="TorchScriptMLModelComparator.__init__">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.TorchScriptMLModelComparator.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
        <span class="n">example_inputs</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">],</span>
        <span class="n">num_predict_intermediate_outputs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
        <span class="n">target_device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">converter_kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the TorchScriptMLModelComparator.</span>

<span class="sd">        This constructor sets up the comparator by preparing both the PyTorch model and its Core ML counterpart</span>
<span class="sd">        for comparison. It traces the PyTorch model, converts it to a Core ML model, and initializes necessary attributes</span>
<span class="sd">        for the comparison process.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        model: torch.nn.Module</span>
<span class="sd">            The PyTorch model to be compared. This should be a valid PyTorch module that can be traced</span>
<span class="sd">            using `torch.jit.trace` and converted to Core ML.</span>

<span class="sd">        example_inputs: Tuple[torch.tensor]</span>
<span class="sd">            A tuple of example input tensors that will be used to trace the PyTorch model. These inputs</span>
<span class="sd">            should be representative of the expected input format and shapes for the model.</span>

<span class="sd">        num_predict_intermediate_outputs: int</span>
<span class="sd">            The number of intermediate outputs to retrieve in each ``MLModel`` prediction call. Defaults to 20.</span>

<span class="sd">        target_device: Optional[Device]</span>
<span class="sd">            The target device on which to run the Core ML model. If None, the current default device will be used.</span>

<span class="sd">        **converter_kwargs : dict</span>
<span class="sd">            Additional keyword arguments to be passed to the Core ML converter. These can include</span>
<span class="sd">            options like &#39;minimum_deployment_target&#39;, &#39;compute_units&#39;, etc., allowing for fine-tuning</span>
<span class="sd">            of the conversion process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source_model_inspector</span> <span class="o">=</span> <span class="n">_TorchModuleInspector</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">traced_model</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">example_inputs</span><span class="p">)</span>
        <span class="n">target_model</span><span class="p">,</span> <span class="n">module_map_infos</span> <span class="o">=</span> <span class="n">_convert_and_retrieve_jit_module_mapping</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="n">traced_model</span><span class="p">,</span>
            <span class="o">**</span><span class="n">converter_kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_source_root_module</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">module_map</span><span class="p">:</span> <span class="n">module_map</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">hierarchy</span> <span class="o">==</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,),</span> <span class="n">module_map_infos</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">),</span>
            <span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_module_map_infos</span> <span class="o">=</span> <span class="n">module_map_infos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_model</span> <span class="o">=</span> <span class="n">target_model</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_target_model_inspector</span> <span class="o">=</span> <span class="n">MLModelInspector</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target_model</span><span class="p">,</span>
            <span class="n">function_name</span><span class="o">=</span><span class="s2">&quot;main&quot;</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">target_device</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_target_output_name_to_op_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_model_inspector</span><span class="o">.</span><span class="n">output_name_to_op_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_model_input_names</span> <span class="o">=</span> <span class="n">_get_model_input_names</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target_model</span><span class="p">,</span>
            <span class="n">function_name</span><span class="o">=</span><span class="s2">&quot;main&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_source_outputs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_outputs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_predict_intermediate_outputs</span> <span class="o">=</span> <span class="n">num_predict_intermediate_outputs</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">module_map_infos</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">TorchScriptModuleMappingInfo</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_module_map_infos</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">get_source_ops_for_targe_ops</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target_op</span><span class="p">:</span> <span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">TorchScriptNodeInfo</span><span class="p">]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">module_map_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">module_map_infos</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">module_map_info</span><span class="o">.</span><span class="n">get_source_ops_for_target_op</span><span class="p">(</span>
                    <span class="n">target_op</span><span class="o">=</span><span class="n">target_op</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_set_target_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target_model</span><span class="p">:</span> <span class="n">MLModel</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">compute_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_model</span><span class="o">.</span><span class="n">compute_unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_model</span> <span class="o">=</span> <span class="n">target_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_model_inspector</span> <span class="o">=</span> <span class="n">MLModelInspector</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target_model</span><span class="p">,</span>
            <span class="n">compute_units</span><span class="o">=</span><span class="n">compute_units</span><span class="p">,</span>
            <span class="n">function_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_target_model_inspector</span><span class="o">.</span><span class="n">_function_name</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_target_model_inspector</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_retrieve_outputs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">op</span><span class="p">:</span> <span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]]:</span>
        <span class="n">processed_output_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_target_outputs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">dep_names</span> <span class="o">=</span> <span class="n">_retrieve_dependency_names</span><span class="p">(</span>
            <span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span>
            <span class="n">max_dependencies</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_predict_intermediate_outputs</span><span class="p">,</span>
            <span class="n">processed_output_names</span><span class="o">=</span><span class="n">processed_output_names</span><span class="p">,</span>
            <span class="n">output_name_to_op_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_target_output_name_to_op_map</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">op_output_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">output</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">outputs</span><span class="p">]</span>
        <span class="n">output_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op_output_names</span><span class="p">)</span> <span class="o">+</span> <span class="n">dep_names</span>
        <span class="c1"># Retrieve the operation outputs along with selected dependencies.</span>
        <span class="c1"># This will reduce the number of prediction calls.</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_model_inspector</span><span class="o">.</span><span class="n">retrieve_outputs</span><span class="p">(</span>
            <span class="n">output_names</span><span class="o">=</span><span class="n">output_names</span><span class="p">,</span>
            <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_outputs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_model_inspector</span><span class="o">.</span><span class="n">clear_cached_models</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_outputs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">outputs</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_process_module</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">source_module_outputs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
        <span class="n">module_map_info</span><span class="p">:</span> <span class="n">TorchScriptModuleMappingInfo</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">],</span>
        <span class="n">compare_outputs</span><span class="p">:</span> <span class="n">CompareOutputs</span><span class="p">,</span>
        <span class="n">queue</span><span class="p">:</span> <span class="n">deque</span><span class="p">,</span>
        <span class="n">deps</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">TorchScriptModuleInfo</span><span class="o">.</span><span class="n">Key</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="s2">&quot;TorchScriptModuleMappingInfo&quot;</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Status</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">add_module_deps</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">deps</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">module_map_info</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dep</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_module_outputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">add_module_deps</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">_Status</span><span class="o">.</span><span class="n">PASS</span>

        <span class="k">def</span> <span class="nf">to_numpy</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Failed to reshape output for module </span><span class="si">{</span><span class="n">module_map_info</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="n">source_module_outputs</span> <span class="o">=</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">source_module_outputs</span><span class="p">)</span>
        <span class="n">target_outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">target_op</span> <span class="ow">in</span> <span class="n">module_map_info</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retrieve_outputs</span><span class="p">(</span>
                <span class="n">target_op</span><span class="p">,</span>
                <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">target_outputs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">outputs</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_module_outputs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_outputs</span><span class="p">):</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Output mismatch detected for module: </span><span class="si">{</span><span class="n">module_map_info</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Number of source outputs: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">source_module_outputs</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Number of target outputs: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">target_outputs</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="c1"># We will skip this module but process it&#39;s dependencies</span>
            <span class="n">add_module_deps</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">_Status</span><span class="o">.</span><span class="n">UNKNOWN</span>

        <span class="n">status</span> <span class="o">=</span> <span class="n">_Status</span><span class="o">.</span><span class="n">PASS</span>
        <span class="k">for</span> <span class="n">source_output</span><span class="p">,</span> <span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="n">target_output</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">source_module_outputs</span><span class="p">,</span> <span class="n">target_outputs</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">target_output</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Failed to retrieve target output for &#39;</span><span class="si">{</span><span class="n">target_name</span><span class="si">}</span><span class="s2">&#39; in module: </span><span class="si">{</span><span class="n">module_map_info</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">status</span> <span class="o">=</span> <span class="n">_Status</span><span class="o">.</span><span class="n">UNKNOWN</span>
                <span class="k">break</span>

            <span class="n">source_output</span> <span class="o">=</span> <span class="n">to_numpy</span><span class="p">(</span><span class="n">source_output</span><span class="p">,</span> <span class="n">target_output</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">source_output</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Failed to retrieve source output for &#39;</span><span class="si">{</span><span class="n">target_name</span><span class="si">}</span><span class="s2">&#39; in module: </span><span class="si">{</span><span class="n">module_map_info</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">status</span> <span class="o">=</span> <span class="n">_Status</span><span class="o">.</span><span class="n">UNKNOWN</span>
                <span class="k">break</span>

            <span class="n">target_op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_output_name_to_op_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">compare_outputs</span><span class="p">(</span><span class="n">target_op</span><span class="p">,</span> <span class="n">source_output</span><span class="p">,</span> <span class="n">target_output</span><span class="p">):</span>
                <span class="n">status</span> <span class="o">=</span> <span class="n">_Status</span><span class="o">.</span><span class="n">FAIL</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">status</span> <span class="o">!=</span> <span class="n">_Status</span><span class="o">.</span><span class="n">PASS</span><span class="p">:</span>
            <span class="n">add_module_deps</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">status</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_find_failing_modules</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">source_outputs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
        <span class="n">module_map_info</span><span class="p">:</span> <span class="n">TorchScriptModuleMappingInfo</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">],</span>
        <span class="n">compare_outputs</span><span class="p">:</span> <span class="n">CompareOutputs</span><span class="p">,</span>
        <span class="n">statuses</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">TorchScriptModuleInfo</span><span class="o">.</span><span class="n">Key</span><span class="p">,</span> <span class="n">_Status</span><span class="p">],</span>
        <span class="n">pbar</span><span class="p">:</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">TorchScriptModuleMappingInfo</span><span class="p">]:</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">failing_module_map_infos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">deps</span> <span class="o">=</span> <span class="n">module_map_info</span><span class="o">.</span><span class="n">deps</span>

        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">module_map_info</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">statuses</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">module_map_info</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="n">_Status</span><span class="o">.</span><span class="n">FAIL</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">deps</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">module_map_info</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dep</span><span class="p">)</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">curr_module_map_info</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">statuses</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">curr_module_map_info</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">status</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_failure_source</span><span class="p">(</span>
                    <span class="n">module_map_info</span><span class="o">=</span><span class="n">curr_module_map_info</span><span class="p">,</span>
                    <span class="n">statuses</span><span class="o">=</span><span class="n">statuses</span><span class="p">,</span>
                    <span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">,</span>
                <span class="p">):</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    The module did not pass comparison check, but its dependencies did.</span>
<span class="sd">                    This suggests that the failure likely comes from this module.</span>
<span class="sd">                    &quot;&quot;&quot;</span>
                    <span class="n">failing_module_map_infos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_module_map_info</span><span class="p">)</span>

                <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">source_module_outputs</span> <span class="o">=</span> <span class="n">source_outputs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">curr_module_map_info</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span>
                <span class="n">status</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_module</span><span class="p">(</span>
                    <span class="n">module_map_info</span><span class="o">=</span><span class="n">curr_module_map_info</span><span class="p">,</span>
                    <span class="n">source_module_outputs</span><span class="o">=</span><span class="n">source_module_outputs</span><span class="p">,</span>
                    <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span>
                    <span class="n">compare_outputs</span><span class="o">=</span><span class="n">compare_outputs</span><span class="p">,</span>
                    <span class="n">queue</span><span class="o">=</span><span class="n">queue</span><span class="p">,</span>
                    <span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">pbar</span><span class="o">.</span><span class="n">set_description</span><span class="p">(</span>
                    <span class="n">desc</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\033</span><span class="s2">[1mAnalyzed module: </span><span class="si">{</span><span class="n">curr_module_map_info</span><span class="o">.</span><span class="n">key</span><span class="si">}</span><span class="se">\033</span><span class="s2">[0m&quot;</span>
                <span class="p">)</span>
                <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">statuses</span><span class="p">[</span><span class="n">curr_module_map_info</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">status</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">curr_module_map_info</span> <span class="ow">in</span> <span class="n">failing_module_map_infos</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">curr_module_map_info</span> <span class="ow">is</span> <span class="n">module_map_info</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_module_map_info</span><span class="o">.</span><span class="n">submodules</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_module_map_info</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Check submodules</span>
                <span class="n">values</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_failing_modules</span><span class="p">(</span>
                    <span class="n">source_outputs</span><span class="o">=</span><span class="n">source_outputs</span><span class="p">,</span>
                    <span class="n">module_map_info</span><span class="o">=</span><span class="n">curr_module_map_info</span><span class="p">,</span>
                    <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span>
                    <span class="n">compare_outputs</span><span class="o">=</span><span class="n">compare_outputs</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="TorchScriptMLModelComparator.find_failing_modules">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.TorchScriptMLModelComparator.find_failing_modules">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">find_failing_modules</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">],</span>
        <span class="n">compare_outputs</span><span class="p">:</span> <span class="n">CompareOutputs</span><span class="p">,</span>
        <span class="n">source_module_keys</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">TorchScriptModuleInfo</span><span class="o">.</span><span class="n">Key</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">TorchScriptModuleMappingInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Asynchronously finds failing operations in the converted model.</span>

<span class="sd">        This method compares the outputs of the source PyTorch model with the</span>
<span class="sd">        converted Core ML model to identify operations that produce different results.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inputs : Tuple[torch.tensor]</span>
<span class="sd">            Input data for the models.</span>

<span class="sd">        compare_outputs : CompareOutputs</span>
<span class="sd">            Function to compare outputs between models.</span>

<span class="sd">        source_module_keys : Optional[List[TorchScriptModuleInfo.Key]]</span>
<span class="sd">            Specific module keys to check. Defaults to None (checks all modules).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[TorchModuleMLModelMappingInfo]</span>
<span class="sd">            A list of failing modules.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. sourcecode:: python</span>

<span class="sd">            class Model(torch.nn.Module):</span>
<span class="sd">                def forward(self, x, y):</span>
<span class="sd">                    return x + y</span>


<span class="sd">            model = Model()</span>
<span class="sd">            input1 = torch.full((1, 10), 1, dtype=torch.float)</span>
<span class="sd">            input2 = torch.full((1, 10), 2, dtype=torch.float)</span>
<span class="sd">            example_inputs = (input1, input2)</span>
<span class="sd">            comparator = (</span>
<span class="sd">                coremltools.models.ml_program.experimental.torch.TorchScriptMLModelComparator(</span>
<span class="sd">                    model=model,</span>
<span class="sd">                    example_inputs=example_inputs,</span>
<span class="sd">                    inputs=[</span>
<span class="sd">                        coremltools.TensorType(name=&quot;x&quot;, shape=inputs[0].shape, dtype=np.float32),</span>
<span class="sd">                        coremltools.TensorType(name=&quot;y&quot;, shape=inputs[1].shape, dtype=np.float32),</span>
<span class="sd">                    ],</span>
<span class="sd">                    minimum_deployment_target=coremltools.target.iOS16,</span>
<span class="sd">                    compute_units=coremltools.ComputeUnit.ALL,</span>
<span class="sd">                )</span>
<span class="sd">            )</span>


<span class="sd">            def compare_outputs(module, reference_output, target_output):</span>
<span class="sd">                return np.allclose(reference_output, target_output, atol=0.01)</span>


<span class="sd">            modules = await comparator.find_failing_modules(</span>
<span class="sd">                inputs=example_inputs, compare_outputs=compare_outputs</span>
<span class="sd">            )</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">statuses</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">source_module_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">source_module_keys</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_source_root_module</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">key</span><span class="p">]</span>

        <span class="n">source_module_outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_model_inspector</span><span class="o">.</span><span class="n">inspect</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span>
            <span class="n">module_info_keys</span><span class="o">=</span><span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_module_map_infos</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">target_inputs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="nb">input</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_target_model_input_names</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
            <span class="n">target_inputs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

        <span class="n">source_outputs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">source_module_outputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">source_outputs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">source_outputs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">output</span><span class="p">]</span>

        <span class="n">module_map_infos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">module_key</span> <span class="ow">in</span> <span class="n">source_module_keys</span><span class="p">:</span>
            <span class="n">module_map_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_module_map_infos</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">module_key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">module_map_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Module key &#39;</span><span class="si">{</span><span class="n">module_key</span><span class="si">}</span><span class="s2">&#39; not found in the module map. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Available keys are: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_module_map_infos</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="n">module_map_infos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">module_map_info</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
            <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_module_map_infos</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\033</span><span class="s2">[1mAnalyzing modules...</span><span class="se">\033</span><span class="s2">[0m&quot;</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">module_map_info</span> <span class="ow">in</span> <span class="n">module_map_infos</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_failing_modules</span><span class="p">(</span>
                    <span class="n">source_outputs</span><span class="o">=</span><span class="n">source_outputs</span><span class="p">,</span>
                    <span class="n">module_map_info</span><span class="o">=</span><span class="n">module_map_info</span><span class="p">,</span>
                    <span class="n">inputs</span><span class="o">=</span><span class="n">target_inputs</span><span class="p">,</span>
                    <span class="n">compare_outputs</span><span class="o">=</span><span class="n">compare_outputs</span><span class="p">,</span>
                    <span class="n">statuses</span><span class="o">=</span><span class="n">statuses</span><span class="p">,</span>
                    <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_source_outputs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_outputs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="n">result</span></div>
</div>



<span class="k">class</span> <span class="nc">_TorchFXNodeValueInterpreter</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Interpreter</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">module</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
        <span class="n">garbage_collect_values</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">garbage_collect_values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intermediates</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interested_nodes</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">run_node</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">run_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interested_nodes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interested_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_intermediates</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">],</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interested_nodes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interested_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intermediates</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intermediates</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">_find_terminal_ops</span><span class="p">(</span>
    <span class="n">ops</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">]:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ops</span>

    <span class="n">bindings</span> <span class="o">=</span> <span class="p">[</span><span class="nb">input</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span> <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="n">arguments</span> <span class="o">=</span> <span class="p">[</span><span class="n">argument</span> <span class="k">for</span> <span class="n">binding</span> <span class="ow">in</span> <span class="n">bindings</span> <span class="k">for</span> <span class="n">argument</span> <span class="ow">in</span> <span class="n">binding</span><span class="o">.</span><span class="n">arguments</span><span class="p">]</span>
    <span class="n">input_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">argument</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">argument</span> <span class="ow">in</span> <span class="n">arguments</span> <span class="k">if</span> <span class="n">argument</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">])</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">output_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">output</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">outputs</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">output_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">input_names</span> <span class="k">for</span> <span class="n">output_name</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="TorchExportMLModelComparator">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.TorchExportMLModelComparator">[docs]</a>
<span class="k">class</span> <span class="nc">TorchExportMLModelComparator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compares intermediate outputs between a PyTorch ExportedProgram and its converted Core ML model.</span>

<span class="sd">    This class facilitates the comparison of intermediate outputs from a PyTorch model</span>
<span class="sd">    and its corresponding Core ML conversion. It helps identify specific PyTorch operations</span>
<span class="sd">    that may produce divergent results in the converted model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">CompareOutputs</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span>
        <span class="p">[</span>
            <span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="nb">bool</span><span class="p">,</span>
    <span class="p">]</span>

<div class="viewcode-block" id="TorchExportMLModelComparator.__init__">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.TorchExportMLModelComparator.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="s2">&quot;ExportedProgram&quot;</span><span class="p">,</span>
        <span class="n">num_predict_intermediate_outputs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
        <span class="n">target_device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">converter_kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the TorchExportMLModelComparator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : torch.export.ExportedProgram</span>
<span class="sd">            The ExportedProgram to be compared.</span>

<span class="sd">        num_predict_intermediate_outputs : int</span>
<span class="sd">            The number of intermediate outputs to retrieve in each ``MLModel`` prediction call. Defaults to 20.</span>

<span class="sd">        target_device : Optional[Device]</span>
<span class="sd">            The target device on which to run the Core ML model. If None, the current default device will be used.</span>

<span class="sd">        **converter_kwargs : Any</span>
<span class="sd">            Additional keyword arguments to be passed to the Core ML converter. These can include</span>
<span class="sd">            options like &#39;minimum_deployment_target&#39;, &#39;compute_units&#39;, etc., allowing for fine-tuning</span>
<span class="sd">            of the conversion process.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source_model_inspector</span> <span class="o">=</span> <span class="n">_TorchFXNodeValueInterpreter</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">graph_module</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="p">(</span>
            <span class="n">target_model</span><span class="p">,</span>
            <span class="n">source_to_target_ops_mapping</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">_convert_and_retrieve_exported_program_op_mapping</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
            <span class="o">**</span><span class="n">converter_kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_source_to_target_ops_mapping</span> <span class="o">=</span> <span class="n">source_to_target_ops_mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_model</span> <span class="o">=</span> <span class="n">target_model</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_target_model_inspector</span> <span class="o">=</span> <span class="n">MLModelInspector</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target_model</span><span class="p">,</span>
            <span class="n">function_name</span><span class="o">=</span><span class="s2">&quot;main&quot;</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">target_device</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_target_output_name_to_op_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_model_inspector</span><span class="o">.</span><span class="n">output_name_to_op_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_model_input_names</span> <span class="o">=</span> <span class="n">_get_model_input_names</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target_model</span><span class="p">,</span>
            <span class="n">function_name</span><span class="o">=</span><span class="s2">&quot;main&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_source_outputs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_outputs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_predict_intermediate_outputs</span> <span class="o">=</span> <span class="n">num_predict_intermediate_outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_to_target_ops_mapping</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_to_target_ops_mapping</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_source_ops_for_target_op</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target_op</span><span class="p">:</span> <span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">source_op</span><span class="p">,</span> <span class="n">target_ops</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_to_target_ops_mapping</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">item</span> <span class="ow">is</span> <span class="n">target_op</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">target_ops</span><span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source_op</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_set_target_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target_model</span><span class="p">:</span> <span class="n">MLModel</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">compute_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_model</span><span class="o">.</span><span class="n">compute_unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_model</span> <span class="o">=</span> <span class="n">target_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_model_inspector</span> <span class="o">=</span> <span class="n">MLModelInspector</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="n">target_model</span><span class="p">,</span>
            <span class="n">compute_units</span><span class="o">=</span><span class="n">compute_units</span><span class="p">,</span>
            <span class="n">function_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_target_model_inspector</span><span class="o">.</span><span class="n">_function_name</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_target_model_inspector</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_retrieve_outputs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">op</span><span class="p">:</span> <span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]]:</span>
        <span class="n">processed_output_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_target_outputs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">dep_names</span> <span class="o">=</span> <span class="n">_retrieve_dependency_names</span><span class="p">(</span>
            <span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span>
            <span class="n">max_dependencies</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_predict_intermediate_outputs</span><span class="p">,</span>
            <span class="n">processed_output_names</span><span class="o">=</span><span class="n">processed_output_names</span><span class="p">,</span>
            <span class="n">output_name_to_op_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_target_output_name_to_op_map</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">op_output_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">output</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">outputs</span><span class="p">]</span>
        <span class="n">output_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op_output_names</span><span class="p">)</span> <span class="o">+</span> <span class="n">dep_names</span>
        <span class="c1"># Retrieve the operation outputs along with selected dependencies.</span>
        <span class="c1"># This will reduce the number of prediction calls.</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_model_inspector</span><span class="o">.</span><span class="n">retrieve_outputs</span><span class="p">(</span>
            <span class="n">output_names</span><span class="o">=</span><span class="n">output_names</span><span class="p">,</span>
            <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_outputs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_model_inspector</span><span class="o">.</span><span class="n">clear_cached_models</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_outputs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">outputs</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_failure_source</span><span class="p">(</span>
        <span class="n">node</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span>
        <span class="n">statuses</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">_Status</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">statuses</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_Status</span><span class="o">.</span><span class="n">FAIL</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">add_deps</span><span class="p">(</span><span class="n">curr</span><span class="p">:</span> <span class="n">TorchScriptModuleMappingInfo</span><span class="p">):</span>
            <span class="n">op_type_to_skip</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;placeholder&quot;</span><span class="p">,</span> <span class="s2">&quot;get_attr&quot;</span><span class="p">,</span> <span class="s2">&quot;call_module&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">curr</span><span class="o">.</span><span class="n">all_input_nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dep</span><span class="o">.</span><span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">op_type_to_skip</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dep</span><span class="p">)</span>

        <span class="n">add_deps</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dep</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">statuses</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dep</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">status</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">status</span> <span class="o">==</span> <span class="n">_Status</span><span class="o">.</span><span class="n">FAIL</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">status</span> <span class="o">==</span> <span class="n">_Status</span><span class="o">.</span><span class="n">UNKNOWN</span><span class="p">:</span>
                <span class="c1"># If the dep status is unknown then we check its direct dependencies.</span>
                <span class="n">add_deps</span><span class="p">(</span><span class="n">dep</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_process_node</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span>
        <span class="n">target_inputs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">],</span>
        <span class="n">queue</span><span class="p">:</span> <span class="n">deque</span><span class="p">,</span>
        <span class="n">compare_outputs</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Status</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">is_output_op</span><span class="p">(</span><span class="n">op</span><span class="p">:</span> <span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">any</span><span class="p">(</span>
                <span class="n">output</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="n">output</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_cast&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">outputs</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">add_deps</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">all_input_nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dep</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_visited</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dep</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">to_numpy</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to reshape tensor for </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;get_attr&quot;</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;placeholder&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_Status</span><span class="o">.</span><span class="n">PASS</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">source_outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_outputs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">source_outputs</span> <span class="o">=</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">source_outputs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_outputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to retrieve outputs for node: </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">add_deps</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_Status</span><span class="o">.</span><span class="n">UNKNOWN</span>

        <span class="c1"># Find ops that produce the output</span>
        <span class="n">target_ops</span> <span class="o">=</span> <span class="n">_find_terminal_ops</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_source_to_target_ops_mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">[]))</span>
        <span class="n">target_ops</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="n">op</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s2">&quot;const&quot;</span> <span class="ow">and</span> <span class="n">is_output_op</span><span class="p">(</span><span class="n">op</span><span class="p">),</span> <span class="n">target_ops</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_ops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to retrieve target ops for node: </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">add_deps</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_Status</span><span class="o">.</span><span class="n">UNKNOWN</span>

        <span class="n">target_outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">target_op</span> <span class="ow">in</span> <span class="n">target_ops</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retrieve_outputs</span><span class="p">(</span>
                <span class="n">target_op</span><span class="p">,</span>
                <span class="n">inputs</span><span class="o">=</span><span class="n">target_inputs</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">target_outputs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">outputs</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_outputs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_outputs</span><span class="p">):</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Output mismatch detected for node: </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Number of source outputs: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">source_outputs</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Number of target outputs: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">target_outputs</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">add_deps</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_Status</span><span class="o">.</span><span class="n">UNKNOWN</span>

        <span class="n">status</span> <span class="o">=</span> <span class="n">_Status</span><span class="o">.</span><span class="n">PASS</span>
        <span class="k">for</span> <span class="n">source_output</span><span class="p">,</span> <span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="n">target_output</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">source_outputs</span><span class="p">,</span> <span class="n">target_outputs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">target_output</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Failed to retrieve target output for &#39;</span><span class="si">{</span><span class="n">target_name</span><span class="si">}</span><span class="s2">&#39; for node: </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">status</span> <span class="o">=</span> <span class="n">_Status</span><span class="o">.</span><span class="n">UNKNOWN</span>
                <span class="k">break</span>

            <span class="n">source_output</span> <span class="o">=</span> <span class="n">to_numpy</span><span class="p">(</span><span class="n">source_output</span><span class="p">,</span> <span class="n">target_output</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">source_output</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Failed to retrieve source output for &#39;</span><span class="si">{</span><span class="n">target_name</span><span class="si">}</span><span class="s2">&#39; for node: </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">status</span> <span class="o">=</span> <span class="n">_Status</span><span class="o">.</span><span class="n">UNKNOWN</span>
                <span class="k">break</span>

            <span class="n">target_op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_output_name_to_op_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">compare_outputs</span><span class="p">(</span><span class="n">target_op</span><span class="p">,</span> <span class="n">source_output</span><span class="p">,</span> <span class="n">target_output</span><span class="p">):</span>
                <span class="n">status</span> <span class="o">=</span> <span class="n">_Status</span><span class="o">.</span><span class="n">FAIL</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">status</span> <span class="o">!=</span> <span class="n">_Status</span><span class="o">.</span><span class="n">PASS</span><span class="p">:</span>
            <span class="n">add_deps</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">status</span>

<div class="viewcode-block" id="TorchExportMLModelComparator.find_failing_ops">
<a class="viewcode-back" href="../../../../../../source/coremltools.models.html#coremltools.models.ml_program.experimental.torch.debugging_utils.TorchExportMLModelComparator.find_failing_ops">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">find_failing_ops</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">],</span>
        <span class="n">compare_outputs</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">proto</span><span class="o">.</span><span class="n">MIL_pb2</span><span class="o">.</span><span class="n">Operation</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span>
        <span class="n">output_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identifies operations that produce different outputs in the reference and target models.</span>

<span class="sd">        This method compares the outputs of the source and target models for specified operations,</span>
<span class="sd">        identifying those that fail the comparison criteria.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inputs: Tuple[torch.tensor]</span>
<span class="sd">            Input data for the model.</span>

<span class="sd">        compare_outputs : Callable[[proto.MIL_pb2.Operation, np.array, np.array], bool])</span>
<span class="sd">            A function to compare outputs of an operation between the two models.</span>

<span class="sd">        outputs: Optional[List[torch.fx.Node]]</span>
<span class="sd">            Specific outputs to compare. If None, all model outputs are compared. Defaults to None.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The method uses a breadth-first search strategy to traverse the operation graph.</span>
<span class="sd">        - An operation is considered a failure source if it fails comparison while its direct inputs do not.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[proto.MIL_pb2.Operation]</span>
<span class="sd">            A list of operations that failed the comparison.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. sourcecode:: python</span>
<span class="sd">        </span>
<span class="sd">            class Model(torch.nn.Module):</span>
<span class="sd">                def forward(self, x, y):</span>
<span class="sd">                    return x + y</span>


<span class="sd">            model = Model()</span>
<span class="sd">            input1 = torch.full((1, 10), 1, dtype=torch.float)</span>
<span class="sd">            input2 = torch.full((1, 10), 2, dtype=torch.float)</span>
<span class="sd">            inputs = (input1, input2)</span>
<span class="sd">            exported_program = torch.export.export(model, inputs)</span>

<span class="sd">            comparator = (</span>
<span class="sd">                coremltools.models.ml_program.experimental.torch.TorchExportMLModelComparator(</span>
<span class="sd">                    model=exported_program,</span>
<span class="sd">                    inputs=[</span>
<span class="sd">                        coremltools.TensorType(name=&quot;x&quot;, shape=inputs[0].shape, dtype=np.float16),</span>
<span class="sd">                        coremltools.TensorType(name=&quot;y&quot;, shape=inputs[1].shape, dtype=np.float16),</span>
<span class="sd">                    ],</span>
<span class="sd">                    minimum_deployment_target=coremltools.target.iOS16,</span>
<span class="sd">                    compute_units=coremltools.ComputeUnit.ALL,</span>
<span class="sd">                )</span>
<span class="sd">            )</span>


<span class="sd">            def compare_outputs(op, reference_output, target_output):</span>
<span class="sd">                return np.allclose(reference_output, target_output, atol=0.01)</span>


<span class="sd">            ops = await comparator.find_failing_ops(inputs=inputs, compare_outputs=compare_outputs)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">output_nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_nodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;output&quot;</span><span class="p">:</span>
                    <span class="n">output_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="n">source_outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_model_inspector</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source_outputs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">node</span><span class="p">:</span> <span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">source_outputs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="n">target_inputs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">input_names</span> <span class="o">=</span> <span class="n">_get_model_input_names</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_model</span><span class="p">,</span> <span class="s2">&quot;main&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="nb">input</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">input_names</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
            <span class="n">target_inputs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">output_nodes</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">statuses</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">with</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
            <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\033</span><span class="s2">[1mAnalyzing nodes...</span><span class="se">\033</span><span class="s2">[0m&quot;</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">status</span> <span class="o">=</span> <span class="n">statuses</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">status</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_failure_source</span><span class="p">(</span>
                        <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
                        <span class="n">statuses</span><span class="o">=</span><span class="n">statuses</span><span class="p">,</span>
                    <span class="p">):</span>
<span class="w">                        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                        The node did not pass comparison check, but its dependencies did.</span>
<span class="sd">                        This suggests that the failure likely comes from this node.</span>
<span class="sd">                        &quot;&quot;&quot;</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

                    <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">status</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_node</span><span class="p">(</span>
                        <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
                        <span class="n">target_inputs</span><span class="o">=</span><span class="n">target_inputs</span><span class="p">,</span>
                        <span class="n">queue</span><span class="o">=</span><span class="n">queue</span><span class="p">,</span>
                        <span class="n">compare_outputs</span><span class="o">=</span><span class="n">compare_outputs</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="n">pbar</span><span class="o">.</span><span class="n">set_description</span><span class="p">(</span>
                        <span class="n">desc</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\033</span><span class="s2">[1mAnalyzed node: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, type: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="se">\033</span><span class="s2">[0m&quot;</span>
                    <span class="p">)</span>
                    <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">statuses</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">status</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reference_outputs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_target_outputs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Apple Inc.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>